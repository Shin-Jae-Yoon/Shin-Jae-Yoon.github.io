{"/about":{"title":"About","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain":{"title":"Brain","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/":{"title":"_index","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Book/":{"title":"도서","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/":{"title":"Do it! 자바 프로그래밍","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/chap01":{"title":"01.자바 프로그래밍","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 01 - 자바 프로그래밍\n\n\u003cbr\u003e\n\n## Java 특징\n\n\u003cbr\u003e\n\n### 01. 플랫폼(프로그램이 실행되는 환경)에 영향을 받지 않음\n\n**한 번 작성하면, 어디서든 돌아간다. write once, run anywhere** \u003cbr\u003e\n\n자바 소스 코드 (`.java`) -\u003e 자바 컴파일러 -\u003e 바이트 코드 (`.class`) -\u003e 자바 가상머신 (JVM) -\u003e 각 운영체제에서 실행\n\n\u003cbr\u003e\n\n- 자바 가상 머신 (Java Virtual Machine, JVM)은 자바 프로그램 실행 환경을 만들어주는 소프트웨어\n\n- 자바 코드를 **컴파일**하여 `.class` 바이트 코드로 만들면 바이트 코드가 JVM에서 실행\n\n- 현재 사용하는 컴퓨터의 OS에 맞는 자바 실행 환경 (Java Runtime Environment, JRE)이 설치되어 있으면 JVM이 설치되어 있는 것\n\n- JIT(Just In Time) 컴파일러는 실행 시점에 기계어 코드를 생성하는데, 같은 코드가 반복되면 매번 기계어 코드를 새로 생성하지 않고 이전에 만든 기계어를 재사용함.\n\n- JIT 컴파일러는 운영체제에 맞게 바이트 실행 코드로 한 번에 변환하여 실행해서 이전의 자바 해석기(Java Interpreter) 방식보다 성능이 10~20배 좋음\n\n\n\u003cbr\u003e\n\n### 02. 객체지향 언어라서 유지보수가 쉽고 확장성이 좋음\n\n객체지향프로그래밍은 일의 순서대로 프로그래밍 하는 것 X, **여러 객체의 협력을 통해 프로그램을 구현하는 것, 각 객체의 상호 관계를 이용하여 프로그래밍 하는 것이다.**. 쇼핑몰 사이트 예시에서 회원, 상품, 주문, 배송 등이 객체.\n\n\u003cbr\u003e\n\n\n### 03. 프로그램이 안정적임\n\n- C, C++과는 다르게 포인터를 사용하지 않아서, 메모리 직접 제어 불가능. 메모리를 직접 제어할 경우 위험할 수 있지만, 그렇지 않으니까 안정적임.\n\n- 동적 메모리 수거를 프로그래머가 하지 않고 **가비지 컬렉터(Garbage Collector)** 이용하여 메모리 효율적으로 관리\n\n\u003e [!note] Garbage Collector?\n\u003e\n\u003e 가비지 컬렉터란, 이름 그대로 쓰레기를 수집하는 기능. 여기서 쓰레기란 더이상 사용하지 않는 메모리를 의미한다. C, C++에서는 필요 없는 메모리 사용 해제를 프로그래머가 직접 하지만, 자바는 가비지 컬렉터가 사용하지 않는 동적 메모리를 주기적으로 수거\n\n\u003cbr\u003e\n\n### 04. 풍부한 기능을 제공하는 오픈소스\n\n\n특정 기능을 대부분 개발자가 직접 개발하여 사용하는 기존의 다른 언어와는 달리 자바는 기본 기능을 제공하는 클래스, 뿐만 아니라 자료구조, 네트워크, 입출력, 예외 처리 등에 최적화 된 **알고리즘 라이브러리를 제공하는 자바 개발 키트(Java Development Kit, JDK)가 있음**.\n\n\u003chr\u003e\n\n## Hello Java\n\n\u003cbr\u003e\n\n이클립스든 인텔리제이이든 `new project`로 project 생성을 한다. 그러면서 워크스페이스를 지정하는 것이다.\n\n- 프로젝트(project) : 개발자가 만드는 하나의 프로그램 단위\n\n- 클래스(class) : 객체를 소스 코드로 나타낸 것\n\n- 패키지(package) : 프로그램 소스의 묶음으로 클래스를 만드는 데 만드시 필요, 패키지 이름은 항상 소문자로 쓴다.\n\n\u003cbr\u003e\n\nsrc 폴더 -\u003e package 생성 -\u003e class 생성의 순서로 만든다. 이때\n\n\n```java\npackage hello;\n  \npublic class HelloJava {\n\tpublic static void main(String[] args) {\n\tSystem.out.println(\"Hello, JAVA\");\n\t}\n}\n```\n\n추가로, build 결과물인 class 파일이 저장되는게 이클립스는 bin 폴더, 인텔리제이는 out 폴더인 것 같음","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/chap02":{"title":"02.변수와 자료형","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 02 - 변수와 자료형\n\n\u003cbr\u003e\n\n## Java 변수\n\n### Java 변수 선언, 초기화\n\n- 초기화 : 변수의 선언과 동시에 값을 대입\n\n```java\npackage chapter2;\n\npublic class Variable1 {\n\tpublic static void main(String[] args) {\n\t\tint level; // 변수 선언\n\t\tlevel = 10; // 변수에 값 대입\n\t\tSystem.out.println(level);\n\t  \n\t\tint level2 = 10; // 초기화\n\t\tSystem.out.println(level2);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n- 변수 이름 정하기\n\n|제약사항|예시|\n|------|---|\n|영문자, 숫자 사용 \u003cbr\u003e 특수문자는 `$`, `_`만| g_level (O), count100 (O)\u003cbr\u003e _master (O), $won (O)|\n|숫자로 시작 불가|27day (X), 1abc (X)|\n|예약어 사용 불가|while, int, break, ... |\n\n\u003cbr\u003e\n\n\n- 변수를 선언한다 = 선언한 변수 이름으로 어떤 위치에 있는 메모리를 얼마만큼의 크기로 사용하겠다.\n\n- 1byte = 8bits\n\n\n| |정수형|문자형|실수형|논리형|\n|:---:|:-----:|:-----:|:-----:|:-----:|\n|1바이트|byte|-|-|boolean|\n|2바이트|short|char|-|-|\n|4바이트|int|-|float|-|\n|8바이트|long|-|double|-|\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Java 자료형\n\n\u003cbr\u003e\n\n### 정수형\n\n- **자바에서 정수 값 연산 시 4바이트를 기본 단위로 사용. 모든 정수 값을 기본으로 int형으로 처리.** 따라서 다른 자료형이라면 그를 표시해야함.\n\n```java\nint num1 = 12345678900;\nlong num2 = 12345678900;\n// num1은 int 범위 벗어나서 오류\n// num2도 오류. java는 정수를 int로 처리하니까\n  \nlong num3 = 12345678900L;\n// long 자료형으로 처리하라고 컴파일러에게 알려주는\n// 식별자 L이나 l을 사용하여 알려줘서 오류 X\n```\n\n\u003cbr\u003e\n\n### 문자형\n\n- **자바의 기본 인코딩 방식은 모든 문자를 2바이트로 표현하는 UTF-16**\n\n- 자바에서는 따옴표(`''`)와 쌍따옴표(`\"\"`) 구분하자. 따옴표가 **문자형, char**, 쌍따옴표가 **문자열, string**인 듯 하다.\n\n- 아스키 코드 : 영문자, 소문자, 특수 문자 등을 나타내는 문자 세트, 1바이트만 사용\n\n- 유니코드(unicode) : 영어 이외에 한글이나 다른 언어 문자는 복잡하고 다양해서 2바이트 이상을 사용하게 됨. 그래서 각 언어의 표준 인코딩을 정의해놓은 것. 유니코드의 1바이트는 아스키 코드 값과 호환되면서 그 밖의 문자를 2바이트나 그 이상의 조합으로 표현. **자바는 유니코드에 기반하여 문자를 표현. 따라서, 자바의 문자 자료형인 char형은 2바이트 사용**\n\n```java\nchar myChar = 'A';\n// 문자 그대로 저장되는 것이 아니라\n// 문자에 해당하는 정수 값(아스키 코드 값)이 저장\n```\n\n\u003cbr\u003e\n\n### 문자형 - 유니코드\n\n유니코드를 표현하는 인코딩 방법은 **UTF-8**, **UTF-16**이 있음 \u003cbr\u003e\n\n**자바의 기본 인코딩 방식은 모든 문자를 2바이트로 표현하는 UTF-16** \u003cbr\u003e\u003cbr\u003e\n\n모두 2바이트로 표현하니까 알파벳 같은 자료(1바이트 자료)를 저장하는 경우 낭비가 있을 수 있음. 반면에, UTF-8은 각 문자마다 1바이트에서 4바이트를 사용하여 문자를 나타내는 방식임. 따라서, UTF-8은 UTF-16에 비해 메모리 낭비가 적고 전송 속도가 빠름. 이러한 특성으로 인터넷에서 많이 사용 (예를 들어, HTML emmet 해보면 UTF-8로 나옴)\n\n\u003cbr\u003e\n\n- `\\u`를 붙히고 뒤에 유니코드를 적는다.\n\n- \u003ca href='https://www.unicode.org/charts/PDF/UAC00.pdf' target='_blank'\u003e한글 유니코드\u003c/a\u003e에서 코드 참조\n\n```java\npackage chapter2;\n  \npublic class ExQ5 {\n\tpublic static void main(String[] args) {\n\t\tchar ch = '\\uAE00';\n\t\tSystem.out.println(ch);\n\t}\n}\n// 글\n```\n\n\u003cbr\u003e\n\n### 실수형\n\n- 부동 소수점 방식 사용\n\n- `0.1`은 `1.0 X 10^-1`로 표현 가능. 1.0이 가수, 10이 밑수, 제곱수가 지수\n\n- **자바에서 실수는 double형을 기본으로 사용**\n\n- 기본이 double이니까 float 사용하면 식별자 `F` 또는 `f`를 붙혀야함\n\n\u003cbr\u003e\n\n- float형 : 부호 1비트, 지수부 8비트, 가수부 23비트 = 총 32비트(4바이트)\n\n- double형 : 부호 1비트, 지수부 11비트, 가수부 52비트 = 총 64비트(8바이트)\n\n\n```java\npublic class DoubleEx2 {\n\tpublic static void main(String[] args) {\n\t\tdouble dnum = 1;\n\t  \n\t\tfor (int i = 0; i \u003c 10000; i++) {\n\t\t\tdnum = dnum + 0.1;\n\t\t}\n\t\t\n\t\tSystem.out.println(dnum);\n\t}\n}\n  \n// 1001.000000000159\n```\n\n\n정확하게 1001로 떨어지지 않는 이유는 순환소수 문제이다. 다음 [코딩애플 자바스크립트 LEVEL2](brain/Lecture/apple-js/apple-js-02)의 부동소수점 부가 설명을 참고하도록 하자.\n\n\u003cbr\u003e\n\n### 논리형\n\n- `boolean 변수명`\n\n- boolean형 변수는 1바이트 값으로 저장, true / false만 가짐\n\n\n\u003cbr\u003e\n\n### 자료형 추론\n\n- 자바 10부터 생긴 문법\n\n- 자바스크립트에 var 같은 거임. 자료형을 정확히 명시 안하고도 변수를 사용가능한 것\n\n- **지역 변수 자료형 추론(local variable type inference)** 라고 한다. 변수에 대입되는 자료를 보고 컴파일러가 추측 가능\n\n\u003cbr\u003e\n\n단, 자바스크립트의 var과는 다르다. 자바스크립트의 var는 재선언, 재할당 모두 가능했지만, **자바의 var는 재선언이 불가능**하다. 추가로, var로 자료형 없이 변수를 선언하려면 **지역 변수만 가능**하다. 지역 변수는 프로그램의 `{}`의 내에서 사용할 수 있는 변수이다. 즉, 자바스크립트의 var은 function 스코프였는데, 자바의 var는 block 스코프이다.\n\n```java\nvar i = 10; // int i = 10으로 컴파일\nvar j = 10.0; // double j = 10.0으로 컴파일\nvar str = \"hello\"; // String str = \"hello\"로 컴파일\n```\n\n\u003chr\u003e\n\n## Java 상수\n\n- 자바스크립트에서는 const 썼는데, **자바에서는 final 예약어 사용**\n\n- 재선언, 재할당 당연히 불가. 처음에 할당 안하고 써도 오류\n\n```java\nfinal double PI = 3.14;\nfinal int MAX_NUM = 100;\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter2;\n  \npublic class Constant {\n\tpublic static void main(String[] args) {\n\t\tfinal int MAX_NUM = 100;\n\t\tfinal int MIN_NUM;\n\t\t  \n\t\tMIN_NUM = 0; // 사용하기 전에 초기화 한 것, 초기화 안하면 오류 발생\n\t\t  \n\t\tSystem.out.println(MAX_NUM);\n\t\tSystem.out.println(MIN_NUM);\n\t}\n}\n\n```\n\n\u003chr\u003e\n\n## Java 리터럴\n\n- 리터럴(literal)은 프로그램에서 사용하는 모든 숫자, 문자, 논리값을 일컫는 말\n\n- 리터럴 혹은 리터럴 상수라고 함\n\n리터럴은 **프로그램이 시작할 때 시스템에 같이 로딩되어 특정 메모리 공간인 상수 풀(constant pool)에 놓인다.** 예를 들어, `int num = 3;`에서 값인 3이 메모리 공간 어딘가에 존재해야, num 변수에 그 값을 복사할 수 있다. **즉, 숫자가 변수에 대입되는 과정은 일단 숫자 값이 어딘가 메모리에 써져 있어야 하고, 이 값이 다시 변수 메모리에 복사되는 것이다.**\n\n![](brain/image/chap02-1.png)\n\n\u003cbr\u003e\n\nlong형에서 식별자 L을 사용해주는 이유가 이때문이다. 자바에서 정수를 표현하는 메모리의 기본 크기는 4바이트인데, 상수 풀에서도 마찬가지다. 리터럴은 int형으로 처리되는데 long형은 4바이트 크기에 들어갈 수 없어서 8바이트로 처리하라고 컴파일러에게 알려주어야 한다. 이 때문에 **이 리터럴은 long형으로 저장되어야 한다는 의미로 리터럴 뒤에 식별자 L 이나 l을 붙혀주는 것**이다.\n\n\u003chr\u003e\n\n## Java 형 변환\n\n형 변환 기본 원칙 (작고 덜 정밀 -\u003e 크고 더 정밀은 자동)\n\n1. **바이트 크기가 작은 자료형 -\u003e 큰 자료형** : 자동으로 형 변환\n\n2. **덜 정밀한 자료형 -\u003e 더 정밀한 자료형** : 자동으로 형 변환\n\n![](brain/image/chap02-2.png)\n\n\u003cbr\u003e\n\n### 묵시적 형 변환 (자동)\n\n- 바이트 크기가 작은 자료형 -\u003e 큰 자료형으로 대입하는 경우\n\n\n```java\nbyte bNum = 10;\nint iNum = bNum;\n```\n\n1바이트 -\u003e 4바이트이므로 자료 손실 없이 다 저장됨. 남은 3바이트는 0으로 채워짐\n\n\u003cbr\u003e\n\n- 덜 정밀한 자료형 -\u003e 더 정밀한 자료형으로 대입하는 경우\n\n```java\nint iNum2 = 20;\nfloat fNum = iNum2;\n```\n\n4바이트 -\u003e 4바이트이지만, float 자료형이 더 정밀하게 표현가능해서 변환됨\n\n\u003cbr\u003e\n\n- 연산 중 자동 형 변환\n\n```java\nint iNum = 20;\nfloat fNum = iNum;\ndobule dNum;\ndNum = fNum + iNum;\n```\n\n대입 전 float + int 해서 float형으로 먼저 되고, float -\u003e double로 형 변환 됨.\n\n\u003cbr\u003e\n\n### 명시적 형 변환 (강제)\n\n- 바이트 크기가 큰 자료형 -\u003e 작은 자료형\n\n```java\nint iNum = 10;\nbyte bNum = (byte)iNum;\nSystem.out.println(bNum);\n// 10\n  \nint iNum2 = 1000;\nbyte bNum2 = (byte)iNum2;\nSystem.out.println(bNum2);\n// -24\n```\n\n4바이트 -\u003e 1바이트이므로 자료 손실 발생 가능하다. \u003cbr\u003e\n\n예를 들어, 10은 1바이트에 표현 가능하니까 자료손실 X \u003cbr\u003e\n\n하지만, 1000의 경우 byte 범위 (-128~127) 벗어나니까 자료손실 O\n\n\n\u003cbr\u003e\n\n- 더 정밀한 자료형 -\u003e 덜 정밀한 자료형\n\n\n```java\ndouble dNum = 3.14;\nint iNum = (int)dNum;\n  \nSystem.out.println(dNum);\nSystem.out.println(iNum);\n// 3.14\n// 3\n```\n\n더 정밀 -\u003e 덜 정밀이니까 자료 손실 발생 가능. 실수의 소수점 이하 부분이 생략되고 정수 부분만 대입되는 것을 확인 가능\n\n\u003cbr\u003e\n\n\n- 연산 중 형 변환\n\n\n```java\npackage chapter2;\n  \npublic class ExplicitConversion {\n\tpublic static void main(String[] args) {\n\t\tdouble dNum1 = 1.2;\n\t\tfloat fNum2 = 0.9F;\n\t\t  \n\t\tint iNum3 = (int)dNum1 + (int)fNum2;\n\t\tint iNum4 = (int)(dNum1 + fNum2);\n\t\tSystem.out.println(iNum3);\n\t\tSystem.out.println(iNum4);\n\t}\n}\n\n// 1\n// 2\n```\n\n형 변환이 언제 이루어지는 지도 key point. 위에는 형 변환을 하고 더하기 때문에 소수점 아래를 버려버리면 `1 + 0 = 1`의 결과가 나오고, 아래에는 더한 이후 형 변환을 하기 때문에 `1.2 + 0.9 = 2.1을 소수점 아래 버리면 2`이다.","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/chap03":{"title":"03.자바의 연산자","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 03 - 자바의 여러 가지 연산자\n\n\u003cbr\u003e\n\n\n## Java 기본 연산자\n\n### 항과 연산자\n\n\u003cbr\u003e\n\n| 연산자 | 설명 | 예시 |\n| :---------: | :-----------------: | :----------------: |\n| 단항 연산자 | 항이 한 개인 연산자 | ++num |\n| 이항 연산자 | 항이 두 개인 연산자 | num1 + num2; |\n| 삼항 연산자 | 항이 세 개인 연산자 | ( 5 \u003e 3 ) ? 1 : 0; |\n\n\u003cbr\u003e\n\n\n추가로, `/`는 몫, `%`는 나머지 !\n\n```java\nint num1 = 10;\nint num2 = 4;\n  \nnum1 / num2 = 2; // 몫\nnum1 % num2 = 2; // 나머지\n```\n\n\u003cbr\u003e\n\n### 논리 연산 주의점\n\n- AND(`\u0026\u0026`) 연산 : 둘다 true여야 결과가 true라서 앞에꺼 하나라도 false가 나오면 뒤에 문장을 실행 안하고 false로 확정짓고 넘어감\n\n- OR(`||`) 연산 : 둘 중 하나만 true여도 겨로가가 true라서 앞에꺼 하나라도 true가 나오면 뒤에꺼 실행 안하고 true로 확정짓고 넘어감\n\n**논리 곱, 논리 합 연산 시 두 항을 모두 실행하지 않더라도 결과 값을 알 수 있는 경우에, 나머지 항이 실행되지 않는 것을 단락 회로 평가(Short Circuit Evaluation; SCE)라고 한다.**\n\n```java\npackage chapter03;\n\npublic class pr03_OperationEx3 {\n\tpublic static void main(String[] args) {\n\t\tint num1 = 10;\n\t\tint i = 2;\n\t\t  \n\t\tboolean value = ((num1 = num1 + 10) \u003c 10) \u0026\u0026 ((i = i + 2) \u003c 10);\n\t\tSystem.out.println(value);\n\t\tSystem.out.println(num1);\n\t\tSystem.out.println(i);\n\t\t\n\t\tvalue = ((num1 = num1 + 10) \u003e 10) || ((i = i + 2) \u003c 10);\n\t\tSystem.out.println(value);\n\t\tSystem.out.println(num1);\n\t\tSystem.out.println(i);\n\t}\n}\n\n// false\n// 20\n// 2 논리 곱, 앞 항 거짓이라서 뒷 항 실행 안되고 i값 그대로\n// true\n// 30\n// 2 논리 합, 앞 항 참이라서 뒷항 실행 안되고 i값 그대로\n```\n\n\u003cbr\u003e\n\n### 조건 연산자\n\n\u003cbr\u003e\n\n| 연산자 | 기능 | 예시 |\n| :--------------------: | :-------------------------------------------------------: | :--------------------------: |\n| 조건식 ? 결과1 : 결과2 | 조건식이 참이면 결과 1, \u003cbr\u003e 조건식이 거짓이면 결과2 선택 | int num = (5 \u003e 3) ? 10 : 20; |\n\n\u003cbr\u003e\n\n```java\npackage chapter03;\n\npublic class pr04_OperationEx4 {\n\tpublic static void main(String[] args) {\n\t\tint num = 10;\n\t\tboolean isEven;\n\t\tisEven = (num % 2 == 0) ? true : false;\n\t\tSystem.out.println(isEven);\n\t}\n}\n\n// true\n```\n\n\u003chr\u003e\n\n## Java 비트 연산자\n\n### 비트 논리 연산자\n\n- `\u0026` : AND 연산자\n\n```java\nnum1 : 0 0 0 0 0 1 0 1 // 5\n\u0026 num2 : 0 0 0 0 1 0 1 0 // 10\n------------------------\nresult : 0 0 0 0 0 0 0 0 // 0\n  \n// 5 \u0026 10 = 0\n```\n  \n- `|` : OR 연산자\n  \n```java\nnum1 : 0 0 0 0 0 1 0 1 // 5\n| num2 : 0 0 0 0 1 0 1 0 // 10\n------------------------\nresult : 0 0 0 0 1 1 1 1 // 15\n  \n// 5 | 10 = 15\n```\n\n- `^` : XOR 연산자, 같으면 0, 다르면 1\n  \n```java\nnum1 : 0 0 0 0 0 1 0 1 // 5\n^ num2 : 0 0 0 0 1 0 1 0 // 10\n------------------------\nresult : 0 0 0 0 1 1 1 1 // 15\n\n// 5 ^ 10 = 15\n```\n\n- `~` : 반전 연산자, 부호 비트가 1이면 음수인거 까먹지 말기  \n\n```java\nnum : 0 0 0 0 0 1 0 1 // 10\n------------------------\n~ num : 1 1 1 1 1 0 1 0 // -11\n// ~10 = -11\n```\n  \n\u003cbr\u003e\n\n### 비트 이동 연산자\n\n- `\u003c\u003c` : 좌측 시프트 연산자, 왼쪽으로 비트 이동, 뒷부분인 오른쪽에 0 채우기  \n\n```java\nnum : 0 0 0 0 0 1 0 1 // 5\nnum \u003c\u003c 2 : 0 0 0 1 0 1 0 0 // 20\n```\n\n왼쪽으로 n비트 이동한다는 것은 **기존 값 \\* n\u003csup\u003e2\u003c/sup\u003e** 이다.\n\n따라서, `5 \u003c\u003c 2`는 5 \\* 2\u003csup\u003e2\u003c/sup\u003e = 20이다.\n\n\u003cbr\u003e\n\n- `\u003e\u003e` : 우측 시프트 연산자, 오른쪽으로 비트 이동, 앞부분인 왼쪽에 0 채우기, 추가로 기존 값의 부호비트와 동일\n\n```java\nnum : 0 0 0 0 1 0 1 0 // 10\nnum \u003e\u003e 2 : 0 0 0 0 0 0 1 0 // 2\n```\n  \n왼쪽으로 n비트 이동한다는 것은 **기존 값 / n\u003csup\u003e2\u003c/sup\u003e** 이다.\n\n따라서, `10 \u003e\u003e 2`는 10 / 2\u003csup\u003e2\u003c/sup\u003e = 2이다.\n\n\u003cbr\u003e\n\n- `\u003e\u003e\u003e` : 우측 시프트 연산자, 오른쪽으로 비트 이동, 앞부분인 왼쪽에 0 채우기, \u003e\u003e와 다른점은 얘는 기존 값의 부호비트와 상관 없이 무조건 0이 채워짐","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/chap04":{"title":"04.제어문","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 04 - 자바의 제어문\n\n\u003cbr\u003e\n\n## Java 조건문\n\n### Java if문\n\n\u003cbr\u003e\n\n```java\nif (조건식1) {\n\t수행문1;\n}\n\nelse if (조건식2) {\n\t수행문2;\n}\n\nelse {\n\t수행문3;\n}\n```\n\n\u003cbr\u003e\n\n- if문 내부 수행하는 문장이 1개면 중괄호`{}` 없어도 됨. 하지만, 코드 가독성이 좋게 하려면 쓰는 것을 추천\n\n```java\nif (조건식1) 수행문1;\n```\n\n\u003cbr\u003e\n\n### Java switch-case문\n\n- break의 역할은 switch문 밖으로\n\n- break 안쓰면 해당하는 case부터 아래로 쭈욱 실행\n\n\n```java\nswitch(조건) {\n\tcase 값1 : 수행문1;\n\t\tbreak;\n\t  \n\tcase 값2 : 수행문2;\n\t\tbreak;\n\t  \n\tcase 값3 : 수행문3;\n\t\tbreak;\n\t  \n\tdefault : 수행문4;\n\t// 주어진 값이 case에 해당하지 않을 시 default 실행\n}\n```\n\n\u003cbr\u003e\n\n- case문 동시 사용\n\n- 1, 3, 5, 7, 8, 10, 12월은 31일 까지\n\n- 4, 6, 9, 11월은 30일 까지\n\n- 2월은 28일 까지\n\n```java\ncase 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 : day = 31;\n\tbreak;\n\ncase 4 : case 6 : case 9 : case 11 : day = 30;\n\tbreak;\n\t\ncase 2 : day = 28;\n\tbreak;\n```\n\n\u003cbr\u003e\n\n- 자바7부터 case 값에 정수 말고 문자열도 사용 가능\n\n- 이전에는 원래 `equals()` 메서드를 이용해서 비교했어야함\n\n```java\nif (medal.equals(\"Gold\")) {\n\t...\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter04;\n  \npublic class pr04_SwitchCase2 {\n\tpublic static void main(String[] args) {\n\t\tString medal = \"Gold\";\n\t\t  \n\t\tswitch(medal) {\n\t\t\tcase \"Gold\":\n\t\t\t\tSystem.out.println(\"금메달입니다.\");\n\t\t\t\tbreak;\n\t\t\tcase \"Silver\":\n\t\t\t\tSystem.out.println(\"은메달입니다.\");\n\t\t\t\tbreak;\n\t\t\tcase \"Bronze\":\n\t\t\t\tSystem.out.println(\"동메달입니다.\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"메달이 없습니다.\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n\u003chr\u003e\n\n## Java 반복문\n\n### while문\n\n\u003cbr\u003e\n\n```java\nwhile(조건식) {\n\t수행문1;\n\t// 조건식 참이면 수행\n}\n  \n// 무한루프\nwhile(true) {\n\t수행문2;\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter04;\n  \npublic class pr05_WhileExample1 {\n\tpublic static void main(String[] args) {\n\t\tint num = 1;\n\t\tint sum = 0;\n\t\t  \n\t\twhile (num \u003c= 10) {\n\t\t\tsum += num;\n\t\t\tnum++;\n\t\t}\n\t\tSystem.out.println(\"1부터 10까지의 합 = \" + sum);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### do-while문\n\n\u003cbr\u003e\n\n```java\n// 수행문1을 일단 1번 실행, 그 이후 while 조건식 참이면 실행\n\ndo {\n\t수행문1;\n\t...\n} while (조건식);\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter04;\n\npublic class pr06_DoWhileExample {\n\tpublic static void main(String[] args) {\n\t\tint num = 1;\n\t\tint sum = 0;\n  \n\t\tdo {\n\t\t\tsum += num;\n\t\t\tnum++;\n\t\t} while(num \u003c= 10);\n\t\tSystem.out.println(\"1부터 10까지의 합 = \" + sum);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### for문\n\n\u003cbr\u003e\n\n```java\nfor (int i = 0; i \u003c= 10; i++) {\n\t수행문~\n}\n```\n  \n\u003cbr\u003e\n\n### for문 요소 생략하기\n\n\u003cbr\u003e\n\n**초기화식 생략**\n\n- 이미 변수 초기화 해서 중복으로 초기화할 필요 없을 때\n\n```java\nint i = 0;  \n\nfor ( ; i \u003c 5; i++) {\n\t...\n}\n```\n\n\u003cbr\u003e\n\n**조건식 생략**\n\n- 어떤 연산 결과 값이 나왔을 때 바로 for문 수행 멈추고 싶을 때\n\n- 조건식 생략하고 if문과 break 활용\n\n\n```java\nfor (i = 0; ; i++) {\n\tsum += i;\n\tif (sum \u003e 200) break;\n}\n```\n\n\u003cbr\u003e\n\n**증감식 생략**\n\n- 증감식 연산이 복잡하거나 다른 변수의 연산 결과 값에 좌우될 때\n\n```java\nfor ( i = 0; i \u003c 5; ) {\n\t...\n\ti = (++i) % 10;\n}\n```\n\n\u003cbr\u003e\n\n**요소 모두 생략**\n\n- 무한 루프\n\n```java\nfor ( ; ; ) {\n\t// 무한루프\n}\n```\n\n**구현 예시**\n\n```java\npackage chapter04;\n  \npublic class pr07_forExample {\n\tpublic static void main(String[] args) {\n\t\t// 초기화식 생략\n\t\tint i = 0;\n\t\tfor ( ; i \u003c 5; i++) {\n\t\t\tSystem.out.println(\"초기화식 생략 예제 \" + \"반복횟수 = \" + i);\n\t\t}\n\t  \n\t\t// 조건식 생략\n\t\tint j;\n\t\tint sum = 0;\n\t\tfor ( j = 0; ; j++ ) {\n\t\t\tsum += j;\n\t\t\tSystem.out.println(\"조건식 생략 예제 더하는 중, 반복횟수 = \" + j);\n\t\t\tif (sum \u003e 200) break;\n\t\t}\n\t\tSystem.out.println(\"조건식 생략 예제 끝난 후 합 = \" + sum);\n\t  \n\t\t// 증감식 생략\n\t\tfor (int k = 0; k \u003c 5; ) {\n\t\t\tk = (++k) % 10;\n\t\t\tSystem.out.println(k);\n\t\t}\n\t  \n\t\t// 요소 모두 생략\n\t\t// for ( ; ; ) {\n\t\t// 무한루프 입니다.\n\t\t// }\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### continue문\n\n- continue문은 반복문과 함께 씀\n\n- 반복문 안에서 continue문 만나면 **이후 문장 수행 X**\n\n- 그 이후 for문 처음으로 돌아가서 **증감식 수행**\n\n- 사용 용도 : 반복문 수행 중 특정 조건에서는 수행하지 않고 건너뛰고 싶을 때\n\n```java\npackage chapter04;\n  \npublic class pr09_ContinueExample {\n\tpublic static void main(String[] args) {\n\t\tint sum = 0;\n\t\tfor (int i = 1; i \u003c= 100; i++) {\n\t\t\tif ( i % 2 == 0 ) continue;\n\t\t\tsum += i;\n\t\t}\n\t\tSystem.out.println(\"1부터 100까지 홀수의 합은 = \" + sum);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### break문\n\n실제로 어디에 사용하냐를 보이겠음. 0부터 시작해서 숫자를 1씩 늘리면서 합을 계산할 때 숫자를 몇까지 더하면 100이 넘는지 알고 싶다고 하자.\n\n```java\npackage chapter04;\n  \npublic class pr10_BreakExample1 {\n\tpublic static void main(String[] args) {\n\t\tint sum = 0;\n\t\tint num = 0;\n\t\t  \n\t\tfor (num = 0; sum \u003c 100; num++) {\n\t\t\tsum += num;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"num : \" + num);\n\t\tSystem.out.println(\"sum : \" + sum);\n\t}\n}\n  \n// num : 15\n// sum : 105\n```\n\nnum이 아닌 sum의 조건에 따라 코드가 진행되다 보니, num이 증감된 상태에서 sum의 조건을 만나 올바르지 않은 답이 나오는 것을 볼 수 있음.\n\n```java\npackage chapter04;\n\npublic class pr11_BreakExample2 {\n\tpublic static void main(String[] args) {\n\t\tint sum = 0;\n\t\tint num = 0;\n\t\t\n\t\tfor (num = 0; ; num++) {\n\t\t\tsum += num;\n\t\t\tif (sum \u003e= 100)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(\"num : \" + num);\n\t\tSystem.out.println(\"sum : \" + sum);\n\t}\n}\n\n// num : 14\n// sum : 105\n``` \n\n\u003ca href='/brain/Book/do-it-java/chap04/#for문-요소-생략하기'\u003e조건식 생략\u003c/a\u003e의 스킬을 이용하였고 for문 내부에 조건을 걸어줌으로써 break 시켜서 반복문을 아예 빠져나가게 했음\n\n\u003cbr\u003e\n\n- break 문의 위치\n\n```java\nwhile(조건식1) {\n\twhile(조건식2) {\n\t\tif (조건식) // 조건에 해당하는 경우\n\t\t\tbreak; // 내부 반복문만 빠져나옴\n\t}\n}\n```\n\n중첩 반복문을 사용하는 경우 break를 사용하면 해당 반복문만 빠져나온다. 즉, 내부 반복문만 빠져나오고 외부 반복문은 계속 수행한다.\n\n\u003cbr\u003e\n\n### break, continue 차이\n\n- break문은 break; 를 적어준 곳에서 해당 조건문 블록과 그 밖의 반복문 자체를 탈출한다.\n\n- continue문은 해당 조건문 블록을 탈출하여 아래 명령문은 실행하지 않고, 다음 반복문 실행절차를 수행한다.\n\n\u003cbr\u003e\n\n### 연습문제 2번\n\n\n```java\npackage chapter04;\n\npublic class ex02_Q2 {\n\tpublic static void main(String[] args) {\n\t\tint dan, times;\n\t\t\n\t\t// 내가 짠 코드\n//\t\tfor (dan = 1; dan \u003c= 9; dan++) {\n//\t\t\tfor (times = 1; times \u003c= 9; times++) {\n//\t\t\t\tif (dan % 2 == 0) {\n//\t\t\t\t\tSystem.out.println(dan + \" X \" + times + \" = \" + (dan * times));\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\t  \n\t\t// 정답 코드\n\t\tfor (dan = 1; dan \u003c= 9; dan++) {\n\t\t\tif (dan % 2 != 0) continue;\n\t\t\tfor (times = 1; times \u003c= 9; times++) {\n\t\t\t\tSystem.out.println(dan + \" X \" + times + \" = \" + (dan * times));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n내가 짠 코드는 결국 두번째 for문까지 와서 일단 다 돌려야 한다. \u003cbr\u003e\u003cbr\u003e\n\n하지만 정답 코드는 continue문을 이용해서 홀수면 밑에 for문을 수행하지 않고 바로 다음 반복문으로 넘어가도록 설계했기 때문에 더 좋은 코드이다.\n\n\u003cbr\u003e\n\n### 연습문제 3번\n\n\u003cbr\u003e\n\n```java\npackage chapter04;\n\npublic class ex03_Q3 {\n\tpublic static void main(String[] args) {\n\t\tint dan, times;\n\n        // 내가 짠 코드\n//\t\tfor (dan = 1; dan \u003c= 9; dan++) {\n//\t\t\tfor (times = 1; times \u003c= dan; times++) {\n//\t\t\t\tSystem.out.println(dan + \" X \" + times + \" = \" + (dan * times));\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\t\n\t\t// 정답 코드\n\t\tfor (dan = 1; dan \u003c= 9; dan++) {\n\t\t\tfor (times = 1; times \u003c= 9; times++) {\n\t\t\t\tif (dan \u003c times) break;\n\t\t\t\t\tSystem.out.println(dan + \" X \" + times + \" = \" + (dan * times));\n\t\t\t}\n\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n이건 내가 짠 코드대로 짤 것 같은데 정답코드처럼 break 문을 이용할 수도 있다. 이건 내가 적은 방법이 더 좋은듯 \u003cbr\u003e\u003cbr\u003e\n\n\n연습문제 4번, 5번은 백준 별찍기 5번, 7번이니까 그거 참조","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/chap05":{"title":"05.클래스와 객체 (1)","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 05 - 클래스와 객체 (1)\n\n\u003cbr\u003e\n\n|용어|설명|\n|:--:|:--:|\n|객체|객체 지향 프로그램의 대상, 생성된 인스턴스|\n|클래스|객체를 프로그래밍하기 위해 코드로 만든 상태|\n|인스턴스|클래스가 메모리에 생성된 상태|\n|멤버 변수|클래스의 속성, 특성|\n|메서드|멤버 변수를 이용하여 클래스의 기능을 구현|\n|참조 변수|메모리에 생성된 인스턴스를 가리키는 변수|\n|참조 값|생성된 인스턴스의 메모리 주소 값|\n\n\u003cbr\u003e\n\n## 클래스와 객체\n\n### 객체 지향 프로그래밍 기본 컨셉  \n\n- 절차 지향 프로그래밍 : 일어나는 일을 시간 순서으로 프로그래밍\n\n- 객체 지향 프로그래밍 : 객체를 만들고 객체 사이에 일어나는 일을 구현하는 프로그래밍\n\n\u003cbr\u003e\n\n### 클래스 (Class)\n\n- 객체 지향 프로그램은 클래스를 기반으로 프로그래밍\n\n- 클래스 : 객체의 속성과 기능을 구현\n\n- 클래스를 정의한다 : 객체를 클래스로 구현한다\n\n- 멤버 변수 : 객체의 속성\n\n- 메서드 : 객체의 기능\n\n\u003cbr\u003e\n\nStudent 클래스를 생각했을 때, 학번, 이름, 학년, 사는 곳 등 선언하는 클래스의 속성을 **멤버 변수**라고 한다.\n\n```java\n(접근 제어자) class 클래스 이름 {\n\t멤버 변수;\n\t메서드;\n}\n\npublic class Student {\n\tint studentID;\n\tString studentName;\n\tint grade;\n\tString address;\n}\n```\n\n- 접근 제어자가 public인 경우 `클래스 이름 = 자바 파일 이름` 이어야 한다.\n\n- 클래스 외부에는 package 선언, import 문장 외에 아무 것도 선언 X\n\n- 클래스 코딩 컨벤션 : 클래스 이름은 대문자로 시작\n\n\u003chr\u003e\n\n## 클래스 살펴보기\n\n### 멤버 변수\n\n- 멤버 변수(member variable) = 속성(property) = 특성(attribute)\n\n- 클래스형 = 객체 자료형 = 참조 자료형\n\n\u003cbr\u003e\n\n변수의 자료형 = 기본 자료형 + 참조 자료형\n\n- 기본 자료형 : int, long, float, double 등\n\n- 참조 자료형 : JDK에서 제공하는 String, Date 혹은 내가 만든 Student 등\n\n\u003cbr\u003e\n\n### 메서드\n\n- 메서드(method) = 멤버 함수(member function)\n\n```java\npackage classpart;\n  \npublic class Student {\n\t// 멤버 변수 - 클래스의 속성\n\tint studentID;\n\tString studentName;\n\tint grade;\n\tString address;\n\t  \n\t// 메서드 - 클래스의 기능\n\tpublic void showStudentInfo() {\n\t\tSystem.out.println(studentName + \",\" + address);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### 패키지\n\n- 패키지 : 클래스 파일의 묶음, 계층 구조 가질 수 있음\n\n- 계층 구조를 잘 구성해야 소스코드 관리, 유지 보수 수월\n\n\n```java\npackage domain.student.view;\n  \npublic class StudentView {\n\n}\n```\n\n위 코드에서 `클래스 이름 = StudentView` 이지만, `클래스 전체 이름 = domain.student.view.StudentView`이다. **클래스 이름이 같아도 패키지 이름이 다르면 클래스 전체 이름이 다른 것이므로 다른 클래스이다.**\n\n\u003chr\u003e\n\n## 메서드 (method)\n\n- 메서드는 함수(function)의 한 종류\n\n\u003cbr\u003e\n\n### 함수란?\n\n- **하나의 기능**을 수행하는 일련의 코드\n\n- 함수는 어떤 **기능**을 수행하도록 미리 구현해 놓고 필요할 때마다 호출해서 사용\n\n\u003cbr\u003e\n\n### 함수의 입력과 반환\n\n- 함수는 이름, 입력 값, 결과 값을 가짐\n\n- Input이 있으면 Output이 있다는 말\n\n- 매개변수(parameter) : 함수의 **입력**으로 받는 변수\n\n- 반환 값 : 입력의 결과로 반환해주는 함수의 결과\n\n\u003cbr\u003e\n\n### 함수 정의하기\n\n\u003cbr\u003e\n\n```java\nint add(int num1, int num2) {\n\tint result;\n\tresult = num1 + num2;\n\treturn reslt;\n}\n```\n\n- `int` : 함수 반환형\n\n- `add` : 함수 이름\n\n- `(int num1, int num2)` : 매개변수\n\n\u003cbr\u003e\n\n매개변수가 필요 없는 함수도 있음. 함수 실행하면 함수를 수행한 결과 값만 있음\n\n```java\nint getTenTotal() {\n\tint i;\n\tint total = 0;\n\tfor (i = 1; i \u003c= 10; i++) {\n\t\ttotal += i;\n\t}\n\treturn total;\n}\n```\n\n\u003cbr\u003e\n\n반환 값 없는 함수\n\n- 반환 값 없어도 위치 비우지말고 return은 쓰기\n\n- 반환형에 **void** 표시\n\n- return은 함수 수행을 종료하는 명령어로 이해\n\n```java\nvoid printGreeting(String name) {\n\tSystem.out.println(name + \"님 안녕하세요\");\n\treturn; // 반환 값 없음\n}\n```\n\n\u003cbr\u003e\n\n### 함후 호출과 스택 메모리\n\n\n- 스택(stack) : 함수를 호출하면 그 함수만을 위하여 할당되는 메모리 공간\n\n- 자료가 상자처럼 쌓임, LIFO(Last In First Out)\n\n![](brain/image/chap05-1.png)\n\n![](brain/image/chap05-2.png)\n\n- 지역변수 : num1, num2 혹은 n1, n2 같이 함수 내부에서만 사용하는 변수\n\n- 지역변수는 스택 메모리에 생성\n\n\u003cbr\u003e\n\n### 함수의 장점\n\n1. 기능을 나누어 코드를 효율적으로 구현\n\n2. 기능별로 함수 구현해 놓으면 같은 기능 매번 코드로 안짜고 함수 호출하면 됨\n\n3. **오류 수정 디버깅 작업 편함**, 하나의 기능이 함수로 구현되어 있으니까 오류가 난 기능만 찾아서 수정하면 됨\n\n하나의 함수에 여러 기능이 섞여 있으면, 함수의 장점을 활용할 수 없음. **이름에 맞는 하나의 기능을 구현하는 함수를 작성하자.**\n\n\u003cbr\u003e\n\n### 메서드는 클래스 기능을 구현\n\n위에서 설명한건 프로그래밍 언어적인 면에서 함수의 기능이다. 자바의 클래스 내부에는 클래스의 속성인 멤버 변수, 클래스의 기능인 멤버 함수(메서드)가 있다. 메서드는 함수에 객체지향 개념이 포함된 용어\n\n\u003cbr\u003e\n\n```java\npackage classpart;\n  \npublic class Student {\n\tint studentID;\n\tString studentName;\n\tint grade;\n\tString address;\n\t  \n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n\t  \n\tpublic void setStudentName(String name) {\n\t\tstudentName = name;\n\t}\n}\n```\n\n- `getStudentName()` : 학생 이름 반환하는 메서드\n\n- `setStudentName()` : 학생 이름을 멤버 변수에 대입하는 메서드\n\nsetStudentName() 메서드는 Student 클래스를 사용하는 다른 코드에서 학생 이름을 새로 지정하거나 바꿔준다. **studentName 값을 지정하는 set 기능을 제공하는 것이다.**\n\n\u003chr\u003e\n\n## 클래스와 인스턴스\n\n### 클래스 사용과 main() 함수\n\n**프로그램을 시작하는 main() 함수** \u003cbr\u003e\n\n`main() 함수` : 자바 가상 머신(JVM)이 프로그램을 시작하기 위해 호출하는 함수, 클래스 내부에 만들지만, 클래스의 메서드는 아니다.\n\n\u003cbr\u003e\n\nmain() 함수에서 클래스 사용하는 방법\n\n- 만든 클래스 내부에 main() 함수 만들기\n\n- 외부에 테스트용 클래스 만들어서 사용\n\n\u003cbr\u003e\n\n**Student 클래스 내부에 main() 만들어서 사용**\n\n```java\npackage chapter05;\n\npublic class Student {\n\tint studentID;\n\tString studentName;\n\tint grade;\n\tString address;\n\t  \n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n\t  \n\tpublic static void main(String[] args) {\n\t\tStudent studentAhn = new Student(); // Student 클래스 생성\n\t\tstudentAhn.studentName = \"안연수\";\n\t\t  \n\t\tSystem.out.println(studentAhn.studentName);\n\t\tSystem.out.println(studentAhn.getStudentName());\n\t}\n}\n\n// 안연수\n// 안연수\n```\n\n- 클래스 내부에 main() 함수를 만들면 이 클래스가 프로그램의 시작 클래스\n\n- 클래스가 제대로 수행되는지 알아보기 위해 클래스 내부에 main() 함수 만들고 직접 실행할 수 있음\n\n- 하지만, 이렇게 모든 클래스 내부에 main()을 포함시키지는 않음. 귀찮으니까\n\n\u003cbr\u003e\n\n**main() 함수를 포함한 실행 클래스 따로 만들기**\n\n\n```java\npackage chapter05;\n  \npublic class StudentTest {\n\tpublic static void main(String[] args) {\n\t\tStudent studentAhn = new Student(); // Student 클래스 생성\n\t\tstudentAhn.studentName = \"안승연\";\n\t  \n\t\tSystem.out.println(studentAhn.studentName);\n\t\tSystem.out.println(studentAhn.getStudentName());\n\t}\n}\n  \n// 안연수\n// 안연수\n```\n\n- Student 클래스를 만들지 않은 것이 아니다. 같은 패키지 내부에 아까 Student 클래스를 만들어놨으니 당연히 불러와서 사용할 수 있는 것\n\n- 이 말은 패키지가 다르다면, 사용할 수 없다는 말이다. 그럴때는 **import문을 사용해서 함께 사용하기를 원하는 클래스를 불러와야 한다.**\n\n\u003cbr\u003e\n\n### new 예약어로 클래스 생성\n\n- 클래스를 사용하려면 클래스를 생성해야 함\n\n- 클래스가 생성된다는 것 = 클래스를 실제 사용할 수 있도록 **메모리 공간(힙 메모리)에 올린다는 의미**\n\n- 인스턴스 : 실제로 사용할 수 있도록 생성된 클래스\n\n- 참조 변수 : 인스턴스를 가리키는 클래스형 변수\n\n\u003cbr\u003e\n\n```java\n클래스형 변수이름 = new 생성자;\nStudent studentAhn = new Student();\n```\n\n1. `Student` 클래스 자료형으로\n\n2. `studentAhn` 변수를 선언하고\n\n3. `new Student();`로 Student 클래스를 생성하여\n\n4. `studentAhn`에 대입한다\n\n\t- studentAhn = 참조 변수\n\t- studentAhn이 생성된 인스턴스를 가리킴\n\n\u003cbr\u003e\n\n### 인스턴스와 참조 변수\n\n- 객체 : 의사나 행위가 미치는 대상\n\n- 클래스 : 객체를 코드로 구현한 것\n\n- 인스턴스 : 클래스가 메모리 공간(힙 공간)에 생성된 상태\n\n생성된 클래스의 인스턴스도 객체라고 함\n\n![](brain/image/chap05-3.png)\n\n\u003cbr\u003e\n\n**인스턴스 여러 개 생성**\n\n```java\npackage chapter05\n  \npublic class StudentTest1 {\n\tpublic static void main(String[] args) {\n\t\tStudent student1 = new Student(); // 첫 번째 학생 생성\n\t\tstudent1.studentName = \"안연수\";\n\t\tSystem.out.println(student1.getStudentName());\n\t\tStudent student2 = new Student(); // 두 번째 학생 생성\n\t\tstudent2.studentName = \"안승연\";\n\t\tSystem.out.println(student2.getStudentName());\n\t}\n}\n  \n// 안연수\n// 안승연\n```\n\n\u003cbr\u003e\n\n**참조 변수 사용하기**\n\n- 참조 변수를 사용하여, 인스턴스의 멤버 변수와 메서드 참조가능\n\n- 이때, `도트(.)` 연산자 사용\n\n```java\nstudentAhn.studentName = \"안연수\"; // 멤버 변수 사용\nSystem.out.println(studentAhn.getStudentName()); // 메서드 사용\n```\n\n\u003cbr\u003e\n\n### 인스턴스와 힙 메모리\n\n- 인스턴스가 가지고 있는 멤버 변수를 **힙 메모리**에 저장\n\n- 클래스 생성자를 하나 호출하면 인스턴스가 힙 메모리에 생성됨\n\n```java\nStudent studentAhn = new Student();\n```\n\n![](brain/image/chap05-4.png)\n\n- studentAhn 변수는 **지역 변수**, 따라서 **스택 메모리에 저장**\n\n- 지역 변수인 studentAhn에 생성된 인스턴스를 대입하는 것 = studentAhn에 인스턴스가 생성된 힙 메모리의 주소를 대입한다.\n\n\u003cbr\u003e\n\n```java\nStudent student1 = new Student();\nStudent student2 = new Student();\n```\n\n![](brain/image/chap05-5.png)\n\n- 생성된 다른 인스턴스는 당연히 다른 힙 메모리 공간을 차지\n\n- 클래스가 생성될 때마다 인스턴스는 다른 힙 메모리 공간 차지\n\n- **즉, 멤버 변수를 저장하는 공간이 매번 따로 생긴다는 의미**\n\n- 따라서, 클래스에 선언한 멤버 변수를 다른 말로 **인스턴스 변수**라고 부름\n\n\u003cbr\u003e\n\n**힙 메모리**\n\n힙(heap)은 동적 메모리(dynamic memory) 공간이다. 객체가 생성될 때 사용하는 공간이 힙이다. 힙은 동적으로 할당되고 사용이 끝나면 메모리를 해제해 줘야 한다. 자바는 가비지 컬렉터(garbage collector)가 자동으로 메모리를 해제해 준다.\n\n\u003cbr\u003e\n\n**참조 변수와 참조 값**\n  \n참조 변수(ex.student1, student2)는 힙 메모리에 생성된 인스턴스(ex.Student 클래스)를 가리킨다. 참조 변수에 실제로 어떤 내용이 있는지 출력하겠다.\n\n\u003cbr\u003e\n\n```java\npackage chapter05;\n  \npublic class StudentTest2 {\n\tpublic static void main(String[] args) {\n\t\tStudent student1 = new Student();\n\t\tstudent1.studentName = \"안연수\";\n\t\t  \n\t\tStudent student2 = new Student();\n\t\tstudent2.studentName = \"안승연\";\n\t  \n\t\tSystem.out.println(student1);\n\t\tSystem.out.println(student2);\n\t}\n}\n  \n// chapter05.Student@1b6d3586\n// chapter05.Student@4554617c\n```\n\n- 힙 메모리에 생성된 **인스턴스의 메모리 주소**는 **참조 변수**에 저장 됨\n\n- `클래스 이름@주소 값`\n\n- `주소 값` = `해시 코드(hash code) 값`\n\n- 해시 코드 값은 자바 가상 머신(JVM)에서 객체가 생성되었을 때, **생성된 객체에 할당하는 가상 주소 값**\n\n- 즉, `student1`이 참조 변수, `주소 값`이 참조 값\n\n\u003chr\u003e\n\n## 생성자\n\n\u003cbr\u003e\n\n```java\npackage constructor;\n  \npublic class Person {\n\tString name;\n\tfloat height;\n\tfloat weight;\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage constructor;\n  \npublic class PersonTest {\n\tpublic static void main(String[] args) {\n\t\tPerson personLee = new Person();\n\t}\n}\n```\n\n- 클래스의 멤버 변수는 메서드에 의해 값이 변경될 수도 있지만, 처음 클래스를 생성할 때 값을 정해야 하는 경우도 있음\n\n- 생성자 : 클래스 처음 생성 시, 멤버 변수나 상수를 초기화하는 것\n\n\u003cbr\u003e\n\n**디폴트 생성자** \n\n디폴트 생성자(default constructor) : 생성자가 없는 클래스는 클래스 파일을 컴파일할 때 자바 컴파일러에서 자동으로 생성자를 만들어주는데, 이때, 자동으로 만들어진 생성자\n  \n\u003cbr\u003e\n\n```java\npackage constructor;\n\npublic class Person {\n\tString name;\n\tfloat height;\n\tfloat weight;\n\t\n\t// 자바 컴파일러가 자동으로 제공하는 디폴트 생성자\n\tpublic Person() {}\n}\n```\n\n\u003cbr\u003e\n\n### 생성자 만들기\n\n필요한 경우, 프로그래머가 직접 생성자 구현할 수 있음.\n\n1. 멤버 변수에 대한 값들을 매개변수로 받음\n\n2. 인스턴스가 생성될 때, 멤버 변수 값들을 초기화\n\n즉, 인스턴스가 생성됨과 동시에 멤버 변수의 값을 지정하고 인스턴스를 초기화하기 위해 생성자를 직접 구현해서 사용하기도 함.\n\n\u003cbr\u003e\n\n**생성자 직접 구현한 경우**\n\n- 프로그래머가 직접 구현한 새로운 생성자는 문자열 String형 매개변수를 입력받아서 이름을 지정함.\n\n```java\npackage constructor;\n\npublic class Perseon {\n\tString name;\n\tfloat height;\n\tfloat weight;\n\t  \n\tpublic Person(String pname) {\n\t\tname = pname;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**생성자를 구현하여 디폴트 생성자 없는 경우**\n\n```java\npackage constructor;\n\npublic class PersonTest {\n\tpublic static void main(String[] args) {\n\t\tPerson personLee = new Person();\n\t}\n}\n```\n\n오류 발생. 위에서 String 문자열 하나를 매개변수로 받도록 하는 생성자를 만들면서, **default 생성자가 없음**. 뭐, 쓰고싶으면 디폴트 생성자 하나 만들어서 사용하면 됨\n\n\u003cbr\u003e\n\n**생성자를 구현하고 디폴트 생성자도 구현**\n\n```java\npackage constructor;\n  \npublic class Perseon {\n\tString name;\n\tfloat height;\n\tfloat weight;\n\t  \n\tpublic Person() {}\n\t\n\tpublic Person(String pname) {\n\t\tname = pname;\n\t}\n}\n```\n\n이 경우, 클래스를 실행하면 **두 생성자 중 하나를 선택해서 사용 가능**. 보안 수업 생각해보면 라이브러리 불러와서 쓸 때 import로 막 받아와서 쓰잖음? 그게 클래스를 불러와서 사용할 수 있는거. 그때 그냥 `new keygenerator()` 이런식으로 쓰기도 하지만 매개변수로 값을 넣어서도 쓸 수 있었음. 이는 라이브러리 열어보면 생성자가 여러 개 정의되어 있는 것을 확인가능 !\n\n\u003cbr\u003e\n\n### 생성자 오버로드\n\n- 클래스에 생성자가 두 개 이상 제공되는 경우가 **생성자 오버로드(constructor overload)**\n\n- 매개변수가 있는 생성자를 추가한다고 해서 디폴트 생성자를 꼭 추가해야 하는 것은 아님\n\n\u003cbr\u003e\n\n\u003e [!note] Memo\n\u003e\n\u003e 객체 지향 프로그램에서 메서드 이름이 같고 매개변수만 다른 경우를 \"오버로드\"라고 함\n\n\u003cbr\u003e\n\n학생이 생성될 때 반드시 학번이 있어야 한다면, 아래 처럼 생성자 제공 가능\n\n```java\npublic class Student {\n\tint studentID;\n\t  \n\tpublic Student(int studentID) {\n\t\tthis.studentID = studentID;\n\t}\n}\n```\n\n- 학번을 매개변수로 입력받아, Student 클래스를 생성하는 생성자를 추가함\n\n- 학생을 생성할 때 학번이 꼭 필요하니까, 그냥 만들면 안만들어짐\n\n\u003cbr\u003e\n\n### this 맛보기\n\n\u003cbr\u003e\n\n```java\npublic class Student {\n\tint studentID;\n  \n\tpublic Student(int studentID) {\n\t\tstudentID = studentID\n\t}\n}\n```\n\n- 현재, 인스턴스 변수인 studentID와 매개변수로 전달받은 studentID가 있음\n\n- 나의 마음은 앞의 studentID은 인스턴스 변수로, 뒤의 studentID는 매개변수로 전달받은 것으로 생각할 수 있다. 하지만, 컴파일러는 그렇게 하지 못한다.\n\n```java\npublic class Student {\n\tint studentID;\n  \n\tpublic Student(int mystudentID) {\n\t\tstudentID = mystudentID\n\t}\n}\n```\n\n- 그럼 인스턴스 변수와 매개변수로 전달받은 변수의 이름을 바꾸면 된다. 위에서 pname 사용한 것처럼. 그러나, 이렇게하면 인생이 피곤하지 않을까? 그래서 this 투입\n\n```java\npublic class Student {\n\tint studentID;\n\n\tpublic Student(int studentID) {\n\t\tthis.studentID = studentID;\n\t}\n}\n```\n\n- 매개변수로 전달받은 것은 studentID. 납득하지?\n\n- this는 인스턴스 자기 자신을 가리킨다. 이거 지금 내가 만든 클래스라서 명확하게 인스턴스랑은 다른거 아닌가?라고 생각하고 삐딱선 탄 것 같은데.. 그냥 객체 자기 자신을 가리킨다고 생각하자.\n\n\u003cbr\u003e\n\n\u003e [!note] Tip !\n\u003e\n\u003e 추가로, 정보 은닉과 관련된 이야기인데, 어떤 멤버 변수들은 외부 클래스에서 값을 지정하지 못하는 경우도 있다. (ex. `personLee.name = \"이소룡\"` 이런거 안된다는 말) public이냐 private이냐 등등 접근제어자 신경 안쓸거면 **매개변수가 있는 생성자를 구현하고 이를 사용하는 것이 편리한 경우가 많다.**\n\n\u003chr\u003e\n\n## 참조 자료형\n\n- 자료형 = 기본 자료형(int, float 등) + 참조 자료형(String, Date, Student 등)\n\n- 즉, 필요하다면 클래스를 분리하여 참조 자료형으로 다른 클래스를 참조하여 코드를 짤 수 있음\n\n- 참조 자료형은 프로그래머가 필요에 의해 만든 클래스 or JDK에서 제공하느 클래스를 사용할 수 있음\n\n```java\npackage reference;\n\npublic class Subject {\n\tString SubjectName;\n\tint scorePoint;\n}\n\npublic class Student3 {\n\tint studentID;\n\tString studentName;\n\tSubject korean;\n\tSubject math;\n}\n```\n\n\u003chr\u003e\n\n## 정보 은닉\n\n### 접근 제어자\n\n접근 제어자(access modifier)는 **클래스 내부의 변수/메서드/생성자에 대한 접근 권한을 지정**할 수 있는 예약어이다.\n\n- public : public으로 선언한 변수나 메서드는 **외부 클래스에서 접근 가능**\n\n- private : private으로 선언한 변수나 메서드는 **외부 클래스에서 접근 불가능**\n\n\n```java\npackage hiding;\n  \npublic class Student {\n\tint studentID;\n\tprivate String studentName;\n\tint grade;\n\tString address;\n\t  \n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n\t\n\tpublic void setStudentName(String studentName) {\n\t\tthis.studentName = studentName;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage hiding;\n  \npublic class StudentTest {\n\tpublic static void main(String[] args) {\n\t\tStudent studentLee = new Student();\n\t\tstudentLee.studentName = \"이상원\";\n\t\t  \n\t\tSystem.out.println(studentLee.getStudentName());\n\t}\n}\n```\n\nStudent 클래스의 studentName 변수의 접근 제어자를 private으로 바꾸고 StudentTest 클래스에서 studentName을 접근하려고 하니 바로 오류가 출력된다. `studentLee.studentName = \"이상원\";` 여기부터 바로 오류 출력\n\n접근 제어자가 public일 때는 외부 클래스인 StudentTest에서 접근 가능했지만, private으로 바뀌자 접근이 불가능해졌다.\n\n\u003cbr\u003e\n\n### get(), set() 메서드\n\nprivate으로 선언한 studentName 변수를 외부 코드에서 사용하려면 어떻게?\n\n- studentName 변수를 사용할 수 있도록 public 메서드를 제공해야 함\n\n- 그것이 바로 `get()`, `set()` 메서드.\n\n- 값을 얻는 get() 메서드를 getter, 값을 저장하는 set() 메서드를 setter 라고도 함\n\n\u003cbr\u003e\n\n```java\npackage hiding;\n\npublic class Student {\n\tint studentID;\n\tprivate String studentName;\n\tint grade;\n\tString address;\n\t\n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n\t\n\tpublic void setStudentName(String studentName) {\n\t\tthis.studentName = studentName;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage hiding;\n\npublic class StudentTest {\n\tpublic static void main(String[] args) {\n\t\tStudent studentLee = new Student();\n\t\t// studentLee.studentName = \"이상원\";\n\t\tstudentLee.setStudentName(\"이상원\");\n\t\t  \n\t\tSystem.out.println(studentLee.getStudentName());\n\t}\n}\n```\n\n- studentName 변수에 직접 값을 대입하는 방식 (X)\n\n- public인 setStudentName() 메서드를 활용하여 값 대입\n\n\u003cbr\u003e\n\n### 정보 은닉이란?\n\n그래서 변수를 public으로 선언하고 접근하는 것과 private으로 선언하고 public인 메서드로 접근하는 것의 차이가 뭔데? 어차피 접근하는거 똑같은데\n\n\u003cbr\u003e\n\n```java\npublic class Mydate {\n\tpublic int day;\n\tpublic int month;\n\tpublic int year;\n}\n```\n\n\u003cbr\u003e\n\n```java\npublic class MydateTest {\n\tpublic static void main(String[] args) {\n\t\tMydate date = new Mydate();\n\t\tdate.month = 2;\n\t\tdate.day = 31;\n\t\tdate.year = 2022;\n\t}\n}\n```\n\n당연히 Mydate 클래스에 변수들을 전부 public으로 선언했으니까 막 접근해서 값 대입 가능하다. 그러나, 2월은 알다시피 28일이나 29일까지인데 31을 넣어버렸다. **public으로 선언하면 접근이 제한되지 않으니까 정보의 오류가 발생할 수 있다.**\n\n그래서, 단순히 값을 변수에 대입하는 형태가 아니라, 메서드 형태로 값을 대입하도록 하면 if문과 같은 제어문을 넣어서 잘못된 값인지 아닌지 알려줄 수 있다.  \n\n```java\npublic class Mydate {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\t  \n\tpublic setDay(int dau) {\n\t\tif (month == 2) {\n\t\t\tif (day \u003c 1 || day \u003e 28) {\n\t\t\t\tSystem.out.println(\"오류입니다.\");\n\t\t\t} else {\n\t\t\t\tthis.day = day;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\u003cbr\u003e\n\n|접근 제어자|설명|\n|:--:|:--:|\n|public|외부 클래스 어디에서나 접근 O|\n|protected|같은 패키지 내부, 상속 관계의 클래스에서만 접근 O, 그외 X|\n|아무것도 없는 경우| default, 같은 패키지 내부에서만 접근 O|\n|private|같은 클래스 내부에서만 접근 O|","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/chap06":{"title":"06.클래스와 객체 (2)","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 06 - 클래스와 객체 (2)\n\n\u003cbr\u003e\n\n## this 예약어\n\n### 자신의 메모리를 가리키는 this\n\nthis : 생성된 인스턴스 자기 자신을 가리키는 예약어\n\n```java\npackage chapter06;\n  \nclass BirthDay {\n\tint year;\n\tint month;\n\tint day;\n\npublic void setYear(int year) {\n\tthis.year = year;\n}\n  \npublic void printThis() {\n\tSystem.out.println(this);\n}\n}\n  \npublic class ThisExample {\n\tpublic static void main(String[] args) {\n\tBirthDay bDay = new BirthDay();\n\t\tbDay.setYear(2022);\n\t\tSystem.out.println(bDay);\n\t\tbDay.printThis();\n\t}\n}\n\n// chapter06.BirthDay@1b6d3586\n// chapter06.BirthDay@1b6d3586\n```\n\n![](brain/image/chap06-1.png)\n\n- 참조 변수 (bDay)를 출력한 결과 `클래스 이름@메모리 주소`\n\n- printThis() 메서드를 실행하여 this 출력한 결과 `클래스 이름@메모리 주소`\n\n- 힙 메모리에 생성된 인스턴스를 가리키는 것을 확인 가능\n\n\u003cbr\u003e\n\n보통, 하나의 자바 파일에 하나의 클래스가 있는 것이 대부분이지만, 하나의 파일에 여러 클래스가 존재할 수 있다. 하지만 그때 public 클래스는 \"1개\" 뿐이라는 것을 명심! 간단한 클래스를 활용하는 경우 하나의 파일에 여러 클래스가 있을 수 있다.\n\n\u003cbr\u003e\n\n### 생성자에서 다른 생성자를 호출하는 this\n\n```java\npackage chapter06;\n  \nclass Person {\n\tString name;\n\tint age;\n  \n\tPerson() {\n\t\tthis(\"이름 없음\", 1);\n\t}\n  \n\tPerson(String name, int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n}\n  \npublic class CallAnohterConst {\n\tpublic static void main(String[] args) {\n\t\tPerson noName = new Person();\n\t\tSystem.out.println(noName.name);\n\t\tSystem.out.println(noName.age);\n\t}\n}\n\n// 이름 없음\n// 1\n```\n\n- 현재, `Person()` 디폴트 생성자, `Person(String, int)` 생성자 2개 존재\n\n- 클래스 생성 시 `Person()` 디폴트 생성자 이용 : 디폴트 생성자가 호출되는 경우에는 초깃값으로 \"이름 없음\"과 1을 대입하려고 this로 다른 생성자 호출한 것\n\n- `Person(String, int)` 생성자는 매개변수 넣고 똑같이 사용하면 됨\n  \n\u003cbr\u003e\n\n**주의 !!** this로 다른 생성자 호출 시 this 코드 이전에 다른 코드 넣으면 오류 발생. 디폴트 생성자에서 생성이 완료되는 것이 아니라, this를 사용해 다른 생성자를 호출하기 때문에 this를 활용한 문장이 가장 먼저 와야함.\n\n\u003cbr\u003e\n\n### 자신의 주소를 반환하는 this\n\n인스턴스 주소 값을 반환할 때 this를 사용하고 반환형은 클래스 자료형을 사용하면 된다.\n\n```java\npackage chapter06;\n\nclass Person {\n\tPerson returnItSelf() {\n\t\treturn this;\n\t}\n}\n  \npublic class CallAnohterConst {\n\tpublic static void main(String[] args) {\n\t\tPerson noName = new Person();\n\t\tPerson p = noName.returnItSelf();\n\t\tSystem.out.println(p);\n\t\tSystem.out.println(noName);\n\t}\n}\n  \n// chapter06.Person@1b6d3586\n// chapter06.Person@1b6d3586\n```\n\n\u003chr\u003e\n\n## 객체 간 협력\n\n결국, 객체지향 프로그래밍은 객체를 정의하고 객체 간 협력을 기반으로 만든다.\n\n- 학생 class (이름, 학년, 가진 돈)\n\n- 버스 class (버스 번호, 승객 수, 수입)\n\n- 지하철 class (노선 번호, 승객 수, 수입)\n\n- 학생 -\u003e 버스 : 버스를 탄다.\n\n- 학생 -\u003e 지하철 : 지하철을 탄다.\n\n즉, 객체가 필요한 멤버 변수를 선언하고, 생성자를 정의하고 객체 사이의 협력 기능을 구현한다. \"학생이 지하철을 탄다\"는 **학생 객체의 입장에서 사용한 문장**이다. **지하철 객체의 입장에서 생각해보면, 지하철에 학생이 탄다**이다.\n\n**두 객체에서 서로 다른 일이 발생하는 것이므로 이를 각각의 클래스에 메서드로 구현한다.** 각 객체의 입장을 잘 생각해서 코드를 짜자. 코드는 \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter06/Student.java' target='_blank'\u003eStudent 클래스\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter06/Bus.java' target='_blank'\u003eBus 클래스\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter06/Subway.java' target='_blank'\u003eSubway 클래스\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter06/Taxi.java' target='_blank'\u003eTaxi 클래스\u003c/a\u003e, 테스트 클래스인 \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter06/TakeTrans.java' target='_blank'\u003eTakeTrans 클래스\u003c/a\u003e를 참조한다.\n\n\u003chr\u003e\n\n## static 변수\n\n### 변수를 여러 클래스에서 공통으로 사용하려면?\n\n\u003cbr\u003e\n\n```java\npublic class Student {\n\tpublic int studentID;\n\tpublic String studentName;\n\tpublic int grade;\n\tpublic String address;\n}\n```\n\n위와 같은 학생 클래스가 예시로 있다. 만약 학생이 입학할 때 (=클래스가 생성되면) 학번이 자동으로 부여되도록 만들고 싶다. 생성된 인스턴스는 학번을 순서대로 가져야 한다.\n\n이러한 경우, 각 인스턴스마다 따로 생성되는 변수가 아닌, **클래스 전반에서 공통으로 사용할 수 있는 기준 변수**가 있어야 한다.\n\n\u003e 클래스에서 공통으로 사용하는 변수를 **static 변수**로 선언한다.\n\n\u003cbr\u003e\n\n### static 변수의 정의와 사용 방법\n\nstatic 변수는 정적 변수이다. 클래스 내부에 선언하고 자료형 앞에 static 예약어 사용\n\n```java\nstatic int serialNum;\n```\n\nstatic 변수 (= 정적 변수)는 클래스 내부에 선언하지만, 다른 멤버 변수처럼 인스턴스가 생성될 때마다 새로 생성되는 변수가 아니다. static 변수는 프로그램이 실행되어 메모리에 올라갔을 때 딱 한 번 메모리 공간이 할당된다. 이 값은 **모든 인스턴스가 공유한다.**\n\nstatic으로 선언한 변수는 인스턴스 생성과 상관없이 **먼저 생성**되고 그 값을 모든 인스턴스가 공유하게 된다. 이러한 이유로 클래스스에 기반한 변수라고 하며 **클래스 변수**라고도 한다.\n\n- static 변수 = 정적 변수 = 클래스 변수\n\n- 딱 한 번 메모리 공간 메서드 영역에 할당\n\n- 모든 인스턴스가 이 값을 공유\n\n\u003cbr\u003e\u003cbr\u003e\n\n**메모리 영역 정리** \n\n- JVM은 메모리를 할당받고 용도에 따라 여러 영역으로 나누어 관리\n\n- 대표적으로 3가지 (메서드 영역, 호출 스택, 힙)\n\n- 메서드 영역 : 클래스파일(`.class`) 읽어서 분석하고 클래스에 대한 정보, 클래스 데이터, 클래스 변수 등\n\n- 호출 스택 : 메서드의 작업에 필요한 메모리 공간 제공, 지역 변수, 매개변수 등\n\n- 힙 : 인스턴스가 생성되는 공간, 인스턴스 변수\n\n\u003cbr\u003e\n\n```java\npackage chapter06;\n  \npublic class StudentStatic {\n\tpublic static int serialNum = 1000;\n\tpublic int studentID;\n\tpublic String studentName;\n\tpublic int grade;\n\tpublic String address;\n\n\tpublic StudentStatic() {\n\t\tserialNum++;\n\t\tstudentID = serialNum;\n\t}\n  \n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n  \n\tpublic void setStudentName(String studentName) {\n\t\tthis.studentName = studentName;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter06;\n  \npublic class StudentStaticTest {\n\tpublic static void main(String[] args) {\n\t\tStudentStatic studentLee = new StudentStatic();\n\t\tstudentLee.setStudentName(\"이지원\");\n\t\tSystem.out.println(studentLee.serialNum);\n\t\tSystem.out.println(studentLee.studentName + \" 학번 : \" + studentLee.studentID);\n\t\t  \n\t\tStudentStatic studentSon = new StudentStatic();\n\t\tstudentSon.setStudentName(\"손수경\");\n\t\tSystem.out.println(studentSon.serialNum);\n\t\tSystem.out.println(studentSon.studentName + \" 학번 : \" + studentSon.studentID);\n\t}\n}\n  \n// 1001\n// 이지원 학번 : 1001\n// 1002\n// 손수경 학번 : 1002\n```\n\n\u003cbr\u003e\n\n### 클래스 변수\n\nstatic 변수 = 정적 변수 = 클래스 변수는 인스턴스를 생성할 때마다 만들어지는 것이 아니다. 인스턴스 생성과는 별개이고 **인스턴스보다 먼저 생성되어 메서드 영역에 저장**된다. 그래서 위에 코드를 인스턴스말고 **클래스 이름으로 직접 참조**하도록 하여 serialNum을 가져올 수 있다.\n\n```java\npackage chapter06;\n  \npublic class StudentStaticTest {\n\tpublic static void main(String[] args) {\n\t\tStudentStatic studentLee = new StudentStatic();\n\t\tstudentLee.setStudentName(\"이지원\");\n\t\t// 인스턴스 생성 안하고 그냥 가져올 수 있음\n\t\tSystem.out.println(StudentStatic.serialNum);\n\t\tSystem.out.println(studentLee.studentName + \" 학번 : \" + studentLee.studentID);\n\t\t\n\t\tStudentStatic studentSon = new StudentStatic();\n\t\tstudentSon.setStudentName(\"손수경\");\n\t\t// 인스턴스 생성 안하고 그냥 가져올 수 있음\n\t\tSystem.out.println(StudentStatic.serialNum);\n\t\tSystem.out.println(studentSon.studentName + \" 학번 : \" + studentSon.studentID);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### 클래스 메서드\n\nstatic 변수를 위한 메서드도 있다. 이것을 **static 메서드** 혹은 **클래스 메서드**라고 한다.\n\n- 외부 클래스에서 serialNum 직접 참조 못하게 private으로 선언\n\n- private으로 바꿨으니 StudentStaticTest 클래스에서 접근 못하니까 직접 참조 불가\n\n- serialNum에 대한 get(), set() 생성\n\n- get()으로 참조하기\n\n```java\npackage chapter06;\n\npublic class StudentStaticMethod {\n\tprivate static int serialNum = 1000;\n\tint studentID;\n\tString studentName;\n\tint grade;\n\tString address;\n\t  \n\tpublic StudentStaticMethod() {\n\t\tserialNum++;\n\t\tstudentID = serialNum;\n\t}\n\t  \n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n\t  \n\tpublic void setStudentName(String studentName) {\n\t\tthis.studentName = studentName;\n\t}\n\t  \n\tpublic static int getSerialNum() {\n\t\treturn serialNum;\n\t}\n\t\n\tpublic static void setSerialNum(int serialNum) {\n\t\tStudentStaticMethod.serialNum = serialNum;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter06;\n  \npublic class StudentStaticMethodTest {\n\tpublic static void main(String[] args) {\n\t\tStudentStaticMethod studentLee = new StudentStaticMethod();\n\t\tstudentLee.setStudentName(\"이지원\");\n\t\tSystem.out.println(StudentStaticMethod.getSerialNum());\n\t\tSystem.out.println(studentLee.studentName + \" 학번 : \" + studentLee.studentID);\n\t\t  \n\t\tStudentStaticMethod studentSon = new StudentStaticMethod();\n\t\tstudentSon.setStudentName(\"손수경\");\n\t\tSystem.out.println(StudentStaticMethod.getSerialNum());\n\t\tSystem.out.println(studentSon.studentName + \" 학번 : \" + studentSon.studentID);\n\t}\n}\n```\n\nstatic 메서드 또한 static 변수처럼 **인스턴스 참조 변수가 아닌 클래스 이름으로 직접 호출할 수 있음**. 다음으로, `getSerialNum()` 메서드를 더 살펴보겠다.\n\n```java\npublic static int getSerialNum() {\n\tint i = 10;\n\tstudentName = \"이지원\";\n\treturn serialNum;\n}\n```\n\n- `int i = 10`은 메서드 내부에서 선언한 **지역 변수**이다. `getSerialNum()` 메서드 내부에서만 사용 가능하다.\n\n- `return serialNum;`은 serialNum이 static 변수라서 static 메서드에서 사용 가능하다.\n\n- 그러나, `studentName`은 인스턴스 변수라서 인스턴스가 생성될 때 만들어지는 변수라서 아직 인스턴스를 생성하고 이런 상태가 아니라서 사용할 수 없다. 오류발생\n\n\u003e 클래스 메서드, 클래스 변수는 인스턴스가 생성되지 않아도 클래스를 직접 참조하여 사용 가능하다.\n\n\u003cbr\u003e\n\n정리하자면, **클래스 메서드 내부에서 지역 변수와 클래스 변수는 사용할 수 있지만, 인스턴스 변수는 사용할 수 없다.** 반대로, 일반 메서드에서 클래스 변수를 사용하는 것은 문제 없다.\n\n- 일반 메서드 : 인스턴스 생성될 때 호출되는 메서드, 클래스 변수는 이미 만들어져있어서 호출 가능\n\n- 클래스 메서드 : 이미 만들어져있는 클래스 변수는 사용 가능, 하지만 인스턴스 변수는 아직 생성 안되었으니까 사용 불가능 !\n\n\u003chr\u003e\n\n## 변수 유효 범위\n\n변수는 어디에 어떻게 선언되느냐에 따라 **유효범위(scope)** 가 달라진다.\n\n\u003cbr\u003e\n\n### 지역 변수 유효범위\n\n- 지역 변수(로컬 변수, local variable)는 함수나 메서드 내부에 선언, 함수 밖에서 사용 못함\n\n- 지역 변수가 생성되는 메모리는 **스택(stack)**\n\n- 함수가 호출될 때 스택에 생성되었다가 함수가 반환되면 할당되었던 메모리 공간 해제하면서 없어짐\n\n\u003cbr\u003e\n\n### 멤버 변수 유효범위\n\n- 멤버 변수(인스턴스 변수)는 클래스의 어느 메서드에서나 사용 가능\n\n- 멤버 변수가 생성되는 메모리는 **힙(heap)**\n\n- 힙에 생성된 인스턴스가 가비지 컬렉터(garbage collector)에 의해 수거되면 메모리에서 사라진다. 따라서 클래스 **내부**의 여러 메서드에서 사용할 변수는 멤버 변수로 선언하는 것이 좋음\n\n\u003cbr\u003e\n\n### 정적 변수 유효범위\n\n- 정적 변수(static 변수, 클래스 변수)는 private이 아니라면 클래스 외부에서도 객체 생성(인스턴스 생성)과 무관하게 사용 가능\n\n- 정적 변수가 생성되는 메모리는 **메서드 영역**\n\n- 메서드 영역 (책에서는 데이터 영역이라고 표현)에는 상수, 문자열, static 변수가 생성된다. 따라서 클래스 생성과 상관 없이 처음부터 메모리에 올라가는 것\n\n- 프로그램 실행이 끝난 뒤 메모리에서 내려가면 그때 static 변수가 소멸된다. 즉, 프로그램의 시작부터 끝까지 메모리에 상주하므로, 너무 큰 변수를 static으로 선언하는 것은 좋지 않다.\n\n\u003cbr\u003e\n\n### 변수 유형에 따른 용도\n\n![](brain/image/chap06-2.png)\n\n- 클래스의 여러 메서드에서 사용할 변수\n\n이러한 상황에 지역 변수로 선언하면, 다른 메서드에서 사용할 일이 있을 때 지역 변수를 메서드의 매개변수로 전달해야해서 매우 번거로움\n\n\u003cbr\u003e\n\n모든 변수를 멤버 변수나 static 변수로 선언하면 메모리가 낭비되고 코드의 가독성 떨어짐. 따라서, 정답은 없으니까 상황에 맞게 효율적으로 프로그래밍 해야함.\n\n\u003cbr\u003e\n\n- [x] 함수에서 기능 구현을 위해 잠시 사용 -\u003e 지역 변수\n\n- [x] 클래스의 속성을 나타내고 각 인스턴스 마다 다른 값 가짐 -\u003e 멤버 변수\n\n- [x] 여러 인스턴스에서 공유해서 사용하도록 한 번만 생성 -\u003e 정적 변수\n\n\u003chr\u003e\n\n## static 응용 - 싱글톤 패턴\n\n### 디자인 패턴이란?\n\n- 객체지향 프로그램을 구현할 때 더 유연하고 재활용성이 높은 프로그램을 만들 수 있도록 정리한 내용\n\n- 프로그램 특성에 따른 설계 유형을 이론화 한 것\n\n- 자바에만 한정 짓는 것이 아닌 다른 객체 지향 언어에도 적용 가능\n\n\u003cbr\u003e\n\n### 싱글톤 패턴이란?\n\n프로그램 구현 시, 여러 개의 인스턴스가 필요한 경우, 단 하나의 인스턴스만 필요한 경우가 있는데, **인스턴스를 단 하나만 생성하는 디자인 패턴을 싱클톤 패턴(singleton pattern)** 이라고 함.\n\n여기서 살펴볼 싱글톤 패턴은 **static을 응용하여 프로그램 전반에서 사용하는 인스턴스를 하나만 구현하는 방식**\n\n\u003cbr\u003e\n\n예시\n\n- 어떤 회사의 직원들을 객체 지향 프로그램으로 구현\n\n- 회사는 하나, 직원은 여러명\n\n- 회사 객체는 **단 하나만 생성**\n\n- 직원 인스턴스는 여러 개 생성\n\n\u003cbr\u003e\n\n### 싱글톤 패턴으로 회사 클래스 구현\n\n1. 생성자를 private으로 만들기\n\n\t- 컴파일러가 만들어주는 디폴트 생성자는 항상 public\n\n\t- 생성자가 public이면 외부 클래스에서 인스턴스 여러 개 생성 가능\n\n\t- 싱글톤 패턴에서는 생성자를 **반드시** 명시적으로 만들고 접근 제어자 private으로\n\n```java\npackage chapter06.singleton;\n  \npublic class Company {\n\tprivate Company() {}\n}\n```\n\n\u003cbr\u003e\n\n2. 클래스 내부에 static으로 유일한 인스턴스 생성\n  \n\t- 1단계에서 private으로 바꿔서 외부 인스턴스를 생성 못하게 바꿨음\n\n\t- 하지만, 프로그램에서 사용할 인스턴스 **단 하나**는 필요\n\n\t- 싱글톤 패턴으로 만든 클래스 내부에서 **하나의 인스턴스 생성**\n\n\t- 이 인스턴스가 프로그램 전체에서 사용할 유일한 인스턴스\n\n```java\npackage chapter06.singleton;\n  \npublic class Company {\n\tprivate static Company instance = new Company();\n\tprivate Company() {}\n}\n```\n\n\u003cbr\u003e\n\n3. 외부에서 참조할 수 있는 public 메서드 생성\n\n\t- private으로 선언한 유일한 인스턴스를 외부에서 사용할 수 있도록 설정\n\n\t- 위 작업을 위해 public 메서드 생성하고 유일하게 생성한 인스턴스 반환\n\n\t- 인스턴스를 반환하는 메서드는 반드시 **static**으로 선언\n\n\t- static 선언 이유 : 인스턴스 생성과 상관없이 호출해야해서\n\n```java\npackage chapter06.singleton;\n  \npublic class Company {\n\tprivate static Company instance = new Company();\n\tprivate Company() {}\n\t  \n\tpublic static Company getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Company();\n\t\t}\n\t\t\n\t\treturn instance;\n\t}\n}\n```\n\n이는 마치 private 변수 선언했을 때, 외부에서 사용하려고 public get() 메서드 구현한 것과 동일한 모습이다.\n\n\u003cbr\u003e\n\n4. 실제로 사용하는 코드 생성\n\n\t- 외부 클래스에서 Company 생성 불가능한 상태\n\n\t- 따라서, static으로 제공되는 getInstance() 메서드를 호출\n\n\t- `Company.getInstance();`로 호출하면 반환값으로 유일한 인스턴스 받음\n\n\t- 아래 코드는 같은 주소인지 확인하여 유일한 인스턴스가 맞는지 증명하는 코드\n\n```java\npackage chapter06.singleton;\n  \npublic class CompanyTest {\n\tpublic static void main(String[] args) {\n\t\tCompany myComapny1 = Company.getInstance();\n\t\tCompany myCompany2 = Company.getInstance();\n\t\tSystem.out.println(myComapny1 == myCompany2);\n\t}\n}\n  \n// true\n```","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/chap07":{"title":"07.배열과 ArrayList","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 07 - 배열과 ArrayList\n\n\u003cbr\u003e\n\n## 배열이란?\n\n### 배열 선언과 초기화\n\n\u003cbr\u003e\n\n```java\n자료형[] 배열이름 = new 자료형[개수];\n자료형 배열이름[] = new 자료형[개수];\nint[] studentsID = new int[10];\n```\n\n뭘 사용해도 되지만, 두잇자바 교재에서는 위 방식을 채택함\n\nint형이니까 4바이트 이므로, 10칸 선언했으니 40바이트가 배열 전체의 크기이다. **선언한 자료형과 배열 길이에 따라 메모리가 할당**된다. 이때 **선언과 동시에 요소의 값이 초기화**된다.\n\n- 정수형 : 0\n\n- 실수형 : 0.0\n\n- 객체 : null\n\n\u003cbr\u003e\n\n**배열 선언 방법**\n\n- 개수 생략, 초기화 요소의 개수만큼 배열이 생성\n\n```java\nint[] studentIDs = new int[] {101, 102, 103};\n```\n\n- 위 케이스에서 `new int[]` 부분 생략 가능 (초기화 개수만큼 배열 생성)\n\n```java\nint[] studentIDs = {101, 102, 103};\n```\n\n- 위 케이스에서 new int 안에 개수 넣으면 오류 발생\n\n```java\n// 이거 오류 발생 !!!!!!\nint[] studentIDs = new int[3] {101, 102, 103};\n```\n\n- 배열 자료형을 먼저 선언하고 초기화 하는 경우, new int 생략 불가\n\n```java\nint[] studentIDs;\nstudentIDs = new int[] {101, 102, 103};\n```\n\n\u003cbr\u003e\n\n### 배열 사용하기\n\n인덱스에 값 저장하거나 인덱스에서 값 뽑아오는거 말함\n\n- 배열의 물리적 위치 : 메모리에서 배열이 실제로 저장되는 곳\n\n- 배열의 논리적 위치 : 이론상 배열 위치\n\n이게 무슨 말이냐면, 배열 이외의 자료구조는 논리적으로 바로 옆에 붙어있다고 해도 실제 메모리 위치는 아예 다를 수도 있음.\n\n하지만, 배열은 논리적 위치에서 사용하는 실제 값도 바로 이웃한 메모리에 위치함. 예를 들어, 5칸짜리 배열이 있으면 그 5칸은 실제의 물리적 위치에서도 이웃하게 붙어있음. 주소값 출력 찍어보면 바로 암\n\n\u003cbr\u003e\n\n### 전체 배열 길이와 유효한 요소 값\n\n- 배열 사용할 때 처음 선언한 배열 길이만큼 값을 저장해서 사용하는 경우는 많지 않음\n\n- `전체 배열길이 != 현재 배열에 유효한 값이 저장되어 있는 배열 요소 개수`\n\n```java\npublic class ArrayTest {\n\tpublic static void main(String[] args) {\n\t\tdouble[] data = new double[5];\n\t\tdata[0] = 10.0;\n\t\tdata[1] = 20.0;\n\t\tdata[2] = 30.0;\n\t\t  \n\t\tfor (int i = 0; i \u003c data.length; i++) {\n\t\t\tSystem.out.println(data[i]);\n\t\t}\n\t}\n}\n  \n// 10.0\n// 20.0\n// 30.0\n// 0.0\n// 0.0\n```\n\n전체 배열 길이 5에서 유효한 값은 3까지임. 그러면 유효한 값까지만 출력해보는 프로그램은 어떻게 만들까?\n\n```java\npublic class ArrayTest2 {\n\tpublic static void main(String[] args) {\n\t\tdouble[] data = new double[5];\n\t\t// 유효한 값이 저장된 배열 요소 개수를 저장할 변수\n\t\tint size = 0;\t  \n\t\tdata[0] = 10.0; size++;\n\t\tdata[1] = 20.0; size++;\n\t\tdata[2] = 30.0; size++;\n\t\t  \n\t\t// 유효한 값이 저장된 배열 요소 개수만큼 반복문 실행\n\t\tfor(int i = 0; i \u003c size; i++) {\n\t\t\tSystem.out.println(data[i]);\n\t\t}\n\t}\n}\n  \n// 10.0\n// 20.0\n// 30.0\n```\n\n- 이렇게 추가적인 변수를 통하여 유효한 값만 뽑아올 수 있다.\n\n- ArrayList 객체 배열은 이런 부분을 미리 구현해서 메서드로 제공해줌 ㅎ\n\n\u003cbr\u003e\n\n### 문자 저장 배열 만들기\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\n  \npublic class CharArray {\n\tpublic static void main(String[] args) {\n\t\tchar[] alphabets = new char[26];\n\t\tchar ch = 'A';\n\t\t  \n\t\tfor(int i = 0; i \u003c alphabets.length; i++, ch++) {\n\t\t\talphabets[i] = ch;\n\t\t}\n\t\t  \n\t\tfor(int i = 0; i \u003c alphabets.length; i++) {\n\t\t\tSystem.out.println(alphabets[i] + \", \" + (int)alphabets[i]);\n\t\t}\n\t}\n}\n```\n\n- 알파벳 문자는 실제 메모리에 아스키 코드 값으로 저장됨\n\n- 예를 들어, 아스키 코드값 65는 대문자 'A'임\n\n- 아스키 코드값을 1씩 증가시키면 A, B, C .. 이렇게 증가\n\n\u003cbr\u003e\n\n### 객체 배열 사용\n\n- 기본 자료형(int, double 등)이 아닌 참조 자료형으로 선언하는 방법\n\n- 참조 자료형 변수는 클래스형으로 선언한 변수를 의미\n\n```java\n// Book 클래스\npackage chapter07;\n  \npublic class Book {\n\tprivate String bookName;\n\tprivate String author;\n\t  \n\tpublic Book () {};\n\t  \n\tpublic Book(String bookName, String author) {\n\t\tthis.bookName = bookName;\n\t\tthis.author = author;\n\t}\n\t  \n\tpublic String getBookName() {\n\t\treturn bookName;\n\t}\n\t  \n\tpublic void setBookName(String bookName) {\n\t\tthis.bookName = bookName;\n\t}\n\t  \n\tpublic String getAuthor() {\n\t\treturn author;\n\t}\n\t  \n\tpublic void setAuthor(String author) {\n\t\tthis.author = author;\n\t}\n\t  \n\tpublic void showBookInfo() {\n\t\tSystem.out.println(bookName + \", \" + author);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\n// BookArray 클래스\npackage chapter07;\n  \npublic class BookArray {\n\tpublic static void main(String[] args) {\n\t\tBook[] library = new Book[5];\n\t\t  \n\t\tfor(int i = 0; i \u003c library.length; i++) {\n\t\t\tSystem.out.println(library[i]);\n\t\t}\n\t}\n} \n\n// null\n// null\n// null\n// null\n// null\n```\n\n- `Book[] library = new Book[5];`은 Book 클래스의 인스턴스가 5개 생성된 것이 아님\n\n- 인스턴스를 생성하면 그 인스턴스를 가리키는 주소 값이 있는데, 인스턴스 주소 값을 담을 공간 5개를 생성한다는 의미\n\n- 그래서 Book 클래스 주소를 담을 공간 5개를 만들었고, 비어있으니까 null이 출력되는 것\n\n\u003cbr\u003e\n\n```java\n// BookArray2 클래스\npackage chapter07;\n  \npublic class BookArray2 {\n\tpublic static void main(String[] args) {\n\t\tBook[] library = new Book[5];\n\t\t  \n\t\tlibrary[0] = new Book(\"태백산맥\", \"조정래\");\n\t\tlibrary[1] = new Book(\"데미안\", \"헤르만 헤세\");\n\t\tlibrary[2] = new Book(\"어떻게 살 것 인가\", \"유시민\");\n\t\tlibrary[3] = new Book(\"토지\", \"박경리\");\n\t\tlibrary[4] = new Book(\"어린왕자\", \"생택쥐페리\");\n\t\t  \n\t\tfor (int i = 0; i \u003c library.length; i++) {\n\t\t\tlibrary[i].showBookInfo();\n\t\t}\n\t\t  \n\t\tfor (int i = 0; i \u003c library.length; i++) {\n\t\t\tSystem.out.println(library[i]);\n\t\t}\n\t}\n}\n  \n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것 인가, 유시민\n// 토지, 박경리\n// 어린왕자, 생택쥐페리\n// chapter07.Book@1b6d3586\n// chapter07.Book@4554617c\n// chapter07.Book@74a14482\n// chapter07.Book@1540e19d\n// chapter07.Book@677327b6\n```\n\n- 참조 변수 library에 5칸의 인스턴스 주소값을 담을 공간을 생성\n\n- 이후 Book 클래스에 매개변수로 값을 담은 상태\n\n- 그 이후 showBookInfo 메서드로 내용을 출력해보고\n\n- 그 이후 참조 변수에 저장된 주소 값을 출력해봄\n\n\u003cbr\u003e\n\n### 배열 복사하기\n\n- 기존 배열과 똑같은 배열을 만들고 싶거나, 자료가 꽉 차서 더 큰 배열을 만들어 **기존 배열에 저장된 자료를 가져오고 싶을 때** 복사해보자\n\n- `01. for문을 사용하여 각 요소 값을 반복해서 복사`\n\n- `02. System.arraycopy() 메서드 이용`\n\n`System.arraycoppy(src, srcPos, dest, destPost, length) `매개 변수 형식\n\n\u003cbr\u003e\n\n|매개변수|설명|\n|-------|-----|\n|src|복사할 배열 이름|\n|srcPos|복사할 배열의 첫 번째 위치|\n|dest|복사해서 붙여 넣을 대상 배열 이름|\n|destPost|복사해서 대상 배열에 붙여 넣기를 시작할 첫 번째 위치|\n|length|src에서 dest로 자료를 복사할 요소 개수|\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\n\npublic class ArrayCopy {\n\tpublic static void main(String[] args) {\n\t\tint[] array1 = {10, 20, 30, 40, 50};\n\t\tint[] array2 = {1, 2, 3, 4, 5};\n\t\tSystem.arraycopy(array1, 0, array2, 1, 4);\n\t\t\n\t\tfor(int i = 0; i \u003c array2.length; i++) {\n\t\t\tSystem.out.println(array2[i]);\n\t\t}\n\t}\n}\n\n// 1\n// 10\n// 20\n// 30\n// 40\n```\n\n- 복사할 대상 배열의 전체 길이 \u003c 복사할 요소 개수 = 오류\n\n\u003cbr\u003e\n\n### 객체 배열 복사\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\n  \npublic class ObjectCopy1 {\n\tpublic static void main(String[] args) {\n\t\tBook[] bookArray1 = new Book[3];\n\t\tBook[] bookArray2 = new Book[3];\n\t\t  \n\t\tbookArray1[0] = new Book(\"태백산맥\", \"조정래\");\n\t\tbookArray1[1] = new Book(\"데미안\", \"헤르만 헤세\");\n\t\tbookArray1[2] = new Book(\"어떻게 살 것인가\", \"유시민\");\n\t\tSystem.arraycopy(bookArray1, 0, bookArray2, 0, 3);\n\t\t\n\t\tfor (int i = 0; i \u003c bookArray2.length; i++) {\n\t\t\tbookArray2[i].showBookInfo();\n\t\t}\n\t}\n}\n```\n\n- 여기서 의문, bookArray2 배열의 인스턴스를 따로 만든건 아니고 주소 값 저장할 공간만 만들어놨는데 어떻게 출력이 잘 될까? (사실 벌써 감 오지? 주소 값 가리키는 포인터 개념이니까 ㅎ)\n\n\u003cbr\u003e\n\n**얕은 복사(shallow copy)**\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\n  \npublic class ObjectCopy1 {\n\tpublic static void main(String[] args) {\n\t\tBook[] bookArray1 = new Book[3];\n\t\tBook[] bookArray2 = new Book[3];\n\t\t\n\t\tbookArray1[0] = new Book(\"태백산맥\", \"조정래\");\n\t\tbookArray1[1] = new Book(\"데미안\", \"헤르만 헤세\");\n\t\tbookArray1[2] = new Book(\"어떻게 살 것인가\", \"유시민\");\n\t\tSystem.arraycopy(bookArray1, 0, bookArray2, 0, 3);\n\t\t  \n\t\tfor (int i = 0; i \u003c bookArray2.length; i++) {\n\t\t\tbookArray2[i].showBookInfo();\n\t\t}\n\t\t  \n\t\tSystem.out.println(\"bookArray2[0]의 내용을 변경\");\n\t\tbookArray2[0].setBookName(\"나목\");\n\t\tbookArray2[0].setAuthor(\"박완서\");\n\t\t  \n\t\tSystem.out.println(\"--- bookArray1 출력 ---\");\n\t\tfor (int i = 0; i \u003c bookArray1.length; i++) {\n\t\t\tbookArray1[i].showBookInfo();\n\t\t}\n\t}\n}\n\n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n// bookArray2[0]의 내용을 변경\n// --- bookArray1 출력 ---\n// 나목, 박완서\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n```\n\n- `bookArray2[0]`의 요소 값을 변경했는데, `bookArray[1]`의 요소 값도 같이 바뀜\n\n- 객체 배열의 요소에 저장된 값 = 인스턴스의 주소 값\n\n- 객체 배열의 요소에 저장된 값 != 인스턴스 자체\n\n- 객체 배열을 복사할 때 인스턴스를 따로 생성하는게 아니라 **기존 인스턴스의 주소 값만 복사**하기 때문에 이런 일 발생\n\n\u003cbr\u003e\n\n**깊은 복사(deep copy)**\n\n- `System.arraycopy()` 메서드 사용 / 객체 배열 복사하면 **항상 인스턴스 주소가 복사됨**\n\n- 인스턴스를 따로 관리하고 싶으면 직접 인스턴스를 만들고 값을 복사해야함\n\n- 즉, 인스턴스 생성 -\u003e 배열 복사가 되어야 함\n\n```java\nbookArray2[0] = new Book();\nbookArray2[1] = new Book();\nbookArray2[2] = new Book();\n  \nfor (int i = 0; i \u003c bookArray1.length; i++) {\n\tbookArray2[i].setBookName(bookArray1[i].getBookName());\n\tbookArray2[i].setAuthor(bookArray1[i].getAuthor());\n}\n```\n\n\u003cbr\u003e\n\n- 전체 코드\n\n```java\npackage chapter07;\n  \npublic class ObjectCopy2 {\n\tpublic static void main(String[] args) {\n\t\tBook[] bookArray1 = new Book[3];\n\t\tBook[] bookArray2 = new Book[3];\n\t\t  \n\t\tbookArray1[0] = new Book(\"태백산맥\", \"조정래\");\n\t\tbookArray1[1] = new Book(\"데미안\", \"헤르만 헤세\");\n\t\tbookArray1[2] = new Book(\"어떻게 살 것인가\", \"유시민\");\n\t\t  \n\t\tbookArray2[0] = new Book();\n\t\tbookArray2[1] = new Book();\n\t\tbookArray2[2] = new Book();\n\t\t  \n\t\tfor (int i = 0; i \u003c bookArray1.length; i++) {\n\t\t\tbookArray2[i].setBookName(bookArray1[i].getBookName());\n\t\t\tbookArray2[i].setAuthor(bookArray1[i].getAuthor());\n\t\t}\n\t\t  \n\t\tSystem.out.println(\"--- 인스턴스 생성 이후 값 복사한 bookArray2 ---\");\n\t\tfor (int i = 0; i \u003c bookArray2.length; i++) {\n\t\t\tbookArray2[i]. showBookInfo();\n\t\t}\n\t\t  \n\t\tbookArray1[0].setBookName(\"나목\");\n\t\tbookArray1[0].setAuthor(\"박완서\");\n\t\tSystem.out.println(\"--- bookArray1 ---\");\n\t\tfor (int i = 0; i \u003c bookArray1.length; i++) {\n\t\t\tbookArray1[i].showBookInfo();\n\t\t}\n\t\t  \n\t\tSystem.out.println(\"--- bookArray2에 변경 끼쳤나 확인 ---\");\n\t\tfor (int i = 0; i \u003c bookArray2.length; i++) {\n\t\t\tbookArray2[i]. showBookInfo();\n\t\t}\n\t}\n}\n\n// --- 인스턴스 생성 이후 값 복사한 bookArray2 ---\n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n// --- bookArray1 ---\n// 나목, 박완서\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n// --- bookArray2에 변경 끼쳤나 확인 ---\n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n```\n\n\u003cbr\u003e\n\n### 향상된 for문과 배열\n\n- 배열의 처음에서 끝까지 모든 요소를 참조할 때 사용하면 편리함\n\n- **향상된 for문**은 배열 요소 값을 순서대로 하나씩 가져와서 변수에 대입\n\n```java\nfor(변수 : 배열) {\n\t반복 실행문;\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\n  \npublic class EnhancedForLoop {\n\tpublic static void main(String[] args) {\n\t\tString[] strArray = {\"Java\", \"Android\", \"C\", \"JavaScript\", \"Python\"};\n\t  \n\t\tfor(String language : strArray) {\n\t\t\tSystem.out.println(language);\n\t\t}\n\t}\n}\n  \n// Java\n// Android\n// C\n// JavaScript\n// Python\n```\n\n\u003chr\u003e\n\n## 다차원 배열  \n\n### 이차원 배열\n\n\u003cbr\u003e\n\n```java\n// 둘다 2 X 3 행렬\nint[][] arr = new int[2][3];\nint[][] arr = {{1, 2, 3}, {4, 5, 6}};\n```\n  \n- 이차원 배열은 중첩 for문 활용\n\n- `arr.length` : 행의 길이\n\n- `arr[0].length` : 열의 길이\n\n```java\npackage chapter07;\n  \npublic class TwoDimension {\n\tpublic static void main(String[] args) {\n\t\tint[][] arr = {{1, 2, 3}, {4, 5, 6}};\n\t\t  \n\t\tfor (int i = 0; i \u003c arr.length; i++) {\n\t\t\tfor (int j = 0; j \u003c arr[i].length; j++) {\n\t\t\t\tSystem.out.print(arr[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n  \n// 1 2 3\n// 4 5 6\n```\n\n\u003chr\u003e\n\n## ArrayList 클래스 활용\n\n### 기존 배열의 단점, 그리고 ArrayList\n\n1. 항상 배열 길이를 정하고 시작\n\n2. 당연히 배열 길이는 가변적으로 변할 것\n\n3. 혹은 중간에 배열 값이 빠지게 되면, 중간에 요소 비우면 안되니까 수정해야함\n\n그래서 자바는 객체 배열 더 쉽게 사용하게 ArrayList로 멤버 변수, 메서드 제공\n\n### ArrayList 클래스 주요 메서드\n\n\u003cbr\u003e\n\n|메서드|설명|\n|------|----|\n|boolean add(E e)|요소 하나를 배열에 추가. E는 요소의 자료형|\n|int size()|배열에 추가된 요소 전체 개수 반환|\n|E get(int index)|배열의 index 위치에 있는 요소 값 반환|\n|E remove(int index)|배열의 index 위치에 있는 요소 값 제거하고 그 값 반환|\n|boolean isEmpty()|배열이 비어 있는지 확인|\n  \n\u003cbr\u003e\n\n추가\n\n- `add() 메서드` : 배열 길이와 상관없이 객체 추가 (배열 요소 개수가 부족하면 배열 크기 자동으로 키워줌 + 배열 중간에 요소 값 제거 되면 그 다음 요소 값 하나씩 앞으로 당겨줌)\n\n\u003cbr\u003e\n\n### ArrayList 클래스 활용\n\n\u003cbr\u003e\n\n```java\nArrayList\u003cE\u003e 배열 이름 = new ArrayList\u003cE\u003e();\n```\n  \n- 어떤 자료형 객체를 사용할 지 선언할 수 있음\n\n- ArrayList 클래스는 util 패키지에 있음. 쓰려면 import 해와야겠지?\n\n- `\u003cE\u003e`는 제네릭 자료형\n\n- `\u003c\u003e` 안에 객체의 자료형 쓰면 됨\n\n- 예를 들어서, 위에서 한 Book 클래스형을 자료형으로 쓴다면\n\n```java\nArrayList\u003cBook\u003e library = new ArrayList\u003cBook\u003e();\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\nimport java.util.ArrayList;\n  \npublic class ArrayListTest {\n\tpublic static void main(String[] args) {\n\t\tArrayList\u003cBook\u003e library = new ArrayList\u003cBook\u003e();\n\t\t  \n\t\tlibrary.add(new Book(\"태백산맥\", \"조정래\"));\n\t\tlibrary.add(new Book(\"데미안\", \"헤르만 헤세\"));\n\t\tlibrary.add(new Book(\"어떻게 살 것인가\", \"유시민\"));\n\t\tlibrary.add(new Book(\"토지\", \"박경리\"));\n\t\tlibrary.add(new Book(\"어린왕자\", \"생텍쥐페리\"));\n\t\t  \n\t\tfor (int i = 0; i \u003c library.size(); i++) {\n\t\t\tBook book = library.get(i);\n\t\t\tbook.showBookInfo();\n\t\t}\n\t\t\n\t\tSystem.out.println();\n\t\t  \n\t\tSystem.out.println(\"--- 향상된 for문 사용 ---\");\n\t\tfor(Book book : library) {\n\t\t\tbook.showBookInfo();\n\t\t}\n\t}\n}\n\n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n// 토지, 박경리\n// 어린왕자, 생텍쥐페리\n\n// --- 향상된 for문 사용 ---\n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n// 토지, 박경리\n// 어린왕자, 생텍쥐페리\n```\n\n\u003cbr\u003e","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/chap08":{"title":"08.상속과 다형성","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 08 - 상속과 다형성\n\n\u003cbr\u003e\n\n## 상속이란?\n\n- 객체 지향 프로그래밍의 중요한 특징인 상속(inheritance)\n\n- B클래스가 A클래스를 상속받으면 B클래스는 A클래스의 멤버 변수, 메서드 사용 가능\n\n- 유지 보수, 프로그램 수정, 새로운 내용 추가에 굉장히 유연한데 그것이 상속 덕분 !\n\n\u003cbr\u003e\n\n### 클래스의 상속\n\n![](brain/image/chap08-1.png)\n\n- (상위 클래스) A 클래스\n\n\t- A 클래스가 B 클래스에게 상속한다.\n\n- (하위 클래스) B 클래스\n\n\t- B 클래스가 A 클래스를 상속받는다.\n\n- **화살표 방향**\n\n\t- `상속받는 클래스` -\u003e `상속하는 클래스`\n\n\t- `하위 클래스` -\u003e `상위 클래스`\n\n\t- `자식 클래스` -\u003e `부모 클래스`\n\n\u003cbr\u003e\n\n**클래스 상속 문법**\n\n```java\nclass B extends A {\n  \n}\n```\n\n- A가 가지고 있는 속성이나 기능을 추가로 **확장**하여 B 클래스 구현\n\n- 일반적인 클래스 A에서 더 구체적인 클래스 B가 구현된다.\n\n\u003cbr\u003e\n\n### 상속을 사용하여 고객 관리 프로그램 구현\n\n- Customer 클래스\n\n```java\npackage Chapter08;\n  \npublic class Customer {\n\tprivate int customerID; // 고객 아이디\n\tprivate String customerName; // 고객 이름\n\tprivate String customerGrade; // 고객 등급\n\tint bonusPoint; // 적립 포인트\n\tdouble bonusRatio; // 적립 비율\n\t\n\tpublic Customer() {\n\t\tcustomerGrade = \"SILVER\";\n\t\tbonusRatio = 0.01;\n\t}\n\t\n\tpublic int calcPrice(int price) {\n\t\tbonusPoint += price * bonusRatio;\n\t\treturn price;\n\t}\n\t\n\tpublic String getCustomerInfo() {\n\t\treturn customerName + \" 님의 등급은 \" + customerGrade + \"이며, 보너스 포인트는 \" + bonusPoint + \"입니다.\";\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**Customer 클래스 설명**\n\n\u003cbr\u003e\n\n|멤버 변수|설명|\n|:------:|----|\n|customerID|고객 아이디|\n|customerName|고객 이름|\n|customerGrade|고객 등급\u003cbr\u003e기본 생성자에서 지정되는 기본 등급은 Silver|\n|bonusPoint|\u0026nbsp;고객의 보너스 포인트\u003cbr\u003e- 고객이 제품을 구매할 경우 누적되는 보너스 포인트|\n|bonusRatio|\u0026nbsp;보너스 포인트 적립 비율\u003cbr\u003e- 고객이 제품을 구매할 때 구매 금액의 일정 비율이 보너스 포인트로 적립됨. 이때 계산되는 적립 비율\u003cbr\u003e- 기본 생성자에서 지정되는 적립 비율은 1%이다. 즉, 10,000원 짜리를 사면 100원이 적립|\n\n- 모든 멤버 변수 private으로 선언 안해도 됨\n\n- 외부에 노출하고 싶지 않은 멤버 변수나 메서드만 private으로 생성 !\n\n\u003cbr\u003e\n\n|메서드|설명|\n|:----:|----|\n|Customer()|기본 생성자. 고객 한 명이 새로 생성되면 등급은 실버, 적립 비율 1%|\n|calcPrice(int price)|제품에 대해 지불해야 하는 금액 계산 후 반환. 할인되지 않으면 가격 그대로 반환. 가격에 대한 보너스 포인트 비율을 적용하여 보너스 포인트 적립|\n|getCustomerInfo()|고객 정보 출력. 고객 이름/등급/적립된 포인트|\n\n\u003cbr\u003e\n\n지금까지는 단순한 객체 지향 프로그램. 여기서 특별한 상황 부여\n\n\u003cbr\u003e\n\n\u003e [!note] 예제 시나리오\n\u003e \n\u003e 고객이 점점 늘어나고 파내가 많아져서 단골 고객 생김. 단골 고객은 회사 매출에 큰 기여를 하는 우수 고객이라 좋은 혜택을 주고 싶음. 우수 고객 등급은 VIP이고 아래와 같은 혜택 제공\n\u003e - 제품 살 때 항상 10% 할인\n\u003e - 보너스 포인트 5% 적립\n\u003e - 담당 전문 상담원 배정\n\n\u003cbr\u003e\n\n기존의 Customer 클래스에 VIP 고객 추가로 구현해도 됨. 그러나, 단점\n\n1. Customer 클래스 코드 복잡해짐\n\n2. 일반 고객 인스턴스 생성할 때도 불편\n\n3. 한마디로 낭비가 발생\n\n따라서, VIPCustomer 클래스를 따로 구현하기로 결정. 대신, Customer 클래스와 겹치는 부분이 있을 것임 (예를 들어, 멤버 변수 customerID, customerGrade, bonusPoint, bonusRatio) 겹치는 부분은 상속 받아서 구현하는게 훨씬 편할 것 !!\n\n\u003cbr\u003e\n\n**그러나, 상속 시 문제점**\n\n1. Customer 클래스의 멤버 변수를 private으로 선언해놔서 외부 클래스에서 접근 불가\n\n2. VIP 고객에게 제공하는 혜택인 할인율과 세일 가격을 어떻게 적용할지?\n\n- 두 번째 문제는 \u003ca href='/brain/Book/do-it-java/chap08/#메서드-오버라이딩'\u003e메서드 오버라이딩\u003c/a\u003e에서 해결\n\n\u003cbr\u003e\n\n**첫 번째 문제 해결 - proteted**\n\n이전에 [클래스와 객체 (1)](brain/Book/do-it-java/chap05)의 정보은닉에서 배운 접근제어자 protected를 이용하자. protected 예약어는 상위 클래스에 작성한 멤버 변수, 메서드 중 외브 클래스에서 사용할 수는 없지만 (private의 기능) 하위 클래스에서는 사용할 수 있도록 하는 것 ! 따라서, Customer 클래스의 private을 protected로 바꾸면 VIPCustomer 클래스에서 사용할 수 있고, 추가로 외부 클래스에서 사용할 수 있도록 get(), set() 메서드를 구현해놓으면 VIPCustomer 클래스도 자연스레 상속받는다.\n\n- Customer 클래스\n\n```java\npackage Chapter08;\n  \npublic class Customer {\n\tprotected int customerID; // 고객 아이디\n\tprotected String customerName; // 고객 이름\n\tprotected String customerGrade; // 고객 등급\n\tint bonusPoint; // 적립 포인트\n\tdouble bonusRatio; // 적립 비율\n\t  \n\tpublic Customer() {\n\t\tcustomerGrade = \"SILVER\";\n\t\tbonusRatio = 0.01;\n\t}\n\t  \n\tpublic int calcPrice(int price) {\n\t\tbonusPoint += price * bonusRatio;\n\treturn price;\n\t}\n\t  \n\tpublic String showCustomerInfo() {\n\t\treturn customerName + \" 님의 등급은 \" + customerGrade + \"이며, 보너스 포인트는 \" + bonusPoint + \"입니다.\";\n\t}\n\t  \n\tpublic int getCustomerID() {\n\t\treturn customerID;\n\t}\n\t  \n\tpublic void setCustomerID(int customerID) {\n\t\tthis.customerID = customerID;\n\t}\n\t\n\tpublic String getCustomerName() {\n\t\treturn customerName;\n\t}\n\t  \n\tpublic void setCustomerName(String customerName) {\n\t\tthis.customerName = customerName;\n\t}\n\t\n\tpublic String getCustomerGrade() {\n\t\treturn customerGrade;\n\t}\n\t  \n\tpublic void setCustomerGrade(String customerGrade) {\n\t\tthis.customerGrade = customerGrade;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n- VIPCustomer 클래스\n\n```java\npackage Chapter08;\n\n// VIPCustomer 클래스는 Customer 클래스를 상속 받음\npublic class VIPCustomer extends Customer {\n\tprivate int agentID; // VIP 고객 상담원 ID\n\tdouble saleRatio; // VIP 할인율\n\t  \n\tpublic VIPCustomer() {\n\t\tcustomerGrade = \"VIP\";\n\t\tbonusRatio = 0.05;\n\t\tsaleRatio = 0.1;\n\t}\n\t  \n\tpublic int getAgentID() {\n\t\treturn agentID;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n- CustomerTest 클래스\n\n```java\npackage Chapter08;\n\npublic class CustomerTest {\n\tpublic static void main(String[] args) {\n\t\tCustomer customerLee = new Customer();\n\t\tcustomerLee.setCustomerID(10010);\n\t\tcustomerLee.setCustomerName(\"이순신\");\n\t\tcustomerLee.bonusPoint = 1000;\n\t\tSystem.out.println(customerLee.showCustomerInfo());\n\t\t  \n\t\tVIPCustomer customerKim = new VIPCustomer();\n\t\tcustomerKim.setCustomerID(10020);\n\t\tcustomerKim.setCustomerName(\"김유신\");\n\t\tcustomerKim.bonusPoint = 10000;\n\t\tSystem.out.println(customerKim.showCustomerInfo());\n\t}\n}\n  \n// 이순신 님의 등급은 SILVER이며, 보너스 포인트는 1000입니다.\n// 김유신 님의 등급은 VIP이며, 보너스 포인트는 10000입니다.\n```\n\n\u003chr\u003e\n\n## 클래스 생성과 형 변환\n\n- 하위 클래스 생성 시 상위 클래스의 생성자가 **먼저 호출**\n\n\u003cbr\u003e\n\n### 하위 클래스가 생성되는 과정\n\n![](brain/image/chap08-2.png)\n  \n- 단순히 생각해보면, 하위 클래스에서 상위 클래스의 변수나 메서드를 사용할 수 있다는 것은 이미 저장하고 있는 메모리가 존재한다는 말이다.\n\n- 이를 테스트 해보고 싶으면, 각 클래스 생성자에 출력문 찍어보고 테스트\n\n```java\npublic Customer() {\n\tcustomerGrade = \"SILVER\";\n\tbonusRatio = 0.01;\n\tSystem.out.println(\"Customer() 생성자 호출\");\n}\n```\n\n\u003cbr\u003e\n\n```java\npublic VIPCustomer() {\n\tcustomerGrade = \"VIP\";\n\tbonusRatio = 0.05;\n\tsaleRatio = 0.1;\n\tSystem.out.println(\"VIPCustomer() 생성자 호출\");\n}\n```\n\n\u003cbr\u003e\n\n```java\n// Customer() 생성자 호출\n// VIPCustomer() 생성자 호출\n// 김유신 님의 등급은 VIP이며, 보너스 포인트는 10000입니다.\n```\n\n\u003cbr\u003e\n\n### super - 부모를 부르는 예약어\n\n- super는 하위 클래스에서 상위 클래스로 접근할 때 사용\n\n- 하위 클래스는 상위 클래스의 주소(참조 값)를 알고 있음.\n\n- 상위 클래스의 생성자를 호출할 때도 super를 사용\n\n- this : 자기 자신의 참조 값 보유\n\n- super : 부모의 참조 값 보유\n\n생성자 호출이 궁금하다면? [클래스와 객체 (2)](brain/Book/do-it-java/chap06) 생성자에서 다른 생성자를 호출하는 this 참고\n  \n\n\u003cbr\u003e\n\n**상위 클래스 생성자 호출** \n\n바로 위에 VIPCustomer() 생성자 호출한거 보면 Customer() 생성자도 같이 불러와졌는데, 이는 하위 클래스 생성자에서 `super();`가 디폴트로 설정되어 있어서 컴파일러에서 자동으로 불러온다.\n\n\u003cbr\u003e\n\n**super로 매개변수 있는 생성자 호출**\n\n- super는 상위 클래스의 **매개변수 없는 디폴트 생성자**를 받아온다.\n\n- 만약, 묵시적으로 호출될 디폴트 생성자가 상위 클래스에 정의되어있지 않다면, 오류가 발생한다.\n\n- 따라서, 반드시 명시적으로 다른 생성자를 호출해야한다.\n\n```java\npublic Customer() {\n\tcustomerGrade = \"SILVER\";\n\tbonusRatio = 0.01;\n\tSystem.out.println(\"Customer() 생성자 호출\");\n}\n```\n\nCustomer 클래스에 위와 같이 정의되어 있으면 VIPCustomer 클래스에서 super()가 디폴트 생성자를 묵시적으로 불러와줌. 그러나, 디폴트 생성자가 없다면?\n\n```java\npublic Customer(int customerID, String customerName) {\n\tthis.customerID = customerID;\n\tthis.customerName = customerName;\n\tcustomerGrade = \"SILVER\";\n\tbonusRatio = 0.01;\n\tSystem.out.println(\"Customer(int, String) 생성자 호출\");\n}\n```\n\n\u003cbr\u003e\n\n```java\npublic VIPCustomer(int customerID, String customerName, int agentID) {\n\tsuper(customerID, customerName);\n\tcustomerGrade = \"VIP\";\n\tbonusRatio = 0.05;\n\tsaleRatio = 0.1;\n\tSystem.out.println(\"VIPCustomer(int, String) 생성자 호출\");\n}\n```\n\n이런식으로 `super(매개변수)`라고 명시적으로 적어서 VIPCustomer 생성자를 실행하면, Customer 생성자를 실행하도록 해야 한다.\n\n\u003cbr\u003e\n\n**상위 클래스의 멤버 변수나 메서드를 참조하는 super**\n\n- VIPCustomer 클래스에서 상속받은 Customer 클래스의 showCustomerInfo() 메서드를 그냥 사용할 수 있지만, `showCustomerInfo() 메서드 기능 + 추가적인 기능`를 구현하고 싶다면?\n\n```java\n// VIPCustomer 클래스에 구현\npublic String showVIPInfo() {\n\treturn super.showCustomerInfo() + \" VIP전용 담당 상담원 아이디는 \" + agentID + \"입니다.\";\n}\n```\n\n\u003cbr\u003e\n\n```java\n// Customer 클래스 출력 비교\nSystem.out.println(customerLee.showCustomerInfo());\nSystem.out.println(customerKim.showVIPInfo());\n  \n// 이순신 님의 등급은 SILVER이며, 보너스 포인트는 1000입니다.\n// 김유신 님의 등급은 VIP이며, 보너스 포인트는 10000입니다. VIP전용 담당 상담원 아이디는 1입니다.\n```\n\n- 굳이 super를 쓰는건 여기서는 super를 안써도 상위 클래스의 메서드 호출이 잘 되지만, **하위 클래스가 상위 클래스와 동일한 이름의 메서드를 구현하는 경우**라면 어떤가? super가 무조건 필요하겠지\n\n- 이는 나중에 배울 \u003ca href='/brain/Book/do-it-java/chap08/#메서드-오버라이딩'\u003e메서드 오버라이딩\u003c/a\u003e관련된 내용!\n\n\u003cbr\u003e\n\n### 상위 클래스로 묵시적 클래스 형 변환 (업캐스팅)\n\n- 상속 공부할 때, 자료형 형 변환처럼 **클래스 간 형 변환 개념**이 매우 중요!\n\n- Customer는 일반적인 개념\n\n- VIPCustomer는 일반적인 개념 + 더 많은 기능\n\n- 따라서, VIPCustomer는 VIPCustomer형 이면서, 동시에 Customer형!\n\n- VIPCustomer 클래스로 인스턴스 생성할 때, 인스턴스의 자료형을 **Customer형으로 클래스 형 변환하여 선언 가능**\n\n```java\nCustomer vc = new VIPCustomer();\n```\n\n- `Customer` : 선언된 클래스형 (상위 클래스형)\n\n- `VIPCustomer()` : 생성된 인스턴스의 클래스형 (하위 클래스형)\n\n\u003cbr\u003e\n\n**최종 정리**\n\n- 하위 클래스 자료형 (더 많은 기능) -\u003e 상위 클래스 자료형 (일반적인 기능) O\n\n- 상위 클래스 자료형 (일반적인 기능) -\u003e 하위 클래스 자료형 (더 많은 기능) X\n\n\u003cbr\u003e\n\n![](brain/image/chap08-3.png)\n\n다시 이 그림을 보자. 위에서 `VIPCustomer()`로 VIPCustomer의 생성자를 이용하여 만들었다고 해도 `Customer`로 자료형을 선언했기에, 사용가능한 기능은 1번의 기능인 `Customer 클래스의 기능`만 사용 가능하다.\n\n이렇게 클래스 형 변환 사용하는 이유 -\u003e \u003ca href='/brain/Book/do-it-java/chap08/#메서드-오버라이딩'\u003e메서드 오버라이딩\u003c/a\u003e과  \u003ca href='/brain/Book/do-it-java/chap08/#다형성'\u003e다형성\u003c/a\u003e 때문 \u003cbr\u003e\n\nvc 참조 변수를 다시 VIPCustomer형으로 변환하는 것은  \u003ca href='/brain/Book/do-it-java/chap08/#다운-캐스팅과-instanceof'\u003e다운 캐스팅과 instanceof\u003c/a\u003e\n\n\u003chr\u003e\n\n## 메서드 오버라이딩\n\n### 상위 클래스 메서드 재정의\n\nVIPCustomer 클래스가 Customer 클래스 상속받을 시 언급했던 두 번째 문제점\n\n- VIP 고객에게 제공하는 혜택인 할인율과 세일 가격을 어떻게 적용할지?\n\n- 문제가 되는 이유 : 상속받은 메서드 calcPrice()가 일반 고객과 VIP 고객에게 다르게 적용되어야 함\n\n- 따로 vip를 위한 계산을 구현하기에는 리소스 낭비. 10% 할인만 적용하면 되니까\n\n- 따라서, 상위 클래스의 메서드를 하위 클래스 입맛에 맞게 메서드를 재정의해보자\n\n- 이를 **메서드 오버라이딩**이라고 함\n\n- **오버라이딩 조건 : 반환형/메서드 이름/매개변수 개수/매개변수 자료형 반드시 동일**\n\n```java\n// Customer 클래스의 calcPrice 메서드\npublic int calcPrice(int price) {\n\tbonusPoint += price * bonusRatio;\n\treturn price;\n}\n```\n\n\u003cbr\u003e\n\n```java\n// VIPCustomer 클래스의 calcPrice 메서드\n\n@Override\npublic int calcPrice(int price) {\n\tbonusPoint += price * bonusRatio;\n\n\t// 할인된 가격을 계산하여 반환\n\treturn price - (int)(price * saleRatio);\n}\n```\n\n`@Override 애노테이션`은 \"이 메서드는 재정의된 메서드입니다.\"라고 컴파일러에게 명확하게 알려주기 위함!\n\n\u003cbr\u003e\n\n\u003e [!note] 애노테이션(Annotation) ?\n\u003e\n\u003e 애노테이션은 해석해보면 \"주석\"이다. '@애노테이션 이름'으로 표현 자바의 애노테이션은 컴파일러에게 특정한 정보를 제공 미리 정의되어 있는 애노테이션을 표준 애니테이션이라고 함 \n\n\u003cbr\u003e\n\n|애노테이션|설명|\n|:--------|:----|\n|@Override|재정의된 메서드라는 정보 제공|\n|@FunctionalInterface|함수형 인터페이스라는 정보 제공|\n|@Deprecated|이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용됨|\n|@SuppressWarnings|특정 경고가 나타나지 않도록 함|\n\n\u003cbr\u003e\n\n### 묵시적 클래스 형 변환과 메서드 재정의\n\n\u003cbr\u003e\n\n```java\nCustomer vc = new VIPCustomer(10030, \"나몰라\", 2000);\nvc.calcPrice(10000);\n```\n  \n해당 코드는 묵시적 형 변환에 의해 VIPCustomer형이 Customer형으로 변환됨. 이 경우 calcPrice() 메서드는 오버라이딩 된 메서드인데, 어떤 클래스의 메서드를 호출하겠는가? Customer 클래스라면 지불해야하는 금액은 10000원, VIPCustomer 클래스라면 지불해야하는 금액은 9000원이다. 웃기게도.. VIPCustomer 결과가 나온다.\n\n```java\npackage Chapter08;\n\npublic class OverridingTest {\n\tpublic static void main(String[] args) {\n\t\tCustomer vc = new VIPCustomer(10030, \"나몰라\", 2000);\n\t\tvc.bonusPoint = 1000;\n\t\t\n\t\tSystem.out.println(vc.getCustomerName() + \" 님이 지불해야하는 금액은 \" + vc.calcPrice(10000) + \"원입니다.\");\n\t}\n} \n\n// 나몰라 님이 지불해야하는 금액은 9000원입니다.\n```\n\n- 멤버 변수와 메서드 : 선언한 클래스형에 따라 호출\n\n- 상속에서 상위와 하위에 같은 이름의 메서드가 존재할 때 : 인스턴스에 따라 결정\n\n메서드 오버라이딩을 한 경우에는 선언한 클래스 형이 아닌 **생성된 인스턴스의 메서드를 호출**한다. 이렇게 인스턴스의 메서드가 호출되는 기술을 **가상 메서드(virtual method)** 라고 한다.\n\n\u003cbr\u003e\n\n### 가상 메서드\n\n- 자바의 클래스는 멤버 변수와 메서드로 이루어짐\n\n- 인스턴스 변수는 힙 메모리에 위치하는거 이제 기억하지?\n\n- 변수는 인스턴스가 생성될 때마다 힙 메모리에 새로 생성\n\n- 메서드는 실행해야 할 명령 집합이라서 **인스턴스가 달라도 같은 로직 수행**\n\n- 즉, 인스턴스 여러 개 생성한다고 해도 메서드도 여러 개 생성되지는 않음. 또 애초에 메서드와 관련된 지역 변수와 매개 변수는 스택 메모리에 할당받고 메서드 끝나면 해제하잖아!\n\n- 메서드의 명령 집합은 **메서드 영역**에 위치함\n\n\u003cbr\u003e\n\n자바의 모든 메서드는 가상 메서드이다.\n\n\u003cbr\u003e\n\n```java\npackage Chapter08;\n\npublic class TestA {\n\tint num;\n\t  \n\tvoid aaa() {\n\t\tSystem.out.println(\"aaa() 출력\");\n\t}\n\t  \n\tpublic static void main(String[] args) {\n\t\tTestA a1 = new TestA();\n\t\ta1.aaa();\n\t\tTestA a2 = new TestA();\n\t\ta2.aaa();\n\t}\n}\n\n// aaa() 출력\n// aaa() 출력\n```\n\n\u003cbr\u003e\n\n![](brain/image/chap08-4.png)\n\n- main() 함수가 실행되면 지역 변수 스택에 위치\n\n- 참조 변수 a1, a2가 가리키는 인스턴스 힙 메모리에 생성\n\n- 메서드 aaa()의 명령 집합 메서드 영역에 생성\n\n- 메서드 호출하면 콜 스택에서 메서드 영역의 주소를 참조하여 명령 실행\n\n- **따라서, 인스턴스 달라도 동일한 메서드 호출**\n\n\u003cbr\u003e\n\n**가상 메서드의 원리**\n\n일반적으로 메서드를 호출한다는 것\n\n- 메서드를 호출 한다 = 메서드의 명령 집합이 있는 메모리 위치를 참조하여 명령 실행\n\n\u003cbr\u003e\n\n가상 메서드의 경우 (**자바의 모든 메서드는 가상 메서드**)\n\n- **가상 메서드 테이블**이 생성됨\n\n- 각 메서드 이름, 실제 메모리 주소가 짝을 이룸\n\n- 따라서, 어떤 메서드가 호출되면 가상 메서드 테이블에서 주소 값을 찾아서 해당 메서드의 명령을 수행\n\n\u003cbr\u003e\n\n![](brain/image/chap08-5.png)\n\n- calcPrice() 메서드와 같이 재정의 된 메소드\n\n- 실제 인스턴스에 해당하는 메서드가 호출\n\n- showCustomerInfo() 메서드와 같이 재정의 되지 않은 메소드\n\n- 메서드 주소가 같으며 상위 클래스의 메서드가 호출\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n```java\npackage Chapter08;\n  \npublic class OverridingTest2 {\n\tpublic static void main(String[] args) {\n\t\tint price = 10000;\n\t\t  \n\t\tCustomer customerLee = new Customer(10010, \"이순신\");\n\t\tSystem.out.println(customerLee.getCustomerName() + \" 님이 지불해야하는 금액은 \" + customerLee.calcPrice(price) + \"입니다.\");\n\t\t\n\t\tVIPCustomer customerKim = new VIPCustomer(10020, \"김유신\", 12345);\n\t\tSystem.out.println(customerKim.getCustomerName() + \" 님이 지불해야하는 금액은 \" + customerKim.calcPrice(price) + \"입니다.\");\n\t\t  \n\t\tCustomer vc = new VIPCustomer(10030, \"나몰라\", 2000);\n\t\tSystem.out.println(vc.getCustomerName() + \" 님이 지불해야하는 금액은 \" +\n\t\tvc.calcPrice(price) + \"입니다.\");\n\t}\n}\n  \n// 10000원\n// 9000원\n// 9000원\n```\n\n1. Customer 형으로 선언하고 Customer 인스턴스 생성 -\u003e Customer의 메서드 호출\n\n2. VIPCustomer 형으로 선언하고 VIPCustomer 인스턴스 생성 -\u003e VIPCustomer의 메서드 호출\n\n3. Customer 형으로 선언하고 VIPCustomer 인스턴스 생성 -\u003e 원래라면 Customer형 메서드가 호출되는 것이 맞지만, **가상 메서드 방식에 의해 VIPCustomer의 인스턴스의 메서드가 호출**\n\n![](brain/image/chap08-6.png)\n\n\u003chr\u003e\n\n## 다형성\n\n### 다형성이란?\n\n묵시적 클래스 형 변환 + 가상 메서드를 바탕으로 다형성을 이해해보자.\n\n\u003cbr\u003e\n\n\n다형성(polymorphism) : 하나의 코드가 여러 자료형으로 구현되어 실행되는 것\n\n- 쉽게 말해서, 같은 코드에서 여러 실행결과가 나옴\n\n\u003cbr\u003e\n\nAnimal 클래스를 상속받는 Human, Tiger, Eagle 클래스가 있다고 가정  \n\n```java\npackage Chapter08.polymorphism;\n  \nclass Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"동물이 움직입니다.\");\n\t}\n}\n  \nclass Human extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"사람이 두 발로 걷습니다.\");\n\t}\n}\n  \nclass Tiger extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"호랑이가 네 발로 뜁니다.\");\n\t}\n}\n  \nclass Eagle extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"독수리가 하늘을 납니다.\");\n\t}\n}\n  \npublic class AnimalTest1 {\n\tpublic static void main(String[] args) {\n\t\tAnimalTest aTest = new AnimalTest();\n\t\taTest.moveAnimal(new Human());\n\t\taTest.moveAnimal(new Tiger());\n\t\taTest.moveAnimal(new Eagle());\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage Chapter08.polymorphism;\n  \npublic class AnimalTest {\n\tpublic void moveAnimal(Animal animal) {\n\t\tanimal.move();\n\t}\n}\n```\n\n- AnimalTest 클래스의 moveAnimal() 메서드는 어떤 인스턴스가 매개변수로 넘어와도 모두 Animal 형으로 형 변환 됨 (디테일한 하위 클래스 -\u003e 일반적인 상위 클래스 이니까)\n\n- 예를 들어, 매개 변수가 전잘되는 부분에 Human 인스턴스가 전달되었다면, Animal 형으로 선언한 곳에 Human 인스턴스가 들어온 것이니까 아래와 같다.\n\n```java\nAnimal animal = new Human();\n```\n\n- 가상 메서드 원리에 따라, `animal.move()` 메서드가 호출하는 메서드는 매개변수로 넘어온 **실제 인스턴스의 메서드를 호출함**.\n\n- 그래서 Animal의 move가 아닌 Human, Tiger, Eagle의 move를 호출하는 것\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n1. Animal의 `move()` 메서드를 Human, Tiger, Eagle에서 메서드 오버라이딩 함\n\n2. AnimalTest 클래스의 `moveAnimal()` 메서드의 매개 변수를 Animal 형으로 선언\n\n3. 따라서, 매개변수로 들어오는 Human, Tiger, Eagle은 Anmial 형으로 묵시적 형 변환 일어남\n\n4. 묵시적 형 변환이 일어났지만, **가상 메서드의 원리**에 의하여 `animal.move()` 메서드가 호출하는 메서드는 실제 인스턴스의 메서드를 호출\n\n5. 결과적으로 `animal.move()` 코드는 변함이 없지만, **어떤 매개변수가 넘어왔느냐에 따라 결과가 달라짐**\n\n6. 하나의 코드가 여러 자료형으로 구현되어 실행됨. 이것이 다형성\n\n\u003cbr\u003e\n\n### 다형성의 장점\n\n다른 동물이 새로 추가되어도, Animal 클래스를 상속받아 구현하면, **모든 클래스를 Animal 자료형 하나로 쉽게 관리할 수 있을 것이다.** 어차피, AnimalTest 클래스를 인스턴스 생성하고 AnimalTest의 메서드를 실행하는데 그 메서드는 매개변수로 Animal 자료형을 받기 때문이다.\n\n각 자료형에 따라 코드를 다르게 구현한 것보다 코드가 훨씬 간단해지고 유지보수가 수월해진다. 자 그러면 느껴봐야지?\n\n\u003cbr\u003e\u003cbr\u003e\n\n**다형성을 활용해 VIP 고객 클래스 리팩토링**\n\n- Customer.java\n\n```java\npackage Chapter08.polymorphism;\n\npublic class Customer {\n\tprotected int customerID;\n\tprotected String customerName;\n\tprotected String customerGrade;\n\tint bonusPoint;\n\tdouble bonusRatio;\n\t  \n\tpublic Customer() {\n\t\tinitCustomer();\n}\n  \npublic Customer(int customerID, String customerName) {\n\t\tthis.customerID = customerID;\n\t\tthis.customerName = customerName;\n\t\tinitCustomer();\n\t}\n\t  \n\t// 생성자에서만 호출하는 메서드니까 private으로 선언\n\tprivate void initCustomer() {\n\t\tcustomerGrade = \"SILVER\";\n\t\tbonusRatio = 0.01;\n\t}\n\t\n\tpublic int calcPrice(int price) {\n\t\tbonusPoint += price * bonusRatio;\n\t\treturn price;\n\t}\n\t  \n\tpublic String showCustomerInfo() {\n\t\treturn customerName + \"님의 등급은 \" + customerGrade + \"이며, 보너스 포인트는 \" + bonusPoint + \"입니다.\";\n\t}\n\t\n\tpublic int getCustomerID() {\n\t\treturn customerID;\n\t}\n\t  \n\tpublic void setCustomerID(int customerID) {\n\t\tthis.customerID = customerID;\n\t}\n\t\n\tpublic String getCustomerName() {\n\t\treturn customerName;\n\t}\n\t  \n\tpublic void setCustomerName(String customerName) {\n\t\tthis.customerName = customerName;\n\t}\n\t\n\tpublic String getCustomerGrade() {\n\t\treturn customerGrade;\n\t}\n\t  \n\tpublic void setCustomerGrade(String customerGrade) {\n\t\tthis.customerGrade = customerGrade;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n- VIPCustomer.java\n\n```java\npackage Chapter08.polymorphism;\n\npublic class VIPCustomer extends Customer {\n\tprivate int agentID;\n\tdouble saleRatio;\n\t\n\tpublic VIPCustomer(int customerID, String customerName, int agentID) {\n\t\tsuper(customerID, customerName);\n\t\tcustomerGrade = \"VIP\";\n\t\tbonusRatio = 0.05;\n\t\tsaleRatio = 0.1;\n\t\tthis.agentID = agentID;\n\t}\n\t\n\tpublic int calcPrice(int price) {\n\t\tbonusPoint += price * bonusRatio;\n\t\treturn price - (int)(price * saleRatio);\n\t}\n\t\n\tpublic String showCustomerInfo() {\n\t\treturn super.showCustomerInfo() + \" 담당 상담원 번호는 \" + agentID + \"입니다.\";\n\t}\n\t\n\tpublic int getAgentID() {\n\t\treturn agentID;\n\t}\n}\n```\n\n\u003cbr\u003e\n  \n- CustomerTest.java\n\n```java\npackage Chapter08.polymorphism;\n\npublic class CustomerTest {\n\tpublic static void main(String[] args) {\n\t\tCustomer customerLee = new Customer(10010, \"이순신\");\n\t\tcustomerLee.bonusPoint = 1000;\n\t\tSystem.out.println(customerLee.showCustomerInfo());\n\t\t  \n\t\tCustomer customerKim = new VIPCustomer(10020, \"김유신\", 12345);\n\t\tcustomerKim.bonusPoint = 10000;\n\t\tSystem.out.println(customerKim.showCustomerInfo());\n\t\t\n\t\tSystem.out.println(\"----- 할인율과 보너스 포인트 계산 -----\");\n\t\t\n\t\tint price = 10000;\n\t\tint leePrice = customerLee.calcPrice(price);\n\t\tint kimPrice = customerKim.calcPrice(price);\n\t\t  \n\t\tSystem.out.println(customerLee.getCustomerName() + \"님이 \" + leePrice + \"원 지불하셨습니다.\");\n\t\tSystem.out.println(customerLee.showCustomerInfo());\n\t\tSystem.out.println(customerKim.getCustomerName() + \"님이 \" + kimPrice + \"원 지불하셨습니다.\");\n\t\tSystem.out.println(customerKim.showCustomerInfo());\n\t}\n}\n```\n\n핵심은 Customer 자료형 하나로 관리하는 모습이다. 자료형은 Customer 형으로 동일하지만, 할인율과 보너스 포인트는 각 인스턴스의 메서드에 맞게 계산했다. 재정의된 메서드는 각각 호출되고 서로 다른 역할을 구현하기 떄문이다. 다형성을 적절하게 이용했다.\n\n\u003chr\u003e\n\n## 다형성 활용하기\n\n### 새로운 상황 부여 ver 01\n\n\u003e [!note] 예제 시나리오\n\u003e\n\u003e 고객이 늘어 VIP 고객까진 아니고 GOLD 등급 하나 추가하려함 \n\u003e - 제품을 살 때는 항상 10% 할인 (VIP랑 동일)\n\u003e - 보너스 포인트를 2% 적립 (SILVER는 1%, VIP는 5%)\n\u003e - 담당 전문 상담원 없음\n\n![](brain/image/chap08-7.png)\n\n```java\npackage Chapter08.polymorphism;\n  \npublic class GoldCustomer extends Customer {\n\tdouble saleRatio;\n\t  \n\tpublic GoldCustomer(int customerID, String customerName) {\n\t\tsuper(customerID, customerName);\n\t\tcustomerGrade = \"GOLD\";\n\t\tbonusRatio = 0.02;\n\t\tsaleRatio = 0.1;\n\t}\n\t  \n\t@Override\n\tpublic int calcPrice(int price) {\n\t\tbonusPoint += price * bonusRatio;\n\t\treturn price - (int)(price * saleRatio);\n\t}\n}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**배열로 고객 5명 구현하기**\n\n```java\npackage Chapter08.polymorphism;\nimport java.util.ArrayList;\n\npublic class CustomerTest2 {\n\tpublic static void main(String[] args) {\n\t\tArrayList\u003cCustomer\u003e customerList = new ArrayList\u003cCustomer\u003e(); \n\t\t\n\t\tCustomer customerLee = new Customer(10010, \"이순신\");\n\t\tCustomer customerShin = new Customer(10020, \"신사임당\");\n\t\tCustomer customerHong = new GoldCustomer(10030, \"홍길동\");\n\t\tCustomer customerYoul = new GoldCustomer(10040, \"이율곡\");\n\t\tCustomer customerKim = new VIPCustomer(10050, \"김유신\", 12345);\n\t\t  \n\t\tcustomerList.add(customerLee);\n\t\tcustomerList.add(customerShin);\n\t\tcustomerList.add(customerHong);\n\t\tcustomerList.add(customerYoul);\n\t\tcustomerList.add(customerKim);\n\t\t\n\t\tSystem.out.println(\"----- 고객 정보 출력 -----\");\n\t\tfor (Customer customer : customerList) {\n\t\t\tSystem.out.println(customer.showCustomerInfo());\n\t\t}\n\t\t  \n\t\tSystem.out.println();\n\t\t\n\t\tSystem.out.println(\"----- 할인율과 보너스 포인트 계산 -----\");\n\t\tint price = 10000;\n\t\tfor(Customer customer : customerList) {\n\t\t\tint cost = customer.calcPrice(price);\n\t\t\tSystem.out.println(customer.getCustomerName() + \"님이 \" + cost + \"원 지불하셨습니다.\");\n\t\t\tSystem.out.println(customer.getCustomerName() + \"님의 현재 보너스 포인트는 \" + customer.bonusPoint + \"점 입니다.\");\n\t\t}\n\t}\n}\n```\n\n- **Customer 형**으로 객체 배열 ArrayList 선언\n\n- **Customer 형**으로 선언하고 Customer, GoldCustomer, VIPCustomer 인스턴스 생성해서, 각 인스턴스 (하위) -\u003e Custmer (상위)로 묵시적 형 변환\n\n- 가상 메서드 원리에 의하여 **Customer 형**임에도 calcPrice() 메서드 호출 시 각 인스턴스의 메서드 호출하여 실행\n\n- 배열의 요소를 **Customer 형** 변수에 넣음\n\n- 이것이 바로 다형성 ~\n\n만약, 재정의한 (오버라이딩한) 메서드가 가상 메서드 방식에 의해 자동으로 호출되지 않는다면? -\u003e if/else-if로 각 자료형에 적합한 코드를 하나하나 따로 구현해야함 -\u003e 코드 길어짐, 유지보수 힘듬\n\n\u003cbr\u003e\n\n### 상속은 언제 사용?\n\n상속을 사용하여 이미 Customer 클래스가 있는 상태에서 (기본 뼈대) 추가적인 내용만 따로 구현 가능했다. 만약 상속을 사용하지 않는다면? 아래처럼 답 없이 짜야함\n\n```java\nif (customerGrade == \"VIP\") {\n\t// 할인해주고, 적립도 많이해주고\n} else if (customerGrade == \"GOLD\") {\n\t// 할인해주고, 적립 적당히\n} else if (customerGrade == \"SILVER\") {\n\t// 할인 없음, 적립만\n}\n```\n\n\u003cbr\u003e\n\n**그렇다면, 상속을 항상 사용하는 것이 좋은가?**\n\n- 아니다. 상속은 ==IS-A 관계(is a relationship; inheritance)== 처럼 일반적인 개념과 구체적인 개념의 관계에서 사용하는 것이 가장 효율적이다.\n\n- 일반 클래스를 점차 구체화하는 상황에서 사용하는 것이지 상속을 사용하면 **하위 클래스가 상위 클래스형에 종속되기 때문에** 이질적인 클래스 간에는 상속을 사용하지 않는 것이 좋다.\n\n\u003cbr\u003e\n\n예를 들어, 과목을 나타내는 Subject 클래스와 학생을 나타내는 Student 클래스가 있다고 하자. 모든 학생은 전공 과목(Subject)을 가지고 있으니까 Subject 클래스에서 제공하는 여러 메서드를 활용하면 좋을 것 같아서 상속받으면 될까?\n\nSubject가 Student를 **포괄**하는 개념이 **아니기** 때문에 좋지 않다. 이런 경우에는 IS-A 관계가 아닌 ==HAS-A 관계(has a relationship; association)== 로 표현한다. HAS-A 관계는 **한 클래스가 다른 클래스를 소유한 관계**이다.\n\n- 학생이 과목을 가지고 있다. HAS-A 관계\n\n- Subject는 Student에 포함되어 Student의 멤버 변수로 사용하는 것이 적절\n\n```java\nclass Student {\n\tSubject majorSubject;\n}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n- 상속은 무조건적인 코드 재사용 개념이 아니다.\n\n- 상속을 사용하면 클래스 간의 결합도가 높아져서, 상위 클래스의 변화가 하위 클래스에 미치는 영향이 커진다.\n\n- 일반적인 클래스와 구체적인(확장되는) 클래스, IS-A 관계에서 구현하는 것이 맞다.\n\n\u003cbr\u003e\n\n### 자바에는 다중 상속이 없어요\n\n다중 상속 : 한 클래스가 여러 클래스를 상속 받는 것\n\n- 다중 상속에서 오는 장점이 있겠지만, 다중 상속으로 인한 모호성 때문에 자바에서는 다중 상속 지원 X\n\n- ex) 두 개 이상의 상위 클래스에 같은 이름의 메서드가 정의되어 있다면, 다중 상속을 받는 하위 클래스는 어떤 메서드를 상속받을지 모호해짐\n\n- 객체 지향에서 다중 상속의 모호성에 대한 문제가 **다이아몬드 문제(diamond problem)**\n\n- 따라서, extends 예약어 뒤에 오는 클래스는 무조건 한 개\n\n\u003chr\u003e\n\n## 다운 캐스팅과 instanceof\n\n### 하위 클래스로 형 변환, 다운 캐스팅\n\n상위 클래스(일반적인 개념) -\u003e 하위 클래스(구체적인 개념)으로 형 변환 되는 과정\n\n\u003cbr\u003e\n\n```java\nAnimal ani = new Human();\n```\n\n- 생성된 인스턴스 Human은 Anmial 자료형\n\n- 업 캐스팅(하위-\u003e상위) 된 경우에는 상위 클래스에서 선언한 메서드나 멤버 변수만 사용 가능\n\n- 다시 말해, Human 클래스에 더 많은 메서드, 다양한 멤버 변수가 있어도 Animal 클래스의 메서드와 멤버 변수만 사용 가능\n\n- 필요에 따라 원래 인스턴스의 자료형(여기서 Human형)으로 되돌아가야하는 경우가 있음\n\n- 이때 쓰는 것을 다운 캐스팅(down casting)\n\n\u003cbr\u003e\n\n### instanceof  \n\n예를 들어, 상속 관계에서 모든 인간은 동물이지만, 모든 동물은 인간이 아니다. 따라서, 변환에서 생기는 오류를 막기 위하여, 다운 캐스팅 전 하위 클래스 -\u003e 상위 클래스로 형 변환된 **인스턴스의 원래 자료형을 확인하는 예약어가 instanceof** 이다.\n\n```java\nAnimal hAnimal = new Human();\n\nif(hAnimal instanceof Human) {\n\tHuman human = (Human)hAnimal;\n}\n```\n\n- `hAnimal instanceof Human` : hAnimal 인스턴스의 원래 자료형이 Human 형 이라면\n\n- `Human human = (Human)hAnimal` : 인스턴스 hAnimal을 Human형으로 다운 캐스팅\n\n```java\nAnimal ani = new Tiger();\nHuman h = (Human)ani;\n```\n\n- 이렇게 코딩해도 컴파일 에러는 안남. 왜? Human형으로 자료형이 같으니까\n\n- 대신 실행오류가 발생함\n\n```java\npackage Chapter08.polymorphism;\nimport java.util.ArrayList;\n\nclass Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"동물이 움직입니다.\");\n\t}\n}\n\nclass Human extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"사람이 두 발로 걷습니다.\");\n\t}\n\n\tpublic void readBook() {\n\t\tSystem.out.println(\"사람이 책을 읽습니다.\");\n\t}\n}\n\nclass Tiger extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"호랑이가 네 발로 뜁니다.\");\n\t}\n\t\n\tpublic void hunting() {\n\t\tSystem.out.println(\"호랑이가 사냥을 합니다.\");\n\t}\n}\n\nclass Eagle extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"독수리가 하늘을 납니다.\");\n\t}\n\t  \n\tpublic void flying() {\n\t\tSystem.out.println(\"독수리가 날개를 쭉 펴고 멀리 날아갑니다.\");\n\t}\n}\n\npublic class AnimalTest {\n\tArrayList\u003cAnimal\u003e aniList = new ArrayList\u003cAnimal\u003e();\n\t  \n\tpublic static void main(String[] args) {\n\t\tAnimalTest aTest = new AnimalTest();\n\t\taTest.addAnimal();\n\t\tSystem.out.println(\"원래 형으로 다운 캐스팅\");\n\t\taTest.testCasting();\n\t}\n\n\tpublic void addAnimal() {\n\t\taniList.add(new Human());\n\t\taniList.add(new Tiger());\n\t\taniList.add(new Eagle());\n\t\t  \n\t\tfor (Animal ani : aniList) {\n\t\t\tani.move();\n\t\t}\n\t}\n\n\tpublic void testCasting() {\n\t\tfor (int i = 0; i \u003c aniList.size(); i++) {\n\t\t\tAnimal ani = aniList.get(i);\n\t\t\t  \n\t\t\tif (ani instanceof Human) {\n\t\t\t\tHuman h = (Human) ani;\n\t\t\t\th.readBook();\n\t\t\t} else if (ani instanceof Tiger) {\n\t\t\t\tTiger t = (Tiger) ani;\n\t\t\t\tt.hunting();\n\t\t\t} else if (ani instanceof Eagle) {\n\t\t\t\tEagle e = (Eagle) ani;\n\t\t\t\te.flying();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"지원되지 않는 형입니다.\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 사람이 두 발로 걷습니다.\n// 호랑이가 네 발로 뜁니다.\n// 독수리가 하늘을 납니다.\n// 원래 형으로 다운 캐스팅\n// 사람이 책을 읽습니다.\n// 호랑이가 사냥을 합니다.\n// 독수리가 날개를 쭉 펴고 멀리 날아갑니다.\n```\n\n- 배열 요소가 Animal 형이라서 각 인스턴스에서 제공하는 구체적인 메서드를 사용할 수 없음\n\n- 따라서, 사용하려면 원래 자료형으로 다운캐스팅 되어야 함","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/chap09":{"title":"09.추상 클래스","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 09 - 추상 클래스\n\n\u003cbr\u003e\n\n## 추상 클래스\n\n- 추상 클래스는 완전하지 않은 클래스\n\n- 부족하다는 뜻도 있지만,\n\n- 다른 한 편으로 **가능성이 남아 있다는 의미**, 즉, 확장이 가능하다\n\n\u003cbr\u003e\n\n### 추상 클래스란?\n\n- 추상적이다 = 구체적이지 않고 막연하다\n\n- 어떤 클래스가 추상적이다 = 구체적이지 않은 클래스\n\n- 추상 클래스 (abstract class)\n\n- 추상 클래스가 아닌 클래스 (concrete class), 지금까지 해온 모든 클래스가 이거\n\n**추상 클래스는 항상 추상 메서드를 포함한다.** 추상 메서드는 구현 코드가 없다. 즉, **함수 몸체가 없다**. 아래와 같이 `{}` 안의 내용이 함수 몸체이다.\n\n```java\nint add(int x, int y) {\n\treturn x + y;\n}\n```\n\n- 중괄호 `{}`로 감싼 부분 = 함수의 구현부(implementation)\n\n- 함수의 구현부가 없는 함수 = 추상 함수(abstract function)\n\n- 자바에서는 이를 **추상 메서드(abstract method)** 라고 한다.\n\n- 추상 메서드는 선언만 하며 abstract 예약어 사용  \n\n```java\nabstract int add(int x, int y);\n```\n\n아래는 중괄호 `{}`가 있으니까 추상 메서드 아님. `{}`안에 코드만 없을 뿐 `{}`를 구현은 한 것이다.\n\n```java\nint add(int x, int y) {}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**메서드 선언의 의미** \n\n변수를 선언하고 제어문을 사용하여 로직을 만들고 기능을 구현하는 것도 물론 중요하지만, 로직을 구현하는 것보다 중요한 것이 **어떻게 구현할지를 결정하는 것**이다.\n\n```java\nint add(int num1, int num2);\n```\n\n위 코드만 봐도 두 개의 정수를 입력받고 더해서 반환한다는 것을 유추할 수 있다.\n\n- **메서드의 선언부(declaration)만 봐도 어떤 일을 하는 메서드인지 유추할 수 있다.**\n\n- 선언부에 해당하는 반환 값(리턴), 함수 이름, 매개변수를 정의한다는 것이 **함수의 역할이 무엇인지, 어떻게 구현해야 하는지를 정의한다**는 의미다.\n\n- 어떤 의미로는, **함수 몸체를 구현하는 것보다 함수 선언부 작성이 더 중요하다는 말이다.**\n\n\u003cbr\u003e\n\n### 추상 클래스 구현\n\n- 클래스 다이어그램에서 일반 클래스는 똑바로 쓰는데 **추상 클래스는 기울임 꼴**로 작성\n\n![](brain/image/chap09-1.png)\n\n\u003cbr\u003e\n\n**Computer 클래스**\n\n```java\npackage chapter09.abstractex;\n  \npublic abstract class Computer {\n\tpublic abstract void display();\n\tpublic abstract void typing();\n\t\n\tpublic void turnOn() {\n\t\tSystem.out.println(\"전원을 켭니다.\");\n\t}\n\t\n\tpublic void turnOff() {\n\t\tSystem.out.println(\"전원을 끕니다.\");\n\t}\n}\n```\n\n- 추상화 하고자 하는 메서드(몸체, 구현부 `{}` 없는)에 abstract 안붙히면 오류\n\n- 추상 메서드가 들어있는 클래스에 abstract 안붙히면 오류\n\n- Computer 클래스를 상속받는 클래스 중 `turnOn()`과 `turnOff()` 구현 코드는 공통\n\n- 하지만, 추상 메서드인 `display()`와 `typing()`은 하위 클래스에 따라 달라질 수 있음\n\n- 추상 메서드는 **이 메서드는 Computer 클래스에서 구현하지 않고, 구현에 대한 책임을 상속 받는 클래스에 위임한다**라는 의미\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n- 상위 클래스에서 하위 클래스도 공통으로 사용할 메서드 구현\n\n- 하위 클래스마다 다르게 구현할 메서드는 추상 메서드로 선언\n\n\u003cbr\u003e\u003cbr\u003e\n\n**DeskTop 클래스**\n\n```java\npackage chapter09.abstractex;\n  \npublic class DeskTop extends Computer{\n  \n}\n```\n\n- 이렇게 하면 오류 발생\n\n- Computer 클래스가 추상 클래스니까, 추상 클래스를 상속받는 클래스는 **추상 메서드를 상속받음**\n\n- 해결방법 01. DeskTop도 추상 클래스로 만들기\n\n- 해결방법 02. DeskTop에서 Computer에서 구현되지 않았던 추상 메서드를 구현하기, 대신 모든 추상 메서드를 모두 구현해야함. 하나라도 추상 메서드 있으면 추상 클래스니까\n\n\u003cbr\u003e\u003cbr\u003e\n\n아래에서 해결방법 02를 사용했다.\n\n```java\npackage chapter09.abstractex;\n\npublic class DeskTop extends Computer{\n\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"DeskTop display()\");\n\t}\n\n\t@Override\n\tpublic void typing() {\n\t\tSystem.out.println(\"DeskTop typing()\");\n\t}\n}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**NoteBook 클래스**\n\n```java\npackage chapter09.abstractex;\n  \npublic abstract class NoteBook extends Computer{\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"NoteBook display()\");\n\t}\n}\n```\n\n- 추상 메서드 `display()`와 `typing()`중 `display()`만 구현했으니 추상 클래스라고 해주는 `abstract`를 붙혀야함\n\n\u003cbr\u003e\u003cbr\u003e\n\n**MyNoteBook 클래스**\n\n```java\npackage chapter09.abstractex;\n  \npublic class MyNoteBook extends NoteBook {\n\t@Override\n\tpublic void typing() {\n\t\tSystem.out.println(\"MyNoteBook typing()\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**모든 추상 메서드를 구현하고도 클래스에 abstract 사용하면?**\n\n```java\npublic abstract class AbstractTV {\n\tpublic void turnOn() {\n\t\tSystem.out.println(\"전원을 켭니다.\");\n\t}\n\t  \n\tpublic void turnOff() {\n\t\tSystem.out.println(\"전원을 끕니다.\");\n\t}\n}\n```\n\n- 모든 추상 메서드를 구현했어도, 완벽하게 TV의 기능이 구현된 것은 아니고 TV의 **공통 기능만 구현해놓은 것**이다.\n\n- 이 클래스는 사용할 목적이 아닌 **상속만을 위해 만든 추상 클래스**이다.\n\n- 이런 경우 **new 예약어로 인스턴스 생성 불가**\n\n추상 클래스 연습한거는 \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter09/abstractex/alone/Car.java' target='_blank'\u003eCar\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter09/abstractex/alone/Bus.java' target='_blank'\u003eBus\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter09/abstractex/alone/AutoCar.java' target='_blank'\u003eAutoCar\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter09/abstractex/alone/CarTest.java' target='_blank'\u003eCarTest\u003c/a\u003e\n\n\u003cbr\u003e\n\n### 추상 클래스를 만드는 이유\n\n\u003cbr\u003e\n\n**추상 클래스는 인스턴스로 생성할 수 없다.**\n\n- 추상 클래스는 모든 메서드가 구현된 것은 아니므로, 인스턴스로 생성 불가\n\n- 추상 메서드를 호출했을 때 구현된 코드가 없으므로 수행할 수 있는 내용 없으니까.\n\n\u003cbr\u003e\n\n**추상 클래스에서 구현하는 메서드**\n\n- 생성할 수 없는 추상 클래스를 어디에 씀? -\u003e 추상 클래스는 상속을 하기 위해 만든 클래스\n\n- 추상 클래스에서 구현하는 메서드 : 하위 클래스에서도 사용할, 하위 클래스에서도 구현 내용을 공유할 메서드를 구현\n\n- 하위 클래스에서 내용을 각각 다르게 구현해야 하면, 구현 내용을 추상 메서드로 남겨 두고 하위 클래스에 구현을 위임\n\n\u003cbr\u003e\n\n| 메서드        | 특징                                                                           |\n|:------------- |:------------------------------------------------------------------------------ |\n| 구현된 메서드 | 하위 클래스에서 공통으로 사용할 구현 코드. 하위 클래스에서 재정의 할 수도 있음 |\n| 추상 메서드 | 하위 클래스가 어떤 클래스냐에 따라 구현 코드가 달라짐  |\n\n\u003cbr\u003e\n\n예를 들어, `turnOn()`, `turnOff()`의 구현은 하위 클래스에서 공유할 수 있다. 하지만, `display()`와 `typing()`의 구현내용은 NoteBook인지 DeskTop인지에 따라 달라지니까 Computer 클래스에서 구현 안했던 것\n\n\u003cbr\u003e\u003cbr\u003e\n\n**추상 클래스와 프레임워크**\n\n- 추상 클래스는 많은 프레임워크에서 사용하고 있는 구현 방식\n\n- ex) 안드로이드 앱 만들 때 안드로이드 라이브러리에서 제공하는 많은 클래스 사용. 모두 구현된 클래스도 있지만, 일부만 구현되어 있어서 상속 받고 그 뒤에 구현하는 경우도 많음\n\n- 구현을 미루어 놓은 메서드(추상 메서드)는 앱을 어떻게 만드냐에 따라 다르게 구현해야할 내용으로 앱에서 구현하도록 **선언**만 해둔 것\n\n\u003chr\u003e\n\n## 템플릿 메서드\n\n### 추상 클래스와 템플릿 메서드\n\n- 템플릿 메서드는 추상 클래스를 활용한 예\n\n- 템플릿(template)는 사전적 의미로 틀이나 견본을 의미\n\n- 즉, 템플릿 메서드 = 틀이 있는 메서드\n\n- 싱글톤 패턴과 같은 디자인 패턴\n\n\u003cbr\u003e\n\n**Car 클래스**\n\n```java\npackage chapter09.template;\n  \npublic abstract class Car {\n\tpublic abstract void drive();\n\tpublic abstract void stop();\n\t\n\tpublic void startCar() {\n\t\tSystem.out.println(\"시동을 켭니다.\");\n\t} \n\t\n\tpublic void turnOff() {\n\t\tSystem.out.println(\"시동을 끕니다.\");\n\t}\n\t\n\tfinal public void run() {\n\t\tstartCar();\n\t\tdrive();\n\t\tstop();\n\t\tturnOff();\n\t}\n}\n```\n\n- `final`이 부분이 템플릿 메서드\n\n- 시동을 켜고 끄는 방법은 비슷비슷 하니까 `startCar()`, `turnOff()`는 미리 구현해놈\n\n- `drive()`, `stop()`은 차종에 따라 다를 수 있으니까 추상 메서드로 선언\n\n- `run()`은 템플릿 메서드인데, 자동차가 달리는 방법을 순서대로 구현해뒀음. 시동 키고 -\u003e 달리고 -\u003e 브레이크로 멈추고 -\u003e 시동 끔\n\n\u003cbr\u003e\n\n**AICar 클래스**\n\n```java\npackage chapter09.template;\n\npublic class AICar extends Car {\n\t@Override\n\tpublic void drive() {\n\t\tSystem.out.println(\"자율 주행합니다.\");\n\t\tSystem.out.println(\"자동차가 알아서 방향을 전환합니다.\");\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\tSystem.out.println(\"스스로 멈춥니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**ManualCar 클래스**\n\n```java\npackage chapter09.template;\n  \npublic class ManualCar extends Car {\n\t@Override\n\tpublic void drive() {\n\t\tSystem.out.println(\"사람이 운전합니다.\");\n\t\tSystem.out.println(\"사람이 핸들을 조작합니다.\");\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\tSystem.out.println(\"브레이크로 정지합니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**CarTest 클래스**\n\n```java\npackage chapter09.template;\n  \npublic class CarTest {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"--- 자율 주행하는 자동차 ---\");\n\t\tCar myCar = new AICar();\n\t\tmyCar.run();\n\t\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"--- 사람이 운전하는 자동차 ---\");\n\t\tCar hisCar = new ManualCar();\n\t\thisCar.run();\n\t}\n}\n\n// --- 자율 주행하는 자동차 ---\n// 시동을 켭니다.\n// 자율 주행합니다.\n// 자동차가 알아서 방향을 전환합니다.\n// 스스로 멈춥니다.\n// 시동을 끕니다.\n  \n// --- 사람이 운전하는 자동차 ---\n// 시동을 켭니다.\n// 사람이 운전합니다.\n// 사람이 핸들을 조작합니다.\n// 브레이크로 정지합니다.\n// 시동을 끕니다.\n```\n\n\u003cbr\u003e\n\n### 템플릿 메서드 역할\n\n- 템플릿 메서드는 **메서드 실행 순서와 시나리오를 정의**하는 것\n\n- 시나리오를 정의한 메서드라서 바꾸면 안됨\n\n- `final` 예약어를 사용하면 상속받은 하위 클래스가 메서드를 재정의 할 수 없음\n\n- 상수를 선언할 때 `final` 썼잖음 그거\n\n- 템플릿 메서드는 로직 흐름이 이미 정해져 있는 프레임워크에서 많이 사용하는 기본 구현 방법\n\n\u003chr\u003e\n\n## 템플릿 메서드 응용하기\n\n\u003e [!note] 예제 시나리오\n\u003e\n\u003e Player가 게임을 한다. 게임에서 Player가 가지는 레벨에 따라 할 수 있는 세 가지 기능이 있다. 이 기능은 run(), jump(), turn()이다.\n\u003e - 초보자 레벨 : 천천히 달릴(run) 수 있음\n\u003e - 중급자 레벨 : 빠르게 달리고(run) 점프(jump)할 수 있음\n\u003e - 고급자 레벨 : 엄청 빠르게 달리고(run) 점프하고(jump) 턴(turn)할 수 있음\n\u003e \u003cbr\u003e\n\u003e 모든 레벨에서 Player가 사용할 수 있는 필살기 go(int count) 메서드 제공 \u003cbr\u003e\n\u003e  go() 메서드는 한 번 run하고, 매개변수로 전달된 count만큼 jump하고, 한 번 turn 함 \u003cbr\u003e\n\u003e  그 레벨에서 불가능한 기능을 요청하면 할 수 없다는 메세지 출력\n  \n\u003cbr\u003e\n\n### 클래스 설계하기\n\n![](brain/image/chap09-2.png)\n\n- Player 클래스와 PlayerLevel 클래스는 포함(HAS-A) 관계\n\n- 게임에서 모든 플레이어는 레벨이 있으니까, 플레이어가 레벨을 멤버 변수로 갖는 것\n\n- 모든 레벨에서 공통으로 수행하는 기능은 구현\n\n- 레벨마다 달라지는 기능은 추상 메서드로 선언만\n\n다이아몬드 표시는 포함 관계를 나타내는 것\n\n\u003cbr\u003e\n\n**Player 클래스**\n\n```java\npackage chapter09.gameLevel;\n  \npublic class Player {\n\tprivate PlayerLevel level;\n\t  \n\tpublic Player() {\n\t\tlevel = new BeginnerLevel();\n\t\tlevel.showLevelMessage();\n\t}\n\t  \n\tpublic PlayerLevel getLevel() {\n\t\treturn level;\n\t}\n\t  \n\tpublic void upgradeLevel(PlayerLevel level) {\n\t\tthis.level = level;\n\t\tlevel.showLevelMessage();\n\t}\n\t  \n\tpublic void play(int count) {\n\t\tlevel.go(count);\n\t}\n}\n```\n\n- Player가 가지는 level 변수 선언\n\n- 디폴트 생성자로 처음 생성되었을 때 초보자 레벨로 시작하게\n\n- 레벨 변경 메서드는 현재 자신의 level을 매개변수로 받은 level로 변경\n\n- 이때, 매개변수 자료형을 모든 레벨로 변환 가능하게 PlayerLevel 형으로 선언\n\n- PlayerLevel의 템플릿 메서드 go 호출\n\n\u003cbr\u003e\n\n**PlayerLevel 클래스**\n\n```java\npackage chapter09.gameLevel;\n  \npublic abstract class PlayerLevel {\n\tpublic abstract void run();\n\tpublic abstract void jump();\n\tpublic abstract void turn();\n\tpublic abstract void showLevelMessage();\n\t  \n\tfinal public void go(int count) {\n\t\trun();\n\t\t\n\t\tfor(int i = 0; i \u003c count; i++) {\n\t\t\tjump();\n\t\t}\n\t\t\n\t\tturn();\n\t}\n}\n```\n\n- 레벨마다 다른 기능인 `run(), jump(), turn(), showLevelMessage()`는 추상 메서드로 선언만\n\n- 템플릿 메서드인 `go()`는 예약어 `final`써서 순서 마음대로 못바꾸게\n\n- count에 따라 점프 횟수 바뀌니까 반복문으로\n\n\u003cbr\u003e\n\n**BeginnerLevel 클래스**\n\n```java\npackage chapter09.gameLevel;\n  \npublic class BeginnerLevel extends PlayerLevel {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"천천히 달립니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void jump() {\n\t\tSystem.out.println(\"Jump 할 줄 모르지롱. 레벨 올려오셈\");\n\t}\n\t  \n\t@Override\n\tpublic void turn() {\n\t\tSystem.out.println(\"Turn 할 줄 모르지롱. 레벨 올려오셈\");\n\t} \n\t\n\t@Override\n\tpublic void showLevelMessage() {\n\t\tSystem.out.println(\"****** 초보자 레벨입니다. ******\");\n\t}\n}\n```\n\n\u003cbr\u003e  \n\n**AdvancedLevel 클래스**\n\n```java\npackage chapter09.gameLevel;\n  \npublic class AdvancedLevel extends PlayerLevel {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"빨리 달립니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void jump() {\n\t\tSystem.out.println(\"높이 점프합니다.\");\n\t}\n\t\n\t@Override\n\tpublic void turn() {\n\t\tSystem.out.println(\"Turn 할 줄 모르지롱. 레벨 올려오셈\");\n\t}\n\t\n\t@Override\n\tpublic void showLevelMessage() {\n\t\tSystem.out.println(\"****** 중급자 레벨입니다. ******\");\n\t}\n}\n```\n\n\u003cbr\u003e \n\n**SuperLevel 클래스**\n\n```java\npackage chapter09.gameLevel;\n\npublic class SuperLevel extends PlayerLevel {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"엄청 빨리 달립니다.\");\n\t}\n\t\n\t@Override\n\tpublic void jump() {\n\t\tSystem.out.println(\"아주 높이 점프합니다.\");\n\t}\n\t\n\t@Override\n\tpublic void turn() {\n\t\tSystem.out.println(\"한 바퀴 돕니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void showLevelMessage() {\n\t\tSystem.out.println(\"****** 고급자 레벨입니다. ******\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**MainBoard 클래스**\n\n```java\npackage chapter09.gameLevel;\n\npublic class MainBoard {\n\tpublic static void main(String[] args) {\n\t\tPlayer player = new Player();\n\t\tplayer.play(1);\n\t\n\t\tAdvancedLevel aLevel = new AdvancedLevel();\n\t\tplayer.upgradeLevel(aLevel);\n\t\tplayer.play(2);\n\t\n\t\tSuperLevel sLevel = new SuperLevel();\n\t\tplayer.upgradeLevel(sLevel);\n\t\tplayer.play(3);\n\t}\n} \n\n//****** 초보자 레벨입니다. ******\n//천천히 달립니다.\n//Jump 할 줄 모르지롱. 레벨 올려오셈\n//Turn 할 줄 모르지롱. 레벨 올려오셈\n\n//****** 중급자 레벨입니다. ******\n//빨리 달립니다.\n//높이 점프합니다.\n//높이 점프합니다.\n//Turn 할 줄 모르지롱. 레벨 올려오셈\n\n//****** 고급자 레벨입니다. ******\n//엄청 빨리 달립니다.\n//아주 높이 점프합니다.\n//아주 높이 점프합니다.\n//아주 높이 점프합니다.\n//한 바퀴 돕니다.\n```\n\n- 당연히, 이번 실습에서도 다형성이 사용됨을 확인 가능\n\n- Player가 가질 수 있는 여러 레벨을 **PlayerLevel**로 관리함\n\n- 레벨 변경하는 upgradeLevel() 메서드의 매개변수 자료형도 **PlayerLevel**\n\n- **하나의 코드가 다양한 자료형을 대상으로 동작하는 다형성을 활용한 것**\n\n\u003chr\u003e\n\n## final 예약어\n\n\u003cbr\u003e\n\n| 사용 위치 | 설명 |\n| :-------: | :----------------------------------------: |\n| 변수 | final 변수는 상수를 의미 |\n| 메서드 | final 메서드는 하위 클래스에서 재정의 불가 |\n| 클래스 | final 클래스는 상속할 수 없음 |\n  \n\u003cbr\u003e\n\n### final 변수\n\n\u003cbr\u003e\n\n```java\npackage chapter09.finalex;\n\npublic class Constant {\n\tint num = 10;\n\tfinal int NUM = 100;\n\t  \n\tpublic static void main(String[] args) {\n\t\tConstant cons = new Constant();\n\t\tcons.num = 50;\n\t\tcons.NUM = 200;\n\t\t  \n\t\tSystem.out.println(cons.num);\n\t\tSystem.out.println(cons.NUM);\n\t}\n}  \n\n// 오류\n```\n\n- 변수 이름은 소문자와 대문자 구분해서 `num`이랑 `NUM`은 다른거임\n\n- `final`로 선언한 `NUM`에 값을 넣으려고 하면 오류 발생\n\n\u003cbr\u003e\u003cbr\u003e\n\n**여러 자바 파일에서 공유하는 상수 값 정의**\n\n- 하나의 자바 파일에서만 사용하는 상수 값은 그냥 파일 안에서 final 정의하고 쓰면 됨\n\n- ex) 최솟값(MIN), 최댓값(MAX), 과목 코드 값 등 이런 값들은 여러 파일에서 공유하면서 써야하는 상수\n\n- 여러 파일에서 공유하는 상수 값은 **한 파일에 모아 `public static final`로 선언하여 사용하면 좋음**\n\n```java\npackage chapter09.finalex;\n  \npublic class Define {\n\tpublic static final int MIN = 1;\n\tpublic static final int MAX = 99999;\n\tpublic static final int ENG = 1001;\n\tpublic static final int MATH = 2001;\n\tpublic static final double PI = 3.14;\n\tpublic static final String GOOD_MORNING = \"Good Morning!\";\n}\n```\n\n- 상수를 모두 `public` 예약어로 선언해서 외부에서 사용 가능\n\n- 상수를 모두 `static` 예약어로 선언해서 인스턴스 안만들고 클래스 이름으로 참조해서 사용 가능\n\n```java\npackage chapter09.finalex; \n\npublic class UsingDefine {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(Define.GOOD_MORNING);\n\t\tSystem.out.println(\"최솟값은 \" + Define.MIN + \"입니다.\");\n\t\tSystem.out.println(\"최댓값은 \" + Define.MAX + \"입니다.\");\n\t\tSystem.out.println(\"수학 과목 코드 값은 \" + Define.MATH + \"입니다.\");\n\t\tSystem.out.println(\"영어 과목 코드 값은 \" + Define.ENG + \"입니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### final 메서드\n\nfinal 메서드는 위에서 배웠던 하위 클래스에서 재정의 불가능한 \u003ca href='/brain/Book/do-it-java/chap09/#템플릿-메서드'\u003e템플릿 메서드\u003c/a\u003e 참고\n\n\u003cbr\u003e\n\n### final 클래스\n\n클래스를 final로 선언하면 상속 불가능.\n\n- 상속하면 변수나 메서드 재정의할 수 있게되니까 그러면 클래스가 가지고 있는 기능에 오류 생길 수 있음\n\n- 보안과 관련, 기반 클래스가 변하면 안되는 경우 =\u003e final로 선언\n\n- 대표적으로 JDK에서 제공하는 클래스인 문자열을 나타내는 `String 클래스`, 정수 값을 나타내는 `Integer 클래스`가 final로 선언되었음.\n\n\u003cbr\u003e\n\n### 프로그램을 잘 구현하는 또 다른 방법\n\n- 테스트 코드(최종 실행 파일)부터 만들기\n\n위에서는 MainBoard 클래스 -\u003e 각 레벨 클래스 -\u003e PlayerLevel 클래스 -\u003e Player 클래스 순으로 개발했다. 이제는 반대로 MainBoard 클래스부터 구현해보자.\n\n```java\npackage chapter09.gameLevel; \n\npublic class MainBoard {\n\tpublic static void main(String[] args) {\n\t\tPlayer player = new Player(); // 오류 발생\n\t\tplayer.play(1); \n\t\t\n\t\tAdvancedLevel aLevel = new AdvancedLevel();\n\t\tplayer.upgradeLevel(aLevel); // 오류 발생\n\t\tplayer.play(2);\n\t\t\n\t\tSuperLevel sLevel = new SuperLevel();\n\t\tplayer.upgradeLevel(sLevel); // 오류 발생\n\t\tplayer.play(3);\n\t}\n}\n```\n\n- 정의되어있지 않은 클래스를 인스턴스로 생성하려니 많은 오류가 뜰 것\n\n- 이 오류들을 없애기 위하여 **MainBoard.java (테스트 코드)** 가 제대로 실행되게 하나씩 고쳐나가는 것\n\n\u003cbr\u003e\n\n이렇게 테스트 코드를 먼저 개발하는 방법론을 ==테스트 주도 개발(Test Driven Development; TDD)== 라고 한다. 테스트 코드를 만들 수 있다는 것은 이미 구현 코드가 머릿속에 있다는 의미이기도 하다.","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/chap10":{"title":"10.인터페이스","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 10 - 인터페이스\n\n\u003cbr\u003e  \n\n## 인터페이스란?\n\n- 인터페이스(interface) : 모든 메서드가 추상 메서드로만 이루어져있음\n\n\u003cbr\u003e\n\n### 구현 코드가 없는 인터페이스\n\n- 인터페이스는 클래스 혹은 프로그램이 제공하는 기능을 **명시적으로 선언하는 역할**\n\n- 인터페이스는 **추상 메서드와 상수로만 이루어짐**\n\n\u003cbr\u003e\u003cbr\u003e\n\n**인터페이스 만들기**, 인텔리제이는 new - java class에서 interfaces 클릭하면 됨\n\n```java\npackage chapter10.interfaceex;\n  \npublic interface Calc {\n\tdouble PI = 3.14;\n\tint ERROR = -999999999;\n\t  \n\tint add(int num1, int num2);\n\tint substract(int num1, int num2);\n\tint times(int num1, int num2);\n\tint divide(int num1, int num2);\n}\n```\n\n- 파일 생성 시 인터페이스로 생성했기 때문에 `public abstract` 예약어를 명시적으로 쓰지 않아도 컴파일 과정에서 **자동으로 추상메서드로 변환**됨\n\n- 인터페이스에서 **선언한 변수**는 모두 컴파일 과정에서 값이 변하지 않는 **상수로 자동 변환됨**. `public static final` 예약어를 쓰지 않아도 무조건 상수로 인식!\n\n\u003cbr\u003e\n\n### 클래스에서 인터페이스 구현\n  \n클래스에서 인터페이스를 구현한다 (implements) = 인터페이스를 클래스가 사용하는 것\n\n![](brain/image/chap10-1.png)\n\n클래스 다이어그램\n- 점선 : 인터페이스 구현\n- 마름모 : 챕터9에서 했는데 복습하려고, 포함(HAS-A) 관계 의미\n\n\u003cbr\u003e\n\n```java\npackage chapter10.interfaceex;\n\npublic abstract class Calculator implements Calc {\n\t@Override\n\tpublic int add(int num1, int num2) {\n\t\treturn num1 + num2;\n\t}\n\t  \n\t@Override\n\tpublic int substract(int num1, int num2) {\n\t\treturn num1 - num2;\n\t}\n}\n```\n\n생각해보면, 인터페이스 자체가 추상 메서드만으로 이루어져있으니, 그걸 `implements`하면 클래스인 Calculator는 추상 메서드 4개를 포함하는 상태이니까 이걸 구현하지 않으면 Calculator 클래스도 추상 클래스가 되는 것. **추상 메서드 4개 다 구현하던가~** 혹은 **추상 클래스로 만들던가~**\n\n여기서는 add하고 substract만 구현했으니까 abstract class로 만든 것\n\n\u003cbr\u003e\n\n![](brain/image/chap10-2.png)\n\n\u003cbr\u003e\n\n```java\npackage chapter10.interfaceex;\n\npublic class CompleteCalc extends Calculator {\n\t@Override\n\tpublic int times(int num1, int num2) {\n\t\treturn num1 * num2;\n\t}\n\t\n\t@Override\n\tpublic int divide(int num1, int num2) {\n\t\tif (num2 != 0) {\n\t\t\treturn num1 / num2;\n\t\t} else {\n\t\t\treturn Calc.ERROR;\n\t\t}\n\t}\n\t\n\tpublic void showInfo() {\n\t\tSystem.out.println(\"Calc 인터페이스를 구현하였습니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e  \n\n```java\npackage chapter10.interfaceex;\n\npublic class CalculatorTest {\n\tpublic static void main(String[] args) {\n\t\tint num1 = 10;\n\t\tint num2 = 5;\n\t\t  \n\t\tCompleteCalc calc = new CompleteCalc();\n\t\tSystem.out.println(calc.add(num1, num2));\n\t\tSystem.out.println(calc.substract(num1, num2));\n\t\tSystem.out.println(calc.times(num1, num2));\n\t\tSystem.out.println(calc.divide(num1, num2));\n\t\tcalc.showInfo();\n\t}\n}\n```\n\n- Calculator 클래스는 추상 클래스 =\u003e 인스턴스 생성 불가\n\n- 그래서 CompleteCalc를 인스턴스 생성한거임\n\n\u003cbr\u003e\n\n### 인터페이스 구현과 형 변환\n\n\u003cbr\u003e\n\n```java\n// 이렇게 가능\nCalc calc = new CompleteCalc();\n```\n\n- 인터페이스도 마찬가지로 하위 클래스 =\u003e 상위 클래스로 묵시적 형 변환 가능\n\n- CompleteCalc 클래스는 상위 클래스인 Calculator형이면서 Calc형이기도 함\n\n- 이렇게하면, `showInfo()` 메서드는 CompleteCalc에서 선언한 메서드니까 `showInfo()`메서드 사용 불가능하겠군.\n\n\u003chr\u003e\n\n## 인터페이스와 다형성\n\n### 인터페이스의 역할\n\n자바 8에서 새롭게 추가된 \u003ca href='/brain/Book/do-it-java/chap10/#디폴트-메서드'\u003e디폴트 메서드\u003c/a\u003e, \u003ca href='/brain/Book/do-it-java/chap10/#정적-메서드'\u003e정적 메서드 구현부\u003c/a\u003e가 없다면, 인터페이스는 그야말로 껍데기이다. 메서드 구현부(implementation part)가 없고 메서드 선언부(declaration part)만 있는 인터페이스를 왜 사용할까?\n\n- 인터페이스는 클라이언트 프로그램에 어떤 메서드를 제공하는지 미리 알려주는 **명세(specification) 혹은 약속**의 역할\n\n\u003cbr\u003e\n\n예를 들어, Abc 인터페이스, 이를 구현한 A 클래스, 이 클래스를 사용하는 Z 프로그램이 있다고 하면, **Z 프로그램에서 A 클래스의 구현 코드 전체를 살펴보지 않고 Abc 인터페이스의 선언부만 봐도 이 A 클래스를 어떻게 사용할지 알 수 있는 것**이다.\n\n프로그램에서 클래스를 사용할 때 클래스에서 구현한 내용을 몰라도 **인터페이스에서 선언한 메서드의 매개변수 자료형과 반환 값만 알면** 인터페이스를 구현한 어떤 클래스든 사용할 수 있다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n- 인터페이스의 역할 : 인터페이스를 구현한 클래스가 어떤 기능의 메서드를 제공하는지 명시하는 것\n\n- 클라이언트 프로그램은 인터페이스에서 약속한 명세대로 구현한 클래스를 생성해서 사용하면 됨\n\n\u003cbr\u003e\n\n### 인터페이스와 다형성\n\n- 인터페이스 사용하면 다형성 구현해서 확장성 있는 프로그램 만들 수 있음\n\n- 이는 클라이언트 프로그램을 많이 수정하지 않고 **기능을 추가하거나 다른 기능을 사용할 수 있음**을 의미한다.\n\n\u003e [!note] 예제 시나리오\n\u003e\n\u003e 고객 센터에 전화 상담하는 상담원들이 있음. 센터로 전화가 오면 대기열에 저장됨. 상담원이 지정되기 전까지 대기 상태가 됨. 각 전화를 상담원에게 배분하는 정책은 여러 방식으로 구현 가능\n\u003e - 순서대로 배분\n\u003e - 짧은 대기열 찾아 배분\n\u003e - 우선순위에 따라 배분\n\u003e \u003cbr\u003e\n\u003e 1. 순서대로 배분하기 : 모든 상담원이 동일한 상담 건수를 처리하도록, 들어오는 전화 순서대로 상담원에게 하나씩 배분\n\u003e 2. 짧은 대기열 찾아 배분 : 고객 대기 시간을 줄이기 위해 상담을 하지 않는 상담원이나 가장 짧은 대기열을 보유한 상담원에게 배분\n\u003e 3. 우선순위에 따라 배분 : 고객 등급에 따라 등급이 높은 고객의 전화를 우선 가져와서 업무 능력이 좋은 상담원에게 우선 배분\n\n![](brain/image/chap10-3.png)\n\n\u003cbr\u003e\n\nScheduler 인터페이스를 구현하는 RoundRobin(순서대로), LeastJob(짧은 대기열 먼저), PriorityAllocation(우선순위에 따라) 클래스를 구현\n\n\u003cbr\u003e\n\n**Scheduler 인터페이스**\n\n```java\npackage chapter10.scheduler;\n\npublic interface Scheduler {\n\tpublic void getNextCall();\n\tpublic void sendCallToAgent();\n}\n```\n\n\u003cbr\u003e\n\n**RoundRobin 클래스**\n\n```java\npackage chapter10.scheduler;\n\npublic class RoundRobin implements Scheduler {\n\t@Override\n\tpublic void getNextCall() {\n\t\tSystem.out.println(\"상담 전화를 순서대로 대기열에서 가져옵니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void sendCallToAgent() {\n\t\tSystem.out.println(\"다음 순서 상담원에게 배분합니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**LeastJob 클래스**\n\n```java\npackage chapter10.scheduler;\n\npublic class LeastJob implements Scheduler {\n\t@Override\n\tpublic void getNextCall() {\n\t\tSystem.out.println(\"상담 전화를 순서대로 대기열에서 가져옵니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void sendCallToAgent() {\n\t\tSystem.out.println(\"현재 상담 업무가 없거나 대기가 가장 적은 상담원에게 할당합니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**PriorityAllocation 클래스**\n\n```java\npackage chapter10.scheduler;\n\npublic class PriorityAllocation implements Scheduler {\n\t@Override\n\tpublic void getNextCall() {\n\t\tSystem.out.println(\"고객 등급이 높은 고객의 전화를 먼저 가져옵니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void sendCallToAgent() {\n\t\tSystem.out.println(\"업무 skill 값이 높은 상담원에게 우선적으로 배분합니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**SchedulerTest 클래스**\n\n```java\npackage chapter10.scheduler;\nimport java.io.IOException;\n\npublic class SchedulerTest {\n\tpublic static void main(String[] args) throws IOException {\n\t\tSystem.out.println(\"전화 상담 할당 방식을 선택하세요.\");\n\t\tSystem.out.println(\"R : 한명씩 차례로 할당 \");\n\t\tSystem.out.println(\"L : 쉬고 있거나 대기가 가장 적은 상담원에게 할당 \");\n\t\tSystem.out.println(\"P : 우선순위가 높은 고객 먼저 할당 \");\n\t\t  \n\t\tint ch = System.in.read();\n\t\tScheduler scheduler = null;\n\t\t\n\t\tif(ch == 'R' || ch == 'r') {\n\t\t\tscheduler = new RoundRobin();\n\t\t} else if(ch == 'L' || ch == 'l') {\n\t\t\tscheduler = new LeastJob();\n\t\t} else if(ch == 'P' || ch == 'p') {\n\t\t\tscheduler = new PriorityAllocation();\n\t\t} else {\n\t\t\tSystem.out.println(\"지원되지 않는 기능입니다.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tscheduler.getNextCall();\n\t\tscheduler.sendCallToAgent();\n\t}\n}\n```\n\n- 문자를 입력받는 `System.in.read()`를 사용하려면 IOException에서 오류를 처리해야 한다.\n\n- 마지막에 Scheduler 자료형으로 선언한 scheduler 참조변수를 이용하여, 어떤 클래스를 호출하든가와 상관없이 **인터페이스에 선언한 메서드 호출**\n\n\u003cbr\u003e\n\n### 클라이언트가 클래스를 사용하는 방법\n\n간단하다. 인터페이스를 통해 구현해야 할 메서드를 선언해놨으니까, 약속한 명세대로 클래스를 만들어서 사용하면 된다.\n\n\u003e 예를 들어, 상담 전화 할당 방식이 아닌 상담원이 본인이 필요할 때 가져오는 정책을 추가해보자. getNextCall() 호출되면 \"상담원이 다음 전화 요청\" 출력, sendCallToAgent() 호출되면 \"상담원이 전화를 가져갔습니다\" 출력, 추가된 정책은 A나 a 입력하면 선택되게\n\n\u003cbr\u003e\n\n```java\npackage chapter10.scheduler;\n\npublic class AgentGetCall implements Scheduler {\n\t@Override\n\tpublic void getNextCall() {\n\t\tSystem.out.println(\"상담원이 다음 전화 요청\");\n\t}\n\t\n\t@Override\n\tpublic void sendCallToAgent() {\n\t\tSystem.out.println(\"상담원이 전화 상담을 가져갔습니다.\");\n\t}\n}\n```\n\n\u003chr\u003e\n\n## 인터페이스 요소 살펴보기\n\n### 인터페이스 상수\n\n- 인터페이스는 추상 메서드로 이루어짐, 인스턴스 생성 불가, 멤버 변수 사용 불가\n\n- 하지만, 인터페이스에 아래와 같이 선언해도 오류 발생 X\n\n```java\npublic interface Calc {\n\tdouble PI = 3.14;\n\tint ERROR = -9999999;\n}\n```\n\n- 인터페이스에 선언한 변수를 컴파일하면 상수로 변환되기 때문 !\n\n- 인터페이스의 `PI`를 컴파일하면 `public static final double PI = 3.14` 즉, 상수 3.14로 변환된다. ERROR도 마찬가지로 `public static final`로 변환!\n\n\u003cbr\u003e\n\n### 디폴트 메서드와 정적 메서드\n\n- 자바 7까지는 인터페이스에서 추상 메서드, 상수만 선언 가능했음\n\n\t- 이렇게 하면 불편한 점이 인터페이스에서 코드를 구현할 수 없으므로, **여러 클래스에서 사용할 메서드가 클래스마다 같은 기능을 제공하는 경우, 클래스마다 반복해서 구현해야 했음**\n\n- 자바 8부터는 디폴트 메서드, 정적 메서드 기능 제공\n\n\t- 디폴트 메서드 : 인터페이스에서 구현 코드까지 작성한 메서드, 인터페이스를 구현한 클래스에 기본적으로 제공할 메서드\n\n\t- 정적 메서드 : 인스턴스 생성과 상관없이 사용할 수 있는 메서드\n\n- But, 디폴트 메서드나 정적 메서드가 추가되었다고 해도 인터페이스가 인스턴스를 생성할 수 있는 것은 아님  \n\n\u003cbr\u003e\n\n### 디폴트 메서드\n\n- 기본으로 제공되는 메서드\n\n- 인터페이스에서 디폴트 메서드 구현\n\n- 인터페이스를 구현한 클래스가 생성되면, 그 클래스에서 사용할 기본 기능\n\n- `default` 예악어 사용해서 디폴트 메서드 선언\n\n- 클래스 입장에서 구현이 강제되지 않는다 !\n\n\u003cbr\u003e\n\n**Calc 인터페이스에 코드 추가**\n\n```java\npackage chapter10.interfaceex;\n\npublic interface Calc {\n\tdefault void description() {\n\t\tSystem.out.println(\"정수 계산기를 구현합니다.\");\n\t}\n}\n```\n\n이후, Calculator 클래스, CompleteCalc 클래스에 별다른 코드를 추가 안해도 CalculatorTest 클래스에서 디폴트 메서드 그냥 호출하면 됨\n\n\u003cbr\u003e\n\n**CalculatorTest 클래스**\n\n```java\npackage chapter10.interfaceex;\n  \npublic class CalculatorTest {\n\tpublic static void main(String[] args) {\n\t\tCompleteCalc calc = new CompleteCalc();\n\t\tcalc.description();\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**디폴트 메서드 재정의하기**\n\n- 이미 인터페이스에서 구현된 디폴트 메서드가 **새로 생성한 클래스에서 원하는 기능이 아니라면, 하위 클래스에서 디폴트 메서드를 재정의 가능**\n\n```java\npackage chapter10.interfaceex;\n  \npublic interface Calc {\n\tdefault void description() {\n\t\tSystem.out.println(\"정수 계산기를 구현합니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e  \n\n```java\npackage chapter10.interfaceex;\n\npublic class CompleteCalc extends Calculator {\n\t@Override\n\tpublic void description() {\n\t\tSystem.out.println(\"디폴트 메서드를 재정의\");\n\t}\n}\n```\n\n\u003cbr\u003e \n\n```java\npackage chapter10.interfaceex;\n\npublic class CalculatorTest {\n\tpublic static void main(String[] args) {\n\t\tCompleteCalc calc = new CompleteCalc();\n\t\tcalc.description();\n\t}\n}\n\n// 디폴트 메서드를 재정의\n```\n\n\u003cbr\u003e\n\n### 정적 메서드\n\n- 정적 메서드는 `static` 예약어를 사용하여 선언\n\n- 클래스 생성과 무관하게 사용 가능\n\n- 인터페이스 이름으로 직접 참조하여 사용\n\n- 클래스 입장에서 구현이 강제되지 않는다 !\n\n\u003cbr\u003e\n\n**Calc 인터페이스**\n\n- `total()` : 매개변수로 전달된 배열의 모든 요소 값을 더하는 정적 메서드\n\n```java\npackage chapter10.interfaceex;\n\npublic interface Calc {\n\tstatic int total(int[] arr) {\n\tint total = 0;\n\t\n\tfor (int i : arr) {\n\t\ttotal += i;\n\t}\n\t\n\treturn total;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter10.interfaceex;\n\npublic class CalculatorTest {\n\tpublic static void main(String[] args) {\n\t\tCompleteCalc calc = new CompleteCalc();\n\t\t  \n\t\tint[] arr = {1, 2, 3, 4, 5};\n\t\tSystem.out.println(Calc.total(arr));\n\t}\n}\n\n// 15\n```\n\n- CompleteCalc를 참조한 calc를 쓴 것이 아님\n\n- System.out.println을 보면 **Calc 인터페이스를 직접 참조**했음\n\n\u003cbr\u003e\n\n### private 메서드\n\n- 자바 9부터 인터페이스에 private 메서드 구현 가능\n\n- private 메서드는 인터페이스를 구현한 클래스에서 사용하거나 재정의 불가\n\n기존에 구현된 코드를 변경하지 않고, **인터페이스를 구현한 클래스에서 공통으로 사용하는 경우에 private 메서드로 구현하면 코드 재사용성을 높일 수 있다.**\n\n추가로, 클라이언트 프로그램에 제공할 기본 기능을 private 메서드로 구현하기도 한다.\n\n\u003cbr\u003e\n\n**private 메서드는 코드를 모두 구현**해야 하므로, **추상 메서드에 private 예약어를 사용할 수 없음**. 하지만, **static 예약어는 사용 가능**하다. **private static 메서드는 정적 메서드에서 호출하여 사용**한다.\n\n```java\npackage chapter10.interfaceex;\n\npublic interface Calc {\n\tdefault void description() {\n\t\tSystem.out.println(\"정수 계산기를 구현합니다.\");\n\t\tmyMethod();\n\t}\n\t\n\tstatic int total(int[] arr) {\n\t\tint total = 0;\n\t\t\n\t\tfor (int i : arr) {\n\t\t\ttotal += i;\n\t\t}\n\t\t\n\t\tmyStaticMethod();\n\t\treturn total;\n\t}\n\t\n\tprivate void myMethod() {\n\t\tSystem.out.println(\"private 메서드입니다.\");\n\t}\n\t\n\tprivate static void myStaticMethod() {\n\t\tSystem.out.println(\"private static 메서드입니다.\");\n\t}\n}\n```\n\n- 디폴트 메서드에서 private 메서드 호출\n\n- 정적 메서드에서 private static 메서드 호출\n\n\u003chr\u003e\n\n## 인터페이스 활용\n\n### 한 클래스가 여러 인터페이스를 구현하는 경우\n\n- 한 클래스가 여러 클래스를 상속받으면, 호출이 모호해져서 자바에서는 다중 상속을 막았었음\n\n- 하지만, 인터페이스는 한 클래스가 여러 인터페이스 구현 가능\n\n![](brain/image/chap10-4.png)\n\n**한 클래스에서 인터페이스 여러 개 구현 가능한 이유**\n\n- 인터페이스는 구현 코드나 멤버 변수를 가지지 않음\n\n- 따라서 여러 개 동시에 구현 가능\n\n- 두 인터페이스에 이름이 같은 메서드가 선언되었다고 해도 **구현은 클래스에서 이루어지니까, 어떤 메서드를 호출해야 하는지 모호하지 않은 것!**\n\n- Diamond problem(다이아몬드 문제) 발생 안함!\n\n\u003cbr\u003e\n\n**Buy 인터페이스**\n\n```java\npackage interfaceex;\n\npublic interface Buy {\n\tvoid buy();\n}\n```\n\n\u003cbr\u003e  \n\n**Sell 인터페이스**\n\n```java\npackage interfaceex;\n\npublic interface Sell {\n\tvoid sell();\n}\n```\n\n\u003cbr\u003e  \n\n**Customer 클래스**\n\n```java\npackage chapter10.interfaceex;\n\npublic class Customer implements Buy, Sell {\n\t@Override\n\tpublic void sell() {\n\t\tSystem.out.println(\"판매하기\");\n\t} \n\t\n\t@Override\n\tpublic void buy() {\n\t\tSystem.out.println(\"구매하기\");\n\t}\n}\n```\n\n\u003cbr\u003e  \n\n**CustomerTest 클래스**\n\n```java\npackage chapter10.interfaceex;\n\npublic class CustomerTest {\n\tpublic static void main(String[] args) {\n\t\tCustomer customer = new Customer();\n\t\t\n\t\tBuy buyer = customer;\n\t\tbuyer.buy();\n\t\t\n\t\tSell seller = customer;\n\t\tseller.sell();\n\t\t\n\t\tif (seller instanceof Customer) {\n\t\t\tCustomer customer2 = (Customer) seller;\n\t\t\tcustomer2.buy();\n\t\t\tcustomer2.sell();\n\t\t}\n\t}\n}\n\n// 구매하기\n// 판매하기\n// 구매하기\n// 판매하기\n```\n\n- 두 인터페이스를 구현한 Customer 클래스는 Buy형이자, Sell형\n\n- `Buy buyer = customer;`는 customer를 Buy 인터페이스형 변수에 대입하여 형 변환 일어남. 따라서, Buy 인터페이스에 선언한 메서드만 호출 가능\n\n- 상속에서처럼 원래의 인스턴스 자료형으로 다운 캐스팅 하려면 **instanceof** 사용\n\n\u003cbr\u003e\n\n### 두 인터페이스의 정적 메서드가 중복되는 경우\n\n- 정적 메서드는 인스턴스 생성과 상관없이 사용 가능\n\n- Buy 인터페이스, Sell 인터페이스 각각에 `pay()` 정적 메서드가 있다고 가정\n\n- 인스턴스 생성 없이 `Buy.pay()`, `Sell.pay()`와 같이 특정해서 호출하기 때문에 정적 메서드는 중복되어도 상관없음\n\n\u003cbr\u003e\n\n### 두 인터페이스의 디폴트 메서드가 중복되는 경우\n\n- 디폴트 메서드는 인스턴스를 생성해야 호출할 수 있는 메서드\n\n- 이름이 같은 디폴트 메서드가 두 인터페이스에 있으면 문제가 됨\n\n- Diamond problem(다이아몬드 문제) 발생!\n\n\u003cbr\u003e\n\n**Buy 인터페이스**\n\n```java\npackage interfaceex;\n\npublic interface Buy {\n\tvoid buy();\n\t\n\tdefault void order() {\n\t\tSystem.out.println(\"구매 주문\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**Sell 인터페이스**\n\n```java\npackage interfaceex;\n\npublic interface Sell {\n\tvoid sell();\n\t\n\tdefault void order() {\n\t\tSystem.out.println(\"판매 주문\");\n\t}\n}\n```\n\n- Buy, Sell 인터페이스 중 `어떤 디폴트 메서드 order()`를 불러올 지 모호해진다.\n\n- 따라서, 이를 구현한 Customer 클래스에서 `order()`를 재정의하면 재정의된 메서드가 호출되어서 문제가 해결된다.\n\n\u003cbr\u003e  \n\n```java\npackage interfaceex;\n\npublic class Customer implements Buy, Sell {\n\tpublic void order() {\n\t\tSystem.out.println(\"고객 판매 주문\");\n\t}\n}\n```\n\n\u003cbr\u003e  \n\n```java\npackage chapter10.interfaceex;\n\npublic class CustomerTest {\n\tpublic static void main(String[] args) {\n\t\tCustomer customer = new Customer();\n\t\t\n\t\tBuy buyer = customer;\n\t\tbuyer.buy();\n\t\tbuyer.order();\n\t\t\n\t\tSell seller = customer;\n\t\tseller.sell();\n\t\tseller.order();\n\t\t  \n\t\tif (seller instanceof Customer) {\n\t\t\tCustomer customer2 = (Customer) seller;\n\t\t\tcustomer2.buy();\n\t\t\tcustomer2.sell();\n\t\t}\n\t\tcustomer.order();\n\t}\n}\n\n// 구매하기\n// 고객 판매 주문\n// 판매하기\n// 고객 판매 주문\n// 구매하기\n// 판매하기\n// 고객 판매 주문\n```\n\n- `buyer.order()` 혹은 `seller.order()`를 해도 Customer 클래스에 재정의된 메서드가 호출된다. \u003ca href='/brain/Book/do-it-java/chap08/'\u003e상속과 다형성\u003c/a\u003e에서 배웠던 **가상 메서드** 원리 안까먹었지!?\n\n\u003cbr\u003e\n\n### 인터페이스 상속하기\n\n- 인터페이스 간에도 상속 가능\n\n- 인터페이스 간 상속은 구현 코드를 통해 **기능을 상속하는 것이 아니**므로, **형 상속(type inheritance)** 라고 부른다.\n\n- 클래스의 경우 - 하나의 클래스만 상속\n\n- 인터페이스의 경우 - 여러 인터페이스 동시에 상속 가능\n\n- **상속받은 인터페이스는 상위 인터페이스에 선언한 추상 메서드 모두 가지게 됨**\n\n\u003cbr\u003e\n\n![](brain/image/chap10-5.png)\n\n- Myinterface 인터페이스는 X, Y 인터페이스 상속 받음\n\n- MyClass는 MyInterface 인터페이스를 구현\n\n- MyClass가 구현애햐 하는 추상 메서드는 총 3개\n\n\u003cbr\u003e\n\n**X 인터페이스**\n\n```java\npackage chapter10.interfaceex;\n\npublic interface X {\n\tvoid x();\n}\n```\n\n\u003cbr\u003e\n\n**Y 인터페이스**\n\n```java\npackage chapter10.interfaceex;\n\npublic interface Y {\n\tvoid y();\n}\n```\n\n\u003cbr\u003e\n\n**MyInterface 인터페이스**\n\n```java\npackage chapter10.interfaceex;\n\npublic interface MyInterface extends X, Y {\n\tvoid myMethod();\n}\n```\n\n\u003cbr\u003e\n\n**MyClass 클래스**\n\n```java\npackage chapter10.interfaceex;\n\npublic class MyClass implements MyInterface {\n\t@Override\n\tpublic void x() {\n\t\tSystem.out.println(\"x()\");\n\t}\n\t\n\t@Override\n\tpublic void y() {\n\t\tSystem.out.println(\"y()\");\n\t}\n\t\n\t@Override\n\tpublic void myMethod() {\n\t\tSystem.out.println(\"myMethod()\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**MyClassTest 클래스**\n \n```java\npackage chapter10.interfaceex;\n\npublic class MyClassTest {\n\tpublic static void main(String[] args) {\n\t\tMyClass mClass = new MyClass();\n\t\t\n\t\tX xClass = mClass;\n\t\txClass.x();\n\t\t\n\t\tY yClass = mClass;\n\t\tyClass.y();\n\t\t\n\t\tMyInterface iClass = mClass;\n\t\tiClass.myMethod();\n\t\tiClass.x();\n\t\tiClass.y();\n\t}\n}\n\n// x()\n// y()\n// myMethod()\n// x()\n// y()\n```\n\n- 생성한 클래스는 상위 인터페이스형으로 변환 가능\n\n- 상위 인터페이스로 형 변환 하면 **상위 인터페이스에 선언한 메서드만 호출 가능**\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n- 인터페이스 간 상속은, **인터페이스를 정의할 때 기능상 계층 구조가 필요한 경우에 상속을 사용하기도 함**\n\n\u003cbr\u003e\n\n### 인터페이스 구현과 클래스 상속 함께 쓰기\n\n- 한 클래스에서 클래스 상속, 인터페이스 구현 모두 가능\n\n![](brain/image/chap10-6.png)\n\n\u003cbr\u003e\n\n**Shelf 클래스**\n\n```java\npackage chapter10.bookshelf;\nimport java.util.ArrayList;\n\npublic class Shelf {\n\tprotected ArrayList\u003cString\u003e shelf;\n\t\n\tpublic Shelf() {\n\t\tshelf = new ArrayList\u003cString\u003e();\n\t}\n\t\n\tpublic ArrayList\u003cString\u003e getShelf() {\n\t\treturn shelf;\n\t}\n\t\n\tpublic int getCount() {\n\t\treturn shelf.size();\n\t}\n}\n```\n\n- 자료를 순서대로 저장할 배열 객체 선언 (이름을 저장하게 자료형은 String)\n\n- 디폴트 생성자로 Shelf 클래스 생성 시 ArrayList 생성\n\n\u003cbr\u003e\n\n**Queue 인터페이스**\n\n```java\npackage chapter10.bookshelf;\n\npublic interface Queue {\n\tvoid enQueue(String title); // 배열의 맨 마지막에 추가\n\tString deQueue(); // 배열의 맨 처음 항목 반환\n\tint getSize(); // 현재 Queue에 있는 개수 반환\n}\n```\n\n![](brain/image/chap10-7.png)\n\n\u003cbr\u003e\n\n**BookShelf 클래스**\n\n```java\npackage chapter10.bookshelf;\n\npublic class BookShelf extends Shelf implements Queue {\n\t@Override\n\tpublic void enQueue(String title) {\n\t\tshelf.add(title);\n\t}\n\t\n\t@Override\n\tpublic String deQueue() {\n\t\treturn shelf.remove(0);\n\t}\n\t\n\t@Override\n\tpublic int getSize() {\n\t\treturn getCount();\n\t}\n}\n```\n\n- `enQueue()` : 배열에 요소 추가\n\n- `deQueue()` : 맨 처음 요소 배열에서 삭제하고 반환\n\n- `getSize()` : 배열 요소 개수 반환\n\n\u003cbr\u003e\n\n**BookShelfTest 클래스**\n\n```java\npackage chapter10.bookshelf;\n\npublic class BookShelfTest {\n\tpublic static void main(String[] args) {\n\t\tQueue shelfQueue = new BookShelf();\n\t\tshelfQueue.enQueue(\"태백산맥 1\");\n\t\tshelfQueue.enQueue(\"태백산맥 2\");\n\t\tshelfQueue.enQueue(\"태백산맥 3\");\n\t\t  \n\t\tSystem.out.println(shelfQueue.deQueue());\n\t\tSystem.out.println(shelfQueue.deQueue());\n\t\tSystem.out.println(shelfQueue.deQueue());\n\t}\n}\n\n// 태백산맥 1\n// 태백산맥 2\n// 태백산맥 3\n```\n\n\u003cbr\u003e\n\n### 실무에서 인터페이스를 사용하는 경우\n\n- 인터페이스는 클래스가 제공할 기능을 선언하고 설계하는 것\n\n- 여러 클래스가 같은 메서드를 서로 다르게 구현하는 경우\n\n- 우선, 인터페이스에 메서드 선언\n\n- 다음, 인터페이스를 구현한 각 클래스에서 같은 메서드에 대해 다양한 기능 구현\n\n- 이것이 인터페이스를 이용한 다형성의 구현\n\n\u003cbr\u003e\n\n예를 들어, SI 회사에서 시스템 개발했음. 이 시스템이 자료 저장할 때 DB 사용하는데 회사마다 MySQL, 오라클 DB, MS-SQL 이런식으로 DB가 제각각이라고 하자. 단, 웹 페이지나 모바일 페이지는 DB와 관계없이 수행 된다.\n\n이런 경우 **데이터베이스 기능을 수행할 인터페이스를 정의**. 그리고 인터페이스 정의에 맞게 여러 데이터베이스 관련 모듈을 개발하면 됨.\n\n\u003cbr\u003e\n\n![](brain/image/chap10-8.png)\n\n- 사용자 정보를 DB에 입력, 업데이트, 삭제하는 기능을 UserInfoDao 인터페이스에서 정의\n\n- 여러 DB에 맞게 구현하는 것은 각 클래스가 담당\n\n\u003cbr\u003e\n\n**JDBC와 인터페이스**\n\n- JDBC는 Java DataBase Connectivity\n\n- 자바와 데이터베이스를 연결해 주는 역할\n\n- 자바와 데이터베이스를 연결하려면 여러 기능 수행해야함. 그 중 대표적인 것이 **Connection을 생성하고 연결**하는 것\n\n- 자바에서 DB를 어떻게 사용할 것인지를 기술한 명세, 즉, 약속\n\n\u003cbr\u003e\n\n**Connection** : 자바와 DB를 연결하기 위해 사용하는 인터페이스\n\n- 여기에 여러 메서드들이 미리 구현되어 있음","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/do-it-java/do-it-java":{"title":"Do it! 자바 프로그래밍 입문","content":"\n\u003cbr\u003e\n\n\u003e [!note] Do it! 자바 프로그래밍 입문 필기노트\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2022.10.25 ~ 2022.11.03\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e Java에 대한 기초 지식 확보\n\n\u003cbr\u003e\n\n\u003cimg class=\"book\" src=\"http://image.yes24.com/goods/62281686/XL\"\u003e\n\n## 목차\n\n- [Chapter01 - 자바 프로그래밍](brain/Book/do-it-java/chap01)\n- [Chapter02 - 변수와 자료형](brain/Book/do-it-java/chap02)\n- [Chapter03 - 여러가지 연산자](brain/Book/do-it-java/chap03)\n- [Chapter04 - 제어문](brain/Book/do-it-java/chap04)\n- [Chapter05 - 클래스와 객체 (1)](brain/Book/do-it-java/chap05)\n- [Chapter06 - 클래스와 객체 (2)](brain/Book/do-it-java/chap06)\n- [Chapter07 - 배열과 ArrayList](brain/Book/do-it-java/chap07)\n- [Chapter08 - 상속과 다형성](brain/Book/do-it-java/chap08)\n- [Chapter09 - 추상클래스](brain/Book/do-it-java/chap09)\n- [Chapter10 - 인터페이스](brain/Book/do-it-java/chap10)\n\n\n","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/java-jungseok/":{"title":"Java의 정석","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Book/java-jungseok/java-jungseok":{"title":"자바의 정석","content":"\n\u003cbr\u003e\n\n\u003e [!note] 자바의 정석 필기노트\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2023.02.23 ~ 진행중\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e Java에 대한 구체적인 학습\n\n## 목차\n\n  \n\n**메소드(method) 영역**\n\n메소드(method) 영역은 자바 프로그램에서 사용되는 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역입니다.\n\nJVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일(\\*.class)를 읽어들여, 해당 클래스에 대한 정보를 메소드 영역에 저장합니다.\n\n\u003cbr\u003e\n\n**힙(heap) 영역**\n\n힙(heap) 영역은 자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역입니다.\n\nJVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장합니다. 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.\n\n\u003cbr\u003e\n\n**스택(stack) 영역**\n\n스택(stack) 영역은 자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역입니다.\n\nJVM은 자바 프로그램에서 메소드가 호출되면, 메소드의 호출과 관계되는 지역 변수와 매개변수를 스택 영역에 저장합니다. 이렇게 스택 영역은 메소드의 호출과 함께 할당되며, 메소드의 호출이 완료되면 소멸합니다. 이렇게 스택 영역에 저장되는 메소드의 호출 정보를 스택 프레임(stack frame)이라고 합니다.\n\n스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다. 이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다. 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.\n구체적으로 이해를 위한 값을 추정하기 위해서는 구체적으로 이것을 잘 모르겠습니","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/":{"title":"Computer Science","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/Algo/":{"title":"Algorithm","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/CA/":{"title":"Computer Architecture","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/CA/ComputerArchitecture":{"title":"컴퓨터구조","content":"\n==**컴퓨터구조(Computer Architecture)는 하드웨어를 구성하는 각 장치의 특성과 동작 원리를 다루는 학문이다.**==\n\n- **Computer architecture = Instruction set architecture ([ISA](brain/CS/CA/ISA) ) + Machine organization**\n\t- ISA는 machine이 사용하는 언어이다. 굉장히 low-level language이며, 하드웨어를 제어하기 위한 언어이다.\n\t- 즉, 컴퓨터 구조는 실제 하드웨어와 그것을 제어하기 위한 언어\n\n![](brain/image/ComputerArchitecture-1.png)\n\n\u003cbr\u003e\n\n예전에는 규모가 큰 컴퓨터에서 보드 형태였다면, 지금은 **One-Chip 형태로 바뀌어가고 있다.** \n\n![](brain/image/ComputerArchitecture-2.png)\n","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/CA/CpuArchitecture":{"title":"CPU 아키텍처","content":"\n==**CPU architecture(또는 Micro architecture)는 CPU나 GPU 같은 하드웨어가 작동하는 방식을 서술한 일종의 컴퓨터 설계도이다.**== \n\n사실, 마이크로아키텍처라는 용어가 더 자주 사용되며, 대표적으로 **CISC(Complex Instruction Set Computer) 방식과 RISC(Reduced Instruction Set Computer) 방식이 존재한다.**","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/CA/ISA":{"title":"ISA","content":"\n==**ISA(Instruction Set Architecture, 명령어 집합 구조)는 마이크로프로세서가 인식해서 기능을 이해하고 실행할 수 있는 기계어 명령어를 의미한다.**== 즉, 이는 하드웨어와 소프트웨어 사이의 **Interface를 정의**하는 것이다.\n- ISA는 소프트웨어 관점에서 굉장히 중요한 하드웨어 추상화를 진행한다.\n- ISA는 하드웨어를 프로그래밍한다. 가장 밑단에 있는 언어이다.\n- 장점 : HW가 바뀌더라도 architecture가 동일하면, ISA는 변하지 않는다.\n\t- ( ISA가 변하지 않는다 = SW가 변할 필요 없다. )\n- 단점 : ISA는 SW/HW 양쪽 모두 영향을 받아서 쉽게 바꾸지 못한다.\n- 예시 : IA-32, PowerPC, MIPS, SPARC, ARM 등\n\u003cbr\u003e\n\n![](brain/image/ISA-1.png)\n\n\u003cbr\u003e\n\nISA를 설계하는 것은 아주 중요하다. 왜냐하면, **ISA에 따라 마이크로프로세서의 성능이 정해지기 때문이다.** 하드웨어가 얼마나 잘 설계되었는지 보다는 ISA가 얼마나 잘 설계되었는지가 훨씬 중요하다. 하드웨어는 마음대로 바꿀 수 있지만, ISA는 한번 정해지면 쉽게 바꾸지 못하기 때문이다. 이것이 바로 ISA를 잘 설계해야하는 궁극적인 목표이다.\n\nISA는 굉장히 다양한데, 예를 들어, Intel, AMD 프로세서를 사용하는 아키텍처는 **x86 ISA를 가지고 있다**라고 한다. 스마트폰에 쓰이는 것으로 **ARM ISA**가 있다. x86과 ARM은 서로 다른 ISA이다. 그래서 데스크탑의 application이 있고 모바일 전용 application이 있는데 호환이 안되는 것은 **애초에 Interface가 다르니 말이 통하지 않는 것**이다.\n\nISA를 ==**물리적으로 구현하는 방법을 마이크로 아키텍쳐**==라고 하는데, 같은 ISA를 서로 다른 마이크로 아키텍쳐로 구현하기도 한다. 그래서 Intel과 AMD가 x86 ISA를 사용함에도 다른 성능을 내는 이유는 **ISA를 구현하는 방법이 다르기 때문**이다.\n\n마이크로 아키텍처는 마이크로 프로세서가 사용하는 명령어 처리 방식인데, 마이크로 프로세서를 우리가 흔히 아는 CPU라고 이해하면 된다. 과거와 비교하였을 때, 상대적으로 작아져서 micro가 붙은 것이다. 따라서, micro architecture 역시 [CPU architecture](brain/CS/CA/CpuArchitecture)의 맥락으로 이해하면 편하다. 미리 말하자면, 대표적으로 CISC(Complex Instruction Set Computer)와 RISC(Reduced Instruction Set Computer) 방식이 있다.","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/DS/":{"title":"Data Structure","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/":{"title":"Language Theory","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/BNF":{"title":"BNF","content":"\n\u003cbr\u003e\n\n==**BNF(Backus-Naur Form)는 프로그래밍 언어 Algol(알골)의 구문을 정의하기 위해 배커스와 나우어가 사용한 표현법이다.**== 구문(syntax) 형식을 정의하는 가장 보편적인 표기법이다.\n\n\u003cbr\u003e\n\n| **메타기호** |      **의미**       |\n|:------------:|:-------------------:|\n|    `::==`    |        정의         |\n|     `\\|`      |      택일(OR)       |\n|    `\u003c \u003e`     | 비단말(nonterminal) | \n\n\u003cbr\u003e\n\nBNF에서 규칙은 메타 기호(`::==`)를 이용하여 표현한다.\n\n- 생성 규칙\n\t- 생성 규칙의 왼쪽 : 정의될 대상\n\t- 생성 규칙의 오른쪽 : 그 대상에 대한 정의\n\n메타 기호의 왼쪽에는 하나의 비단말 기호가, 오른쪽에는 기호들을 활용하여 정의하는 내용이 나오는 것이다. 참고로, 꺽쇠가 없는 것은 단말(terminal)이다.\n\n\u003cbr\u003e\n\n|  **기호**   |              **의미**               |                  **예시**                   |\n|:-----------:|:-----------------------------------:|:-------------------------------------------:|\n|  단말 기호  | 비단말 기호 및 메타기호가 아닌 기호 |   A, B, a, b, 0, 1, if, then, +, -, 등등    |\n| 비단말 기호 |     메타 기호 `\u003c \u003e`로 묶인 기호     | `\u003cidentifier\u003e`, `\u003cletter\u003e`, `\u003cdigit\u003e`, 등등 | \n\n\u003cbr\u003e\n\n- 사용 예시\n```\n\u003cif문\u003e ::= if \u003c논리식\u003e then \u003c문장\u003e else \u003c문장\u003e | if \u003c논리식\u003e then \u003c문장\u003e\n```\n\u003cbr\u003e\n\n```\n\u003cidentifier\u003e ::= \u003cletter\u003e | \u003cidentifier\u003e\u003cletter\u003e | \u003cidentifier\u003e\u003cdigit\u003e  \n\u003cletter\u003e ::= A | B | C | ... | X | Y | Z | a | b | ... | z |  \n\u003cdigit\u003e ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n```\n\n\u003cbr\u003e\n\n한 표현이 BNF에 의해 작성될 수 있는지 여부를 나타내는 것이 [파스 트리 (parse tree)](brain/CS/LT/ParseTree)이다. 참고로 BNF를 확장한 것은 [EBNF](brain/CS/LT/EBNF)이다.","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/Compile":{"title":"컴파일","content":"\n\u003cbr\u003e\n\n==**컴파일(Compile)**==은 인간이 이해할 수 있는 언어로 작성된 소스코드를 컴퓨터가 이해할 수 있는 기계어로 번역(변환)하는 작업을 의미한다. C, Java 등으로 작성된 소스코드를 전기 신호인 0, 1로 바꿔주는 과정이라고 이해하자. [컴파일러(Compiler)](brain/CS/LT/Compiler)는 컴파일 과정을 수행하는 프로그램이다. \n\n![](brain/image/Compile-1.png)\n\n컴파일 과정은 왜 반드시 필요할까?\n\n간단히 말하면, 인간이 작성한 언어를 컴퓨터가 이해하도록 변환해주는 것이지만, 상세하게 보면 컴퓨터를 이용하는 사용자들의 컴퓨터는 동일하지 않다. 프로그래밍 언어의 고급 언어는 약속된 문법을 사용하기 때문에 맥북인 내 컴퓨터로 C언어를 작성하든, 윈도우인 다른 사람의 컴퓨터로 C언어를 작성하든 C언어의 문법을 사용해서 application을 작성할 것이다.\n\n**그러나, 운영체제가 다르면[ ISA(Instruction Set Architecture)](brain/CS/CA/ISA)도 다르고 컴퓨터가 작동하는 원리에 차이가 있을 수 밖에 없다.** 같은 윈도우라도 window 7, window 10과 같이 사용자의 컴퓨터들은 차이점이 반드시 존재한다. 컴퓨터 내부의 CPU, RAM 등 모든 부품에도 차이가 있기 때문에 **사용자의 환경에 맞는 적절한 전기 신호를 보내야 하는데 인간이 작성한 고급 언어만 보고는 그런 작업을 할 수 없다.** 컴파일 과정을 통해 각자의 환경에 맞는 어셈블리어로 변환하고 기계어로 변환해야 하는 것이다.\n\n\u003cbr\u003e\n\n대략적인 컴파일 과정은 아래와 같다.\n\n1. High Level Language로 프로그램을 만듦\n\t- source code (소스코드) 생성\n2. High Level Language -\u003e Assembly Language로 컴파일\n\t- 어셈블리 언어는 하드웨어가 어떤 ISA를 사용하느냐에 따라 다름\n3. Assembler를 이용하여 Assembly Language -\u003e Machine language\n\t- object code (목적코드) 생성\n4. Linker object 관계 연결\n\t- out (리눅스), exe (윈도우) 같은 실행파일 생성\n5. Loader에 올라가고 메모리에 들어간 이후 코드를 읽어 실행\n\n\u003cbr\u003e\n\n\u003e [!note] 그렇다면, 인터프리터는? \u003cbr\u003e\n\u003e Python 같은 [인터프리터](brain/CS/LT/Interpreter)는 2, 3, 4, 5의 과정을 **프로그램을 실행시키면서 진행하기 때문에, 느리지만 호환성 걱정이 없다.**\n\n\n\u003cbr\u003e\n\n아래의 그림은 C언어에서의 컴파일 과정이다.\n\n![](brain/image/Compile-2.png)\n\nC에서의 컴파일 과정은 **4가지 단계(전처리 과정 - 컴파일 과정 - 어셈블리 과정 - 링킹 과정)** 로 나누어 진다. 이 4가지 단계를 묶어서 컴파일 과정, 빌드 과정이라고 부르기도 하고 컴파일 과정과 링킹 과정을 따로 나눠서 부르기도 한다. 보통 빌드 과정은 컴파일 과정보다 넓은 의미(`빌드=컴파일+링킹`)로 사용되는데 상황에 맞게 이해하면 될 거 같다.\n\n- 전처리기(preprocessor) : 원시 프로그램을 번역하기 전에 프로그램 내에 포함되어 있는 특별한 지시어를 먼저 해독해주는 번역 프로그램, 전처리기로 처리된 **소스 프로그램**은 컴파일러에 의해 **목적 프로그램**으로 변환됨\n\n- 링커 : 목적 프로그램에 라이브러리로부터 꺼낸 표준함수와 사용자 함수를 연결해서 실행 가능한 프로그램을 생성한다.\n\n- test라는 소스 코드를 C언어로 작성했다고 하면, `test.c`, `test.obj`, `test.exe` 총 3개의 파일이 만들어진다.\n\nC언어에서 컴파일에 관한 자세한 내용은 \u003ca href='https://bradbury.tistory.com/226' target='_blank'\u003e링크\u003c/a\u003e를 참고하자.","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/Compiler":{"title":"컴파일러","content":"\u003cbr\u003e\n\n==**컴파일러(Compiler)는 컴파일 과정을 수행하는 프로그램이다.**==\n- 소스 코드 전체를 목적 코드로 번역하고 그 결과를 한 번에 실행\n- 번역과 실행 작업이 따로 진행된다. 번역의 과정은 오래 걸리지만, 실행의 과정은 빠르다.\n- 실행 프로그램이 따로 생성된다.\n\n\u003cbr\u003e\n\n|           | **컴파일러(Compiler)** | **인터프리터(Interpreter)**          |\n| :---------: | :----------------------: | :------------------------------------: |\n| 번역 단위 | 전체                   | 한 줄 마다                           |\n| 실행 속도 | 빠름                   | 느림                                 |\n| 번역 속도 | 느림                   | 빠름                                 |\n| 목적 코드 | 생성 O                 | 생성 X                               |\n| 예시      | C, C++, Java Compiler  | Python, JavaScript, Java Interpreter | \n\n\u003cbr\u003e\n\n자바에서의 컴파일러에 관한 이야기는 [여기](brain/Java/JavaExecute)를 참고하자.\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Compiler Structure\n\n![](brain/image/Compiler-1.png)\n\n- Front-End : 언어에 의존하고 기계에 독립적인 부분\n- Back-End : 언어에 독립적이고 기계에 의존하는 부분\n\n\u003cbr\u003e\n\n![](brain/image/Compiler-2.png)\n\n1. ==**Lexical Analyzer (Scanner)**==\n\t- 컴파일러 내부에서 효율적이며 다루기 쉬운 정수로 바꿔 줌\n\t- source programs -\u003e **Lexical Analyzer** -\u003e A sequence of tokens\n\t- 대표적인 토큰 분석기로 [Lex](brain/CS/LT/Lex)가 있음\n\t- 예를 들어, `if (a \u003e 10)`이 있다고 하면, `if`, `(`, `a`, `\u003e`, `10`, `)` 6개의 토큰이 생성되는 것\n\n2. ==**Syntax Analyzer (Parser)**==\n\t- 구문(Syntax) 체크, 트리 생성\n\t- A sequence of tokens -\u003e **Syntax Analyzer** -\u003e Error message of syntactic structure\n\t- 대표적인 구문 분석기로[Yacc](brain/CS/LT/Yacc)가 있음\n\t- 출력\n\t\t- incorrect : error message 출력\n\t\t- correct : program structure (tree 형태) 출력\n\n![](brain/image/Compiler-3.png)\n\n3. ==**Intermidate Code Generator**==\n\t- 의미(Semantic) 체킹\n\t- ex) `if (a \u003e 10) a = 1.0` =\u003e a가 정수일 때 semantic error\n\t- ex) `a = b + 1;`\n\n![](brain/image/Compiler-4.png)\n\n4. ==**Code Optimizer**==\n\t- optional phase (선택적 단계)\n\t- 비효율적인 code를 구분해내서 더 효율적인 code로 바꿔준다.\n\t- Meaning of optimization (최적화)\n\t\t- major part : improve running time\n\t\t- minor part : reduce code size\n\t\t- ex) `LDC R1, 1`,  `LDC R1, 1` load가 중복되니까 하나 없애기\n\t- Criteria for optimization (최적화의 기준)\n\t\t- 프로그램 의미 보존\n\t\t- 평균 속도 상승\n\t\t- 노력할 가치가 있는 경우\n\t- Local optimization : local inspection을 통하여 비효율적인 code들을 구분해 내서 더 효율적인 code로 바꾸는 방법\n\t\t1. Constant folding (컴파일 시간 상수 연산)\n\t\t2. Eliminating redundant load, store instructions\n\t\t3. Algebraic simplification\n\t\t4. Strength reduction\n\t- Global optimization : flow analysis technique 이용\n\t\t1. Common subexpression (공통 부분식)\n\t\t2. Moving loop invariants\n\t\t3. Removing unreachable codes\n\n5. ==**Target Code Generator**==\n\t- 중간 코드로부터 machine instruction을 생성\n\t- Intermediate Code -\u003e **Target Code Generator** -\u003e Target Code\n\t- Code generator tasks\n\t\t1. instruction selection \u0026 generation\n\t\t2. register management\n\t\t3. storage allocation\n\t\t4. code optimization (Machine-dependent optimization)\n\n6. ==**Error Recovery**==\n\t- Error recovery : error가 다른 문장에 영향을 미치지 않도록 수정하는 것\n\t- Error repair : error가 발생하며 복구해 주는 것\n\t- Error Handling\n\t\t- Error detection\n\t\t- Error recovery\n\t\t- Error reporting\n\t\t- Error repair\n\t- Error\n\t\t- Syntax Error\n\t\t- Semantic Error\n\t\t- Run-time Error\n\n\u003cbr\u003e\n\n**추가사항**\n\n- Single Pass Compiler\n\t- 초창기의 컴파일러\n\t- 컴파일 속도 빠름\n- Multi-pass Compiler\n\t- 부분적인 기능개선 가능\n\t- 다른 기종으로 이전 편리\n\t- 작은 기억 공간 요구\n\t- 컴파일 속도 느림","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/EBNF":{"title":"EBNF","content":"\n\u003cbr\u003e\n\n==**EBNF(Extended Backus-Naur Form) 표기법은 BNF에 메타 기호를 추가하여 규칙을 더 간결하게 표현할 수 있도록 확장된 BNF이다.**== 총 4가지 메타기호가 추가되었다.\n\n\u003cbr\u003e\n\n| **구분** | **메타 기호** |               **의미**               |\n|:--------:|:-------------:|:------------------------------------:|\n|   BNF    |    `::==`     |                 정의                 |\n|   BNF    |     `\\|`      |               택일(OR)               |\n|   BNF    |     `\u003c \u003e`     |         비단말(nonterminal)          |\n|   EBNF   |     `[]`      |              생략 가능               |\n|   EBNF   |     `{}`      |            0번 이상 반복             |\n|   EBNF   |     `()`      | 한정된 범위의 택일, `\\|`와 함께 사용 |\n|   EBNF   |     `''`      |  메타 기호 자체를 단말 기호로 사용   | \n\n\u003cbr\u003e\n\n- 메타 기호 `[]`의 예시\n\t- 의미 : 생략 가능\n\n```\nBNF\n\u003cif문\u003e ::= if \u003c논리식\u003e then \u003c문장\u003e else \u003c문장\u003e | if \u003c논리식\u003e then \u003c문장\u003e  \nEBNF\n\u003cif문\u003e ::= if \u003c논리식\u003e then \u003c문장\u003e [ else \u003c문장\u003e ]\n```\n\n\u003cbr\u003e\n\n- 메타 기호 `{}`의 예시\n\t- 의미 : 0번 이상 반복\n\t- `\u003cunsigned integer\u003e ::= \u003cdigit\u003e`\n\t- `\u003cunsigned integer\u003e ::= \u003cdigit\u003e\u003cdigit\u003e`\n\t- `\u003cunsigned integer\u003e ::= \u003cdigit\u003e\u003cdigit\u003e\u003cdigit\u003e ...`\n\t- 이런식으로 재귀적인 표현 방법 사용했음\n\n```\nBNF\n\u003cunsigned integer\u003e ::= \u003cdigit\u003e | \u003cunsigned integer\u003e\u003cdigit\u003e  \nEBNF\n\u003cunsigned integer\u003e ::= \u003cdigit\u003e { \u003cdigit\u003e }\n```\n\n\u003cbr\u003e\n\n- 메타 기호 `()`의 예시\n\t- 의미 : 범위 중 택일\n\n```\nBNF\n\u003c수식\u003e ::= \u003c수식\u003e + \u003c수식\u003e | \u003c수식\u003e - \u003c수식\u003e | \u003c수식\u003e * \u003c수식\u003e | \u003c수식\u003e / \u003c수식\u003e\nEBNF\n\u003c수식\u003e ::= \u003c수식\u003e ( + | - | * | / ) \u003c수식\u003e]\n```\n\n\u003cbr\u003e\n\n- 메타 기호 `''`의 예시\n\t- 의미 : 메타 기호 자체를 단말 기호로 사용\n\n```\n\u003cBNF 규칙\u003e ::= \u003c왼쪽 부분\u003e '::=' \u003c오른쪽 부분\u003e\n```","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/Interpreter":{"title":"인터프리터","content":"\n\u003cbr\u003e\n\n[컴파일(Compile)](brain/CS/LT/Compile)은 인간이 이해할 수 있는 언어로 작성된 소스코드를 컴퓨터가 이해할 수 있는 기계어로 번역(변환)하는 작업을 의미한다고 했다. 이 과정에서 [컴파일러](brain/CS/LT/Compiler)는 **소스 코드 전체를 목적 코드로 바꿔주고 컴퓨터에서 실행 가능하도록**하는 원리였다. 그렇다면 인터프리터는 어떠한가?\n\n==**인터프리터는 소스 코드를 한 줄씩 읽어들여서 즉시 실행한다.**==\n1. 소스 코드 한 줄 마다 번역과 실행이 동시에 이루어진다.\n2. 줄 단위로 진행되어 시분할 시스템에 유용하다.\n3. CPU 사용 시간의 낭비가 크다.\n\n[컴파일러](brain/CS/LT/Compiler)는 사람이 하는 말을 처음부터 끝까지 들은 이후 작업 수행, 인터프리터는 소스 코드 한 줄 마다 번역함과 동시에 실행하는 작업을 수행한다. 쉽게 말해서, ==인터프리터는 사람의 말을 동시통역하는 개념==으로 이해하면 된다. **인터프리터는 줄 단위로 바로바로 프로그램이 실행 되기에 목적 프로그램이 따로 생성되지는 않는다.**\n\n\u003cbr\u003e\u003cbr\u003e\n\n|           | **컴파일러(Compiler)** | **인터프리터(Interpreter)**          |\n| :---------: | :----------------------: | :------------------------------------: |\n| 번역 단위 | 전체                   | 한 줄 마다                           |\n| 실행 속도 | 빠름                   | 느림                                 |\n| 번역 속도 | 느림                   | 빠름                                 |\n| 목적 코드 | 생성 O                 | 생성 X                               |\n| 예시      | C, C++, Java Compiler  | Python, JavaScript, Java Interpreter | \n\n\u003cbr\u003e\n\n위의 표를 보면 실행 속도와 번역 속도에 차이가 있음을 볼 수 있다. 인터프리터는 한 줄, 행마다 번역을 하기 때문에 번역 자체는 빠르지만, **프로그램 전체적으로 봤을 때, 번역 -\u003e 실행, 번역 -\u003e 실행의 과정을 반복하기 때문에 실행 속도는 컴파일러보다 느리게 되는 것이다.**\n\n따라서, 컴파일과 인터프리터는 각각 장단점이 있어서, 사용하는 상황과 용도에 따라서 선택하게 된다. 컴파일러는 실행 파일이 빠르고 안정적이지만, 번역하는데 시간이 걸리며, 수정이 어렵다. 인터프리터는 실행 파일이 빠르지 않고, 수정이 쉽지만, 오류를 찾는데 시간이 걸리고, 실행 중에 성능에 영향을 줄 수 있다.\n\n번역 기법의 장단점\n- 장점 : 실행 시간 효율성 제공 (한번 디코딩으로 반복 실행)\n- 단점 : 번역된 프로그램이 큰 기억 장치 요구 (I/O routine 등)\n\n인터프리터 기법의 장단점\n- 장점 : 줄마다 실행하므로 큰 기억 장치 요구하지 않음, 사용자 적응성(flexibility) 제공\n- 단점 : 실행 시간 효율성 떨어짐\n\n\u003cbr\u003e\n\n\u003e 컴파일러와 인터프리터는 다르지만, 확실하게 다르다고 경계선을 그을 수는 없다. 최근에는 컴파일러 방식, 인터프리터 방식을 섞어서 사용하기 때문이다.\n\n\u003cbr\u003e\n\n자바에서의 인터프리터에 관한 이야기는 [여기](brain/Java/JavaExecute)를 참고하자.","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/LanguageTheory":{"title":"프로그래밍 언어론","content":"\n\u003cbr\u003e\n\n프로그래밍 언어론은 ==**컴퓨터 프로그래밍 언어를 이론적인 측면에서 탐구하는 학문**==이다. 언어의 구문(Syntax), 의미(Semantics), 구조(Structure) 등을 분석하고 구셩 요소들이 언어의 특징과 동작을 어떻게 결정하는 지 연구한다. 대표적인 언어의 구문 표기법에는 [BNF](brain/CS/LT/BNF), [EBNF](brain/CS/LT/EBNF), [구문 도표](brain/CS/LT/SyntaxTable)가 있다.\n\n프로그래밍 언어 구현 기법에는 [컴파일러](brain/CS/LT/Compiler)를 이용한 [번역 기법 Compile](brain/CS/LT/Compile), [인터프리터 기법](brain/CS/LT/Interpreter), 하이브리드 기법이 있다. Java가 하이브리드 기법에 해당하므로, 이는 [Java의 실행원리](brain/Java/JavaExecute)를 참고하도록 하자.","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/Lex":{"title":"Lex","content":"\n\u003cbr\u003e\n\n==**Lex(A Lexical Analyzer Generator)는 입력 스트립에서 정규 표현식(regular expression)으로 기술된 토큰들을 찾아내는 프로그램을 작성하는데 유용한 도구이다.**== Lex 소스는 정규 표현식 및 해당하는 프로그램의 조각의 테이블이다. 그 테이블은 입력 스트림을 읽어서 출력 스트림으로 복사하고, 입력을 주어진 표현식에 매칭되는 문자열로 분할하는 프로그램으로 변환된다.\n\n![](brain/image/Lex-1.png)\n\n보통 Lex scanner와 Yacc parse는 같이 구현하는 경우가 대부분이다. [Yacc](brain/CS/LT/Yacc)가 Lex의 상위에서 구현된다. Lex는 입력문자열에 대한 일차적인 검색을 하고 실제적인 분석은 Yacc가 하는 것이다. ","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/ParseTree":{"title":"파스 트리","content":"\n==**파스트리(Parse Tree)란 BNF 문법을 이해하기 쉬운 구조로 나타낸 것으로, 원시 프로그램의 문법을 검사하는 과정에서 내부적으로 생성되는 트리 형태의 자료구조이다.**== \n\n![](brain/image/ParseTree-1.png)\n\n\u003cbr\u003e\n\n파스트리는 **모호성, 결합성의 우선순위**에 따라 서로 다른 유도과정을 거쳐 트리를 생성해낸다. 예를 들어, `B33`이라는 letter, digit, digit을 유도한다면\n\n1. `\u003cidentifier\u003e` → `\u003cidentifier\u003e \u003cdigit\u003e` → `\u003cidentifier\u003e 3` → `\u003cidentifier\u003e \u003cdigit\u003e 3` → `\u003cidentifier\u003e 3 3` → `\u003cletter\u003e 3 3` → B33\n\n2. `\u003cidentifier\u003e` → `\u003cidentifier\u003e \u003cdigit\u003e` → `\u003cidentifier\u003e \u003cdigit\u003e \u003cdigit\u003e` → `\u003cletter\u003e \u003cdigit\u003e \u003cdigit\u003e` → `B \u003cdigit\u003e \u003cdigit\u003e` → `B 3 \u003cdigit\u003e` → B33\n\n![](brain/image/ParseTree-2.png)\n\n\u003cbr\u003e\n\n그런데, 만약 뺼셈과 곱셈이 있는데 모호성이 발생한다면 어떻게 될까? 곱셈이 먼저 되어야 하는데 뺄셈이 먼저 될 수도 있으므로, 우선순위를 명확하게 하여 모호성을 제거하고 파스 트리를 만들어야 한다.\n\n\u003cbr\u003e\n\n추가적으로, `\u003cidentifier\u003e \u003cdigit\u003e`는 가능하지만 `\u003cdigit\u003e \u003cidentifier\u003e`는 안된다. 이는 변수명에 `sum5`는 되지만, `5sum`은 안되는 것을 의미한다.","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/SyntaxTable":{"title":"구문도표","content":"\n\u003cbr\u003e\n\n==**구문 도표(Syntax diagram)는 형태가 순서도와 유사하다. 그림(도표)으로 구문을 표현하는 것이다.**== 구문 도표는 EBNF와 일대일 대응되며, 초기 프로그래밍 언어 Pascal(파스칼)의 사용자 설명서에 사용되었다.\n\n- 다시 정의될 대상은 네모칸, 단말 기호는 원이나 타원형으로 표시, 이들 사이는 지시선으로 연결\n\n\u003cbr\u003e\n\n|  **도형**  |  **의미**   |\n|:----------:|:-----------:|\n| □ (사각형) | 비단말 기호 |\n|   ○ (원)   |  단말 기호  |\n| → (화살표) |  기호 연결  | \n\n\u003cbr\u003e\n\n![](brain/image/SyntaxTable-1.png)\n\n-   **BNF** : **\u003cif문\u003e ::=** **if \u003c논리식\u003e then \u003c문장\u003e | if \u003c논리식\u003e then \u003c문장\u003e else \u003c문장\u003e**\n-   **EBNF** : **\u003cif문\u003e ::= if \u003c논리식\u003e then \u003c문장\u003e [ else \u003c문장\u003e ]**","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/LT/Yacc":{"title":"Yacc","content":"\n\u003cbr\u003e\n\n==**Yacc(Yet Another Compiler-Compiler)는 컴퓨터 소프트웨어로 유닉스 시스템의 표준 Parser Generator이다.**== Yacc에서 Parse Tree를 생성할 때 Bottom-up (LR)을 채택하고, 그중에서도 LALR(Look-Ahead LR) parser 방식을 채택한다. 단순 LR 방식에서 선행예측을 하는 것이다.\n\n![](brain/image/Yacc-1.png)\n\n![](brain/image/Yacc-2.png)\n\n![](brain/image/Yacc-3.png)\n\n\u003cbr\u003e\n\nYacc는 입력에 대한 토큰(token)이 필요하면, [Lex](brain/CS/LT/Lex)에서 제공하는 `yylex()`함수를 호출하여, 입력된 토큰들의 배열이 주어진 문법에 맞는지를 체크하면서 그 조건에 맞는 실행을 하게 된다. 다르게 표현하면, Lex와 Yacc을 사용 동시에 사용할 시에는 yacc 기술파일의 main()함수에서 yyparse()함수라는 yacc에 의해 만들어지는 구문분석기를 부르고, yyparse()함수는 yylex()라는 lex가 만들어 주는 해석기(lexer)를 이용해서 입력열에서 처리단위의 토큰을 뽑아오게 된다.","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/Network/":{"title":"Network","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/Network/Socket":{"title":"소켓","content":"\n","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/OS/":{"title":"Operating System","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/OS/Scheduling":{"title":"스케줄링","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/CS/OS/SystemCall":{"title":"시스템콜","content":"\n\u003cbr\u003e\n\n==**시스템 콜(System Call)이란, 응용 프로그램과 하드웨어 사이에서 운영체제(OS)에 동작을 요청하는 함수 또는 동작들에 대한 인터페이스이다. 하드웨어를 간접제어하고 OS가 관리하는 정보에 접근하도록 요청하는 규약을 정의한 것을 의미한다.**==\n\nOS는 다양한 서비스 들을 수행하기 위해 하드웨어를 **직접적**으로 관리한다. 반면, 응용 프로그램은 OS가 제공하는 인터페이스를 통해서만 자원을 사용할 수 있다. **OS가 제공하는 이러한 인터페이스를 '시스템 콜 (system call)' 이라고 한다.**\n\n운영체제 커널이 제공하는 함수를 호출하여 운영체제 서비스를 이용하는데, 이러한 운영체제 서비스는 일반적으로 하드웨어와 직접적인 상호작용을 필요로 하는 기능들이며, 프로그램에서 직접 접근할 수 없는 보호된 자원에 대한 접근을 허용한다.\n\n- 사용자가 하드웨어를 직접 제어할 수 없음\n- 사용자와 하드웨어의 중간의 운영체제(OS)가 하드웨어 제어를 대신 해줌\n- 시스템 콜(System Call)은 운영체제의 기능을 호출하는 인터페이스로서, API의 일종이다. ==다만, 시스템 콜은 **운영체제의 기능을 호출하는 데에만 사용**되며, 운영체제의 다른 기능들을 호출하는 API와는 구분된다.==\n\n\u003cbr\u003e\n\n![](brain/image/SystemCall-1.png)\n\n위 그림처럼 운영체제(OS)는 메모리에 프로그램 적재, I/O처리, 파일시스템 처리 등 여러 서비스들을 제공하는데 **사용자 프로세스는 이에 직접적인 접근이 아닌 시스템 콜 호출을 통해 서비스를 제공받을 수 있다.** 이때, 직접적으로 System Call을 사용하기보다는 [API](brain/Common/API) (라이브러리 함수)를 통해 사용하게 된다.\n\n![](brain/image/SystemCall-2.png)\n\n\u003cbr\u003e\n\n시스템 콜은 크게 6가지로 분류할 수 있다.\n\n1. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e프로세스 제어 (Process Control)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- 끝내기(exit), 중지(abort)\n\t- 적재(load), 실행(excute)\n\t- 프로세스 생성(CreateProcess) - fork()\n\t- 프로세스 속성 획득과 속성 설정\n\t- 시간 대기 (wait time)\n\t- 사건 대기 (wait event)\n\t- 사건을 알림 (signal event)\n\t- 메모리 할당 및 해제 (malloc, free)\n\t\n\t\u003c/details\u003e\n\n2. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e파일 조작 (File Manipulation)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- 파일 생성(create), 삭제(delete)\n\t- 열기 / 닫기 / 읽기 / 쓰기 (open, close, read, write)\n\t- 위치 변경 (reposition)\n\t- 파일 속성 획득 및 설정 (get file attribute, set file attribute)\n\t\n\t\u003c/details\u003e\n\n3. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e장치 관리 (Device Manipulation)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- 하드웨어의 제어와 상태 정보를 얻음 (ioctl)\n\t- 장치를 요구(request device), 장치를 방출 (release device)\n\t- 읽기 / 쓰기 / 위치변경 (read, write, reposition)\n\t- 장치 속성 획득 및 설정\n\t- 장치의 논리적 부착 및 분리 (attach, detach)\n\t\n\t\u003c/details\u003e\n\n4. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e정보 유지 (Information Maintenance)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- getpid(), alarm(), sleep()\n\t- 시간과 날짜의 설정과 획득 (time)\n\t- 시스템 데이터의 설정과 획득 (date)\n\t- 프로세스 파일, 장치 속성의 획득 및 설정\n\t\n\t\u003c/details\u003e\n\n5. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e통신 (Communication)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- pipe(), shm_open(), mmap()\n\t- 통신 연결의 생성, 제거\n\t- 메시지의 송신, 수신\n\t- 상태 정보 전달\n\t- 원격 장치의 부착 및 분리\n\t\n\t\u003c/details\u003e\n\n6. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e보호 (Protection)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- chmod()\n\t- umask()\n\t- chown()\n\t\n\t\u003c/details\u003e\n\n\u003cbr\u003e\n\n위 사진을 보면 Windows와 Unix에서 인터페이스를 구현한 함수의 모양이 다른 것을 알 수 있다. 당연하게도 **인터페이스는 사양만 정의해놓은 것이라 동일한 인터페이스에 대한 구현은 OS마다 차이가 있을 수 있는 것**이다.\n\n시스템 콜을","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Common/":{"title":"Common","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Common/API":{"title":"API","content":"\n\u003cbr\u003e\n\n==**API(Application Programming Inteface)는 소프트웨어 컴포넌트(라이브러리, 프레임워크, 플랫폼 등)가 제공하는 인터페이스로, 다른 소프트웨어에서 해당 컴포넌트의 기능을 사용할 수 있게 해주는 것이다.**==\n\n- **응용 프로그램에서 운영체제나 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스**\n- 프로그램 사이를 연결해주는 \"다리\"라고 생각하자.\n- **구현과는 독립적으로** 어떤 하드웨어, 혹은 서로 다른 컴퓨터 프로그램 간 정보를 주고 받을 때 사용하는 **규약 혹은 사양**을 정의한 것\n\n\u003cbr\u003e\n\nApplication\n- 운영체제 위에서 실행되는 모든 소프트웨어를 의미 (운영체제가 아닌 모든 프로그램)\n\nProgramming\n- 메모리에 올라가서 실행될 수 있는 명령어들의 집합인 **프로그램을 작성하는 행위**\n\nInterface\n- 서로 다른 두 개가 서로 정보를 주고 받기 위해 약속된 **규약(규격)**\n\n즉, API는 응용 프로그램을 만들 때 사용하는 인터페이스라는 뜻이 되겠군 !\n\n\u003chr\u003e\n\n**API의 특징**\n\n- ==구현과 독립적으로 사양만 정의==되어 있다.\n- API에 따라 접근 권한이 필요할 수 있다.\n- Java API, 여러 기업들의 오픈 API 등이 있다.\n\n\u003cbr\u003e\n\n**API의 예시**\n\n1. [System Call](brain/CS/OS/SystemCall) \n2. [Socket](brain/CS/Network/Socket)\n3. [REST API](brain/Common/RESTAPI)\n4. [RESTful API](brain/Common/RESTfulAPI)","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Common/Framework":{"title":"프레임워크","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Common/Library":{"title":"라이브러리","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Common/RESTAPI":{"title":"REST API","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Common/RESTfulAPI":{"title":"RESTful API","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/DB/":{"title":"Database","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Infra/":{"title":"Infra","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Interview/":{"title":"Interview","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Interview/dog-study/":{"title":"개발바닥 면접스터디","content":"","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Interview/dog-study/dog-study":{"title":"개발바닥 면접스터디","content":"\n\u003cbr\u003e\n\n# Tech Interview\n\n\u003e 꼬리에 꼬리를 무는 면접 대비\n- [1주차 스터디](brain/Interview/dog-study/dog-week01)\n- [2주차 스터디](brain/Interview/dog-study/dog-week02)\n- [3주차 스터디](brain/Interview/dog-study/dog-week03)\n- [4주차 스터디](brain/Interview/dog-study/dog-week04)\n- [5주차 스터디](brain/Interview/dog-study/dog-week05)\n","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Interview/dog-study/dog-week01":{"title":"1주차 - 불변객체, Exception","content":"\n\u003ca href='https://github.com/dingding-21/Rebellion-Of-Interviewees/issues/1' target='_blank'\u003e1주차 스터디 Issue 바로가기\u003c/a\u003e \n\n\u003chr\u003e\n\n\u003e[!note] 1주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC - 01** \u003cbr\u003e\n\u003e \u0026nbsp;\u0026nbsp;\u0026nbsp;불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요.\n\u003e \u003cbr\u003e\u003cbr\u003e\n\u003e **TOPIC - 02** \u003cbr\u003e\n\u003e \u0026nbsp;\u0026nbsp;\u0026nbsp;Checked Exception과 Unchecked Exception은 어떤 차이가 있는지 설명해주세요.\n\n\n\n## TOPIC 01 - 불변객체\n\n\u003cbr\u003e\n\n### 복사 시리즈\n\n1. 얕은 복사\n\t- 값을 복사하는 것이 아닌, 주소값을 복사\n\t- 따라서, 원본이 바뀌면 원본을 얕은 복사한 객체들도 같이 변경됨 (참조하고 있으니까)\n\n2. 깊은 복사\n\t- 내부 요소들 전부 복사하여 새로운 객체 생성\n\t- 객체가 가리키는 주소값이 원본과 모두 다름\n\t- 원본이든 내부 요소이든 바뀌어도 영향 없음\n\n3. 방어적 복사\n\t- 생성자에서 사용 시 입력받은 인자를 내부 필드로 초기화\n\t\t- 하지만, 인자의 내부 요소들은 그대로 원본 내부요소를 가리킴\n\t- `getter` 메서드에서 내부의 객체를 반환할 때, 객체의 복사본을 만들어 반환하는 것\n\t- ==객체의 내부 필드 값을 외부로부터 보호하는 것이 목적==\n\n4. Unmodifiable Collection\n\t- 원본 컬렉션으로의 수정 메서드를 할 수 없는 Read Only\n\t- `unmodifiableList()` 메서드를 통해 리턴되는 리스트는 읽기 용도로만 사용 가능\n\t- 하지만, `unmodifiable`과 `immutable`은 다르다. \n\t\t- `unmodifiable`이 불변성을 보장해주지는 않음\n\t\t- 원본 자체에 대한 수정이 일어나면 `unmodifiableList()` 메서드를 통해 반환되었던 리스트 또한 변경이 일어남\n\n\n\u003e 즉, 원본과의 주소 공유를 끊으려면 깊은 복사 or 방어적 복사를 해야함 \n\n\n\u003cbr\u003e\n\n**1. 생성자의 인자로 객체를 받았을 때**\n\n- 외부에서 넘겨줬던 객체를 변경해도 내부 객체는 변하지 않아야 하므로 ==방어적 복사==가 적절\n\n**2. getter 를 통해 객체를 리턴할 때**\n\n- 이러한 상황에선 ==방어적 복사==와 ==Unmodifiable Collection== 중 하나를 사용하여 값을 리턴하는것이 적절하다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 불변객체란?\n\n\u003cbr\u003e\n\n불변객체(immutable object)는 말 그대로 변하지않는 객체로 객체가 생성된 후 내부 상태가 변하지 않는 객체를 의미한다. 객체가 변하지 않는다는 것은 신뢰도가 높아진다는 의미이다.\n\n- 반대 개념은 가변객체(mutable object)로  객체 생성 이후에도 상태를 변경할 수 있음\n\n- 객체 생성 이후 내부 상태가 변하지 않으니, 불변객체는 Setter 메서드를 제공하지 않는다.\n\n- 혹은 방어적 복사(defensive-copy)를 통해 제공한다.\n\n\u003cbr\u003e\n\n\u003e [!note] final을 붙이면 불변객체가 되는 것인가?\n\u003e\n\u003e final 예약어 사용시\n\u003e - 변수 : 값을 수정할 수 없는 상수로 만듦\n\u003e - 메서드 : 오버라이딩을 할 수 없게 만듦\n\u003e - 클래스 : 상속이 불가능하게 만듦\n\u003e \u003cbr\u003e\n\u003e 즉, 객체 선언 시 final을 사용해도 **객체 내부 상태는 변경할 수 있다**\n\n\u003cbr\u003e\n\n### 불변객체 장점\n\n1. 쓰레드에 안전하여 멀티-쓰레드 환경에서 동기화를 고려하지 않아도 된다. (thread-safety)\n\n2. 불변객체를 필드로 사용할 때 방어적 복사가 필요없다.\n\n3. 불변객체는 내부상태가 변경되지 않으므로, Map Key와 Set 요소로 사용하기에 적합하다.\n\n4. 불변객체를 한 번 메모리에 할당하면 같은 객체를 계속 호출하여도 새롭게 할당하지 않아도 되므로 Garbage Collector의 성능을 높힐 수 있다.\n\n\u003cbr\u003e\n\n### 불변객체 단점\n\n1.  모든 객체의 불변성을 보장하게 된다면, 상태 변화가 필요한 경우 새로운 객체를 생성해야 한다는 단점이 있고, 새로운 객체를 많이 생성하는 경우 성능 문제가 발생할 수 있다.\n\n2.  하지만 Oracle에 의하면, 객체 생성 비용에 대한 영향은 종종 과대평가되며, 불변 객체를 활용할 때의 이점들이 이런 단점을 상쇄시킨다고 한다.\n\n\u003cbr\u003e\n\n### 불변객체 생성방법\n\n1. **`setter` 메서드 제공 X**\n\t- 내부 상태값을 변경하지 않기 위하여 `setter` 메서드를 제공하지 않는다.\n\n2. **클래스를 `final`로 선언**\n\t- 클래스를 `final`로 선언하면 해당 클래스를 다른 클래스에서 상속받는게 불가능, 따라서 부모 클래스에 선언되어 있는 메서드 Overriding 불가능\n\t- `final`을 선언했다고 객체가 immutable 한 것을 보장할 수 있지는 않음. 위에서 설명한 이유처럼 객체 내부상태는 여전히 바뀔 수 있음\n\t- 즉, 1번 방법이랑 같이 써야하는 것\n\n3. **모든 필드를 final과 private을 사용해서 선언**\n\t- 변수에 final을 붙이면 재할당이 불가능하게 상수 취급됨\n\t- 인스턴스 변수\n\t\t- ==Primitive type, 원시타입== : final로 선언하여 불변성 유지 가능\n\t\t- ==Reference type, 참조타입== : final로 선언하면 참조 대상이 바뀔 수 없다는 의미일 뿐 불변성을 보장할 수는 없다. 객체 내부 상태가 바뀔 수 있기 때문이다.\n\t- 따라서, 접근 제어자를 private으로 선언하여 해당 클래스만 해당 필드에 대한 접근 권한을 가지게 변경, setter 메서드를 제공하지 않으니 외부 클래스로부터 접근 차단하니까\n\n4. **객체를 생성하기 위한 생성자 or 정적 팩토리 메서드 추가**\n\t- 생성자를 통해 초기화되는 필드들은 깊은 복사를 통한 참조 대상 재할당\n\t\t- 생성자를 통해 초기화되는 인스턴스 변수들이 Reference Type이면 깊은 복사를 통해 참조하는 객체 내부의 값이 변경되는 것을 방지할 수 있음\n\t- getter 메서드를 객체의 깊은 복사본을 반환하도록 함\n\t\t- getter 메서드가 실제 객체에 대한 reference를 반환하는 대신 깊은 복사를 통해 ==생성한 객체에 대한 reference를 반환==하여, 반환받은 객체를 사용할 때 실수로라도 기존 객체를 건드릴 수 없게\n\n5. **인스턴스 필드에 가변객체가 포함된다면 방어적 복사를 이용하여 전달**\n\n\u003cdetails\u003e\n\u003csummary\u003e ==\u003cstrong\u003e코드 예시보기\u003c/strong\u003e== \u003c/summary\u003e\n\n\u003ca href='https://dev-cool.tistory.com/23' target='_blank'\u003e코드 출처\u003c/a\u003e\n\n```java \npublic final class ImmutableClass {  \n    /*  \n     * Integer 와 String 은 immutable 객체로  \n     * 값을 변경하는 Setter 가 없어서 값이 변하지 않는다.  \n     * */    \n    private final Integer immutableField1;  \n    private final String immutableField2;  \n    private final Date mutableField;  \n  \n    private ImmutableClass(Integer immutableField1, String immutableField2, Date mutableField) {  \n        this.immutableField1 = immutableField1;  \n        this.immutableField2 = immutableField2;  \n        this.mutableField = new Date(mutableField.getTime());  \n    }  \n  \n    public static ImmutableClass createImmutableClass(Integer immutableField1, String immutableField2, Date mutableField){  \n        return new ImmutableClass(immutableField1,immutableField2,mutableField);  \n    }  \n  \n    public Integer getImmutableField1() {  \n        return immutableField1;  \n    }  \n  \n    public String getImmutableField2() {  \n        return immutableField2;  \n    }  \n  \n    /*  \n     * Date 는 가변 객체로 인스턴스 변수의 참조를 return 하지 않는다.  \n     * 대신에 new 예약어를 사용해서 방어적복사를 수행한다.  \n     * */    \n     public Date getMutableField() {  \n        return new Date(mutableField.getTime());  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return \"immutableField1 = \" + immutableField1 + \", immutableField2 = \" + immutableField2 + \", mutableField = \" + mutableField;  \n    }  \n}\n\n\npublic class Main {  \n    public static void main(String[] args) {  \n        ImmutableClass immutableClass = ImmutableClass.createImmutableClass(1,\"cool\",new Date());  \n        System.out.println(immutableClass);  \n  \n        modiftyField(immutableClass.getImmutableField1(),immutableClass.getImmutableField2(),immutableClass.getMutableField());  \n        System.out.println(immutableClass);  \n    }  \n  \n    private static void modifyField(Integer immutableField1, String immutableField2, Date mutableField){  \n        immutableField1 = 2;  \n        immutableField2 = \"kim\";  \n        //가변객체 Date 의 setter 메소드  \n        mutableField.setTime(2);  \n    }  \n}\n\n// immutableField1 = 1, immutableField2 = cool, mutableField = Tue Feb 08 09:57:02 KST 2002\n// immutableField1 = 1, immutableField2 = cool, mutableField = Tue Feb 08 09:57:02 KST 2002\n```\n\n- 불변객체 생성 방법에 따라 생성 이후 객체의 상태를 바꾸는 메서드를 실힝해도 내부 상태가 변경되지 않은 결과를 확인하였음.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### String\n\n- String은 대표적인 불변객체의 예시이다.\n\t- 변수에 할당되면 참조를 업데이트하거나 내부 상태를 어떤 방법으로도 변경할 수 없기 때문\n\n- String 객체를 생성하는 방법 2가지\n\t- String literal `\"\"` 사용\n\t- new 연산자 사용\n\n```java\nString s1 = \"Cat\";\nString s2 = \"Cat\";\nString s3 = new String(\"Cat\");\n\ns1 == s2; // true\ns1 == s3; // false\n```\n\n\u003cbr\u003e\n\n![](brain/image/dog-week01-1.png)\n\n- literal로 생성한 객체는 String pool에 들어간다.\n\t- 생성한 객체의 값이 이미 존재한다면, String pool의 reference를 참조한다.\n\t- 문자열 리터럴을 캐싱하고 재사용하기 때문에 Heap 공간을 많이 절약할 수 있음\n\n- new 연산자로 생성하면 상수 풀에 있어도 Heap 영역에 새로운 객체를 생성한다.\n\t- 이는 불변객체인 String의 장점을 누리지 못한다는 의미\n\n- `intern()` 메서드\n\t- String pool에 String 객체 존재 -\u003e 그 객체를 그대로 return\n\t- String pool에 String 객체 존재 X (new 연산자로 생성한 경우)\n\t\t- 호출된 String 객체를 String pool에 추가하고 객체의 reference를 return\n\n\u003e String pool, Constant pool, Constant String pool 같은 의미인듯\n\n\u003cbr\u003e\n\n### String이 불변인 이유\n\n\u003cbr\u003e\n\n1. **성능 (Performance)**\n\t- 상수 풀을 이용하여 캐싱하고 재사용하기 때문에 Heap 공간을 절약하여 성능 높힘\n\n\u003cbr\u003e\u003cbr\u003e\n\n2. **동기화 (Synchronization)**\n\t- 불변 객체는 값이 바뀔 일이 없어서 멀티스레드 환경에서 `Thread-safe`\n\t- 동시에 실행되는 여러 스레드에서 공유할 수 있다. 스레드가 값을 변경하면 동일한 문자열을 수정하는 대신, String pool에 새로운 문자열이 생성되기 때문에 스레드가 안전함\n\n```java\nString s1 = \"Hello\";\nString s2 = \"Java\";\nString s3 = s1 + s2;\n\n// String pool에 \"Hello\", \"Java\", \"HelloJava\"가 있는 상태\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n3. **해시코드 캐싱 (Hashcode Caching)**\n\t- String은 데이터 구조로도 많이 사용 (HashMap, HashTable, HashSet)\n\t- String의 `hashCode()` 메서드 구현을 보면 ==아직 hash 값을 계산한 적이 없을 때 최초 1번만 실제 계산 로직을 수행==하고, 이후부터는 해당 값을 그냥 반환만 하도록 overriding 되어 있다. (계산해놓았던 해시코드를 재사용하는 것)\n\t- String이 불변이기 때문에 이렇게 caching이 가능하다는 이점을 활용할 수 있는 것 (값이 변하지 않기 때문에 위와 같이 캐싱해서 사용할 수 있는 것)\n\n\u003e [!note] HashMap, HashSet 등 키를 불변형으로 많이 쓰는데, 이걸 가변형이라고 가정하면 어떤 문제가 있을까? \u003cbr\u003e\n\u003e  만약에 문자열이 가변이라고 하면 매번 해쉬값이 변하니까 이 데이터가 과연 맞는 값일까? 의문점을 가질 것이다. 키가 바뀌다보면 이게 A로, B로 확확 바뀌면 내가 찾고자 하는 값을 찾기 위하여 원하지 않게 두 번,세 번,네 번 계산을 해야하니까 **무조건 key 값은 불변자료로 넣어서 캐싱을 하기 쉽게, 혹은 재사용하기 쉽게 HashSet이나 HashMap에서의 key는 불변성을 유지하고 있다.**\u003cbr\u003e\u003cbr\u003e\n\u003e  간단하게 말해서 캐싱처리를 해서 재사용하기 쉽게, 메모리 공간처럼 자원을 아껴서 조금 더 빠르게 구동할 수 있게 하기 위함이다. Hash 함수를 쓰면 보통 O(1) 만큼의 값을 쳐줄 수 있는 성능상으로도 되게 유리해지고 멀티스레드나 동기성을 쉽게 다룰 수도 있는데 가변상태로 하게 되면, 디버깅을 할 수는 있겠지만 딥하게 파고드는 디버깅을 할 수도 없는 특징이 있다.\n\n\u003cbr\u003e\n\n4. **보안 (Security)**\n\t- 문자열은 Java 애플리케이션에서 사용자 이름, 암호, 연결 URL, 네트워크 연결 등과 같은 중요한 정보를 저장하는 데 널리 사용됨. 클래스를 로드하는 동안 JVM 클래스 로더에서도 광범위하게 사용.\n\t- String이 불변 객체가 아니라면 메서드를 호출했던 클라이언트는 String에 대한 참조가 메서드를 호출 이후에도 남아있다. 따라서 보안 검사를 실시한 이후에도 이 문자열이 안전하다고 보장할 수 없다. ==메서드를 호출했던 클라이언트가 String에 대한 참조를 계속 가지고 있기 때문에 문자열을 변경할 수 있다는 가능성이 남아있다.==\n\t\t- 이러한 보안 이슈 때문에 String을 불변객체로 만들었음\n\n\u003cbr\u003e\n\n### StringBuilder, StringBuffer\n\n- String을 단순 문자열로 활용하고 싶을 때는 불변객체가 적절하지 않을 수 있음\n\t- `문자열 연산 +`이 많은 경우\n- 문자열 연산 등으로 ==기존 객체의 공간이 부족해지는 경우, 기존의 버퍼 크기를 늘려 유연하게 동작하는 가변객체==\n- **StringBuffer**는 각 메서드별로 Synchronized Keyword가 존재하여, 멀티스레드 환경에서도 동기화를 지원.  \n- **StringBuilder**는 동기화를 보장하지 않음.\n\n\u003e [!note] 정리 \u003cbr\u003e\n\u003e **String** : 문자열 연산 자체가 적고 멀티스레드의 경우 \u003cbr\u003e \n\u003e **StringBuffer** : 문자열 연산이 많고 멀티스레드의 경우 \u003cbr\u003e \n\u003e **StringBuilder** : 문자열 연산이 많고 단일스레드고 동기화를 고려하지 않아도 되는 경우 \u003cbr\u003e\u003cbr\u003e\n\u003e 보통 Java-Spring에서는 멀티스레드 환경을 지원하고 있기 때문에 보통은 String, StringBuffer를 사용하는 편이다.\n\n\n\u003cbr\u003e\n\n### (심화) 객체 생성비용 최소화\n\n**생성비용이 많이 드는 객체가 반복해서 필요하다면 어떻게 해야할까?**\n\n- 정답 후보 3가지가 있고, 결론적인 방법은 필드캐싱이다.\n\t1. `static final`을 클래스 내부 필드에 해놓는 ==필드 캐싱== 방법\n\t2.  불변객체 시작하는 것을 클래스를 사용할 때만 맞춰서 하는 ==lazy initialization(지연 초기화) 방법==\n\t3.  인스턴스가 생성이 되는지 존재하지 않는지에 대해서 2번씩 체크하는 ==Double-checked Locking Pattern==\n\n\u003cbr\u003e\n\n상황마다 다르겠지만, 보통 지연 초기화는 코드를 더 복잡하게 만들어서 성능 개선이 크게 되지 않아서 잘 사용하지 않는다고 한다. ==실무에서는 필드 캐싱을 많이 사용==한다.\n\n보통 사람들은 Double-checked Locking을 생각할 수 있는데, 그러면 체크를 하면서 확인을 해야하고 이거에 따라 절차를 밟아가는 것이라서 보통은 캐싱처리를 하고 바로바로 사용하려고 한다. 실무에서는 메모리를 쪼~끔 더 쓰고 그냥 빠르게 쓰자는 의미로 캐싱해서 쓴다. 아니면, 메모리를 대체해줄 수 있는 Redis, NoSQL 같은 것으로 좀 빠르게 쓰자!라고 생각한다.\n\n\u003cbr\u003e\n\n### (심화) DCLP 지양에 관한 이야기\n\n**사실 DCLP는 Java와는 맞지 않는 패턴이다.**\n\n1.  DCLP는 멀티스레드 환경에서 안전하지 않다.\n    -   그 이유는 jvm이 out of order writes를 지원하기 때문인데,\n    -   멀티스레드 환경에서 그에따라 입력되는 순서가 보장되지 못한다.\n2.  순서 입력을 보장받기위해 volatile 키워드를 가용할 수 있습니다.\n    -   volatile 키워드의 기능은따라 cpu caching이 아니라 메인메모리에 직접 작성하는데,\n    -   jvm의 최적화를 끈다는 단점이 있고,\n    -   입력한 순서를 복사하여 jvm에 재입력 한다는 단점이 있다.\n3.  더불어 volatile 키워드가 멀티스레드 자체에서 race condition과 상기했듯이 memory visibility에 취약점을 가지고 있으므로, 결론적으로 보면 지양해야한다.\n\n\u003cbr\u003e\n\n싱글톤 패턴은 생성자가 여러 차례 호출 되어도 실제로 생성되는 인스턴스는 단 1개이고, 최초 생성 이후 호출된 생성자는 최초에 생성한 객체를 리턴하는 형태이다. 그러나, 멀티스레드 환경이라면 어떻게 될까? 인스턴스를 차지하기 위하여 스레드 간 경쟁이 일어나게 된다. 이 문제를 해결하기 위하여, 여러 가지 해결방법을 생각했는데 그중 DCLP는 자바와는 사실 잘 맞지 않는 방법이다. \n\n\u003cbr\u003e\n\n```java\npublic ResLock getInstance() {  \n  if(singletonResource == null) { // 1)  \n   mutex.lock();  \n   if(singletonResource == null) { // 2)  \n    singletonResource = new SingletonResource(); // 3)  \n   }  \n  }  \n  return singletonResource;  \n }\n```\n\n\u003cbr\u003e\n\n흐름을 살펴보면  \n\n1.  스레드1이 null이니까 (1)을 통과하고 뮤텍스의 제어권을 획득함.\n2.  스레드2도 null이지만 스레드1이 뮤텍스의 제어권을 가지고 있으니 여기에서 블락됨\n3.  스레드1은 (2) -\u003e (3)을 거쳐 싱글톤 자원을 만들고 인스턴스에 할당. 끝나면서 리턴\n4.  스레드2가 뮤텍스의 제어권 획득하고 null인지 확인하고 (2) -\u003e (3) 진행\n\n이렇게 흐름상 이론은 완벽해보이지만, DCLP는 자바 플랫폼 메모리 모델과는 맞지 않는 방법이다. \n\n- 조건이 두 개라서 mutex로 (2) 이전까지는 흐름을 제어할 수 있다. \n- mutex 자체가 key를 기반으로 한 상호배제 기법이니까 객체를 소유한 스레드만이 (2)에 접근할 수 있다. \n- 그러나, 자바의 메모리 모델은 “out-of-order-write”를 지원하기 때문에 메모리에 작성되는 순서를 보장하지 않는다. 하나의 스레드가 다른 스레드에 의해 인터럽트 된다면 생성자를 완료하기 이전에 이미 double-checking locking이 실패하는 것이다. \n\n정리하자면, 스레드1이 작업을 끝내고 뮤텍스 제어권을 획득한 스레드2가 (2)에 진입했을 때 초기화 작업을 끝냈을 것이라는 보장이 없다는 의미이다.\n\n그렇다면 volatile 키워드를 붙여서 “메인 메모리에 저장할 것”이라고 명시한다면 괜찮지 않을까? 멀티스레드 환경에서 volatile 변수의 초기값을 필요로 하고 새로운 값이 이 초기값을 근거로 한다면, volatile을 붙여도 더이상 정확한 가시성을 보장하지 못한다. 변수를 읽고 새 값을 쓰는 이 사이의 짧은 차이가 경합을 일으킨다. 또, 많은 JVM이 volataile의 순차적 영속성 기능을 구현하지 않기 때문에 결과적으로 volatile을 써도 보장할 수 없다는 의미이다.\n\n==따라서, DCLP는 지양되어야 한다.==\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## TOPIC 02 - Exception\n\n\u003cbr\u003e\n\n### Error, Exception\n\n- 컴파일 에러 : 컴파일 시에 발생하는 에러\n- 런타임 에러 : 실행 시에 발생하는 에러\n- 논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것\n\nJava에서는 실행 시(runtime) 발생할 수 있는 프로그램 오류를 ==에러(Error)==와 ==예외(Exception)==로 구분하였다.\n\n- Error : 메모리 부족(OutOfMemory), 스택오버플로우(StackOverFlowError)와 같이 일단 발생하면 복구할 수 없는 심각한 오류라서 개발자가 예측해서 프로그램 코드에 어떠한 대비는 불가능\n- Exception : Exception handling과 같이 예외 처리하는 방법을 통해 개발자가 예측하여 프로그램 코드에 대비 가능\n\n![](brain/image/dog-week01-2.png)\n\n\u003cbr\u003e\n\n### Checked vs Unchecked\n\n- Checked Exception : Runtime Exception을 ==상속하지 않는== Exception\n\t- ex) FileNotFoundException, ClassNotFoundException, IOException, SQLException\n- Unchecked Exception : Runtime Exception을 ==상속하는== Exception\n\t- ex) NullpointerException, IndexOutOfBoundException,  ArithmeticException\n\n\u003cbr\u003e\n\n|                   | Checked Exception       | Unchecked Exception     |\n| ----------------- | ----------------------- | ----------------------- |\n| **확인 시점**     | 컴파일 시점             | 런타임 시점             |\n| **처리 여부**     | 반드시 예외처리 O       | 예외처리 안해줘도 됨    |\n| **트랜잭션 처리** | 예외 발생 시 Rollback X | 예외 발생 시 Rollback O | \n\n\u003cbr\u003e\n\nException Handling에 관해서는 [2주차 스터디 참고](brain/Interview/dog-study/dog-week02)\n\n\u003cbr\u003e\n\n\u003e [!note] Spring에서의 Rollback \u003cbr\u003e\n\u003e @Transactional 애노테이션에서는 의도해서 **모든** 경우의 수를 처리하지 않는 이상 롤백이 되지 않는다. 결국, Runtime Error를 발생시키지 않는다는 뜻이다. 정리하자면, 모든 경우의 수를 따져 try catch 해서 throw 하지 않으면 롤백이 되지 않아서, Runtime Error가 발생하지 않아 예외처리가 힘들다는 특징이 있다. (스터디 내용) \u003cbr\u003e\u003cbr\u003e\n\u003e Spring은 디폴트로 **UnCheckedException** 과 **Error**에 대해서 롤백 정책을 설정 - \u003ca href='https://pjh3749.tistory.com/269' target='_blank'\u003e참고링크1\u003c/a\u003e\u003cbr\u003e, \u003ca href='https://kdhyo.kr/31' target='_blank'\u003e참고링크2\u003c/a\u003e\n\u003e 이 파트는 @Transactional 공부하고 다시 돌아오기\n\n\n## 참고\n\n- \u003ca href='https://velog.io/@kbsat/%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC-%EB%B0%A9%EC%96%B4%EC%A0%81-%EB%B3%B5%EC%82%AC%EA%B0%80-%EB%AD%90%EC%95%BC#%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC' target='_blank'\u003e얕은 복사 / 깊은 복사 / 방어적 복사\u003c/a\u003e\n- \u003ca href='https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/' target='_blank'\u003e방어적 복사 vs Unmodifiable Collection\u003c/a\u003e\n- \u003ca href='https://soft.plusblog.co.kr/71' target='_blank'\u003eUnmodifiable Collection 예시\u003c/a\u003e\n- https://dev-cool.tistory.com/23\n- \u003ca href='https://parkcheolu.tistory.com/16' target='_blank'\u003evolatile 키워드\u003c/a\u003e\n- \u003ca href='https://jungwoon.github.io/java/2019/08/11/Singleton-Pattern-with-Multi-Thread.html' target='_blank'\u003e멀티스레드 환경에서의 싱글톤\u003c/a\u003e\n- \u003ca href='https://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS6818849791\u0026cate_cd=' target='_blank'\u003eC#의 DCLP\u003c/a\u003e\n- \u003ca href='https://web.archive.org/web/20171027162134/https://www.ibm.com/developerworks/java/library/j-dcl/index.html' target='_blank'\u003e(원본) Java와 DCLP는 맞지 않다\u003c/a\u003e\n- \u003ca href='https://gampol.tistory.com/entry/Double-checked-locking%EA%B3%BC-Singleton-%ED%8C%A8%ED%84%B4' target='_blank'\u003e(번역본) Java와 DCLP는 맞지 않다\u003c/a\u003e","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Interview/dog-study/dog-week02":{"title":"2주차 - Exception Handling","content":"\n\u003ca href='https://github.com/dingding-21/Rebellion-Of-Interviewees/issues/4' target='_blank'\u003e2주차 스터디 Issue 바로가기\u003c/a\u003e \n\n\u003chr\u003e\n\n\u003e[!note] 2주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC - 01** \u003cbr\u003e\n\u003e \u0026nbsp;\u0026nbsp;\u0026nbsp;Java의 Exception Handling 방법에 대하여 설명해주세요.\n\u003e \u003cbr\u003e\u003cbr\u003e\n\u003e **TOPIC - 02** \u003cbr\u003e\n\u003e \u0026nbsp;\u0026nbsp;\u0026nbsp;Spring에서의 예외 처리 방법과 흐름에 관하여 설명해주세요.\n\n\n\n## TOPIC 01 - 예외 핸들링\n\n제공하고 있는 서비스가 **프로그램 실행 중** 어떤 원인에 의하여 비정상적으로 종료가 되었다고 하자. 이러한 경우 대처를 어떻게 해야할까?\n\n- **실행 중을 뜻하는 것이라서 Runtime Exception을 의미**하는 것이다.\n\t- Error : 오류는 메모리 부족, 스택오버플로우와 같이 일단 발생하면 복구할 수 없는 심각한 오류이기 때문에 개발자가 예측이 불가능하다. 따라서 프로그램 코드에 어떠한 대비는 불가능\n\t- Exception : Exception Handling을 통하여 개발자가 예측해서 프로그램 코드에 대비가 가능하다.\n\t\t- Checked Exception : Runtime 시점이기 때문에 고려하지 않는다. 애초에 Checked Exception이면 컴파일 자체가 안되고 빨간줄이 뜰 것\n\t\t- **Unchecked Exception : 바로 이 부분에 관하여 핸들링하는 것이다.**\n\n\u003cbr\u003e\n\n### 예외복구\n\n- Exception이 발생하여도 Application은 정상적으로 동작\n- Exception 발생 시 이를 예측하여 다른 비즈니스 로직 흐름으로 유도\n- Exception이 발생하지 않는 상황으로 복구를 시도하는 로직을 추가\n- `try-catch-finally` 블록을 이용하여 예외상황을 파악하고 정상상태로 되돌려 놓는 것\n\n예를 들어, 네트워크의 환경이 좋지 않아서 서버에 접속이 안되는 상황의 시스템에 적용하면 효율적일 것이다. \n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e==코드 예시보기==\u003c/strong\u003e\u003c/summary\u003e\n\n```java\nprivate void NetworkThrowException() {\n    int maxTry = 5;\n    while(maxTry --\u003e 0) {\n    \ttry {\n    \t\t// RandomException 이 Throw 될 수 가능성이 있는 로직\n        \t// 성공 시 return, 해당 메소드 종료\n        \treturn ;\n    \t} catch(RandomException re) {\n    \t\t// Error 로그 출력\n            // 실패 로직 존재 시 원상 복구\n        \t// 일정 시간 동안 대기\n    \t} finally {\n    \t\t// 작업에 사용한 Resource 반환 및 정리\n    \t}\n    }\n    // 최대 횟수 실패시 예외 Throw\n    throw new MaxTryFailedException();\n\n\t// 혹은 네트워크 연결 실패 페이지로 이동시켜 흐름을 전환할 수도 있음\n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### 예외회피\n\n- 메서드에 `throws`를 붙여서 예외처리를 직접 담당하지 않고 호출한 쪽으로 던져서 회피\n- 예외를 회피하고 던지는 것이 정말 최선일 경우에만 던지기\n- 긴밀하게 역할을 분담하고 있는 경우가 아니라면, 굉장히 무책임한 행동\n- 프로그래머가 예외처리를 각자 프로그램에 맞기 처리하도록 유도하는 경\u001f우에는 괜찮을 수도 있음\n\n\u003e [!note] 잠깐! throw와 throws의 차이는? \u003cbr\u003e\n\u003e - **throw**는 예외를 던져주는 코드, 특정 조건에서 예외를 던지는 것, 사용자가 직접 예외를 만들어서 일부로 발생시킬 때 사용하는 것\n\u003e - **throws**는 throw 값을 받는 곳에서 예외를 처리하도록 하여, 예외처리의 주체를 바꿔주는 것\n\u003e - 메서드 옆에 붙이는 건 **throws**, new 연산자 옆에 붙이는게 **throw**\n\n\u003cbr\u003e\n\n### 예외전환\n\n- 특정 Exception 발생 시 명확한 의미의 새로운 Exception으로 전환하고 호출한 쪽으로 던짐\n- 호출 부분에서 Exception Handling 할 때, 어떤 Exception인지 분명하게 하여 해당하는 Exception에 대한 Handling이 수월하게 해주는 것\n- `Checked Exception`처럼 복구 불가능한 Exception을 **catch**하여 `Unchecked Exception`으로 전환하여 Handling 하면 다른 계층에서 일일이 Checked Exception을 선언하지 않도록 한다\n\n예를 들어, 클라이언트 단에서는 SQLException에 대하여 어떻게 처리해야할 지 모를 것이다. 이러한 Checked Exception에 관하여 **서버 단에서 클라이언트 단에게 에러 메세지를 정확하게 알려주고 싶은 경우**에 사용하면 유용한 방법이다.\n\n대표적인 예시로, Spring에서 로그인 5회이상 실패 혹은 잘못된 이미지 파일 확장자 검사 등 예외상황에 Unchecked Exception으로 처리하는 것이 일반적이다.\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e==코드 예시보기==\u003c/strong\u003e\u003c/summary\u003e\n\n\u003ca href='https://dev-cool.tistory.com/24' target='_blank'\u003e코드출처\u003c/a\u003e\n\n```java\npublic class ExceptionTest {\n\tpublic static void main(String[] args) throws CustomException {\n\t\tString test = \"test\";\n\n\t\ttry {\n\t\t\tSystem.out.write(test.getBytes());\n\t\t} catch (IOException e) {\n\t\t\tthrow new CustomException(\"list 못 읽음\");\n\t\t}\n\t}\n}\n\npublic class UncheckedExceptionTest {\n\tstatic String test;\n\tpublic static void main(String[] args) throws NullPointerException {\n\t\tString test2 = test.toLowerCase();\n\t\tSystem.out.println(test2);\n\t}\n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 다중 catch\n\ntry 블록 내부는 다양한 종류의 예외가 발생할 수 있다. 이를 해결하는 방법이 여러 개의 catch문을 사용하는 것이다.\n\n**하지만 catch 블록이 여러 개라 할지라도 단 하나의 catch 블록만 실행된다.** 그 이유는 try 블록에서 동시 다발적으로 예외가 발생하지 않고, 하나의 예외가 발생하면 즉시 실행을 멈추고 해당 catch\n블록으로 이동하기 때문이다.\n\n**그렇기 때문에 상위 예외 클래스가 하위 예외 클래스(더 상세한)보다 아래쪽에 위치해야 한다.** try블록에서 예외가 발생했을 때, 예외를 처리해줄 catch블록은 위에서부터 차례대로 검색된다. 만약, 상위 예외 클래스의 catch블록이 위에 있다면, 하위 예외 클래스의 catch 블록은 실행되지 않는다.\n\n왜냐하면 ==하위 예외는 상위 예외를 상속했기 때문에 상위 예외 타입도 되기 때문==이다. 아래 코드 예시처럼 상위 예외 클래스인 Exception이 ArrayIndexOutOfBoundsException보다 위에 있으면 에러가 난다.\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e==코드 예시보기==\u003c/strong\u003e\u003c/summary\u003e\n\n```java\n// Exception이 더 상위니까 에러남\npublic class CatchExceptionTest {  \n    public static void main(String[] args) {  \n        try {\n\t\t    // 블라블라~ \n        } catch (Exception e) {  \n    \n        } catch (ArrayIndexOutOfBoundsException e) {  \n        \n        }\n    }  \n}\n\n// 상위 예외 클래스가 아래로 가야 에러가 안남\npublic class CatchExceptionTest {  \n    public static void main(String[] args) {  \n        try {\n\t\t    // 블라블라~ \n        } catch (ArrayIndexOutOfBoundsException e) {  \n        \n        } catch (Exception e) {  \n        \n        }\n    }  \n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 멀티 catch\n\n\u003ca href='https://dololak.tistory.com/61' target='_blank'\u003e[관련 출처]\u003c/a\u003e 하나의 catch 블록에서 여러 개의 예외를 처리하는 것이다. `|`로 예외 연결한다. 그러나, 다중 catch처럼 멀티 catch도 사용 시 주의사항이 있다. \n\n1. **Multi Catch문에 사용된 예외들은 예외의 상속관계에서 부모와 자식관계에 있으면 안된다.**\n\n```java\ntry {\n} catch (ArithmeticException | RuntimeException e) {\n}\n\n// Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: \n// The exception ArithmeticException is already caught by the alternative RuntimeException\n```\n\n`ArithmeticException`은 `RuntimeException`의 자손 클래스이기 때문에 ==RuntimeException 하나만으로 처리가 가능하기 때문==에 예외가 발생한다. 즉, **다형성에 의해 RuntimeException 하나로 자손 예외들을 모두 처리 가능**하다는 의미이다.\n\n```java\n// 이렇게 수정하면 정상작동\ntry {\n} catch (RuntimeException e) {\n    RuntimeException 하나로 하위 예외들을 모두 처리           \n}\n```\n\n\u003cbr\u003e\n\n2. **Multi Catch문에 사용된 예외들의 공통된 조상의 멤버만 사용할 수 있다.**\n\n```java\ncatch (ExceptionA | ExceptionB | ExceptionC e\u001e) {\n\te.methodA();\n\t// e라는 참조변수 하나로 여러 가지 예외를 처리하기 때문에\n\t// e가 A, B, C 어느 예외인지 몰라서 처리할 수 없다.\n}\n```\n\nMulti Catch문에서는 ==공통된 조상의 메서드만 호출하거나 정확히 어느 예외의 인스턴스인지 판단하여 캐스팅(형변환) 후 해당 메서드를 사용==해야 한다.\n\n![](brain/image/dog-week02-1.png)\n\n```java\ntry {\n} catch(ChildExA | ChildExB | ChildExC e){\n   e.parentsMethod(); //공통조상인 parentsMethod()만 호출 가능\n}\n```\n\n\u003cbr\u003e\n\n```java\ntry {\n} catch(ChildExA | ChildExB | ChildExC e){\n   if (e instanceof ChildExA) {\n       ChildExA a = (ChildExA)e; //캐스팅\n       a.childMethodA();\n   } else if (e instanceof ChildExB) {\n       ChildExB b = (ChildExB)e; //캐스팅                     \n       b.childMethodB();\n   } else{ ... }\n}\n```\n\n그런데, 코드를 보면 이렇게 캐스팅해서 if문 쓸바에 평소대로 여러 개의 캐치문을 쓰는게 낫다\n\n\u003cbr\u003e\n\n### 에러 출력 메서드\n\n- `e.getMessage()` : 에러의 원인을 간단하게 출력\n- `e.toString()` : 에러의 Exception 내용과 원인을 출력\n- `e.printStackTrace()` : 에러의 발생 근원지를 찾아서 단계별로 에러를 출력\n\t- getMesage()와 toString()과는 다르게 printStackTrace는 리턴 값이 없다. 이 메소드를 호출하게 되면 예외 발생 당시의 호출 스택(Call stack)에 있던 메서드의 정보와 예외 결과를 화면에 출력한다. \n\n![](brain/image/dog-week02-2.png)\n\n\u003cbr\u003e\n\n### 진짜 Handling\n\n1. **catch**만 하지마라.\n\n```java\ntry {\n\t// Exception 발생 가능 로직\n} catch(???Exception e) {\n\n}\n```\n\n예외를 잡기만 하지말고, 로깅 / 복구 등 Exception에 대한 처리를 해라\n\n\u003cbr\u003e\n\n2. **catch**하고 바로 **throw** 하지마라.\n\n```java\ntry {\n\t// Exception 발생 가능 로직\n} catch(???Exception e) {\n\tthrow e;\n}\n```\n\n예외를 잡자마자 던질 것이면 왜 잡냐? 역시 로깅 / 복구 등 Exception에 대한 처리를 해라\n\n\u003cbr\u003e\n\n3. `e.printStackTrace()`는 지양하라\n\n```java\ntry {\n    // Exception 발생 가능 로직\n} catch (IOException e) {\n    e.printStackTrace()\n}\n```\n\n단순하게만 보면, Spring 서버의 콘솔에 얼마나 많은 내용이 찍히겠는가? 그 사이에서 `e.printStackTrace()` 내용을 찾기는 하늘에 별따기 일 것이다. 또, 따로 로깅을 통해서 파일에 정리해놔야 할 정도로 중요한 내용인데 단순히 출력만 했다고 에러 처리를 끝마쳤다고 볼 수는 없다.\n\n추가로, `printStackTrace()`를 지양해야하는 이유는 아래와 같다.\n\n- printStackTrace()를 call 할 경우, System.err로 쓰여져서 제어하기가 힘듦\n- printStackTrace()는 java 리플렉션을 사용하여 추적하는 것이라서 많은 오버헤드가 발생할 수 있음\n- printStackTrace()는 서버에서 스택정보를 취합하기 때문에 서버에 부하가 발생할 수 있음\n- printStackTrace()는 출력이 어디로 가는지 파악하기가 어려움. 톰캣의 경우 `catalina.out`에 남음\n- printStackTrace()는 관리가 힘듦\n\n로깅 라이브러리는 **log4j**, **logback**, **slf4j**, **commons logging** 등이 있다. 로그 패턴 및 로그 메세지를 지정 및 콘솔로그 / 파일로그 형태로 관리할 수 있다. 이런식으로 printStackTrace가 아닌 로깅을 하도록 하자. 여담으로 2021년에 log4j에서 엄청난 보안 취약점이 발견되어 세상이 뒤집어진 사건이 있었다. 대표적인 취약점 역직렬화, SQL 인젝션, 역직렬화 코드실행이 있는데 자세한건 검색해보길 바란다.\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e==코드 예시보기==\u003c/strong\u003e\u003c/summary\u003e\n\n```java\nprivate final Logger logger = LoggerFactory.getLogger(this.getClass());  \n  {  \n    try{  \n        //블라블라....  \n    } catch (FileNotFoundException e) {  \n        logger.error(\"FileNotFoundException\", e);  \n    } catch (IOException e) {  \n        logger.error(\"IOException\", e);  \n    }}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n\u003e [!note] Reflection 이란? \u003cbr\u003e\n\u003e 리플렉션은 간단하게 말하면 **구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API**이다. \u003cbr\u003e\u003cbr\u003e\n\u003e 힙 영역에 로드된 Class 타입의 객체를 통해, 원하는 클래스의 인스턴스를 생성할 수 있도록 지원하고, 인스턴스의 필드와 메소드를 접근 제어자와 상관 없이 사용할 수 있도록 지원하는 API이다. \u003cbr\u003e\u003cbr\u003e\n\u003e 여기서 로드된 클래스라고 함은, JVM의 클래스 로더에서 클래스 파일에 대한 로딩을 완료한 후, 해당 클래스의 정보를 담은 **Class 타입의 객체**를 생성하여 메모리의 힙 영역에 저장해 둔 것을 의미한다. new 키워드를 통해 만드는 객체와는 다른 것임을 유의하자.\n\n\u003cbr\u003e\n\n### printStackTrace 취약점\n\nCWE (Common Weakness Enumeration) 취약점이라는 다양한 소프트웨어 언어 및 아키텍처, 디자인 패턴, 설계 단계에 발생 가능한 취약점이라는 것이 있다. printStackTrace는 **CWE-497**에 등록된 취약점으로 매우 주의하여야 한다.\n\n**CWE-497 : Exposure of Sensitive System Information tp an authorized Control Sphere**\n\nException이 발생할 경우 콘솔에 발생지 근원부터 파일 경로 및 각종 정보들이 찍히는데, 이는 내가 아닌 외부인에게도 제공될 수 있다는 것이 큰 취약점이다. 이는 **자바 레벨의 순수 메서드까지 호출 경로가 노출이 된다**는 의미이다.\n\n따라서, printStackTrace를 사용한 경우에는 디버깅 중에 넣었던 시스템 정보 출력 코드를 반드시 **모두 삭제**하여야 한다. \n\n\u003cbr\u003e\n\n### try-with-resources\n\n자세한 내용은 \u003ca href='https://mangkyu.tistory.com/217' target='_blank'\u003e링크\u003c/a\u003e를 참고하자. 설명이 너무 잘되어있다.\n\n- `try-catch-finally`문에서 resources를 사용 후 반납하는 과정에서 여러 문제점이 있다.\n\t- 자원 반납에 의해 코드가 복잡해짐\n\t\t- Null 검사 귀찮게 해야해서\n\t- 실수로 자원을 반납 못함\n\t- 에러로 반납 못함\n\t- 에러 스택 트레이스가 누락되어 디버깅 어려움\n\n- `try-with-resources`를 이용하여 문제점을 해결하자.\n\t- 코드를 간결하게 만들 수 있음\n\t- 번거로운 자원 반납 안해도 됨\n\t- 실수로 자원 반납 못하는 경우 방지\n\t- 에러로 자원 반납 못하는 경우 방지\n\t- 모든 에러에 대한 스택 트레이스 남길 수 있음\n\n그냥 `try ( 여기에서 resources 생성 )`하면 바로 try-with-resources를 사용하는 것이다. 이는 Java에서 ==AutoCloseable 인터페이스를 구현==하고 있는 자원에 대하여 지원한다. 재미있는 점은, AutoCloseable 인터페이스는 Java 7 이전에 있던 기존의 Closeable 인터페이스에 **부모 인터페이스로 추가된 것**이라서 하위 호환성을 100% 달성했다.\n\n```java\npublic interface Closeable extends AutoCloseable {  \n    public void close() throws IOException;  \n}  \n  \npublic interface AutoCloseable {  \n    void close() throws Exception;  \n}\n```\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e==코드 예시보기==\u003c/strong\u003e\u003c/summary\u003e\n\n- `try-catch-finally`\n\n```java\npublic static void main(String args[]) throws IOException {  \n    FileInputStream is = null;  \n    BufferedInputStream bis = null;  \n    \n    try {  \n        is = new FileInputStream(\"file.txt\");  \n        bis = new BufferedInputStream(is);  \n        int data = -1;  \n        while((data = bis.read()) != -1){  \n            System.out.print((char) data);  \n        }    \n    } finally {  \n        // close resources  \n        if (is != null) is.close();  \n        if (bis != null) bis.close();  \n    }\n}\n```\n\n- `try-with-resources`\n\n```java\npublic static void main(String args[]) throws IOException {  \n    try (FileInputStream is = new FileInputStream(\"file.txt\"); BufferedInputStream bis = new BufferedInputStream(is)) {  \n        int data;  \n        while ((data = bis.read()) != -1) {  \n            System.out.print((char) data);  \n        }    \n    }\n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n### try-catch 성능\n\ntry-catch문을 많이 사용한다면 성능이 어떻게 될 지 의문점을 가졌었다.\n\n-   \u003ca href='https://stackoverflow.com/questions/16451777/is-it-expensive-to-use-try-catch-blocks-even-if-an-exception-is-never-throw' target='_blank'\u003e스택오버플로 게시글\u003c/a\u003e에서도  `try-catch는 성능에 별 영향을 끼치지 않는다 vs JVM이 일부 최적화를 수행하지 못하도록 하기 때문에 영향이 있을 수 있다`로 의견이 좀 갈리는 듯 하였다.\n- \u003ca href='https://january-diary.tistory.com/entry/JAVA-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC%EC%9D%98-%EB%B9%84%EC%9A%A9' target='_blank'\u003e다른 게시글\u003c/a\u003e에서는 예외를 만들어내는 비용이 크기 때문에 무분별한 남용을 지양하자고 하였다.\n-   try문 자체는 성능에 영향을 끼치지 않고 exception thread stack을 채우는데 걸리는 시간을 영향에 끼친다고 하는건가? e.printStackTrace 할 때 그것\n\n\u003e [!note] 결론부터 말하겠다 \u003cbr\u003e\n\u003e try-catch 성능저하에 대한 의문점에 답은 예외처리를 했을때와 안했을때 실행시간 차이가 있기는 하지만, 예외처리가 필수로 해야하는 부분은 어쩔수 없고 그렇다고해서 예외처리를 안 할 수 없어서 어느정도는 감안하고 사용한다. \u003cbr\u003e\u003cbr\u003e\n\u003e 그리고, **생각보다 실행시간 차이가 크지 않아서, 성능 이슈는 사실 상관없다. 불필요한 예외처리는 비용이 발생하므로, 적절하게 사용하되 방어코드를 사용하는 것이 비용이 덜 소모된다.** \u003cbr\u003e\u003cbr\u003e\n\u003e \u003ca href='https://jojoldu.tistory.com/58' target='_blank'\u003e향로님의 성능 비교 링크\u003c/a\u003e\n\n\u003cbr\u003e\n\n여기서부터는 고민의 과정일 뿐, 참고만 하자\n\n**Q. try-catch 성능에 관하여**\n\n-   Java에서 try-catch 블록을 사용하면 특히 코드의 중요한 섹션에서 try-catch 블록을 사용하는 경우 성능에 영향을 줄 수 있다고 한다.\n-   try-catch 블록이 발생하면 Java는 예외가 발생했는지 여부와 예외를 잡아서 처리해야 하는지 여부를 결정하기 위해 추가 검사를 수행해야 하는데, 이 추가 오버헤드로 인해 코드 실행 속도가 느려질 수 있다.\n-   **그러나 try-catch 블록이 초당 수백만 번 실행되지 않는 한 일반적으로 try-catch 블록의 성능 영향은 최소로 간주된다. 대부분의 경우 예외를 처리하기 위해 try-catch 블록을 사용하는 이점이 약간의 성능 저하보다 크다.**\n-   또한 try-catch 블록의 기본 목적은 예외 상황을 처리하고 예기치 않은 오류가 발생해도 프로그램이 계속 실행되도록 하는 것임을 기억하는 것이 중요하다. 따라서 일반적으로 try-catch 블록을 피함으로써 발생할 수 있는 작은 성능 향상보다 코드 명확성과 정확성을 우선시하는 것이 좋다.\n-   요약하면 try-catch 블록을 많이 사용하면 성능에 약간의 영향을 줄 수 있지만 일반적으로 최소한의 것으로 간주되며 대부분의 응용 프로그램에서 중요한 문제가 아니다.\n\n\u003cbr\u003e\n\n**Q. Java에서 try-catch 문의 성능 부하를 줄이는 방법에 관하여**\n\nJava에서 try-catch 블록의 성능 영향은 일반적으로 최소로 간주되지만 성능 오버헤드를 추가로 줄이는 데 사용할 수 있는 몇 가지 전략이 있다.\n\n1.  필요한 경우에만 try-catch 블록 사용 : 예외가 발생할 가능성이 있는 경우에만 try-catch 블록을 사용하는 것이 좋다. 예외가 발생할 가능성이 없는 상황과 같이 불필요하게 사용하지 마라.\n2.  try-catch 블록의 범위 제한 : try-catch 블록의 범위를 가능한 가장 작은 코드 블록으로 제한하라. 이렇게 하면 try-catch 블록 내에서 실행해야 하는 코드의 양을 줄이는 데 도움이 되어 성능 오버헤드를 줄일 수 있습니다.\n3.  조건문 사용: 경우에 따라 try-catch 블록이 필요하지 않도록 조건문을 사용할 수 있다. 예를 들어 예외를 발생시키는 조건을 확인하고 try-catch 블록 내에서 잠재적으로 예외를 발생시킬 수 있는 코드만 실행할 수 있다.\n4.  올바른 예외 처리 메커니즘 사용: Java에는 Checked Exception, Unchecked Exception 및 error와 같은 몇 가지 예외 처리 메커니즘이 있는데, 상황에 맞는 메커니즘을 사용하면 try-catch 블록의 성능 오버헤드를 줄이는 데 도움이 될 수 있다.\n5.  로깅 프레임워크 사용: 예외를 발생시키는 대신 로깅 프레임워크를 사용하여 오류를 기록하고 실행을 계속할 수 있다. 이것은 프로그램이 예외를 처리하기 위해 호출 스택을 중지하고 해제할 필요가 없기 때문에 try-catch 블록의 성능 오버헤드를 줄이는 데 도움이 될 수 있다.\n\n전반적으로 try-catch 블록의 성능 오버헤드를 줄일 수 있지만 이를 사용하는 주요 목표는 프로그램이 예외 상황을 처리하고 계속 실행되도록 하는 것임을 기억하는 것이 중요하다. 따라서 정확하고 신뢰할 수 있는 소프트웨어의 필요성과 성능 고려 사항의 균형을 맞추는 것이 중요하다.\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## TOPIC 02 - Spring에서는?\n\n몇몇 자바 파일에서 예외 처리하는 것을 넘어, 서버 규모로 넘어가면 어떻게 될까?\n- 예외처리 해야하는 부분이 매우 많아진다. =\u003e `try-catch`문 남용\n\t- 가독성 저하 : 일반 코드를 예외 처리 코드로 만들면, 코드 본래 목적 혼란스러움\n\t- 부작용 발생 : 예외가 발생해도 무시될 수 있어서 개발자가 모르는 부작용 발생, 디버깅 어려워짐\n\n그렇다면, Spring에서는 어떻게 try-catch문을 줄이면서 Exception Handling을 할 수 있을까?\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 스프링 예외처리\n\n스프링의 처리과정을 보면 예외처리가 발생하는 부분은 크게 2가지로 나눌 수 있다.\n1. Dispatcher Servlet 내에서 발생하는 예외 (Controller, Service, Repository 등)\n2. Dispatcher Servlet 전의 Filter에서 발생하는 예외\n\nDispatcher Servlet은 ==클라이언트에게 요청을 받아  MVC 처리과정을 통제하는== 것이다. Dispatcher Servlet 내에서라는 의미는 Spring 영역에서의 예외처리를 뜻하는 것이고, Disaptcher Servlet 전은 Spring 영역의 바깥에서 예외처리를 뜻하는 것이다. \n\n\u003cbr\u003e\u003cbr\u003e\n\n### Dispatcher Servlet 내에서\n\nDispatcher Servlet 내의 Spring에서 예외처리는 ==HandlerExceptionResolver==가 담당한다.\n\n![](brain/image/dog-week02-3.png)\n\n1. 메서드 단위에서 Handling\n2. Controller Level에서 Handling\n3. Global Level에서 Handling\n\n\u003cbr\u003e\n\n==**메서드 단위 : try-catch**==\n\n메서드 단위는 기존 하던 방법에서 `try-catch`를 이용하여 Exception Handling하는 과정이다. 그러나, 프로그램의 규모가 커지고 try-catch가 많아져서 가독성 저하, 부작용 발생 등의 단점이 생겨난다면 어떻게 해야할까 ?\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**Controller Level에서 Handling : @ExceptionHandler**==\n\n메서드 하나하나의 예외처리가 아닌, 컨트롤러 레벨에서 예외 처리를 진행한다. 즉, 컨트롤러에서 발생하는 예외를 공통적으로 처리해주는 기능을 이용한 것이다. 이때 `@ExceptionHandler` 애노테이션을 사용하여 **Controller의 메서드에서 throw된 Exception에 대한 공통적인 처리**를 할 수 있다.\n\n-   Controller 메서드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메서드 상위까지 예외를 throw 시키면 `@ExceptionHandler` 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.\n-   Controller 메서드 내의 하위 서비스에서 Unchecked Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다\n\n여기에서 나아가, 여러 Controller에서 같은 Exception이 발생하는 경우에, 전체적으로 처리하려면 어떻게 해야할까?\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**Global Level에서 Handling : @ControllerAdvice**==\n\n여러 Controller에서 발생하는 예외를 전역적으로 처리할 수 있다.\n\n- @ControllerAdvice\n\t- 모든 Controller에서 발생하는 예외를 처리하는 애노테이션\n\t- DispatcherServlet에서 발생하는 예외를 전역적으로 처리\n\t- Exception 처리 이후 Error Page 등을 통해 처리가 가능\n- @RestControllerAdvice\n\t- REST API에 대한 Exception 처리 용이\n\t- @ControllerAdvice + @ResponseBody\n\n\u003cbr\u003e\n\n\u003e [!note] 어떤 @ExceptionHandler가 먼저 실행? \u003cbr\u003e\n\u003e Controller 클래스 내의 @ExceptionHandler \u003cbr\u003e\n\u003e @ControllerAdvice 클래스 내의 @ExceptionHandler \u003cbr\u003e\n\u003e 둘 중 어떤 것이 먼저 실행될까? \u003cbr\u003e\u003cbr\u003e\n\u003e =\u003e  **Controller 내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.**  더 상위로 Exception을 throw하더라도 **@ControllerAdvice의 @ExceptionHandler에서 예외처리를 하지 않는다.**\n\n\u003cbr\u003e\n\n### HandlerExceptionResolver\n\nDispatcher Servlet 내에서 예외가 발생했을 때 HandlerExceptionResolver이 처리한다고 했다. 이를 자세히 들여다겠다.\n\n- HandlerExceptionResolver는 Controller의 작업 중 발생한 예외를 어떻게 처리할 지에 대한 전략이다.\n- Controller에서 Exception이 발생하면 Controller 밖으로 던져짐\n- 예외가 발생하면 ExceptionResolver가 발동\n- Dispatcher Servlet 내부에 등록된 3가지가 순서대로 실행\n\t1. ExceptionHandlerExceptionResolver\n\t2. ResponseStatusExceptionResolver\n\t3. DefaultHandlerExceptionResolver\n\n\u003cbr\u003e\n\n==**ExceptionHandlerExceptionResolver**==\n\nSpring 3.2의 AnnotationMethodExceptionResolver가 deprecated 처리되었고 Spring 4.0부터 사용하고 있는 ExceptionHandlerExceptionResolver이다. `@ExceptionHandler` 애노테이션에 관한 Resolver 클래스이다.\n\n1. 예외가 발생한 Controller 안에 적합한 @ExceptionHandler가 있는지 검사\n2. Controller의 @ExceptionHandler에서 처리가 가능하다면 처리하고, 그렇지 않으면 @ControllerAdvice로 넘어감\n3. @ControllerAdvice에 적합한 @ExceptionHandler가 있는지 검사하고 없으면 다음 Resolver로 넘어감\n\n\u003cbr\u003e\n\n==**ResponseStatusExceptionResolver**==\n\nException에 대한 HTTP 응답을 설정해줄 수 있다. 단순히 internal-server-error인 500 에러 대신 더 구체적인 응답 상태값을 전달해줄 수 있다.\n\n1. @ResponseStatus가 있는지 혹은 ResponseStatusException인지 검사\n2. 있다면 ServletResponse의 sendError()로 예외를 Servlet까지 전달하고 Servlet이 BasicErrorController로 요청을 전달\n\n\u003cbr\u003e\n\n\u003e [!note] ResponseStatusException?  \u003cbr\u003e\n\u003e 외부 라이브러리를 사용하는 경우, @ResponseStatus 애노테이션으로 직접적으로 수정할 수 없는 상황이 있다. 이때, 상태값에 관하여 직접 핸들링하고 싶은 경우에는 ResponseStatusException을 사용하여 처리한다.\n\n\n\u003cbr\u003e\n\n==**DefaultHandlerExceptionResolver**==\n\n위의 두 Resolver로도 처리가 안된다면 DefaultHandlerExceptionResolver를 사용하여 내부적으로 Spring 표준 예외처리를 해준다. 각 상황에 맞는 응답 코드를 반환하는 역할이다.\n\n- Request URL에 맞는 Controller를 찾지 못한 경우 - **404 Not Found**\n- Controller 메서드 실행 중 예외가 발생하는 경우 - **500 Internal Server Error**\n- Controller의 파라미터 형식이 잘못된 경우 - **400 Bad Request**\n\n1. Spring의 내부 예외인지 검사하여 맞으면 Exception을 처리하고 아니면 넘어감\n2. 적합한 ExceptionResolver가 없으므로 예외가 Servlet까지 전달되고, Servlet은 SpringBoot가 진행한 자동 설정에 맞게 BasicErrorController로 요청을 다시 전달\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Dispatcher Servlet 외부에서\n\n스프링 영역이 아닌 외부에서 발생하는 Exception은 어떻게 처리해야할까? 이를 말하기에 앞서서 스프링 영역의 컨트롤러 단에서 예외가 발생한 경우, 전체적인 흐름을 먼저 살펴보자.\n\n![](brain/image/dog-week02-4.png)\n\nSpring MVC request life cycle을 보면, 아래와 같이 흐름이 생긴다.\n- ==WAS -\u003e 필터 -\u003e 서블릿 -\u003e 인터셉터 -\u003e 컨트롤러(예외발생)==\n- ==WAS \u003c- 필터 \u003c- 서블릿 \u003c- 인터셉터 \u003c- 컨트롤러==\n\n그렇다면, Dispatcher Servlet 내부인 Spring 영역에서는 HandlerExceptionResolver를 이용하여 다양한 예외 처리를 하는데, **외부인 Filter 단에서 예외가 발생하면 어떻게 처리해야할까?**\n\n\u003cbr\u003e\n\n![](brain/image/dog-week02-5.png)\n\n이 그림을 봤을 때, Filter 단에서 예외가 발생하면 애초에 ==스프링 영역으로 들어가지 못하고, 튕겨져 나온다.== 하지만, `@HandlerException`, `@ControllerAdvice`와 같은 예외 처리는 Spring에서 제공하는 애노테이션이라서 스프링 영역이 아닌 필터에서는 사용할 수 없다.\n\n\u003cbr\u003e\n\n![](brain/image/dog-week02-6.png)\n\n이러한 경우에는 ==Filter에서 try-catch 문으로 예외를 잡아서 처리한다.== 위 그림의 예시로는 `doFilter()` 메서드를 try-catch로 잡아서 그 시점에 발생한 예외를 곧바로 handling 하는 것이다.\n\n\u003cbr\u003e\n\n### Filter에서 처리하는 예외\n\n1. **(가장중요) 모든 요청에 대한 로깅**\n2. 보안 관련 공통 작업 (JWT)\n3. ServletRequest 커스터마이징\n4. 이미지/데이터 압축 및 문자열 인코딩\n\n이중, 모든 요청에 대한 로깅은 특히 중요한데, 말 그대로 request, response 등 모든 처리에 관하여 로깅할 수 있다.\n\n\u003cbr\u003e\n\n## 참고자료\n\n- \u003ca href='https://cheese10yun.github.io/spring-guide-exception/#null' target='_blank'\u003e(가장 쓸만할 듯)프로젝트에 적용하면 좋을 실제 Spring 예외\u003c/a\u003e\n- \u003ca href='https://www.nextree.co.kr/p3239/' target='_blank'\u003e자바에서의 Exception Handling 3가지 방법\u003c/a\u003e\n- \u003ca href='https://catsbi.oopy.io/92cfa202-b357-4d47-8de2-b9b3968dfb2e' target='_blank'\u003e종합적인 예외처리 설명\u003c/a\u003e\n- \u003ca href='https://jaehun2841.github.io/2018/08/30/2018-08-25-spring-mvc-handle-exception/#ResponseStatusExceptionResolver' target='_blank'\u003eSpring Handler Exception\u003c/a\u003e\n- \u003ca href='https://github.com/binghe819/TIL/blob/master/Spring/%EA%B8%B0%ED%83%80/%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC%20%EA%B0%9C%EB%85%90%20%EB%B0%8F%20%EC%A0%84%EB%9E%B5.md' target='_blank'\u003e스프링 예외처리 개념 전략\u003c/a\u003e\n- \u003ca href='https://velog.io/@backtony/면접-시리즈2-Spring-JPA' target='_blank'\u003eSpring-JPA 면접시리즈\u003c/a\u003e\n- \u003ca href='https://terasolunaorg.github.io/guideline/5.3.0.RELEASE/en/ArchitectureInDetail/WebApplicationDetail/ExceptionHandling.html#exception-handling-basic-flow-label' target='_blank'\u003e(원본)Exception Handling Guideline\u003c/a\u003e\n- \u003ca href='https://steady-coding.tistory.com/601' target='_blank'\u003eFilter vs Interceptor\u003c/a\u003e\n- \u003ca href='https://velog.io/@wonizizi99/SpringSpring%EC%9D%98-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-%ED%9D%90%EB%A6%84' target='_blank'\u003eSpring에서의 예외 처리 흐름도\u003c/a\u003e\n- \u003ca href='https://jhkimmm.tistory.com/29' target='_blank'\u003eFilter 내에서 발생한 예외 처리하기\u003c/a\u003e\n- \u003ca href='https://beemiel.tistory.com/11' target='_blank'\u003eSpring Security JWT 토큰 검증시 Exception 처리\u003c/a\u003e","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Interview/dog-study/dog-week03":{"title":"3주차 - Spring 기본","content":"\n\u003ca href='https://github.com/DevInterviewStudy/Backend-6/issues' target='_blank'\u003e3주차 스터디 Issue 바로가기\u003c/a\u003e \n\n\u003chr\u003e\n\n\u003e[!note] 3주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC** \u003cbr\u003e\n\u003e - 프레임워크란?\n\u003e - Spring 프레임워크의 정의 및 장점\n\u003e - DI (Dependency Injection)\n\u003e \t- 주입 방식\n\u003e - IoC\n\u003e - 스프링 컨테이너\n\n\u003cbr\u003e\n\n## 프레임워크란?\n\nFrame(틀, 뼈대) + work(일하다)로, 의미 그대로 해석하면 ==응용 프로그램이나 소프트웨어의 솔루션 개발을 수월하게 하기 위해 제공된 소프트웨어 환경==이다. 개발할 때, 자주 사용되는 범용적인 기능을 한꺼번에 제공하여 개발 효율의 향상을 목표하는 소프트웨어 환경이다.\n\n\u003cbr\u003e\n\n### Framework 특징\n\n-   공통적인 개발 환경을 제공한다. (개발 편의성)\n-   개발할 수 있는 범위가 정해져있다.\n-   상호협력하는 클래스와 인터페이스의 집합\n-   응용 프로그램이 **수동적**으로 프레임워크에 의해 사용된다. ( = 제어의 역전이 발생한다)\n\n\u003cbr\u003e\n\n### Library\n\nLibray는 ==응용 프로그램 개발을 위해 필요한 기능(함수)을 모아 놓은 소프트웨어==이다. \n\n- 개발하는데 필요한 것들을 모아둔 일종의 저장소\n- 필요할 때, 호출해서 사용한다.\n- 독립성을 가진다.\n- 응용 프로그램이 **능동적**으로 라이브러리를 사용한다. ( = 흐름을 제어한다. )\n\n\u003cbr\u003e\n\n### Framework vs Library\n\n둘을 바라봤을 때, 개발할 때 중복된 코드가 발생하지 않도록 필요한 것들을 모아놓았다는 측면에서 비슷해보인다. 그렇다면 둘의 차이는 어떠한가?\n\n- ==흐름을 제어하는 쪽이 어떤 쪽인지가 가장 큰 차이==\n- Framework : 내가 작성한 응용 프로그램이 프레임워크에 의해 **수동적**으로 사용된다. 제어의 흐름이 역전된 형태\n- Library : 내가 작성한 응용프로그램이 **능동적**으로 라이브러리를 사용한다. 제어의 흐름이 개발자에게 있는 형태\n\n\u003cbr\u003e\n\n## Spring 정의 및 장점\n\nSpring은 ==자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크==이다.\n\n- 경량 컨테이너로서 자바 객체를 직접 관리\n\t- 각각의 객체 생성, 소멸과 같은 Life cycle을 관리하며 Spring으로부터 필요한 객체를 얻어올 수 있다.\n- IoC(제어의 역전) 기술을 통한 애플리케이션의 **느슨한 결합** 추구\n- DI(의존성 주입)을 통한 객체 관계 구성을 지원\n- AOP(횡단 관심사 분리)를 이용하여 OOP를 보완\n- MVC 패턴로 계층을 분리하여 유지보수에 수월\n\n\u003cbr\u003e\n\n### Spring Boot\n\n이미, Spring의 장점으로도 충분해보이는데 Spring Boot 기술은 왜 나왔을까?\n\n1.  dependency\n\n\t-   Spring은 모든 dependency를 버전까지 한땀한땀 구성해야해서 매~우 길다. 하지만 Spring Boot는 매우 짧아졌고 버전 관리도 권장 버전으로 자동 설정해준다.\n\n2.  configuration\n\n\t-   Spring은 config가 매~우 길도 bean도 등록해주고 해야하는데 Spring Boot는 따로 config 파일을 작성해주지 않아도 되고 application.properties만 적용하면 된다. 최근에는 application.yml을 많이 사용한다고 한다. depth로 표현하기 때문에 훨씬 인간이 읽기 좋게 만들 수 있는 파일 형식이라고 한다.\n\n3.  embedded server\n\n\t-  서버 구동 시간이 절반 가까이 단축.\n\t-  대표적인 예시로 tomcat이 있는데, tomcat이 싫으면 jetty 써도 된다.\n\t-   `java -jar $REPOSITORY/$JAR_NAME \u0026` - 내장 서블릿 컨테이너 덕분에 jar 파일로 간단하게 배포!\n\t- 즉, Spring은 WAS가 내장되어있지 않아서, 외장 WAS를 따로 `.war`를 이용하여 함께 빌드하여야 했지만, Spring Boot에는 WAS가 내장되어 있기에 `.jar`를 이용하여 보다 빠른 빌드가 가능\n\n\u003cbr\u003e\n\n정리하자면, ==Spring Boot의 장점은 개발자들이 개발에만 더욱 집중==할 수 있도록!\n\n1.  간편한 설정 (configuration)\n2.  편리한 의존성 관리 \u0026 자동 권장 버전 관리 (dependency)\n3.  내장 서버로 인한 간단한 배포 서버 구축 (embedded server)\n4.  스프링 Security, Data JPA 등의 다른 스프링 프레임워크 요소를 쉽게 사용\n\n\u003cbr\u003e\n\n## IoC\n\nIoC(Inversion of Control)은 제어의 역전이라는 의미로 ==프로그램의 제어 흐름을 직접 제어하는 것이 아니라 프레임워크 같이 외부에서 관리하는 것==을 의미한다.\n\nIoC는 제어의 역전이라는 **원칙 그 자체**이므로, 이를 구현해줄 구현체가 필요하다. 이 중 대표적인 디자인 패턴이 아래에서 설명할 \u003ca href='/brain/Interview/dog-study/dog-week03/#DI'\u003eDI\u003c/a\u003e이다.\n\n-   IoC : 치즈떡볶이가 스스로의 재료를 결정하지 못한다는 ==**추상적인 개념**==\n-   DI : 치즈떡볶이의 재료를 외부에서 정해준다는 ==**구체적인 행위**==\n\n\u003cbr\u003e\n\n-  기존에 생성자로 생성하여 객체 생명주기나 메서드의 호출을 직접 **제어(관리)** 하는 방식\n\n```java\npublic class A { \n\tprivate B b; \n\tpublic A() { \n\t\tthis.b = new B(); \n\t} \n}\n```\n\n\u003cbr\u003e\n\n- 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 **외부에서 관리**하는 방식\n\n```java\npublic class A { \n\tprivate B b; \n\tpublic A(B b) { \n\t\tthis.b = b;\n\t} \n}\n```\n\n\u003cbr\u003e\n\n### IoC의 필요성\n\n- 객체 내부에서 제어했을 때, 변경에 자유롭지 못하던 코드가 외부의 제어를 받으면서 ==변경에 자유로운 장점==이 있다.\n- 객체지향 원칙을 잘 지키기 위해서!\n\t- 역할과 관심을 분리하여 ==객체 간 응집도를 높이고 결합도는 낮춘다.==\n\t- 이에 따라 변경에 유연한 코드를 작성할 수 있는 구조가 된다.\n\n\u003cbr\u003e\n\n예를 들어, 떡볶이를 만드는 클래스가 있다고 하자.  하지만, 아래와 같이 **객채 내에서 재료를 제어하는 경우**, 쌀떡을 밀떡으로 바꾸려고 한다면? 큰 변화가 생기는 것이다. **변경에 자유롭지 못하여 유지보수가 어려운 것**이다.\n\n- 즉, 현재는 치즈떡볶이가 스스로 자신의 상태를 결정짓는 상태!\n\n```java\npublic class Cheesetteokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic Cheesetteokbokki() {\n\t\tthis.riceTTok = new RiceTTok();\n\t\tthis.bigPa = new BigPa();\n\t\tthis.sliceOnion = new SliceOnion();\n\t\tthis.mozzarellaCheese = new MozzarellaCheese();\n\t}\n}\n```\n\n\u003cbr\u003e\n\n그럼 아래와 같이 **재료에 대한 제어를 외부로 바꾸면** 어떠한가? 쌀떡이든 밀떡이든 무엇이 들어와도 괜찮도록 변경에 자유롭게 되는 것이다.\n\n- 외부의 존재가 치즈떡볶이의 상태를 결정짓는 상태!\n\n```java\npublic class Cheesetteokbokki {\n\tTTok ttok;\n\tPa pa;\n\tOnion onion;\n\tCheese cheese;\n\n\tpublic Cheesetteokbokki(TTok ttok, Pa pa, Onion onion, Cheese cheese) {\n\t\tthis.ttok = ttok;\n\t\tthis.pa = pa;\n\t\tthis.onion = onion;\n\t\tthis.cheese = cheese;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### DIP\n\nIoC를 검색했을 때, 자주 나오는 DIP란 무엇인가? \n\n**DIP(Dependency Inversion Principle) - 의존 역전 원칙**\n- SOLID 원칙 중 D에 해당하는 부분\n- 상위 레벨의 모듈은 절대 하위 레벨 모듈에 의존하지 않는다. ( **= 둘 다 추상화에 의존해야 한다** )\n\n\u003cbr\u003e\n\n떡볶이의 예시로, 치즈 떡볶이와 일반 떡볶이가 있다고 하면, 조금 더 구체적이고 상세한 치즈 떡볶이가 고수준 모듈이고 일반 떡볶이가 저수준 모델이다.\n\n- 치즈 떡볶이(고수준 모듈) -\u003e 일반 떡볶이(저수준 모듈)\n\t- 필드가 이미 구체 클래스로 작성되어 있으면, 변경에 자유롭지 못하다.\n\t- 즉, 상위 레벨의 모듈이 하위 레벨의 모듈에 의존하면, 변경에 자유롭지 못하다는 의미이다.\n- 치즈 떡볶이 -\u003e 떡(Interface) \u003c- 일반 떡볶이\n\t- 이렇게 어떤 떡볶이든 떡이라는 추상화에 의존한다면, 쌀떡이든 밀떡이든 변경이 일어나도 자유롭게 수정할 수 있다.\n\n\u003cbr\u003e\n\n### IoC와 DIP\n\nIoC와 DIP의 목적\n- 클래스 간 결합을 느슨히 하기 위함\n\t- 한 클래스의 변경에 따른 클래스들의 영향을 최소화\n- 이로 인하여, 애플리케이션을 지속가능하고 확장성 있게 만듬.\n\nIoC와 DIP는 모두 **principle(원칙)**이다.\n- IoC는 ==제어의 역전==\n- DIP는 ==의존 방향의 역전==\n\n\u003cbr\u003e\n\n1. 객채 내에서 제어권을 가진 경우 (개발자가 제어권 가짐)\n\n```java\npublic class Cheesetteokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic Cheesetteokbokki() {\n\t\tthis.riceTTok = new RiceTTok();\n\t\tthis.bigPa = new BigPa();\n\t\tthis.sliceOnion = new SliceOnion();\n\t\tthis.mozzarellaCheese = new MozzarellaCheese();\n\t}\n}\n```\n\n2. 제어권이 외부로 넘어감 (제어의 역전, IoC 적용)\n\n```java\npublic class Cheeseeokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic void inject(RiceTTok riceTTok, BigPa bigPa, SliceOnion sliceOnion, MozzarallaCheese mozzarellaCheese) {\n\t\tthis.riceTTok = riceTTok;\n\t\tthis.bigPa = bigPa;\n\t\tthis.sliceOnion = sliceOnion;\n\t\tthis.mozzarellaCheese = mozzarellaCheese;\n\t}\n}\n```\n\n3. 단, 외부에서 주입한다고 해도 쌀떡, 밀떡 종류마다 넣어야하는 고수준 모듈이 저수준 모듈에 의존하는 상태이기 때문에, 이를 추상화에 의존하도록 바꾼다. (의존 방향의 역전, DIP 적용)\n\n```java\npublic class Cheesetteokbokki {\n\tTTok ttok;\n\tPa pa;\n\tOnion onion;\n\tCheese cheese;\n\n\tpublic Cheesetteokbokki(TTok ttok, Pa pa, Onion onion, Cheese cheese) {\n\t\tthis.ttok = ttok;\n\t\tthis.pa = pa;\n\t\tthis.onion = onion;\n\t\tthis.cheese = cheese;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n## DI\n\nDI(Dependency Injection)\n- 원칙일 뿐인 IoC를 구현하기 위한 구현체 중 대표적인 디자인 패턴이 DI\n- 클래스 간에 의존 관계가 있다는 것\n- 한 클래스가 바뀔 때 다른 클래스가 영향을 받는다는 것\n\n==변경에 의해 영향을 받는 \"의존성\"을 외부에서 주입해주는 것==이 바로 DI이다.\n\n\u003cbr\u003e\n\n### 생성자 주입\n\n- 생성자 호출 시 외부로부터 의존성을 주입받는 방법\n- 필요한 의존성을 모두 포함하는 생성자를 만들고, 그 생성자를 통해서 의존성을 주입한다.\n\n```java\npublic class Cheeseeokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic void inject(RiceTTok riceTTok, BigPa bigPa, SliceOnion sliceOnion, MozzarallaCheese mozzarellaCheese) {\n\t\tthis.riceTTok = riceTTok;\n\t\tthis.bigPa = bigPa;\n\t\tthis.sliceOnion = sliceOnion;\n\t\tthis.mozzarellaCheese = mozzarellaCheese;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### Setter 주입\n\n- 의존성을 주입받는 setter 메서드를 만들고 이 메서드들을 호출해서 의존성을 주입한다.\n\n```java\npublic class Cheeseeokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic void setRiceTTok(RiceTTok riceTTok) {\n\t\tthis.riceTTok = riceTTok;\n\t}\n\t\n\tpublic void setBigPa(BigPa bigPa) {\n\t\tthis.bigPa = bigPa;\n\t}\n\t\n\tpublic void setSliceOnion(SliceOnion sliceOnion) {\n\t\tthis.sliceOnion = sliceOnion;\n\t}\n\t\n\tpublic void setMozzarallaChees(MozzarallaCheese mozzarellaCheese) {\n\t\tthis.mozzarellaCheese= mozzarellaCheese;\n\t}\n\n}\n```\n\n\u003cbr\u003e\n\n### Interface 주입\n\n-   의존성을 주입하는 메서드를 포함한 인터페이스를 작성하고, 이 인터페이스를 구현하도록 함으로써 실행 시 이를 통해서 의존성을 주입\n-   Setter 주입처럼 메서드를 외부에서 호출해줘야 하는 것은 비슷하지만, 의존성 주입을 빠뜨릴 수 있는 Setter 주입과는 다르게 Override를 통해 메서드 구현을 강제할 수 있다는 차이가 있다.\n\n```java\npublic class Cheeseeokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic void inject(RiceTTok riceTTok, BigPa bigPa, SliceOnion sliceOnion, MozzarallaCheese mozzarellaCheese) {\n\t\tthis.riceTTok = riceTTok;\n\t\tthis.bigPa = bigPa;\n\t\tthis.sliceOnion = sliceOnion;\n\t\tthis.mozzarellaCheese = mozzarellaCheese;\n\t}\n\n\tinterface RecipeInjection {\n\t\tvoid inject(RiceTTok riceTTok, BigPa bigPa, SliceOnion sliceOnion, MozzarallaCheese mozzarellaCheese);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n여기까지 하면 의존성이 주입되기는 한 상태이다. 하지만 여전히 구체적인 Cheeseeokbokki 클래스를 구현하고 있는 것으로 보아 변경에 자유롭지 못해보인다. 지금까지는 “의존성을 주입”하는 방법만 생각했다면, 이제 **의존성 분리**를 생각해보자.\n\n의존성 분리 : DIP를 이용해 의존 관계를 분리시킨다.\n-   상위 계층이 하위 계층에 의존하는 상황을 Interface를 이용해 반전시켜 하위계층의 구현으로부터 독립시킨다.\n\n```java\npublic class Cheesetteokbokki {\n\tTTok ttok;\n\tPa pa;\n\tOnion onion;\n\tCheese cheese;\n\n\tpublic Cheesetteokbokki(TTok ttok, Pa pa, Onion onion, Cheese cheese) {\n\t\tthis.ttok = ttok;\n\t\tthis.pa = pa;\n\t\tthis.onion = onion;\n\t\tthis.cheese = cheese;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n## Spring DI\n\n-   MemberService라는 의존성을 주입받는 MemberController\n    -   생성자를 통해 의존성 주입받는 중\n    -   특정한 MemberService를 받는 생성자가 어딘가에서 호출되어야 하겠네\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class MemberController {\n\tprivate final MemberService memberService;\n\n\tpublic MemberController(MemberService memberService) {\n\t\tthis.memberService = memberService;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n하지만, MemberController보다 상위의 어떤 코드를 살펴봐도 MemberController 생성시 MemberService 인스턴스를 주입하는 코드가 없는 것을 확인할 수 있다. 그러면 우리가 어떻게 사용할까?\n\n\u003cbr\u003e\n\n```java\n@SpringBootApplication\npublic class DiApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DiApplication.class, args);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n스프링이 자동으로 의존성을 주입해주기 때문이다. ==**스프링 Bean으로 등록되면 스프링이 자동으로 생성해주는데 이때 필요한 의존성도 주입해준다.**== 그렇다면, 어떻게 해야 스프링이 자동으로 의존성을 주입할 수 있게 해줄까?\n\n\u003cbr\u003e\n\n\u003e **@Autowired 애노테이션**\n\u003e -   여기에 의존성을 주입해달라는 뜻\n\u003e -   스프링이 자동으로 적절한 의존성을 주입해줌\n\n\u003cbr\u003e\n\n### (Spring) 필드 주입\n\n-   스프링을 적용하지 않은 DI의 방법에는 없던 방법\n-   원래는 불가능한 주입을 프레임워크의 힘을 빌려 주입하는 방법\n-   하지만, 필드 주입은 추천되는 방법이 아님 (인텔리제이도 경고함)\n    -   필드주입을 사용하면 테스트 등의 이유로 자동이 아닌 수동 의존성 주입하고 싶어도 ==**생성자도, setter도 없으므로 개발자가 직접 의존성을 넣어줄 수 없다.**==\n    -   이는 ==**의존성이 프레임워크에 강하게 종속된다는 문제점**==이 있다는 것\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class MemberController {\n\t@Autowired\n\tprivate MemberService memberService;\n}\n```\n\n\u003cbr\u003e\n\n### (Spring) Setter 주입\n\n-   setter 메서드에 @Autowired를 붙이면 스프링이 setter를 사용해서 자동으로 의존성을 주입해줌\n-   이때, Bean 객체를 만들고 setter로 의존성을 주입해주기 때문에 Bean 생성자 혹은 Bean 정적 팩토리 메서드가 필요하다.\n    -   ==이때문에 final 필드를 만들 수 없고 의존성의 불변을 보장할 수 없다는 특징이 있다.==\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class MemberController {\n\tprivate MemberService memberService;\n\n\t@Autowired\n\tpublic void setMemberService(MemberService memberService) {\n\t\tthis.memberService = memberService;\n\t}\n}\n```\n\n\u003cbr\u003e\n\nsetter 주입은 왜 존재할까?\n- 런타임에 setter를 다시 호출하면 주입해줬던 의존성을 다시 변경할 수 있을 것이다. \n- 그래서, 주로 런타임에 의존성을 수정해야 하거나 의존성을 선택적으로 주입할 때 사용한다.\n\n\u003cbr\u003e\n\n### (Spring) 생성자 주입\n\n-   생성자 주입을 사용하면 객체의 최초 생성 시점에 스프링이 의존성을 주입해준다.\n-   스프링에서 공식적으로 추천하는 방법. Spring 4.3 버전 이후 ==**생성자가 1개밖에 없을 경우 해당 생성자에 스프링이 자동으로 @Autowired를 붙여주기 때문에 애노테이션 생략이 가능**==하다.\n-   스프링 공식문서에서는 생성자 주입 + Setter 주입을 혼용할 수 있지만 생성자 주입을 추천한다고 한다.\n-   setter 주입은 선택적 의존성에 사용하라고 한다.\n    -   생성자 주입된 컴포넌트들이 완전히 초기화된 상태로 클라이언트에 반환되기 때문이라고 함.\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class MemberController {\n\tprivate final MemberService memberService;\n\n\tpublic MemberController(MemberService memberService) {\n\t\tthis.memberService = memberService;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### 생성자 주입 장점\n\n1.  **생성자 주입을 사용하면 필드를 final로 만들어줄 수 있고 의존성 주입이 생성자 호출 시 최초 1회만 이루어지기 때문에 의존 관계를 불변으로 만들어줄 수 있는 장점이 있다.**\n    \n2.  final이 가능하기 때문에 `NullPointerException` 을 방지할 수 있다.\n    -   필드 주입, setter 주입의 경우 스프링의 빈 관리 기능을 빌리지 않고 new 키워드로 직접 객체를 생성할 경우 NullPointerException이 발생할 수 있다.\n        -   왜냐하면, 이들은 빈 생성자를 사용해서 기본적으로 의존성이 없는 상태니까\n    -   하지만, 생성자 주입은 객체 생성 시점에 모든 의존성을 주입해주므로 Null을 의도적으로 넣지 않는 한 NullPointerException을 방지할 수 있다.\n\n3.  순환참조 문제 방지 가능\n    -   필드 주입, setter 주입의 경우 A객체 → B 객체 의존하는데 B객체 또한 A객체를 의존하는 순환참조 문제가 발생할 수 있다.\n    -   생성자 주입을 사용하는 객체들끼리 의존성이 순환되면, 스프링은 에러메세지와 함께 프로그램을 종료한다.\n\n\u003cbr\u003e\n\n```java\n@Component\npublic class A {\n\t@Autowired\n\tprivate B b;\n\n\tpublic void doSomething() {\n\t\tb.doSomething();\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\n@Component\npublic class B {\n\t@Autowired\n\tprivate A a;\n\n\tpublic void doSomething() {\n\t\ta.doSomething();\n\t}\n}\n```\n\n- 순환호출이 반복되다가 스택오버플로우 에러가 발생해서 프로그램이 멈출 것\n\t- 생성자 주입을 이용하면 애플리케이션 시작 타이밍에 에러를 통해 방지!\n\t- 근데, 스프링부트 2.6 버전부터는 필드 주입이나 setter 주입도 기본 설정으로 순환참조 방지됨\n\n\u003cbr\u003e\n\n### 생성자가 여러 개\n\n**생성자가 여러 개인 경우 어떻게 해야할까?**\n-   의존성을 자동으로 주입하는데 사용할 생성자에 @Autowired 붙이기\n-   @Autowired가 여러 개 있을 경우, 스프링은 가장 많은 의존성을 주입할 수 있는 생성자를 사용해서 의존성을 주입한다.\n-   @Autowired가 붙은 모든 생성자가 사용 불가능하거나 어떤 생성자에도 @Autowired가 없을 경우에는 기본 생성자를 호출한다.\n-   기본 생성자조차 없으면 컴파일 에러 발생\n\n**의존성 주입 순서**\n\n생성자 → 필드 → setter\n\n\u003cbr\u003e\n\n### 주입하고자 하는 의존성이 여러 개\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class PayController {\n\tprivate final PayService payService;\n\n\tpublic PayController(PayService naverPayService) {\n\t\tthis.payService = naverPayService;\n\t}\n}\n```\n\n-   결제를 담당하는 payService 인터페이스가 있다고 하자.\n    -   구현체인 네이버 페이 서비스와, 카카오 페이 서비스가 있음\n    -   모두 Bean으로 등록되어있음\n-   payController에서는 어떤 거를 주입받아야할까?\n    -   그대로 시작하면 애플리케이션 실패되면서 에러가 뜬다.\n\n\u003cbr\u003e\n\n1.  스프링은 의존성 주입 대상을 찾을 때 **정의되어 있는 타입을 기준**으로 찾는다. 현재는 PayService라는 타입으로 검색된다.\n2.  이렇게 타입을 기준으로 여러 Bean이 검색되었다면, 스프링은 Bean의 이름을 기준으로 의존성을 주입한다.\n    -   이때, 주입하는데 사용되는 메서드의 매개변수 명과 등록된 빈의 이름이 일치하는지 체크한다.\n    -   생성자 매개변수 명을 naverPayService로 바꿔주면, 자동으로 naverPayService 빈이 주입되고 생성에 성공한다.\n    -   하지만, 이런식으로 매개변수 명을 바꿔버리면 수동으로 kakaoPayService를 주입해야하는 경우에 헷갈리고 자동으로 주입하는 빈을 바꿀때도 귀찮을 것\n3.  스프링이 제공하는 @Qualifier 애노테이션 사용\n\n\u003cbr\u003e\n\n```java\n@Service\n@Qualifier(\"mainPayService\")\npublic class NaverPayService implements PayService {\n\n}\n```\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class PayController {\n\tprivate final PayService payService;\n\n\tpublic PayController(@Qualifier(\"mainPayService\") PayService payService) {\n\t\tthis.payService = payService;\n\t}\n}\n```\n\n-   @Qualifier 애노테이션 안에 해당 빈의 구분자를 지정할 수 있음\n-   NaverPayService에 `@Qualifier(\"mainPayService\")` 를 붙여서 지정\n-   의존성을 주입받을 부분에 동일하게 @Qualifier 애노테이션 작성하면 네이버 페이 서비스가 주입된다.\n\n\u003cbr\u003e\n\n4. 스프링이 제공하는 @Primary 애노테이션 사용\n\n\u003cbr\u003e\n\n```java\n@Service\n@Primary\npublic class NaverPayService implements PayService {\n\n}\n```\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class PayController {\n\tprivate final PayService payService;\n\n\tpublic PayController(PayService payService) {\n\t\tthis.payService = payService;\n\t}\n}\n```\n\n- @Primary 애노테이션이 붙은 빈은 해당 타입으로 의존성을 검색할 때 우선적으로 주입된다. 일종의 기본 빈이 되는 것이다.\n\n\u003cbr\u003e\n\n5.  @Qualifier vs @Primary\n    -   @Qualifier가 @Primary보다 우선권을 가짐\n\n\u003cbr\u003e\n\n**스프링 의존성 주입 기준**\n\n타입 → @Qualifier → @Primary → 변수 명\n\n\u003cbr\u003e\n\n## 스프링 컨테이너\n\n스프링 컨테이너\n- ==**IoC와 DI의 원리가 이 스프링 컨테이너에 적용**==\n- 자바 객체의 생명 주기를 관리\n- 생성된 자바 객체들에게 추가적인 기능을 제공하는 역할\n- 대표적으로 BeanFactory, ApplicationContext가 있음\n\t- 둘 다 Bean을 등록하고 생성하고 조회하고 돌려주는 등 Bean을 관리하는 역할\n\t- ApplicationContext가 BeanFactory의 빈 관리 기능들을 상속받았고, 그 외에 국제화 등의 추가적인 기능을 갖고 있어 스프링 컨테이너라고 하면 보통 ApplicationContext라고 한다.\n\n\u003cbr\u003e\n\n## 참고\n\n- https://www.youtube.com/watch?v=8lp_nHicYd4","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Interview/dog-study/dog-week04":{"title":"4주차 - Spring 웹","content":"\n\u003chr\u003e\n\n\u003e[!note] 4주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC** \u003cbr\u003e\n\u003e - Web Server, WAS\n\u003e - Servlet, Servlet Container\n\u003e - Filter, Interceptor\n\u003e - AOP\n\n\u003cbr\u003e\n\n## Web Server, WAS\n\n\u003cbr\u003e\n\n**Web Server**\n-   인터넷을 기반으로 클라이언트에게 웹 서비스를 제공하는 컴퓨터\n\n\u003cbr\u003e\n\n**흐름 과정**\n\n-   클라이언트 : 웹서버에게 주소(url)를 가지고 통신 규칙(http)에 맞게 요청하면 알맞은 내용(html)을 응답받음\n-   서버 : 클라이언트의 요청을 기다리고, 웹 요청(http)에 대한 데이터를 만들어서 응답한다. 이때, 데이터는 웹에서 처리할 수 있는 html, css, 이미지 등 ==**정적인 데이터**==로 한정\n-   DB에서 데이터를 가져와서 전달해주는, 동적인 데이터를 줄 수 없을까? html은 프로그래밍 언어가 아니라서 이런게 불가능하다.\n\n\u003cbr\u003e\n\n**Web Application Server**\n\n-   웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크\n-   웹 애플리케이션을 실행시켜 필요한 기능을 수행하고 그 결과를 웹 서버에게 전달\n-   php, jsp, asp와 같은 언어들을 사용해서 ==**동적인 페이지**==를 생성할 수 있는 서버\n-   프로그램 실행 환경과 데이터베이스 접속 기능 제공\n-   비즈니스 로직 수행 가능\n-   ==**웹 서버 + 웹 컨테이너**==\n    -   컨테이너 : jsp, servlet을 실행시킬 수 있는 소프트웨어\n    -   자바 계열에서는 웹 애플리케이션 컨테이너라고 부름\n    -   웹 애플리케이션 컨테이너 : 웹 애플리케이션이 배포되는 공간\n\n\u003cbr\u003e\n\n**예시**\n\n-   Web Server : Apache, nginx, Microsoft IIS\n-   Web Application Server : Tomcat, Jetty, JBoss, IBM WebSphere, 티맥스 JEUS(제우스)\n\n**결론 : “상황에 따라 변하는 정보를 제공할 수 있는가”**\n\n-   Web Server : No. 정적인 페이지만!\n-   Web Application Server : Yes. 동적인 페이지 가능!\n\n\u003cbr\u003e\n\n### WAS 앞 단에 Web Server\n\nQ. **그러면 드는 생각이, WAS가 어차피 다 해주는 Web Server가 굳이 왜 필요할까?**\n\n( = Web Server를 같이 사용했을 때의 장점 )\n\n\u003cbr\u003e\n\n1.  **책임 분할을 통한 서버 부하 방지**\n    -   정적 컨텐츠는 Web Server, 동적 컨텐츠는 WAS가 담당\n    -   WAS는 DB 조회 등 페이지를 만들기 위한 다양한 로직을 처리하는데, 단순한 정적 컨텐츠를 WAS에서 제공한다면 다른 작업에 사용하는 리소스들로 인해 지연이 생겨날 수 있다. (그런데, tomcat 5.5 이상부터는 성능이 크게 떨어지지 않는다고 한다.)\n\n2.  **여러 대의 WAS 로드밸런싱**\n    -  WAS가 처리해야 하는 요청을 여러 WAS가 나누어서 처리할 수 있도록 설정\n    - 앞 단에 Web Server를 두고 뒷단에 여러대의 WAS를 둔다면, WAS가 처리해야하는 요청을 Web Server에서 여러 WAS에 뿌려주는 것\n\n3. 여러 대의 WAS Health check\n\t- \u003cdetails\u003e\u003csummary\u003e\u003cstrong\u003eHealth check란?\u003c/strong\u003e\u003c/summary\u003e \n\t    Web Server가 로드밸런싱 해주다보면, 특정 WAS에서 동작이 제대로 안 될 수 있는 경우가 있는데, 웹 서버에서 WAS가 정상적으로 동작하고 있는지 http 요청을 보내서 서버의 상태를 확인하는 기능\u003c/details\u003e\n\t -   서버에 주기적으로 HTTP 요청을 보내 서버의 상태를 확인\n\t    (ex. 특정 url 요청에 200 응답이 오는지? 200이 오면 정상, 안오면 비정상이니까 비정상 서버로 인지를 하고 서버로 요청 전달하지 않게 설정 가능)\n\t-   Interval : health check를 통해 서버 상태를 확인하는 요청을 날리는 주기 (default : 5초)\n\t-   Fails : 아래의 경우 3회 연속 실패하면 서버가 비정상이라고 인지 (default : 1회)\n\t-   Passes : 서버가 다시 복구되어 요청이 2번 연속 성공하면 서버가 정상으로 인지 (default : 1회)\n\n4.  **보안**\n\t-   리버스 프록시를 통해 실제 서버를 외부에 노출하지 않을 수 있다.\n\t -   WAS 같은 경우, DB 관련 로직이나 DB 접근 권한을 가질 수 있기에 외부에 노출하면 위험할 수 있지만, 앞단에 웹 서버를 둬서 외부에 노출시키지 않는 것이다.\n\t-   물리적으로 분리하여 보안 강화\n\t    -   SSL에 대한 암복호화 처리에 Web Server를 사용\n\t    -   공격에 대해 Web Server를 앞 단에 두어 중요한 정보가 당긴 DB나 로직까지 (WAS까지) 전파되지 못하게 한다.\n\n\u003cbr\u003e\n\n\u003e [!note] Reverse Proxy \u003cbr\u003e\n\u003e 클라이언트 - 웹 - Reverse Proxy Server - 서버의 구조로 서버의 정보를 클라이언트에게 감춰주는 녀석\n\u003e 1.  캐싱 (Forward Proxy와 동일)\n\u003e 2.  보안 : 서버 정보를 클라이언트로부터 숨김 \u003cbr\u003e\n\u003e \t- 클라이언트는 요청할 때 서버 정보를 직접 알지 못함 \u003cbr\u003e\n\u003e \t- 리버스 프록시가 자신이 알고있는 서버들에게 요청을 전달 \u003cbr\u003e\n\u003e \t- Client는 Reverse Proxy를 실제 서버라고 생각하여 요청을 보낸다. 실제 서버의 IP가 노출되지 않는다.\n\u003e 3. Load Balancing\n\n\u003cbr\u003e\n\n### 여러 대의 WAS 장점\n\n1.  위에서 말한 것처럼 Load Balancing을 통한 서버 부하 분산\n2.  fail over (장애극복), fail back\n3.  뭐 이것도 보안이 있을 수 있겠네\n4.  대용량 웹 애플리케이션의 경우 (여러 개의 서버 사용) Web Server와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다.\n5.  다른 종류의 WAS로 서비스 가능\n\n- fail over는 위에서 처럼 하나의 WAS가 작동을 중지한 경우 다른 WAS들로 돌릴 수도 있다는 개념\n- fail back은 작동이 중지된 서버를 다시 재작동 시킨다는 의미\n- 다른 종류의 WAS로 서비스 가능하다는건 하나의 서버에서 PHP application, Java application을 함께 사용할 수 있다는 말이다. 서버는 가운데에다가 두고 하나의 WAS에는 php application~ 다른 WAS에는 java application~ 이런 방식으로!\n\n\u003cbr\u003e\n\n## Servlet, Servlet Container\n\n- Servlet : WAS 안의 웹 컨테이너에 위치하며, **동적인 페이지**를 만드는데 사용되는 서버 프로그램\n\t- 서블릿이 존재하기 전에는 요청이 들어오면 HTTP 요청 메시지를 파싱하는 것부터 여러 부가 작업을 개발자가 수행해야 했다. 하지만 서블릿이 나오면서 부가적인 작업을 대신해주게 되었고, 개발자는 실직적인 비즈니스 로직에만 집중 할 수 있게 되었다.\n\n- Servlet Container : WAS가 Web Server + Web Container라고 했었는데, Java 애플리케이션 진영에서는 이 웹 컨테이너를 Servlet Container라고도 한다.\n\t- 서블릿 컨테이너는 **서블릿의 생명주기**를 관리\n\t-   `init()` : 서블릿 초기화\n\t-   `service()` : HTTP 요청 유형을 확인하고 맞게 doGet, doPost, doPut 등 메서드를 호출하여 요청 처리\n\t-   `destroy()` : 서블릿 제거\n\t- ==서블릿 객체도 **싱글톤** 으로 관리되기 때문에 최초 요청 시점에 서블릿 객체를 초기화해서 서블릿 컨테이너에 보관하고 이후에는 같은 서블릿을 공유해서 사용한다.==\n\n\u003cbr\u003e\n\n**대략적인 동작 과정**\n\n1.  사용자가 URL을 클릭하면 HTTP Request를 Servlet Container로 보낸다.\n    \n2.  **Servlet Container는 쓰레드 풀에서 쓰레드를 꺼내 할당**해주고 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.\n    \n3.  사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다.\n    \n4.  서블릿 컨테이너에 존재하지 않으면 초기화하고 있다면 가져와서 service() 메서드를 호출한다.\n    \n\t-   Spring MVC의 경우 DispatcherServlet이 초기화되고 호출된다.\n\n5.  service 메서드가 수행이 끝나면 HttpServletResponse 객체에 응답을 보낸다.\n\n\u003cbr\u003e\n\n### Dispatcher Servlet\n\n **Spring Web MVC에서는 이 Servlet을 어떻게 사용할까? 없던 시절에는 어떻게 하였을까?**\n\n-   Spring Web MVC가 없던 시절에서는 URL마다 서블릿이 한 개 필요했었고, get만 쓰고 싶다고 해도 서블릿 전체를 만들어야 했다. 또, servlet을 만들 때마다 Web.xml에 servlet 마다 mapping을 시켜줬어야 했었다.\n-   Spring Web MVC 등장으로 Servlet이 Dispatcher Servlet 하나만 있어도 된다. 또, 디스패처 서블릿을 도입하면서 view를 강제로 분리시켜주는 효과가 생김\n\n\u003cbr\u003e\n\n**Dispatcher Servlet의 동작**\n\n1.  클라이언트의 요청을 디스패처 서블릿이 받음 (Dispatcher Servlet)\n2.  요청 정보를 통해 요청을 위임할 컨트롤러를 찾음 (Handler Mapping)\n3.  요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달함 (Handler Adapter)\n4.  핸들러 어댑터가 컨트롤러로 요청을 위임함 (RestController)\n5.  비지니스 로직을 처리함 (Service - Business Logic, Repository - Data access, Database)\n6.  컨트롤러가 반환값을 반환함 (Response Entity)\n7.  핸들러 어댑터가 반환값을 처리함\n8.  서버의 응답을 클라이언트로 반환함\n\n\u003cbr\u003e\n\n## Filter, Interceptor\n\n\u003cbr\u003e\n\nFilter\n-   Dispatcher Servlet에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리하는 기능을 제공하는 것\n-   톰캣과 같은 웹 컨테이너(웹 애플리케이션 WAS 단)에서 동작 하기 때문에 Spring과 무관한 자원에 대해 동작\n-   Spring Context 외부에서 동작하므로 ErrorController 에서 예외 처리\n\n\u003cbr\u003e\n\nFilter 메서드\n-   `init()`\n\t-   필터 객체를 초기화하고 서비스에 추가하기위한 메서드\n\t-   웹 컨테이너(WAS 단)에서 1회 init 메서드를 호출하여 필터 객체를 초기화하면 이후 요청들은 doFilter를 통해 전/후 처리가 된다.\n-   `doFilter()`\n\t-   url-pattern에 맞는 모든 HTTP 요청이 디스패처 서블릿으로 전달되기 전/후에 웹 컨테이너에 의해 실행되는 메서드\n\t-   doFilter의 파라미터로 FilterChain이 있는데, FilterChain의 doFilter 를 통해 다음 대상으로 요청을 전달한다.\n-   `destroy()`\n\t-   필터 객체를 서비스에서 제거하고 사용하는 자원을 반환하는 메서드\n\t-   웹 컨테이너에 의해 1번 호출된다.\n\n\u003cbr\u003e\n\nInterceptor\n-   Spring이 제공하는 기술로, Dispatcher Servlet이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공하는 것\n-   스프링 컨텍스트에서 동작\n-   Spring Context 내부에서 동작하므로 @ControllerAdvice 을 사용하여 예외 처리\n\n\u003cbr\u003e\n\nInterceptor 메서드\n-   `preHandle()`\n\t- 컨트롤러가 호출되기 전에 실행되어 컨트롤러 이전에 처리해야 하는 전처리 작업이나 요청 정보를 가공하거나 추가하는 경우에 사용할 수 있다.\n\t- 리턴값이 boolean이다. 리턴이 true 일경우 preHandle() 실행후 핸들러에 접근한다. false일경우 작업을 중단하기 때문에 컨트롤러와 남은 인터셉터가 실행되지 않는다.\n-   `postHandle()`\n\t- 컨트롤러 호출된 후에 실행되어 컨트롤러 이후에 처리해야하는 후처리 작업이 있을 때 사용할 수 있다. 핸들러가 실행은 완료 되었지만 아직 View가 생성되기 이전에 호출된다.\n\t- 보통 컨트롤러가 반환하는 ModelAndView 타입의 정보가 제공되는데, Controller에서 View 정보를 전달하기 위해 작업한 Model 객체의 정보를 참조하거나 조작할수 있다.\n-   `afterCompletion()`\n\t-   모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후에 실행된다.\n\t-   요청 처리 중에 사용한 리소스를 반환할 때 사용하기 적합하다.\n\t- 뷰가 렌더링 된 이후에 사용되는데, ==**최근에는 React와 Vue 같이 SPA를 사용하면서 뷰를 따로 사용하는 것이 아닌 Json 형태로 데이터를 제공하는 REST API 기반의 컨트롤러가 사용되면서 잘 사용하지 않는다.**==\n\n\u003cbr\u003e\n\n### 실행과정\n\n![](brain/image/dog-week04-1.png)\n\n1.  서버 실행 시 Servlet이 올라오는 동안 init 후 doFilter 실행\n2.  Dispatcher Servlet을 지나쳐 Interceptor의 PreHandler 실행\n3.  컨트롤러를 거쳐 내부 로직 수행 후, Interceptor의 PostHandler 실행\n4.  doFilter 실행\n5.  Servlet 종료 시 destory\n\n\u003cbr\u003e\n\n### 둘의 차이\n\n-   필터는 웹 컨테이너(서블릿 컨테이너)에서 실행, 인터셉터는 스프링 컨택스트에서 실행 ⇒ 실행시점 다름\n-   필터는 디스패처 서블릿 전후, 인터셉터는 컨트롤러의 전후 다룸\n-   필터는 스프링과 무관하게 전역적으로 처리하는 작업, 입력으로 들어온 파라미터 자체 검증\n-   인터셉터는 스프링으로 들어온 요청과 관련되어 전역적으로 처리하는 작업\n-   인터셉터는 @ControllerAdvice, @ExceptionHandler를 사용하여 예외처리 가능, 필터는 이것이 불가능하여 doFilter() 메서드 주변을 try-catch로 감싸서 예외 핸들링\n\n\u003cbr\u003e\n\n| 대상 | 필터(Filter) |인터셉터(Interceptor) |\n|-----|-------------|--------------------|\n| 관리 컨테이너 | 웹 컨테이너 | 스프링 컨테이너 |\n| Request/Response 조작 여부 | 가능 | 불가능 |\n| 용도 | 보안 관련 공통 작업+ 이미지/데이터 압축 및 문자열 인코딩+ 모든 요청에 대한 로깅 또는 감사+ ServletRequest 커스터마이징 | 인증/인가 등과 같은 공통 작업+ Controller로 넘겨주는 정보의 가공+ API 호출에 대한 로깅 |\n\n\u003cbr\u003e\n\n==**인터셉터가 조작 여부가 불가능하다는 것은 HttpServletRequest, HttpServletResponse 객체를 제공받으므로 객체 자체는 조작할 수 없다는 의미이고, 내부 값들은 조작할 수 있다.**==\n\n\u003cbr\u003e\n\n## AOP\n\n**AOP(Aspect Oriented Programming)**\n\n관점 지향 프로그래밍으로 **공통 관심 사항과 핵심 관심 사항을 분리** 하는 것을 의미한다.소스 코드에서 여러 번 반복해서 사용하는 코드(흩어진 관심사)를 Aspect로 모듈화하여 핵심 로직에서 분리해 재사용하는 것이라고 볼 수 있다.여러 객체에 공통으로 적용할 수 있는 기능을 구분함으로써 재사용성을 높여주는 프로그래밍 기법이다.특정 로직(로그, 성능테스트, 권한)을 모든 메서드에 적용하고 싶을 때, 일일이 추가하는 것이 아니라 로직을 만들어서 적용할 수 있다.따라서, 비즈니스 로직 앞/뒤에 공통 관심 사항을 수행해 중복 코드를 줄인다.\n\n-   관점지향 프로그래밍으로, 횡단 관심사에 따라 프로그래밍 하는 것. OOP를 보완하기 위해 나온 개념\n-   예를 들어, 로깅/트랜잭션/권한검사/성능측정 등 부가 기능인 인프라 로직의 중복이 횡단으로 나타나는 경우 이를 모듈화하여 생각하는 것을 말함\n-   AOP는 일종의 패러다임이라, 각 언어마다 AOP의 구현체가 있음. 대표적으로 자바는 AspectJ\n\n\u003cbr\u003e\n\n### AOP 용어\n\n-   Aspect\n\t-   흩어진 관심사를 모듈화 한 것\n\t-   모듈 : 외부에서 재사용할 수 있는 패키지들을 묶은 것\n\t-   advice + pointcut을 모듈화 한 것\n-   Target\n\t-   advice의 대상이 되는 객체\n\t-   Target object는 비즈니스 클래스 같은 핵심 모듈이라고 할 수 있음\n\t-   Pointcut으로 결정\n-   Advice\n\t-   실질적인 부가 기능 로직을 정의하는 곳\n\t-   특정 조인 포인트에서 Aspect에 의해 취해지는 조치\n-   Join point\n\t-   **추상적인 개념** 으로 advice가 적용될 수 있는 모든 위치\n\t-   ex) 메서드 실행 시점, 생성자 호출 시점, 필드 값 접근 시점 등등..\n\t-   **스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메서드 실행 지점**\n-   Point cut\n\t-   Join point의 상세한 스펙을 정의한 것, 구체적으로 실제 advice가 적용될 지점\n\t-  스프링 AOP는 프록시 기반이기 때문에 조인 포인트가 메서드 실행 시점 뿐이 없고 포인트 컷도 메서드 실행 시점만 가능 ( = 실제 advice가 적용될 메서드 )\n-   Advisor\n    -   스프링 AOP에서만 사용되는 용어로 advice + pointcut 한 쌍\n-   Weaving\n    -   pointcut으로 결장한 타겟의 join point에 advice를 적용하는 것\n-   AOP 프록시\n    -   AOP 기능을 구현하기 위해 만든 프록시 객체\n    -   스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시\n\n\u003cbr\u003e\n\n### AOP 적용 방식\n\n-   컴파일 시점\n\t-   .java 파일을 컴파일러를 통해 .class를 만드는 시점에 부가 기능 로직을 추가\n\t-   모든 지점에 적용 가능\n\t-   AspectJ가 제공하는 특별한 컴파일러를 사용해야 하기 때문에 특별할 컴파일러가 필요한 점과 복잡하다는 단점이 있다.\n-   클래스 로딩 시점\n\t-   .class 파일을 JVM 내부의 클래스 로더에 보관하기 전에 조작하여 부가 기능 로직 추가\n\t-   모든 지점에 적용 가능\n\t-   특별한 옵션과 클래스 로더 조작기를 지정해야하므로 운영하기 어렵다.\n-   **런타임 시점**\n\t-   **Spring AOP가 사용하는 방식**\n\t-   컴파일이 끝나고 클래스 로더에 이미 다 올라가 자바가 실행된 다음에 동작하는 런타임 방식\n\t-   실제 대상 코드는 그대로 유지되고 프록시를 통해 부가 기능이 적용\n\t-   **프록시는 메서드 오버라이딩 개념으로 동작하기 때문에 메서드에만 적용 가능** -\u003e **스프링 빈에만 AOP를 적용 가능**\n\t-   특별한 컴파일러나, 복잡한 옵션, 클래스 로더 조작기를 사용하지 않아도 스프링만 있으면 AOP를 적용할 수 있기 때문에 스프링 AOP는 런타임 방식을 사용\n\n\u003cbr\u003e\n\n### Spring에서 AOP 구현\n\n-   XML 기반의 POJO(Java 하드코딩?) 클래스를 이용한 AOP 구현\n\t-   부가 기능을 제공하는 Advice 클래스를 작성하고 XML 설정파일에 Aspect 설정 (Advice, Pointcut)\n-   @Aspect 어노테이션을 이용한 AOP 구현\n\t-   @Aspect 애노테이션을 이용해서 부가기능을 제공하는 Aspect 클래스 작성\n\t-   Aspect 클래스 생성 → Advice 구현 → Pointcut 구현\n\n기본적인 작동 원리\n- Spring AOP에서는 프록시 패턴을 채택\n- 어떤 target 클래스를 부가 기능을 제공하는 프록시로 감싸서 실행하는 방법\n\n\u003cbr\u003e\n\n### Spring AOP vs AspectJ\n\n\u003cbr\u003e\n\n| | Spring AOP | AspectJ |\n| -- | ------- | ------- |\n| 목표 | 간단한 AOP 기능 제공 | 완벽한 AOP 기능 제공 |\n| join point | 메서드 레벨만 지원 | 생성자, 필드, 메서드 등 다양하게 지원 |\n| weaving | 런타임 시에만 가능 | 런타임은 제공 X |\n| 대상 | Spring Container가 관리하는 Bean에만 가능 | 모든 Java Object에 가능 |\n\n- weaving은 AOP를 끼워주는, 바느질하는 시기\n\t- AspectJ는 Spring에서 제공하는 IoC와 DI가 없어서 런타임 제공하지 않음\n- Spring Container가 어떤 객체 생성을 관리해주기 때문에 런타임 시에만 가능한 것이다.\n\t- target object도 Spring 컨테이너가 관리하는 Bean에만 가능하게 되는 것\n\t- 그래서, Spring에서 코드를 작성할 때, @Aspect **애노테이션을 붙여 이 클래스가 Aspect를 나타내는 클래스라는 것을 명시하고 @Component를 붙여 스프링 빈으로 등록한다.**\n\n\u003cbr\u003e\n\n### AOP vs Interceptor\n\n\u003ca href='/brain/Interview/dog-study/dog-week04/#실행과정'\u003eFilter, Interceptor, AOP의 실행과정\u003c/a\u003e에서 보다시피, 스프링 컨택스트 내부의 Interceptor와 AOP는 역할이 비슷하게 보인다. 이 둘의 차이는 뭘까?\n\n-  Interceptor나 Filter와는 달리 AOP는 ==**메소드 전후**==의 지점에 자유롭게 설정이 가능하다.\n-  Interceptor와 Filter는 주소로 대상을 구분해서 걸러내야하는 반면, AOP는 주소, 파라미터, 애노테이션 등 다양한 방법으로 대상을 지정할 수 있다.\n-  AOP의 Advice와 HandlerInterceptor의 가장 큰 차이는 파라미터의 차이다.\n\t-  Advice의 경우 JoinPoint나 ProceedingJoinPoint 등을 활용해서 호출한다.\n\t-  반면 HandlerInterceptor는 Filter와 유사하게 HttpServletRequest, HttpServletResponse를 파라미터로 사용한다.\n\n\u003cbr\u003e\n\n### (심화) AOP 적용 안되는 경우\n\nAutoController -\u003e AuthServce\u0026\u0026프록시 -\u003e AuthService와 같은 경우를 생각해보자.\n- AuthService\u0026\u0026프록시가 AuthService를 감싸고 있으니, AuthService 타입을 가지겠지?\n- 그러면, AuthService 안에 있는 private 메서드에다가 AOP를 적용하면 어떻게 될까?\n\n\u003cbr\u003e\n\n```java {title=\"AuthService.java\"}\npublic void join(AuthService authService) {\n\tinner();\n\tmemberRepository.save(authService.toMember());\n}\n```\n\n\u003cbr\u003e\n\n```java\n@PerformanceCheck\nprivate void inner() {\n\tSystem.out.println(\"여기인가\");\n}\n```\n\n\u003cbr\u003e\n\n1.  AuthService에 join이라는 메서드에는 AOP를 적용하지 않았음\n2.  그 안에 private 메서드로 inner 메서드를 만들었음\n3.  여기에 `@PerformanceCheck` 이라는 AOP를 적용했음\n4.  join 메서드에서 inner 메서드를 호출\n\n\u003cbr\u003e\n\n결과는, ==**PerformanceCheck이 불려지지 않는다.**==\n\n- proxy로 감싼 객체가 실제로 target object의 join 메서드를 실행할 때\n- ==**inner 메서드가 aop로 감싼 proxy 객체가 아니기 때문에** ==\n- 자기 자신을 호출할 때는 AOP로 감싸지지 않는 메서드가 호출되는 것\n\n\u003cbr\u003e\n\n**정리하자면,**\n1.  자기가 자신의 메서드를 호출할 때, target object가 target object에 있는 메서드를 실행할 때는 AOP가 적용이 안된다.\n2. 자기가 자신의 메서드를 실행할 때에는 target object에서 실행한 메서드 내부에 있는 메서드이기 때문에 AOP가 적용이 안된 그냥 target object의 메서드를 그대로 실행하기 때문이다.\n3. 동일 클래스 메서드를 실행할 때, 자기가 자신의 메서드를 실행할 때 AOP가 적용이 되지 않은채로 실행이 된다.\n\n\u003cbr\u003e\n\n### @Transactional 문제도 여기!?\n\n- 우리가 service에서 private 메서드에다가 @Transactional을 붙였을 때 그 Transaction이 작동하지 않는 이유가 바로 이것 때문이다.\n- 갑자기 @Transactional? → 이것도 AOP 중 하나라서.\n\t- 서비스 로직을 하나의 트랜잭션으로 만들 때, 원래는 로직의 시작점에 Transaction을 열어주고 로직이 끝나는 시점에 Transaction을 커밋하는 코드가 항상 들어가야한다.\n\t- 하지만, `@Transactional` 을 통해서 개발자는 비즈니스 로직에만 집중할 수 있고, Transaction이라는 인프라 로직은 AOP로 분리를 하게 된다.\n\n\u003cbr\u003e\n\n## 참고\n\n- https://velog.io/@backtony/%EB%A9%B4%EC%A0%91-%EC%8B%9C%EB%A6%AC%EC%A6%882-Spring-JPA#filter-interceptor\n- https://popo015.tistory.com/115\n- https://www.youtube.com/watch?v=NyhbNtOq0Bc\n- https://www.youtube.com/watch?v=2pBsXI01J6M\n- https://www.youtube.com/watch?v=Hm0w_9ngDpM","lastmodified":"2023-03-15T12:59:54.12361033Z","tags":null},"/brain/Interview/dog-study/dog-week05":{"title":"5주차 - Spring 응용","content":"\n\u003chr\u003e\n\n\u003e[!note] 5주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC** \u003cbr\u003e\n\u003e - Bean 정의\n\u003e \t- 생명주기\n\u003e \t- 스코프\n\u003e - 싱글턴 vs 스프링 싱글턴\n\u003e - Annotation\n\u003e - Spring Annotation\n\u003e - MVC 패턴\n\u003e \t- MVVM MVP MVI\n\u003e - 레이어드 아키텍쳐\n\n\u003cbr\u003e\n\n## Spring Bean\n\n- ==**Spring Bean : Spring IoC Container가 관리하는 객체**==\n- ==**Spring IoC Continaer : Spring Bean을 관리하는 객체**==\n\nSpring Bean 이 왜 필요할까?\n- Spring IoC Container가 특정 객체 Lifecycle을 관리한다는 것을 나타내기 위하여\n\nSpring IoC Container는 왜 Bean을 관리하는 것일까?\n- 의존성을 자동 주입하여 개발자들이 해당 의존성을 사용하는 로직에만 집중할 수 있도록 도와주는 역할\n- 의존성을 주입할 때 사용되는 객체가 항상 동일함을 보장하기 위해\n\n\u003cbr\u003e\n\n### Bean을 쓰지 않는 경우 문제점\n\n객체를 Bean으로 등록하지 않고 직접 의존성 주입을 도입한다면 어떤 문제가 있을까?\n\n\u003cbr\u003e\n\n```java\npublic class Service {\n\tprivate final Dao dao;\n\n\tpublic Service(Dao dao) {\n\t\tthis.dao = dao;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\nService service = new Service(new JdbcDao());\n```\n\n\u003cbr\u003e\n\n이렇게 Dao 구현체를 의존성 주입 한다고 하자. 그렇다면 어디에선가 new 키워드를 사용하여 객체를 생성해야 한다. 이때 Dao 구현체가 변경된다면 어떻게 될까?\n\n\u003cbr\u003e\n\n```java\nService service = new Service(new TestDao());\n```\n\n\u003cbr\u003e\n\nService를 생성할 때 의존성 주입으로 Dao를 초기화하면서 어떤 Dao의 구현체를 선택할 것인지에 대한 책임을 가지기 때문에 Service를 생성하는 곳에서도 변경이 일어난다. \n\n\u003cbr\u003e\n\n```java\nService service = new Service(new Test1Dao(), new Test2Dao(), new Test3Dao());\n```\n\n\u003cbr\u003e\n\n또, 이렇게 의존성 주입을 여러 개 하는 경우 해당 의존성 주입의 순서와 관계를 모두 파악해야해서 번거로움이 생긴다.\n\n따라서, 아래와 같이 Bean을 사용해보자.\n\n- 의존성 주입이 필요한 객체를 Bean으로 등록\n- 스프링 IoC 컨테이너가 객체의 생성과 의존성 주입을 관리하도록 함\n- 장점 : 개발자가 주입된 의존성 부분에만 집중할 수 있게 됨\n\n\u003cbr\u003e\n\n### Bean 생명주기\n\n==**스프링 IoC 컨테이너 생성 → 스프링 빈 객체 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료**==\n\n\u003cbr\u003e\n\nBean의 Lifecycle의 관리자 =\u003e Spring Container\n- Bean의 Lifecycle 관련 **callback 메서드를 호출**하여, Bean 객체의 생성, 초기화, 소멸의 Lifecycle을 관리한다.\n- callback 메서드 : 어떤 이벤트에 의해 호출되는 함수\n\nBean의 Lifecycle에서 callback의 필요성\n- Database Connection, 네트워크 소켓 연결 등 시작 지점에 미리 연결한 뒤 애플리케이션 종료 시점에 연결을 종료해야하는 경우 =\u003e 객체의 초기화 및 종료 작업이 필요할 것\n- 예를 들어, Connection Pool의 connect \u0026 disconnect\n- Spring Bean도 동일한 원리로 **초기화 작업**과 **종료 작업**이 나눠서 진행됨\n\t- Spring Bean은 의존관계 주입이 끝나야만 사용이 가능하기 때문에 그때 **초기화 콜백 메서드**를 호출해서 사용하는 것이니까. 끝나고 나면 다시 **소멸 전 콜백 메서드**로 종료!\n\n\u003cbr\u003e\n\n**Spring이 Bean Lifecycle Callback을 관리하는 방법**\n\n- Spring의 인터페이스 (InitializingBean, DisposableBean)\n\n```java\nclass MySpringBean implements InitializingBean {\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\n\t}\n}\n```\n\n\u003cbr\u003e\n\n- JSR-250 애노테이션 지원\n\t- `@PostConstruct`, `@PreDestroy` 사용\n\t- ==**Spring에서 Bean 초기화, 소멸 시 권장하는 방식**==\n\t- 단점 : 외부 라이브러리에는 적용 못함\n\n```java\n@PostConstruct\npublic void postConstruct() {\n\n}\n\n@PreDestroy\npublic void preDestroy() {\n\n}\n```\n\n\u003cbr\u003e\n\n- `@Bean` 애노테이션에 속성을 추가\n\t- JSR-250 애노테이션이 외부 라이브러리에는 적용 못하기 때문에 그럴 경우 `@Bean` 애노테이션에 속성을 추가하는 방식을 사용함\n\t- 설정 정보에 초기화 메서드, 종료 메서드 지정\n\n```java\n@Bean(initMethod = \"onInitialize\", destroyMethod = \"onDestroy\")\npublic MySpringBean mySpringBean() {\n\treturn new MySpringBean();\n}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eBean의 생성 Lifecycle 상세\u003c/strong\u003e\u003c/summary\u003e\n\n1. Spring이 Bean 객체를 인스턴스화 한다.\n2. 의존 관계를 주입한다.\n3. `BeanNameAware.setBeanName()` 메서드를 호출한다.\n\t- setBeanName의 파라미터로 넘어온 문자열 값으로 빈의 이름 설정\n4. `BeanFactoryAware.setBeanFactory()` 메서드를 호출한다.\n\t- BeanFactory 객체를 주입하기 위해서 사용\n5. `ApplicationContextAware.setApplicationContext()` 메서드를 호출한다.\n\t- ApplicationContext 객체를 주입하기 위해서 사용\n6. `BeanPostProcessor.postProcessBeforeInitialization()` 메서드를 호출한다.\n7. `@PostConstruct`이 붙은 메서드, `InitializingBean.afterPropertiesSet()` 메서드, `@Bean`의 initMethod로 지정한 메서드 순서로 호출\n8. `BeanPostProcessor.postProcessAfterInitialization()` 메서드를 호출한다.\n\nQ. Bean의 생성과 초기화를 분리하는 이유는?\n- 생성자에서 초기화라는 무거운 작업을 하는 것보다 분리하여 유지보수에 용이하도록 하기 위하여.\n\nQ. Spring에서 BeanFactory 컨테이너보다 ApplicationContext를 권장하는 이유?\n- BeanFactory는 스프링 컨테이너의 최상위 인터페이스이고 ApplicationContext는 BeanFactory를 상속하여 만들어져서, BeanFactory의 모든 기능을 포함하며 그보다 더 다양한 기능을 제공하기 때문이다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eBean의 소멸 Lifecycle 상세\u003c/strong\u003e\u003c/summary\u003e\n\n1. Spring IoC 컨테이너가 종료된다.\n2. `@PreDestory` 애노테이션이 붙은 메서드, `DisposableBean.destroy()` 메서드, `@Bean`의 destroyMethod로 지정한 메서드 순서로 실행된다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\nBean의 default 설정은 싱글턴이다. Spring IoC Container에 객체로 Bean을 등록하지 않고 개발자가 객체를 싱글턴으로 만들어서 사용하면 어떤 문제가 있을까?\n\n\u003cbr\u003e\n\n```java\npublic class DatabaseConnection {\n\tprivate static final DatabaseConnection databaseConnection = new DatabaseConnection();\n\n\tprivate DatabaseConnection() {\n\t}\n\n\tpublic static DatabaseConnection getConnection() {\n\t\treturn databaseConnection;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n1. 다형성을 이용하지 못함. 싱글턴이라서 private을 썼기 때문에 해당 객체는 상속이 불가능하게 됨.\n2. 단위 테스트가 어렵다. 메모리 절약에는 이점이 있겠지만, 해당 객체는 공유 객체가 되므로 단위 테스트를 실행할 때마다 테스트의 순서에 따라 결과가 달라지게 된다.\n\n\u003cbr\u003e\n\n객체를 싱글턴으로 만들어서 사용했을 때 단점들은 스프링 IoC 컨테이너가 어떻게 해결했을까? 스프링 IoC 컨테이너가 Bean의 LifeCycle을 관리하는 과정을 보면 해답을 찾을 수 있다.\n\n1. 객체 생성 + property 설정\n2. 의존 설정\n3. 초기화\n4. 사용\n5. 소멸\n\n\u003cbr\u003e\n\n**객체 생성 + property 설정**\n\n- Spring IoC 컨테이너가 생성되면 빈 스코프가 싱글턴인 객체를 생성\n-  Bean으로 등록하기 위해 애노테이션 기반, Java 설정 클래스 기반, xml 기반 등 다양한 configuration 메타 데이터를 이용하여 **통일된 Bean Definition을 생성**한다.\n- Bean으로 등록할 POJO + Bean Definition 정보를 이용하여 Bean 생성\n- 이 과정에서 싱글턴 패턴을 사용하는 것이 아니라 평범한 Java class를 이용하여 객체를 생성\n\n그리고, Spring IoC Container에는 Singleton Registry 기능이 있다.\n- Registry는 CS 전반적으로 사용되는 개념. Key-Value 형태로 데이터를 저장하는 방법\n- Spring IoC Container는 Bean Scope가 Singleton인 객체에 **Bean의 이름을 Key, 객체를 Value로 저장**한다.\n- 의존성이 주입되어야하는 **객체가 빈으로 등록되어 있을 때 Spring은 빈의 이름을 이용하여 항상 동일한 Single Object를 반환하게 되는 것**\n\n\u003cbr\u003e\n\n**의존 설정**\n\n- Bean 객체가 생성되면 IoC 컨테이너가 의존 설정을 함\n- 이 \u0008과정에서 의존성이 자동 주입되게 된다.\n\n\u003cbr\u003e\n\n**겍체 초기화, 사용, 소멸**\n\n- 초기화 : 모든 객체가 초기화 될 필요는 없고, Connection Pool처럼 사용전에 초기화 과정이 필요한 객체들이 초기화 됨\n- 사용 : 초기화가 끝나면 Bean을 사용할 수 있음\n- 소멸 : Spring Container가 종료될 때 Bean scope가 싱글턴인 객체들도 함께 소멸\n\n\u003cbr\u003e\n\n### Bean 스코프\n\n==**Bean 스코프 : 빈이 생성되고 존재하고 적용되는 범위를 지정할 수 있는 것**==\n- `@Scope` 애노테이션을 사용하여 설정 가능\n- default 타입은 싱글턴 타입\n\n- 싱글턴\n\t- Spring Framework의 default scope\n\t- Spring Continaer 시작과 종료까지 1개의 객체로 유지\n\t- 빈 스코프를 싱글턴으로 설정할 경우 상태를 가지면 안된다.\n\t\t- 싱글턴 스코프의 빈이 value라는 상태를 가지고 있고 Thread 1이 value의 값을 증가시키고 Thread 2가 value라는 값을 가져와서 사용한다고 가정해보면, 해당 빈의 상태를 항상 예측할 수 없어서 의도한 결과가 항상 나온다고 보장할 수 없게 된다.\n\t- Spring이 시작할 때 생성됨\n\n- 프로토타입\n\t- 빈의 생성, 의존관계 주입, 초기화까지만 관여하고 이후에는 컨테이너에서 관리하지 않는 스코프\n\t- 이 때문에 매번 요청마다 새로 만들어진다. \n\t\t- 모든 스레드에서 공유하는 것이 아니므로 싱글턴과는 다르게 해당 객체는 상태를 가질 수 있다.\n\t- 요청할 때 생성됨\n\n-   웹 스코프\n    -   request : 각 요청이 들어오고 나갈때까지 유지\n    -   session : 세션이 생성되고 종료될때까지 유지\n    -   application : 웹의 서블릿 컨텍스트와 동일한 생명주기를 갖는 스코프\n        -   서블릿 컨텍스트는 **web application내에 있는 모든 서블릿들을 관리하며 정보공유할 수 있게 도와 주는 역할** 을 하는데, 톰캣 컨테이너가 실행 시 애플리케이션 하나당 한개의 서블릿컨텍스트가 생성된다.\n        -   생명 주기는 보통 톰캣의 시작과 종료와 일치한다.\n\n\u003cbr\u003e\n\n### Bean 설정 시 주의점\n\n1. 빈 스코프를 싱글턴으로 설정할 경우 상태를 가지면 안된다.\n2. 의존성을 자동 주입해야 할 인터페이스에 구현체가 두 개 이상이라면, Spring은 어떤 구현체를 자동 주입할 지 정하지 못해서 충돌이 발생함.\n\n\u003cbr\u003e\n\n```java\n@Repository\npublic class InMemoryStationDao implements StationDao {\n\n}\n\n@Repository\npublic class JdbcStationDao implements StationDao {\n\n}\n\n@Service\npublic class StationService {\n\tprivate final StationDao stationDao;\n\n\tpublic StationService(final StationDao stationDao) {\n\t\tthis.stationDao = stationDao;\n\t}\n}\n\n// 둘 중 어떤 구현체를 넣어야 할 지 Spring은 모른다\n```\n\n\u003cbr\u003e\n이 경우, 애노테이션을 이용하여 의존성 주입 시 우선순위를 정할 수 있음.\n\n1. 의존성을 자동 주입해야 하는 구현체가 하나인 경우\n\t- `@Primary` 애노테이션\n2. 상황에 따라 다른 구현체를 자동 주입 되도록\n\t- `@Qualifier` 애노테이션\n\n\u003ca href='/brain/Interview/dog-study/dog-week03' target='_blank'\u003e3주차 - Spring 기본 # 주입하고자 하는 의존성이 여러 개 참고\u003c/a\u003e\n\n\u003cbr\u003e\n\n## 싱글턴\n\n프로그램 전역에서 사용되는 유일한 클래스를 만드는 방법이 **싱글턴 패턴, 정적 클래스**이다.\n\n싱글턴 패턴 : 디자인 패턴 중 하나로, ==**객체 인스턴스가 오로지 한 개만 생성 되도록 설계하는 패턴이다.**== 따라서, 애플리케이션 내에서 인스턴스가 유일해야 한다.\n\n\u003chr\u003e\n\n### 싱글턴 패턴의 순수한 구현\n\n- 인스턴스를 private static 변수\n- `getInstance()`에서 인스턴스 생성\n- 외부 생성자를 private으로 막는다.\n- 문제점 : Thread-safe하지 않다.\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e상세 설명 보기\u003c/strong\u003e\u003c/summary\u003e\n\n- 클래스의 인스턴스를 정적 필드에 저장 (`private static 변수`)\n- 정적 메서드로 `getInstance()`에서 인스턴스 생성\n\t- 사용자가 인스턴스를 요청할 때마다 만약에 인스턴스가 존재하지 않으면 만들어서 반환하고 존재한다면 인스턴스를 반환\n- 외부에서 인스턴스를 생성할 수 없도록 생성자를 private으로 막음\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n```java\npublic class Settings {\n\tprivate static Settings instance;\n\n\tprivate Settings() {\n\t}\n\n\tpublic static Settings getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Settings();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n하지만, 이와 같은 구현은 ==멀티 스레드 환경에서 싱글턴이 보장되지 않는다. 즉, Thread-safe 하지 않다는 의미이다.==\n\n스레드 A와 B가 동시에 요청을 보낸 상황\n- A가 if문을 통과하여 인스턴스를 생성하기 전에 B도 통과한다고 가정해보자. 그러면 각각 다른 인스턴스가 생길 가능성이 존재한다.\n\n\u003chr\u003e\n\n### 동기화(Synchronized)\n\n- 인스턴스를 private static 변수\n- **synchronized** `getInstance()`\n- 외부 생성자를 private으로 막는다.\n- 문제점 : 리소스 낭비\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e상세 설명 보기\u003c/strong\u003e\u003c/summary\u003e\n\n- 위와 같은 문제를 해결하기 위해 synchronized 키워드를 이용한 동시성 문제 해결\n- 현재 메서드를 사용하고 있는 스레드를 제외하고 나머지 스레드가 메서드에 접근할 수 없도록 막아준다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n```java\npublic class Settings {\n\tprivate static Settings instance;\n\n\tprivate Settings() {\n\t}\n\n\tpublic synchronized static Settings getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Settings();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n하지만, 이와 같은 구현은 ==리소스가 낭비된다==는 단점이 있다. 멀티 스레드 환경에서 인스턴스를 하나만 만들기 위해서 synchronized 키워드를 사용했는데, 인스턴스가 존재하는 경우에는 더이상 필요 없기 때문이다.\n- 괜히, 메서드를 실행할 때마다 Lock이 걸리게 되어 리소스 낭비가 발생\n\n\u003chr\u003e\n\n### DCL\n\nDCL(Double Checked Locking)은 두 번 체크하여 리소스 낭비를 줄여본 버전이다.\n\n- **synchronized 시점 지연**\n- private static **volatile** 인스턴스\n- 외부 생성자를 private으로 막는다.\n- 문제점 : volatile 키워드\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e상세 설명 보기\u003c/strong\u003e\u003c/summary\u003e\n\n- 현재, `getInstance()` 메서드를 호출할 때마다 인스턴스가 있을 때는 synchronized 블록이 스킵되는 것이다. 즉시 인스턴스만 반환하게 되어 리소스 낭비를 없앨 수 있다.\n- 이때, 클래스 변수에 정의해놨던 인스턴스를 `volatile` 키워드를 사용해야 한다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003evolatile 키워드?\u003c/strong\u003e\u003c/summary\u003e\n\n원래, 스레드를 이용하게 되면 각각의 스레드는 성능을 위하여 CPU 레지스터의 캐시 메모리를 사용하게 된다. 첫 번째 스레드 -\u003e 캐시 메모리 -\u003e 메인 메모리 순서로 값을 대입한다면, 다음 스레드는 메인 메모리에 담긴 값을 메인 메모리 -\u003e 캐시 메모리 -\u003e 두 번째 스레드 순서로 가져온다.\n\n문제는, 첫 번째 스레드가 메인 메모리에 값을 넣기 이전인 상황에 두 번째 스레드가 메인 메모리에서 값을 읽으려고 할 때 발생한다. 이때 volatile 키워드를 사용하면 대입과 읽는 것 모두 메인 메모리에서 하도록 만들어서 시간차를 극복할 수 있다.\n\nJava에서 volatile 키워드는 변수의 값을 다른 스레드에서 **변경할 수 있도록** 하며, 클래스를 thread-safe하게 만드는 데 사용된다. 이는 여러 스레드가 동시에 메소드와 클래스 인스턴스를 사용할 수 있게 하고 문제가 발생하지 않도록 한다. volatile 키워드는 기본형 혹은 객체와 함께 사용할 수 있다.\n\nvolatile 키워드는 상호배제(mutual exclusion)를 제공하지 않고도 데이터 변경의 가시성(visibility) 측면을 보장해주므로 매우 유용하다. 다중 스레드가 코드 블록을 병렬로 실행하는 것이 문제가 되지 않지만 가시성 속성을 보장해야 하는 경우에 사용한다. 또한 happens-before ordering을 수행한다.\n\nvolatile 키워드는 두 가지 다른 용도로 사용한다. JVM이 **레지스터(register)에서 값을 읽지 않도록 하고, 값을 메인 메모리에서 읽도록 하여**== 메모리 불일치 오류(memory in-consistency errors)의 위험을 줄인다.== 또한, JVM이 레지스터에서 값을 읽지 않도록 하고, 값을 메모리에서 읽도록 함으로써 ==메모리 일관성 오류(memory consistency errors)를 방지==한다.\n\n정리하자면, Java에서 volatile 키워드는 다중 스레드 환경에서 변수의 가시성을 보장하고, 메모리 일관성 오류를 방지하며, 다중 스레드가 동시에 클래스와 메소드 인스턴스를 사용할 수 있게 하기 위해 사용된다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n```java\npublic class Settings {\n\tprivate static volatile Settings instance;\n\n\tprivate Settings() {\n\t}\n\n\tpublic static Settings getInstance() {\n\t\tif (instance == null) {\n\t\t\tsynchronized (Settings.class) {\n\t\t\t\tif (instance == null) {\n\t\t\t\t\tinstance = new Settings(); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n하지만, 이 코드도 완벽하지 않다. 이는 \u003ca href='/brain/Interview/dog-study/dog-week01/' target='_blank'\u003e개발바닥 1주차 면접스터디\u003c/a\u003e의 DLCP 지양에 관한 이야기에서도 다룬 내용이다.\n\n문제점은 volatile 키워드 자체가 JDK 1.5 이상에서만 구현가능하다는 점이 있고, JVM에 따라서 thread-safe 하지 않는 경우가 발생할 수 있다는 것이다. 자바의 메모리 모델이 \"out-of-order-write\"를 지원하기 때문에 메모리에 작성되는 순서를 보장하지 않기도 하다.\n\n\u003chr\u003e\n\n### Bill Pugh Solution\n\n**Bill Pugh Solution (Initialization on demand holder idiom)** : 싱글턴을 구현할 때 권장되어지는 방법 중의 하나이다. 구현 방법은 Holder 역할을 하는 `private static` 클래스를 이용하는 것이다.\n\n- static inner class 인스턴스\n- 생성자를 private\n- 문제점 : 클라이언트가 임의로 싱글턴을 파괴할 수 있다.\n\n```java\npublic class Settings {\n\tprivate Settings() {\n\t}\n\n\tprivate static class SettingsHolder {\n\t\tprivate static final Settings SETTINGS = new Settings();\n\t}\n\n\tpublic static Settings getInstance() {\n\t\treturn SettingsHolder.SETTINGS;\n\t}\n}\n```\n\n먼저, JVM의 ClassLoader에 의해 클래스가 로드될 때 실행하는 `loadClass()` 메서드의 내부를 봐보자.\n\n![](brain/image/dog-week05-1.png)\n\n여기서 보면 내부적으로 `synchronized`가 실행되는 것을 볼 수 있다. 그래서 명시적으로 synchronized를 이용하지 않고 동일한 효과를 낼 수 있다.\n\n왜냐하면, 해당 SettingsHolder 클래스는 static 이므로 메서드가 실행될 때 JVM의 static initializer에 의해 초기화되고 메모리로 올라간다. **따라서, thread-safe와 lazy-loading을 둘 다 만족하는 싱글턴이 구현 가능하다.**\n\n해당 코드의 문제점도 살펴보자. 클라이언트가 임의로 싱글턴을 파괴할 수 있다는 문제가 있다. 리플렉션과 직렬화를 통해 파괴할 수 있다고 한다.\n\n\u003cbr\u003e\n\n### Enum\n\n- enum 자체가 싱글턴이다.\n- 애초에 생성자를 private으로 갖게 만들거고 상수만 갖는 클래스이기 때문에 싱글턴의 성질을 가진다.\n- 리플렉션과 직렬화로 싱글턴을 깰 수도 없음.\n- 문제점 : 싱글턴을 해제할 때 번거러움, Enum 이외 클래스 상속 불가\n\n```java\npublic enum Settings {\n\tINSTANCE;\n}\n```\n\n\u003cbr\u003e\n\n### 권장 방법\n\n1. Bill Pugh 방법\n\t- Lazy Loading\n\t- thread-safe\n\n2. enum\n\t- thread-Safe\n\t- 간편하다\n\n\n\u003cbr\u003e\n\n### 정적 클래스\n\nstatic class : static method만 갖고 있는 클래스를 의미한다. 자바에서는 따로 정적 클래스라는 것이 존재하지는 않는다.\n\n\u003cbr\u003e\n\n```java\npublic class Setting {\n\tprivate Setting() {\n\t}\n\n\t// static 메서드들\n\tpublic static void setMap() {\n\t\n\t}\n}\n```\n\n\u003cbr\u003e\n\n싱글턴과의 공통점\n1. 스레드가 공유하는 메인 메모리쪽에 static이 올라가니까 전역적으로 사용 가능\n2. 인스턴스를 따로 생성하지 않아서 유일성을 보장받을 수 있다.\n\n싱글턴과의 차이점\n1. 인스턴스를 생성할 수 없기 때문에 클래스 메서드를 이용한다는 점\n\n\u003cbr\u003e\n\n**싱글턴 패턴 vs 정적 클래스**\n\n- 싱글턴 패턴\n\t- 상속 받아서 사용할 수 있다.\n\t- 메서드 파라미터로 사용할 수 있다.\n\t- 권장 환경\n\t\t- 완벽한 객체지향을 필요로 할 때 ( = 애플리케이션 내에서 객체처럼 사용하고 싶을 때 )\n\t\t- lazy-loading이 필요할 때 ( = 인스턴스 생성 할 때 리소스가 많이 드는 경우 )\n- 정적 클래스\n\t- 객체처럼 사용할 수는 없지만 컴파일 시 정적바인딩이 되기 때문에 보통 싱글턴보다 효율이 좋다.\n\t- 권장 환경\n\t\t- 유틸 메서드를 보관하는 용도로 사용할 때 ( = 유틸 클래스처럼 객체 성질이 필요 없을 때 사용하는 것을 권장 )\n\t\t- 다형성이나 상속이 필요없는 클래스\n\n\u003cbr\u003e\n\n### Spring 싱글턴\n\n사실, 위에서 언급한 다양한 싱글턴 패턴 구현의 단점들은 Spring 프레임워크를 사용하면서 모든 단점들이 없어지게 된다. 스프링에서 Bean 생성 시 별 다른 설정이 없으면 default로 싱글턴이 적용되는데, 이때 스프링은 컨테이너를 통해 직접 싱글턴 객체를 생성하고 관리한다.\n\n==**객체의 생성을 스프링에 위임함으로써 스프링 컨테이너가 관리하기 때문에 그러하다.**==\n\n스프링에서 DI(Dependency Injection)하는 방법으로 싱글턴 패턴을 적용하였다. \n\n- 싱글턴 : 농사를 하는 경우, 농부가 매번 삽을 만들면 삽을 만드는 것에 대한 리소스 낭비가 심할 것이기 때문에 공용 삽을 1개만 만들어 놓고 이를 돌려가면서 사용\n\n- DI : 농부의 손에 아무것도 쥐게 하지 않고, 손에 쥘 수 있도록 준비만 해놓은 상태에서 대감마님이 농사 도구를 손에 쥐어주는 상황\n\n싱글턴으로 공용 삽을 만들어놓은 상황에 알아서 사용하면 충분하지 않냐고 생각할 수 있다. 하지만, 그렇게 하면 삽을 만드는 시간, 메모리를 절약할 수 있는 장점이 있지만 **의존성이 높아져서 테스트하기 어려운 단점**이 있다.\n\n예를 들어, 공용 삽과 호미 각각 1개를 농부 10명이 돌려쓰는 경우가 있다. 공용 삽과 공용 호미가 땅을 파는(Digging) 기능이 잘 되는지 테스트 해보고 싶은데, 삽이 단 1개, 호미가 단 1개이기 때문에 돌려 가면서 테스트하기 힘들다. 이때, 대감마님이 나서서 너부터 이걸로 테스트 해봐. 다음은 너가 이걸로 테스트 해봐. 교통정리 해주면 해결될 것이다.\n\n농부가 땅파기 기능이 있는 도구를 받을 준비를 한 것이 생성자를 만들어 놓은 상태이다. 그리고 땅파 기 기능이 있는 인터페이스를 만들어놓으면 살과 호미는 땅파기 기능을 구현만 하면 된다. 이후, 대감 마님이 농사 도구를 농부에게 넘겨주는 식으로 하면 해결 !\n\n결과적으로, 스프링에서 싱글턴 패턴을 사용하면서 얻게 되는 장점에는\n- private 생성자가 필요 없어지게 되니까 상속이 가능해진다.\n- 의존성이 높아져서 테스트하기 어려웠던 문제를 해결하여 테스트하기 편해진다.\n- 프레임워크를 통해 1개의 객체 생성을 보장받을 수 있게 된다.\n- static 메서드를 사용하지 않아서 객체지향적으로 개발할 수 있다.\n\n\u003cbr\u003e\n\n## Annotation\n\n==**Annotation(주석) : 코드 사이에 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술이다.**==\n\n- 메타 데이터의 일종\n\t- 애플리케이션이 처리해야 할 데이터가 아니라 컴파일러를 위한 정보를 제공하기 위한 용도\n- 용도\n\t- 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공\n\t- 소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공\n\t- 실행 시(런타임 시) 특정 기능을 실행하도록 정보 제공\n- 동작 순서\n\t- 애노테이션 정의\n\t- 원하는 위치에 배치\n\t- 코드가 실행되는 중 Reflection을 이용하여 추가 정보를 획득하여 기능 실시\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eReflaction 상세보기\u003c/strong\u003e\u003c/summary\u003e\n\n-   Reflection이란 프로그램이 실행 중에 자신의 구조와 동작을 검사하고, 조사하고, 수정하는 것\n-   Reflection을 사용하면 컴파일 타임에 인터페이스, 필드, 메소드의 이름을 알지 못해도 실행 중에 클래스, 인터페이스, 필드 및 메소드에 접근할 수 있다. 또한 새로운 객체의 인스턴스화 및 메소드 호출을 허용한다.\n-   **Annotation 자체는 아무런 동작을 가지지 않는 단순한 표식일 뿐이지만, Reflection을 이용하면 Annotation의 적용 여부와 엘리먼트 값을 읽고 처리할 수 있다.**\n-   **Spring 컨테이너(BeanFactory)에서 객체가 호출되면 객체의 인스턴스를 생성하게 되는데 이 때 필요하게 된다. 즉, 프레임워크에서 유연성있는 동작을 위해 쓰인다.**\n-   Reflection을 이용하면 Annotation 지정만으로도 원하는 클래스를 주입할 수 있다.\n-   Class에 적용된 Annotation 정보를 읽으려면 java.lang.Class를 이용하고  \n    필드, 생성자, 메소드에 적용된 어노테이션 정보를 읽으려면 Class의 메소드를 통해 java.lang.reflect 패키지의 배열을 얻어야 한다.  \n    - Class.forName(), getName(), getModifier(), getFields() getPackage() 등등 여러 메소드로 정보를 얻을 수 있다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### Java Annotation\n\n자바 표준 애노테이션은 자바에서 기본적으로 제공하는 애노테이션이다. 가장 많이 사용하는 4가지 애노테이션은 아래와 같다.\n\n`@Override`\n- 선언한 메서드가 오버라이드 되었다는 것을 나타냄\n- 상위(부모) 클래스(혹은 인터페이스)에서 해당 메서드를 찾을 수 없으면 컴파일 에러 발생\n\n`@Deprecated`\n- 해당 메서드가 더 이상 사용되지 않음을 표시\n- 컴파일러에게 이 메서드는 없어질 것이라는 걸 알려주고 사용하지 말라고 경고하는 것\n\n`@SuppressWarnings`\n- 선언한 곳의 컴파일 경고를 무시\n\n`@FunctionalInterface`\n- Java 8부터 지원, 함수형 인터페이스를 지정\n- 메서드가 존재하지 않거나, 1개 이상의 메서드 (default 메서드 제외)가 존재할 경우 컴파일 오류 발생\n\n### Meta Annotation\n\n사용자가 직접 정의하여 사용하는 Custom Annotation을 만들 때 사용하는 것이 Meta Annotation이며, 프레임워크나 API 등을 만들어서 사용할 때 주로 사용한다. Custom Annotation은`@interface`를 통해 애노테이션 클래스를 작성할 수 있다. 이때 애노테이션은 내부에 값을 가질 수 있고 설정할 수 있는데, 설정하려면 `default 값` 형태로 설정해야 한다.\n\n`@Retention`\n- 애노테이션이 유지되는 기간을 정하기 위해 사용\n\n`@Target`\n- 애노테이션을 정의할 때 적용 대상을 지정할 때 사용\n\n`@Documented`\n- 애노테이션 정보를 javadoc로 작성된 문서에 포함\n\n`@Inherited`\n- 애노테이션이 하위 클래스에 상속되도록 함\n\n`@Repeatable`\n- 애노테이션을 반복해서 적용할 수 있게 함\n\n\u003cbr\u003e\n\n### Spring Annotation\n\n해당 Annotation에 대한 설명은 \u003ca href='https://velog.io/@ruinak_4127/Annotation%EC%9D%B4%EB%9E%80#annotation-%EC%A2%85%EB%A5%98' target='_blank'\u003eSpring Annotation 총정리\u003c/a\u003e에서 몇 가지 가져온 것이다.\n\n-   **@ComponentScan**\n    -   @Component, @Service, @Repository, @Controller, @Configuration이 붙은 클래스 Bean들을 찾아서 Context에 bean을 등록해주는 애노테이션\n    -   전부 다 @Component를 사용하지 않고 @Repository 등으로 분리해서 사용하는 이유는, 예를 들어 @Repository는 DAO에서 발생할 수 있는 unchecked exception들을 스프링의 DataAccessException으로 처리할 수 있기 때문이다.\n    -   또한 가독성에서도 해당 애노테이션을 갖는 클래스가 무엇을 하는지 단 번에 알 수 있다.\n-   **@EnableAutoConfiguration**\n    -   autoConfiguration도 Configuration중 하나에 해당한다.\n    -   spring.factories 내부에 여러 Configuration들이 있고 조건에 따라 Bean이 등록되게 되는데 메인 클래스 @SpringBootApplication을 실행하면 @EnableAutoConfiguration에 의해 spring.factories 안에 있는 수많은 자동 설정들이 조건에 따라 적용되어 수 많은 Bean들이 생성된다.\n    -   간단하게 정리하면, **Application Context를 만들 때 자동으로 빈설정이 되도록 하는 기능이다.**\n-   @Component\n    -   개발자가 직접 작성한 class를 Bean으로 등록하기 위한 애노테이션\n-   @Bean\n    -   개발자가 직접 제어가 불가능한 외부 라이브러리등을 bean으로 만들려할 때 사용되는 애노테이션\n-   @Configuration\n    -   @Configuration을 클래스에 적용하고 @Bean을 해당 class의 메서드에 적용하면 @autowired로 Bean을 부를 수 있다.\n-   @Autowired\n    -   스프링이 Type에 따라 알아서 Bean을 주입해준다.\n    -   Type을 먼저 확인한 후 못 찾으면 Name에 따라 주입한다.\n    -   강제로 주입하고자 하는 경우 @Qulifier을 같이 명시\n-   @Qualifier\n    -   같은 타입의 빈이 두 개 이상 존재하는 경우 스프링이 어떤 빈을 주입해야할 지 알 수 없어서 스프링 컨테이너를 초기화하는 과정에서 예외가 발생한다.\n    -   @Qualifier는 @Autowired와 함께 사용하여 정확히 어떤 bean을 사용할지 지정하여 특정 의존 객체를 주입할 수 있다.\n-   **@Resource**\n    -   **@Autowired와 마찬가지로 Bean 객체를 주입해주는데 차이점은 Autowired는 타입으로, Resource는 이름으로 연결해준다.**\n    -   **애노테이션 사용으로 인해 특정 Framework에 종속적인 애플리케이션을 구성하지 않기 위해서 @Resource 사용을 권장한다.**\n-   @Controller\n    -   API와 view를 동시에 사용하는 경우에 사용\n    -   보통 view 화면 return을 목적으로 사용한다.\n-   @RestController\n    -   view가 필요 없이 API만 지원하는 서비스에서 사용\n-   @SpringBootApplication\n    -   @Configuration, @EnableAutoConfiguration, @ComponentScan 3가지를 하나로 합친 애노테이션\n\n\u003cbr\u003e\n\n## Spring MVC\n\n\n\n\u003cbr\u003e\n\n## Layered Architecture\n\n==**레이어드 아키텍처 패턴은 소프트웨어 아키텍처의 일반적인 패턴 중 하나이다. 일반적으로 사용자 상호 작용 레이어, 비즈니스 로직 레이어, 데이터 액세스 레이어, 데이터베이스 레이어로 구성된다.**==\n\n레이어드 아키텍처 패턴은 백엔드 API 코드에 가장 널리 적용되는 패턴인데, **코드를 논리적인 부분 혹은 역할에 따라 독립된 모듈로 나누어서 구성하는 패턴**이다.\n\n![](brain/image/dog-week05-2.png)\n\n\u003cbr\u003e\n\n### Presentation Layer\n\nPresentation Layer(User Interface) : 사용자 상호작용 레이어로, 해당 시스템을 사용하는 사용자 혹은 클라이언트 시스템과 직접적으로 연결되는 부분이다. 사용자가 애플리케이션과 상호 작용할 수 있는 스크린, 폼, 메뉴, 리포트 등을 포함한다.\n\n웹 사이트에서는 UI 부분, 백엔드 API에서는 엔드포인트 부분에 해당한다. 그래서 백엔드 API 관점에서 보면, **Presentation layer에서 API의 엔드포인트들을 정의하고 전송된 HTTP request를 읽는 로직을 구현한다. 이 이상의 역할은 담당하지 않고 실제 시스템이 구현하는 비즈니서 로직은 다음 레이어로 넘긴다.**\n\n- EndPoint\n- Authentication (인증)\n- JSON Translation\n\n\u003cbr\u003e\n\n### Business Layer\n\nBusiness Layer(Business Logic) : 애플리케이션의 비즈니스 로직을 처리하는 레이어이다. Presentation layer에서 전송된 요청을 읽어들여 요청에 맞게 동작하는 로직을 구현하면 된다. 예를 들어 회원가입 요청 시 필수적인 요소들이 다 포함되어 있지 않으면 거부한다던가 하는 로직 등이 비즈니스 로직이다.\n\n-   Business Logic\n-   Validation (사용자 중심의 시스템 검증)\n-   Authorisation (권한 부여)\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e영단어 Verification vs Validation\u003c/strong\u003e\u003c/summary\u003e\n\n- **Verificaion**은 개발자 중심의 시스템 검증 과정이며, 무언가를 만드는 **\"과정\"을 잘 지켰는지**를 의미 ( 스펙에 대한 요구사항을 충족했니? )\n- **Validation**은 사용자 중심의 시스템 검증 과정이다. 무언가를 **최종적으로 만든 결과물이 잘 나왔는지**를 말한다. ( 사용자에 대한 요구사랑을 충족했니? )\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### Persistence Layer\n\nPersistence Layer(Data Access)는 데이터베이스와 상호 작용하며 데이터를 검색하고 저장한다. 즉, 데이터베이스와 관련된 로직을 구현하는 부분이다. Business Layer에서 필요한 데이터를 생성, 수정, 읽기 등을 처리하여 실제로 데이터베이스에서 데이터를 저장, 수정, 읽어오기를 하는 역할이다.\n\n- Storage Logic\n\n\u003cbr\u003e\n\n### Spring Layered Architecture\n\nSpring도 레이어드 아키텍터로 구성된다. 레이어는 자신의 고유 역할을 수행하고 인접한 다른 레이어에 무언가를 요청하거나 응답하기 때문에 각 레이어는 자신의 역할에만 충실하면 된다.\n\n**따라서 시스템 전체를 수정하지 않고 특정한 레이어의 기능을 개선하거나 교체할 수 있기 때문에 재사용성이 좋고 유지 보수하기에도 유리하다.  또한, 레이어별로 테스트 구현이 편해지고 코드 가독성도 높아진다.**\n\n- Presentation Layer\n\t- Controller가 여기에 속한다. view를 담당하는 부분으로, 클라이언트와 직접적으로 맞닿는 부분이다.\n- Business Layer\n\t- Service가 여기에 속한다. 비즈니스 핵심 로직을 처리하는 부분이기 때문인데, 이때 Service 객체라는 것은 **하나의 트랜잭션**으로 구성되어 작동한다.\n- Persistence Layer\n\t- Repository가 여기에 속한다.\n\n\u003cbr\u003e\n\n## 참고\n\n- [우테코 10분 테코톡 - 주디의 Spring Bean](https://www.youtube.com/watch?v=3gURJvJw_T4\u0026t=392s)\n- [프로그래머스 데브코스 - Bean의 LifeCycle 정다현](https://www.youtube.com/watch?v=5CBZPb3o0XI)\n- [우테코 10분 테코톡 - 아서의 싱글턴 패턴과 정적 클래스](https://www.youtube.com/watch?v=5oUdqn7WeP0)\n- [Java Annotation](https://bangu4.tistory.com/199)\n- [Custom Annotation](https://ittrue.tistory.com/m/158)\n- [Spring Annotation 총정리](https://velog.io/@ruinak_4127/Annotation%EC%9D%B4%EB%9E%80#annotation-%EC%A2%85%EB%A5%98)\n- [소프트웨어 아키텍처 패턴](https://velog.io/@vov3616/MVVM-MVC-MVP-MVI-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%BC%EA%B9%8C)\n- [레이어드 아키텍처 패턴](https://kimjingo.tistory.com/159)\n- [스프링 부트 레이어드 아키텍처](https://www.javatpoint.com/spring-boot-architecture)","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Interview/iv-Algo/":{"title":"기술면접 - 알고리즘","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Interview/iv-Common/":{"title":"기술면접 - 공통","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Interview/iv-DB/":{"title":"기술면접 - DB","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Interview/iv-DS/":{"title":"기술면접 - 자료구조","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Interview/iv-Java/":{"title":"기술면접 - Java","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Interview/iv-Network/":{"title":"기술면접 - 네트워크","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Interview/iv-OS/":{"title":"기술면접 - 운영체제","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Interview/iv-Spring/":{"title":"기술면접 - Spring","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Java/":{"title":"Java","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Java/GC":{"title":"Garbage Collector","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Java/JVM":{"title":"JVM","content":"\n","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Java/Java":{"title":"Java","content":"\n1996년 01월에 공식적으로 발표한 객체지향 프로그래밍 언어\n- [Java의 실행 원리](brain/Java/JavaExecute)는 너무나 중요하다.\n- 대표적인 [Java 버전](brain/Java/JavaVersion)은 Java 8, Java 11, Java 17이다.\n- 다양한 [환경설정](brain/Java/java-settings)을 통해 편리하게 사용하자\n\n\u003cbr\u003e\n\n## Java의 특징\n\n1. ==**운영체제에 독립적**==\n\t- Java Application은 운영체제나 하드웨어가 아닌 [JVM](brain/Java/JVM)하고만 통신\n\t- JVM이 Java Applcation으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달\n\t- Java로 작성된 프로그램은 운영체제에 독립적, JVM은 운영체제에 종속적\n\t- **한번 작성하면, 어디서나 실행된다(Write once, run anywhere)**\n\n2. 객체지향언어\n\t- 상속, 캡슐화, 다형성이 잘 적용된 순수 객체지향언어\n\n3. ==**자동 메모리 관리(Garbage Collection)**==\n\n\t- [Garbage Collector](brain/Java/GC)가 자동적으로 메모리 관리\n\t- 프로그래머가 보다 프로그래밍에 집중할 수 있게\n\n4. 네트워크, 분산처리 지원\n\t- 다양한 네트워크 프로그래밍 라이브러리(Java API) 지원\n\n5. ==**멀티스레드 지원**==\n\t- Java에서 개발된 멀티스레드 프로그램은 시스템과 관계없이 구현가능\n\t- 여러 스레드에 대한 [스케쥴링(scheduling)](brain/CS/OS/Scheduling)을 자바 인터프리터가 담당\n\n6. ==**동적 로딩(Dynamic Loading)을 지원**==\n\t- Java Application은 여러 개의 클래스로 구성\n\t- 동적 로딩 덕분에 실행 시 모든 클래스 로딩 X\n\t- 필요 시점에 클래스를 로딩 O\n\t- 일부 클래스가 변경되어도 전체 Application을 다시 컴파일하지 않아도 됨\n\t- 변경사항이 발생해도 비교적 적은 작업으로 유연한 Application 작성 가능","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Java/JavaExecute":{"title":"Java 실행원리","content":"\n![](brain/image/JavaExecute-1.png)\n\n![](brain/image/JavaExecute-2.png)\n\n![](brain/image/JavaExecute-3.png)\n\n![](brain/image/JavaExecute-4.png)","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Java/JavaVersion":{"title":"Java 버전별 특징","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Java/java-settings":{"title":"Java 환경설정","content":"\n\u003chr\u003e\n\n## Java 코딩 컨벤션\n\n- 클래스 이름 : 대문자로 시작\n\n- 패키지 이름 : 모두 소문자로\n\n- public 클래스는 단 하나, public 클래스 이름과 자바 파일이름은 동일하게\n\n- 변수, 메서드 이름 : 소문자로 시작, 이름이 길어지는 경우 camel notation이용하여 중간중간 대문자로 구분하기\n\n\u003chr\u003e\n\n## Java settings\n\n### Windows\n\n\u003ca href='https://suzxc2468.tistory.com/141' target='_blank'\u003e환경 변수 설정법 링크\u003c/a\u003e\n\n1. https://www.oracle.com/java/technologies/downloads/ 에서 Java 8에 Java SE Development Kit 8u341를 windows x64 다운로드 받기\n\n2. 검색창 - 내 pc(클릭 X, 마우스 우클릭) 속성 - 고급 시스템 설정 - 환경 변수\n\n\t- 아래 시스템 변수 - 새로 만들기\n\t\t- 변수 이름 : JAVA_HOME\n\t\t- 변수 값 : C:\\Program Files\\Java\\jdk1.8.0_341 (자바 JDK 설치 경로)\n\t- 아래 시스템 변수 - Path - 편집 - 새로 만들기\n\t\t- %JAVA_HOME%\\bin\n\t- 아래 시스템 변수 - 새로 만들기\n\t\t- 변수 이름 : CLASSPATH\n\t\t- 변수 값 : %JAVA_HOME%\\lib\n\n3. 환경변수 설정 이후 확인하려면 cmd에서 `javac -version` 입력\n\n4. 자바11 쓸거면 JAVA_HOME의 JDK 설치 경로만 11로 바꿔주면 됨\n\n\u003cbr\u003e\n\n### WSL2\n\n1. `sudo vi /etc/apt/sources.list`에서 카카오 미러서버 되어있는지 부터 확인\n\t- 안되어 있으면 `%s /기존주소/mirror.kakao.com` 으로 변경하고 저장\n\n2. `sudo apt-get update`로 우분투 패치\n\n3. `sudo apt install openjdk-11-jdk`로 자바11 JDK 설치\n\n\u003cbr\u003e\n\n- 환경설정\n\n1. `which java`로 java 위치 파악, 결과 `/usr/bin/java`로 뜰 것\n\n2. `readlink -f /usr/bin/java` 하면 결과 `/usr/lib/jvm/java-8-openjdk-amd64/bin/java`로 뜰 것, 여기서 `/usr/lib/jvm/java-8-openjdk-amd64`를 기억\n\n3. `sudo vi /etc/environment`에서 기존에 있던거 지우고 `JAVA_HOME=/usr/lib/jvm/java-11-openjdk-arm64` 입력 후 저장\n\n4. `source /etc/environment`로 환경설정 파일 적용\n\n5. `echo $JAVA_HOME`로 JAVA 환경변수 작동 확인. 경로 나오면 제대로 된거\n\n\u003cbr\u003e\n\n- 버전관리\n\n1. \u003ca href='https://codechacha.com/ko/ubuntu-install-open-jdk11/' target='_blank'\u003e블로그 링크\u003c/a\u003e를 따라하려고 했는데.. 나랑은 뭔가 달라서 일단\n\n2. `sudo apt install openjdk-8-jdk`로 자바8 jdk 설치\n\n3. `sudo update-alternatives --config java` 이거 해보면 알아서 적용 되어있음. 아마 환경설정할때 경로 다 날리고 JAVA_HOME만 냅둬서 그런듯\n\n4. 저기서 원하는 모드 선택하면 버전 왔다갔다 끝\n\n\u003cbr\u003e\n\n### Mac (M1)\n\nhomebrew를 이용한 jdk 설치는 인텔 맥을 기반으로 되어있어서, arm 칩셋인 M1은 다른 방식으로 설치하여야 한다.\n\n\u003cbr\u003e\n\n\u003ca href='https://www.azul.com/downloads/?version=java-17-lts\u0026os=macos\u0026architecture=arm-64-bit\u0026package=jdk' target='_blank'\u003ezulu\u003c/a\u003e에서 제공하는 java 버전, ARM-64bit, JDK를 선택하고 설치가 편한 dmg파일로 설치한다.\n\n- `/usr/libexec/java_home -V` : 설치된 자바 버전 목록\n\n- `java -version` : 현재 설정된 자바 버전 (상세한 버전)\n\n- `javac -version` : 현재 설정된 자바 버전 (간단히)\n\n\u003cbr\u003e\n\n이후 환경변수 설정을 위하여 zsh 설정 파일을 연다. (bash 쓰면 bash로)\n\n- `code ~/.zshrc`\n\n- 혹시 zsh 커맨드가 안먹으면 vscode 명령 팔레트에서 **셀 명령 : PATH에 코드 명령 설치**를 이용하여 설치하자.\n\n\n```bash\n# JAVA settings\nexport JAVA_HOME=$(/usr/libexec/java_home -v 1.8)\nalias setJava8='export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)'\nalias setJava11='export JAVA_HOME=$(/usr/libexec/java_home -v 11)'\nalias setJava17='export JAVA_HOME=$(/usr/libexec/java_home -v 17)'\nexport PATH=${PATH}:$JAVA_HOME/bin:\n```\n\n이와 같은 코드를 추가한다. alias를 추가해준 이유는 버전 왔다갔다하면서 사용하려고 추가한 것이다.\n\n\u003chr\u003e\n\n## IntelliJ settings\n\n1. 인텔리제이 pro버전 다운로드 체크는 전부 다 체크하고 맨 밑에 association만 java파일 연관 체크\n\n2. 깃허브 권한 설정으로 아이디 연동\n\n\u003cbr\u003e\n\n### IntelliJ plugins\n\n- Material Theme UI\n\t- 인텔리제이 테마 설정 플러그인\n\t- Monokai Pro 이용 중, 우측 하단에서 설정 가능\n\n![](brain/image/java-settings-1.png)\n\n\u003cbr\u003e\n\n- Atom Material Icons\n\t- 인텔리제이 폴더 아이콘 플러그인\n\n![](brain/image/java-settings-2.png)\n\n\u003cbr\u003e\n\n- CodeGlance Pro\n\t- 코드 우측에 vscode 처럼 작은 화면 뜨는거\n\t- 클릭하면 해당 위치로 바로 이동 가능\n\n![](brain/image/java-settings-3.png)\n\n\u003cbr\u003e\n\n- Commit Message Template\n\t- commit 메시지 템플릿 생성\n\t- Settings - Tools - Commit Message Template\n\t- 좌측 메뉴바 - commit - 연필모양\n\n![](brain/image/java-settings-4.png)\n\n![](brain/image/java-settings-5.png)\n\n![](brain/image/java-settings-6.png)\n\n\u003cbr\u003e\n\n- Embedded Web Browser\n\t- 프로그래머스 같은 문제 풀 때 인터넷 창 띄워놓기\n\t- 우측 메뉴바에 Embedded Web Browser 클릭\n\t- 링크는 찾아서 붙여넣기\n\n![](brain/image/java-settings-7.png)\n\n\u003cbr\u003e\n\n- Key Promoter X\n\t- 마우스로 수행한 동작 단축키 알려줌\n\n![](brain/image/java-settings-8.png)\n\n![](brain/image/java-settings-9.png)\n\n\u003cbr\u003e\n\n- Presentation Assistant\n\t- 키보드로 수행한 동작 단축키 보여줌\n\n![](brain/image/java-settings-10.png)\n\n![](brain/image/java-settings-11.png)\n\n\u003cbr\u003e\n\n- Nyan Progress bar\n\t- 진행바 귀여운 고양이 표시\n\n![](brain/image/java-settings-12.png)\n\n\u003cbr\u003e\n\n- Rainbow Brackets\n\t- 중괄호 구분하기 쉽게 색깔 표시\n\n![](brain/image/java-settings-13.png)\n\n\u003cbr\u003e\n\n- Discord Integration\n\t- 디스코드 게임 활동 중에 인텔리제이 뜨도록\n\n![](brain/image/java-settings-14.png)\n\n\u003cbr\u003e\n\n## 참고\n\n- https://suzxc2468.tistory.com/141\n- https://codechacha.com/ko/ubuntu-install-open-jdk11/\n- https://www.azul.com/downloads/?version=java-17-lts\u0026os=macos\u0026architecture=arm-64-bit\u0026package=jdk","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/":{"title":"강의","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-git/":{"title":"코딩애플 - Git","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-git/apple-git":{"title":"코딩애플 git","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/git-and-github/' target='_blank'\u003e코딩애플의 git/github 강좌\u003c/a\u003e의 필기와 제가 알던 지식을 정리한 글 입니다. \n\n\u003chr\u003e\n\n## git 세팅\n\n\u003cbr\u003e\n\n**Windows**\n\n1. 구글에 git windows 검색 후 다운\n2. 설치 과정에서 `Use Visual Studio Code as Git's default editor` 체크\n3. 설치 과정에서 `Override the default branch` 체크하고 원하는 branch 명 \u003cbr\u003e 현재, 깃과 깃허브 기본 브랜치를 **master**로 설정해놨음\n4. 설치 과정에서 기본 에디터 체크 안했다면 `git config --global core.editor \"code --wait\"`\n5. 기본 브랜치 바꾸는 명령어는 `git branch -M 브랜치명`\n\n\u003cbr\u003e\n\n**mac**  \n\n1. 구글에 Homebrew 검색 후 설치\n2. 터미널에 `brew install git` 입력 후 깃 설치\n3. `git config --global init.defaultBranch master` 기본 브랜치 master 설정\n4. `git config --global core.editor \"code --wait\"` 기본 에디터 vscode 설정\n5. 만약, 기본 브랜치 바꾸는 명령어는 `git branch -M 브랜치명`\n\n\u003cbr\u003e  \n\n```bash\ngit config --global init.defaultBranch master\ngit config --global core.editor \"code --wait\"\ngit config --global user.email \"github 아이디\"\ngit config --global user.name \"이름\"\ngit config --global core.autocrlf true # windows\ngit config --global core.autocrlf input # mac\n```\n\n\u003cbr\u003e\n\n### 현재 세팅\n\n```bash\n[user]\n    name = jae_yoon(mac)\n    email = wlwhsvkdlxh@gmail.com\n\n[init]\n    defaultBranch = master\n\n[core]\n    editor = code --wait\n    autocrlf = input\n\n[push]\n    default = current\n\n[pull]\n    rebase = true\n\n[diff]\n    tool = vscode\n\n[difftool \"vscode\"]\n    cmd = code --wait --diff $LOCAL $REMOTE\n\n[alias]\n    hist = log --graph --all --pretty=format:'%C(yellow)[%ad]%C(reset) %C(green)[%h]%C(reset) | %C(white)%s %C(bold red)[[%an]]%C(reset) %C(blue)%d%C(reset)' --date=short\n\n[merge]\n    tool = vscode\n\n[mergetool \"vscode\"]\n    cmd = code --wait $MERGED\n\n[mergetool]\n    keepBackup = false\n```\n\n\u003chr\u003e\n\n## git 명령어\n\n### 기본 명령어\n\n![[brain/image/apple-git-1.png]]\n\n  \n\n```bash\ngit init # 초기 폴더를 git 사용할 수 있게\ngit add file_name # 작업 폴더 -\u003e staging area\ngit commit -m \"memo\" # staging area -\u003e repository\ngit status # staging area 목록 확인\ngit log --all --oneline # commit 내역 한 줄로 조회\ngit commit --amend -m \"메모\" # 가장 최근 commit 내용 변경\n```\n\n작업 폴더에서 staging area로 올릴 파일을 고르는 행위를 **스테이징 한다** 라고 함\n\ngit add는 파일을 새로 추적할 때도 사용하고\n\n수정한 파일을 staged 상태로 만들 때도 사용한다.\n\n\u003cbr\u003e\n\n### git diff\n\n- `git diff` : 최근 commit과 현재 파일의 차이점 보여줌\n\n- j, k로 스크롤바 조작 / q로 종료\n\n- diff가 엔터키 하나, 스페이스바 하나만 했다고 해도 차이점으로 보여주기 때문에 좀 쓰레기 같음\n\n- `git difftool` : vi 에디터 형태로 비교해서 편하게 보여줌\n\n- vi에디터 기본 동작키 h, j, k, l, `:q` 이런거 사용\n\n- `git difftool 커밋아이디` : 현재 파일과 특정커밋 비교 가능\n\n- 사실 difftool도 쓰레기라... 그냥 vscode로 설정하고 보자\n\n- vscode extensions에서 git graph 다운받으면\n\n\u003cbr\u003e\n\n```bash\ngit config --global diff.tool vscode\ngit config --global difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE'\ngit difftool\n```\n\n\u003cbr\u003e\n\n### vscode git\n\n![](brain/image/apple-git-2.png)\n\n1. 1번 버튼 누르면 사용 가능\n\n2. 플러스 모양 눌러서 `작업폴더 -\u003e staging area`\n\n3. 마이너스 모양 눌러서 `staging area -\u003e 작업폴더`\n\n4. 체크 모양 눌러서 `staging area -\u003e repository`\n\n5. 그래프 모양 눌러서 브랜치 별 커밋 내용들, 각 파일 눌러서 diff 모두 확인 가능\n\n\u003cbr\u003e  \n\n### git branch\n\n![](brain/image/apple-git-3.png)\n\n```bash\ngit branch 브랜치명 # 브랜치 생성\ngit switch 브랜치명 # 브랜치로 이동\ngit log --all --oneline --graph # branch 그래프 모양도 같이 보기\ngit merge 브랜치명 # 현재 위치(HEAD)에 브랜치명을 병합\n```\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-4.png)\n\n- 충돌이 났을 때, 어떤 것을 적용할 지 선택하고 꼭 git add, git commit 해주자.\n\n- merge는 현재 위치(HEAD)에 브랜치를 병합하는 과정이다. 따라서 switch로 브랜치 이동을 꼭 해주고 병합하자.\n\n- 과거에는 checkout을 주로 썼는데, checkout은 만능인 반면 switch는 정말 브랜치 이동만 한다. 무지성 checkout 하는걸 염려해서 브랜치 이동은 `switch`, 스테이징 취소는 `git restore --staged \u003cfile\u003e` 명확하게 나눠서 사용하는 추세인 듯 하다.\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-5.png)\n\n![](brain/image/apple-git-6.png)\n\n- git graph로 보면 시간 순서가 완벽하게 되어있는데, git log는 그래보이진 않음\n\n\u003cbr\u003e\n\n```bash\ngit branch # 브랜치 목록 확인 (로컬)\ngit branch -r # 브랜치 목록 확인 (원격 ex.github)\ngit branch -a # 브랜치 목록 확인 (전체)\ngit branch -d 브랜치명 # 브랜치 삭제 (로컬저장소)\ngit push origin --delete 브랜치명 # 브랜치 삭제 (원격저장소)\n```\n\n\u003cbr\u003e\n\n```bash\ngit branch -d 브랜치명 # merge 완료된 브랜치 삭제\ngit branch -D 브랜치명 # merge 안한 브랜치 삭제\n# 깔끔하게 그 브랜치에서 작업한거 싹 날라감\n\ngit branch -m 변경전 변경후 # 브랜치명 변경\ngit branch -M 브랜치명 # 기본 브랜치 변경\n```\n  \n\u003cbr\u003e\n\n### git hist\n  \n\u003cbr\u003e\n\n`git hist`는 실제로는 없는 명령어이다. 매번 `git log --all --oneline --graph` 이런식으로 작성하기 귀찮으니까 `alias` 기능으로 만든 것이다. 일종의 커스텀 기능이다. 원래 oneline만 하면 날짜나 누가 커밋했는지는 안나와서, 내가 커스텀 한 것은 아래와 같다.\n\n```bash\ngit config --global alias.hist \"log --graph --all --pretty=format:'%C(yellow)[%ad]%C(reset) %C(green)[%h]%C(reset) | %C(white)%s %C(bold red)[[%an]]%C(reset) %C(blue)%d%C(reset)' --date=short\"\n```\n\n![](brain/image/apple-git-7.png)\n\n- 날짜, 커밋명 간단히, 커밋내용, 커밋작성자, 브랜치 다 보인다.\n\n- 보면 git config user name을 수정했었는데, `origin/master`, `orign/HEAD` 저기까지가 깃허브에 git push로 올렸던 커밋들이다. 그 이후 user name을 저렇게 수정했었다. 아직은 push 하지 않은 상태라 브랜치가 coupon, HEAD -\u003e master 이렇게 되어있는 모습이다.\n\n- vim 환경이기 때문에 j가 아래 방향키, k가 위 방향키로 잘먹는다.  \n\n\u003chr\u003e\n\n## 방법론\n  \n\u003cbr\u003e\n\n### 3-way merge\n\n![](brain/image/apple-git-8.png)\n\n- 신규 브랜치, merge 하고자 하는 중심 브랜치 각각에 새로운 commit이 있을 때 merge하면 두 브랜치의 코드를 합쳐서 새로운 commit을 자동으로 생성\n\n- 3-way merge 방식은 merge 했다는 흔적이 남게 된다.\n\n- 3-way 방식이 싫은 경우 강제로 \u003ca href='/brain/Lecture/apple-git/apple-git/#rebase-and-merge'\u003erebase하여 fast-forward 방식\u003c/a\u003e을 사용하거나 \u003ca href='/brain/Lecture/apple-git/apple-git/#squash-and-merge'\u003esquash and merge 방식\u003c/a\u003e을 사용한다.\n\n\u003cbr\u003e  \n\n모든 브랜치를 3-way merge 해버리면 나중에 참사가 일어날 수 있다.\n\n![](brain/image/apple-git-9.png)\n\n- 3-way merge 되면, 흔적이 남아서 매우 복잡하게 보인다.\n\n![](brain/image/apple-git-10.png)\n  \n- master branch의 git log를 출력해보면 3-way merge 된 branch들의 commit 내역도 다 같이 출력되어서 보기 더럽다. (ex. 깃허브에서 커밋 내역 볼 때)\n\n이러한 참사를 해결하기 위하여 **squash and merge 방식**을 사용하곤 한다.\n\n\u003cbr\u003e\n\n### fast-forward merge\n\n![](brain/image/apple-git-11.png)\n  \n- 신규 브랜치에만 새로운 commit이 있고 merge 하고자 하는 브랜치에는 새로운 commit이 없는 경우 사용하는 merge 방식\n\n- 그냥 신규 브랜치보고 지금부터 너의 이름은 master 브랜치야! 라고 한다.\n\n- 그래서 merge한 흔적이 남지 않는다.\n\n- fast-forward merge가 싫은 경우 강제로 `git merge --no --ff 브랜치명`으로 강제로 3-way merge 할 수 있다.\n\n\u003cbr\u003e\n\n### rebase and merge\n\n![](brain/image/apple-git-12.png)\n\n- rebase는 브랜치의 시작점을 다른 commit으로 옮겨주는 것\n\n- 신규 브랜치, merge 하고자 하는 중심 브랜치 각각에 새로운 commit이 있을 때 신규 브랜치의 시작점을 merge 하고자 하는 중심 브랜치의 가장 최근 commit으로 옮기고 fast-forward 방식으로 merge 한다.\n\n- 3-way merge가 싫을 때 사용할 수 있다.\n\n- 역시나 merge한 흔적이 남지 않는다.\n\n- 단, rebase를 사용했기 때문에 master branch의 새로운 커밋과 **conflict 할 가능성이 매우 높아진다.**\n\n\u003cbr\u003e\n\n**rebase and merge 사용법**\n\n1. rebase 할, 시작점 바꾸고 싶은 브랜치로 이동\n\n2. `git rebase merge할 브랜치명`\n\n3. 그 다음 이동하여 fast-forward merge\n\n```bash\ngit switch sub\ngit rebase master\ngit switch master\ngit merge sub\n```\n\n\u003cbr\u003e\n\n### squash and merge\n\n![](brain/image/apple-git-13.png)\n\n- 3-way merge가 너무 많아서 git log 보기 힘들까봐 주로 사용\n\n- merge 흔적이 남지 않음\n\n- 브랜치에서 만들어놨던 많은 commit을 모두 합쳐서 하나의 commit으로 master 브랜치에 생성해줌  \n\n\u003cbr\u003e\n\n**squash and merge 사용법**\n\n```bash\ngit switch master\ngit merge --squash 브랜치명\ngit commit -m \"메세지\"\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 그래서 어떤 방식?\n\n\u003cbr\u003e  \n\n- 프로젝트 마다, 팀마다 branching/merge 가이드가 존재\n\n- 예를 들어, 안중요한 잔챙이 브랜치는 **squash**하세요.\n\n- feature/develop 브랜치는 **3-way merge**하세요.\n\n- 혼자서 할 때는 대충 쓰세요.\n\n\u003chr\u003e\n\n## git merge 실습\n\n실습과정에서, branch를 만드는 시점은 중요하다. 예를 들어, commit2에서 git branch를 이용하며 브랜치를 생성하면 commit2가 시작지점이 되는 것이니까. 이를 잘 이해하며 실습을 시작한다.\n\n### 3-way merge 실습\n\n![](brain/image/apple-git-14.png)\n\n- 분기되었던 모습, 즉, merge된 흔적이 남아있다.\n\n- `git branch -d 3-way`로 브랜치를 지워도 그래프 모양으로 나타난다.\n\n- 3-way merge는 각각의 브랜치가 합쳐져서 새로운걸 만들어내는 형태라 mergetool이 따로 열렸다. 그래서 Merge branch 'commit4'와 같이 커밋을 남겼다.\n\n\u003cbr\u003e\n\n### fast-forward 실습\n\n![](brain/image/apple-git-15.png)\n\n- fast-forward 방식은 master 브랜치에 새로운 commit이 없으니까 master 브랜치의 HEAD만 fastforward 브랜치로 바뀐 모습이다.\n\n- 따라서, merge 흔적이 남아있지 않다.\n\n- HEAD만 바뀌는 형태라 mergetool이 따로 열리지 않았다.\n\n- HEAD가 `(HEAD -\u003e master, fast)` 이런식으로 나타났다.\n\n\u003cbr\u003e\n\n### rebase and fast-forward 실습  \n\n![](brain/image/apple-git-16.png)\n\n- rebase 하기 전 모습\n\n![](brain/image/apple-git-17.png)\n\n- rebase 이후 모습\n\n- 그래프에서 분기가 사라짐을 확인 가능하다.\n\n![](brain/image/apple-git-18.png)\n\n- rebase 이후 fast-forward 한 모습\n\n- fast-forward 방식과 동일하게 HEAD만 바뀐 모습이다.\n\n\u003cbr\u003e\n\n### squash and merge 실습\n\n![](brain/image/apple-git-19.png)\n\n- squash 하기 이전 모습\n  \n![](brain/image/apple-git-20.png)\n\n- squash를 하고 나서 squash는 되었지만, HEAD는 업데이트가 되지 않았다고 한다. commit을 추가적으로 하고 log를 확인해보면\n\n![](brain/image/apple-git-21.png)\n\n- commit4가 정상적으로 생성된 모습이다. 하지만 squash 브랜치는 남아있다. 그래서 `git branch -D squash`로 브랜치를 삭제해보면\n\n![](brain/image/apple-git-22.png)\n  \n- 이와 같이 깔끔하게 merge 흔적이 사라진 모습이다.\n\n- squash로 merge하면 브랜치의 내용이 순간이동하는 개념이라 squash 브랜치는 아직 merge 되지 않았다고 나왔다. 그래서 `git branch -d squash`가 아닌 `git branch -D squash`로 삭제했다.\n\n\u003chr\u003e\n\n## git 되돌리기\n\n\u003cbr\u003e\n\n### git restore  \n\n- 파일 하나를 수정하고 싶은데 ctrl + z로 수정하기에 수정사항이 너무 많다면 사용\n\n- 해당하는 commit 시점으로 파일 내용 되돌림\n\n```bash\ngit restore 파일명\ngit restore --source 커밋아이디 파일명\ngit restore --staged 파일명\n```\n\n예를 들어, `a.txt` 파일 작업 중, 내용1을 입력하고 커밋1, 내용2를 입력하고 커밋2를 한 상태라고 하자. 내용3을 입력했다가 뭔가 이상해서 파일 내용을 돌리려고 하면 `git restore a.txt`를 사용해서 가장 최신 커밋으로 돌리자.  \n\n만약, 가장 최신 커밋보다 이전의 커밋으로 내용을 돌리고 싶으면 `git restore --source 커밋아이디 파일명`으로 돌아가자.\n\n`git add`로 작업폴더에서 staging area로 올렸다가 staging area에서 다시 작업폴더로 내리고 싶으면, 즉, 스테이징을 취소하고 싶으면 `git restore --staged 파일명`을 사용하도록 하자.\n\n\u003cbr\u003e  \n\n### git revert\n\n- commit을 취소하고 싶은 경우 revert 사용\n\n- commit을 없애는 건 아니고 commit 하나를 취소한 commit을 하나 생성해줌\n\n![](brain/image/apple-git-23.png)\n\n- 예를 들어, b파일을 만든 **244ef15** commit을 취소하고싶음.\n\n- `git revert 244ef15`를 입력하면 에디터가 열림. 그리고 새로운 commit을 하나 추가해줌.\n\n- 결과적으로 244ef15에서 일어난 commit을 취소해줌\n\n- 작업폴더에서 a파일과 c파일만 있고 b파일은 사라져있을 것\n\n- merge로 생성된 commit도 취소 가능\n\n```bash\ngit revert 커밋아이디\ngit revert 커밋아이디1 커밋아이디2\ngit revert HEAD # 가장 최근 commit 취소\n```\n\n\u003cbr\u003e\n\n### git reset\n\n- 특정 commit 시절로 아예 모든 것을 되돌려버림  \n\n```bash\ngit reset --hard 커밋아이디\ngit push -f # 원격저장소에도 업데이트 하기\n```\n\n![](brain/image/apple-git-24.png)\n\n- git revert 예제에서 git reset --hard 한 모습\n\n- 아예 c파일 생성, revert b 커밋 자체가 날라간 모습\n\n- (주의) 따라서, 협업시 사용금지. 갑자기 커밋을 다 날려버릴 수도 있기 때문이다.\n\n\u003cbr\u003e\n\n혼자 작업할 때도 reset을 잘 사용하지는 않는다. 기억 잃고 7살로 되돌아갈래?라고 한다면 안돌아가지 않을까. 미래 기억을 reset은 삭제해버리니까 좀 쫄린다.  \n\n```bash\ngit reset --soft 커밋아이디\n```\n\n- 리셋이긴 한데, 변동사항을 지우지는 않고 staging area에 올려놓는다. 사용하려면 git commit 하면 됨\n\n```bash\ngit reset --mixed 커밋아이디\n```\n\n- 리셋이긴 한데, 변동사항을 지우지는 않고 staging area에도 올려놓지 않는다. 사용하려면 git add, git commit 둘다 해야함\n\n\u003chr\u003e\n\n## git push\n\n- 로컬 repository를 원격 repository로 올리기\n  \n```bash\ngit push -u 원격저장소주소 올릴로컬브랜치명\ngit remote add 변수명 주소\ngit push origin 올릴로컬브랜치명\ngit remote -v # 변수목록 확인\ngit clone 원격저장소주소 # 원격저장소 받아오기\n```\n\n- `git push -u https://github.com/Shin-Jae-Yoon/TIL.git master`라고 하면 로컬의 master 브랜치가 해당하는 원격저장소에 push 된다.\n\n- 매번 주소 치기 귀찮으니까 remote 기능 이용해보자.\n\n- `git remote add origin https://github.com/Shin-Jae-Yoon/TIL.git`이라고 하면 git 주소를 origin 변수에 저장한 것이다.\n\n- `git push -u origin master`이라고 하면 위의 것과 같은 말이다.\n\n- `-u` 옵션은 주소를 기억하라는 옵션이라서 앞으로는 `git push`만 입력해도 될 것 이다.\n\n\u003cbr\u003e  \n\n### .gitignore\n\n원격저장소에 쓸데없는 파일은 commit해서 올리지 않도록 하는 것이 좋은데, `.gitignore` 파일을 만들면 원격저장소에 올리지 않을 파일들을 쉽게 명시 가능하다. 명시된 파일들은 git add 해도 스테이징 되지 않는다.\n  \n예를 들어, `node_modules`는 깃허브에 올리지 않는다. 어차피 `package.json` 파일만 잘 있으면 `npm install` 했을 때 자동으로 `node_modules` 폴더가 생성되니까.\n\n\u003chr\u003e\n\n## github 이용 협업\n\n- 기본적으로 `git clone 원격저장소` 하는 것부터 시작한다.\n\n- 팀원도 push 하고 싶으면 깃허브의 settings -\u003e Access -\u003e Collaborators -\u003e Manage access에서 팀원 깃헙아이디를 등록해놔야 push 가능해진다.  \n\n\u003cbr\u003e\n\n### 다른 팀원이 최근에 git push 한 경우\n\n다른 팀원이 최근에 git push 한 경우에 내가 git push를 하지 못하는 경우가 있을 수 있다. 즉, 원격저장소에 변동사항이 생겨서 새로운게 생기면 git push 하지 못한다. 이런 경우 `git pull`로 먼저 원격저장소의 내용을 가져와서 업데이트 해야 한다.\n  \n\n```bash\ngit pull origin 브랜치명\n# 원격저장소에서 해당하는 branch만 pull 가능\n```\n\ngit pull은 엄밀히 말하면 `git fetch + git merge`이다. 원격 저장소의 신규 commit을 가져오고 내 브랜치에 merge 하는 것이다. 이 말은 merge 과정에서 conflict 발생 가능성이 있다는 말이다. 뭐 conflict 나면 에디터 열고 수정해야지 ...\n\n\u003cbr\u003e\n\n### pull request\n\n- 프로젝트를 할 때 branch를 쪼개서 작업하는 경우가 많아질 것\n\n- 예를 들어, `git push origin feature`로 feature 브랜치를 로컬에서 생성하고 작업하고 있다고 가정하자. (물론, 깃허브에서 브랜치 생성하고 pull 해왔어도 가능)\n\n- feature가 잘 작동해서 master 브랜치에 merge 하려고 한다.\n\n- github에서 merge 하거나\n\n- 로컬에서 merge 한 다음 push 하거나\n\n- 협업할 때는 merge 하기 전에 검토를 하는 경우가 일반적\n\n- github의 pull request 기능을 이용해보자.\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-25.png)\n\n1. 로컬 환경에서 만든 다른 브랜치로 작업하고 `git push origin 만든브랜치` 해서 브랜치에서 작업한 내용을 원격 repository로 push\n\n2. github에서 pull requests 탭 들어가서 pull request 생성\n\n3. 검토해보고 merge 될 것 같으면 3가지 옵션 중 선택해서 merge\n\n4. conflict 발생했다면 github에서 수정 가능하니까 conflict 해결하기\n\n5. 다쓰고 나면 브랜치 삭제해주고 이런건 알아서 하기\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-26.png)\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-27.png)\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-28.png)\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-29.png)\n  \n\u003cbr\u003e\n\n![](brain/image/apple-git-30.png)\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-31.png)\n\nmerge 전략 3가지 역시 깃허브에 반영되어있음.\n\n\u003cbr\u003e\n\n1. create a merge commit\n\n새로운 merge commit 생성해주는 \u003ca href='/brain/Lecture/apple-git/apple-git/#3-way-merge'\u003e3-way-merge\u003c/a\u003e를 실행한다. master 브랜치 조회해보면 합쳐진 브랜치의 commit 내역도 전부 나온다. 역시 git log를 보면 합쳐진 브랜치도 나오기 때문에 commit 내역이 많으면 복잡하고 더러워 보일 수 있다.\n\n\u003cbr\u003e\n\n2. squash and merge\n\n합쳐질 브랜치의 commit 내역을 하나로 합쳐서 master 브랜치에 신규 commit을 생성해준다. git log를 보면 합쳐진 브랜치는 안나온다. commit을 하나로 합쳐서 master 브랜치로 순간이동하는 방식이라 많은 사람이 선호한다.\n\n\u003cbr\u003e\n\n3. rebase and merge\n\n합쳐질 브랜치를 master 브랜치 최신 commit으로 rebase 하고 나서 fast-forward merge 같은 작동을 해준다. 결과는 squash and merge와 비슷한데, 합쳐질 브랜치의 commit 내역이 전부 보존된다. 하지만, git log에는 합쳐진 브랜치가 나오지 않는다.\n\n\u003chr\u003e\n\n## 브랜치 전략\n\n- 프로젝트 커지고 사람 많아져도 branch, merge를 깔끔하게 하려고 사용하는 전략들이 있다. **GitFlow, Github Flow, Trunk-based, Gitlab Flow**\n\n\u003cbr\u003e  \n\n### Git Flow 전략\n\n![](brain/image/apple-git-32.png)\n\n![](brain/image/apple-git-33.png)\n\n![](brain/image/apple-git-34.png)\n\n**GitFlow** 개발 전략은 게임 개발 같이 항상 안정적인 release를 해야하는 경우에 사용하기 적합하다. 크게 5개 브랜치를 운영한다.\n\n- main 브랜치\n\n- develop 브랜치 (개발용, main 브랜치의 복사본)\n\n- feature 브랜치 (develop에 기능 추가용)\n\n- hotfix 브랜치 (main 브랜치 버그 픽스용)\n\n- release 브랜치 (develop 브랜치를 main 브랜치에 merge 하기 전 최종 테스트본, 가끔 사용)\n\n장점은 안정적이지만, 단점은 간단한 개발의 경우 리소스 낭비가 심할 수 있다. 간단한 작업임에도 매번 develop 브랜치~ release 브랜치~ 이런식으로 진행해야하니까. 최근 CI/CD를 도입하는 회사가 많이 늘었는데, 그런 경우에 git flow 전략은 적합하지 않다.\n\n\u003e \u003ca href='https://seosh817.tistory.com/104' target='_blank'\u003eCI/CD\u003c/a\u003e에 관한 것은 해당 링크에 자세히 설명되어있다.\n\n  \n\n\u003cbr\u003e\n\n  \n\n### Trunk-based 전략\n\n![](brain/image/apple-git-35.png)\n\n코드 짠 것을 대충 배포해도 상관없거나 굳이 큰 업데이트가 없는 안정적인 프로그램의 경우, git flow 처럼 많은 브랜치를 만드는 것보다 해당하는 **Trunk-based 전략**이 더 적합할 수 있다. 그냥 main 브랜치와 기능추가용 feature 브랜치만 사용하면 된다. **github flow**도 해당하는 전략과 비슷하다.\n\n1. 기능추가, 버그픽스가 필요하면 main 브랜치에서 새로운 브랜치를 분기하여 코드 작성\n\n2. 기능이 완성되면 main 브랜치에 merge (다 쓴 브랜치 삭제)\n\n3. main 브랜치를 필요할 때마다 배포\n\n\u003cbr\u003e\n\n**장점**은 코드를 한 브랜치에서만 관리하기에 편하다는 점이다. 이때 크게 개발하고 한 번에 merge 하는 것보다 작은 단위로 자주 merge 하는 것이 더 안전하다. **단점**은 역시 main 브랜치의 코드가 뻑이 나면 큰일나서 테스트나 코드 리뷰를 자주해야 한다. 그래서 테스트와 배포를 자동으로 하는 \u003ca href='https://seosh817.tistory.com/104' target='_blank'\u003eCI/CD\u003c/a\u003e를 도입한 곳에서 자주 사용한다.\n\n\u003chr\u003e\n\n## git stash\n\n- 코드를 작성하다가 잠시 보관하고 싶을 때 사용\n\n- 최근 commit과 차이점 있는 부분 전부 보관\n\n- 스테이징 되었든 안되었든 모두 stash 된다\n\n- 하지만, 스테이징 안해놓은 새로운 파일 (untranked file 인듯)은 stash 안될 수도 있다.  \n\n\u003cbr\u003e\n\n\n**stash 되는 파일 목록** \u003cbr\u003e\u003cbr\u003e\n\nstash란 아래에 해당하는 파일들을 보관해두는 장소 이다.\n\n1. Modified이면서 Tracked 상태인 파일\n\n\t- Tracked 상태인 파일을 수정한 경우\n\n\t- Tracked: 과거에 이미 commit하여 스냅샷에 넣어진 관리 대상 상태의 파일\n\n2. Staging Area에 있는 파일(Staged 상태의 파일)\n\n\t- git add 명령을 실행한 경우\n\n\t- staged 상태로 만들려면 git add 명령을 실행해야 한다.\n\n\t- git add는 **파일을 새로 추적할 때도 사용**하고 **수정한 파일을 Staged 상태로 만들 때**도 사용한다.\n\n```bash\ngit stash\ngit stash list # 보관된 코드 목록\ngit stash save \"메모\" # 메모와 함께 보관\ngit stash pop # 코드 다시 불러오기\ngit stash drop 번호 # stash 1개 삭제\ngit stash clear # stash 전부 삭제\n```\n\n- git stash pop은 pop에서 알 수 있다시피 가장 최근 것부터 가져온다. stash는 스택에 새로운 stash가 만들어지면서 저기에 넣고 working directory, 작업공간이 깔끔해지는 효과이다.\n\n\u003cbr\u003e\n\n\u003e [!note] stash가 왜 필요함? 주석처리 하면 어떰?  \n\u003e\n\u003e 주석처리를 한다고 하더라도 commit 하면 그 내역이 같이 올라간다. 따라서 그걸 숨기고 싶을 때 stash 쓰면 유용하다. 혹은 따로 stash 같은 역할을 하는 branch 하나 만들고 거기에 작성해도 된다. 둘 중 마음에 드는 방식 사용하자.","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-html/":{"title":"코딩애플 - HTML/CSS","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-html/all-in-one":{"title":"All-in-One 강의노트","content":"\n\u003cbr\u003e\n\n\u003e [!note] HTML/CSS All-in-one : 기초부터 Bootstrap, SASS, 고급 animation 까지\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2022.07.02 ~ 2022.07.25\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e 백엔드여도, 웹 개발자이기 때문에 웹의 기초 구조를 파악하는 것에 목적 \u003cbr\u003e\n\u003e 클론코딩 하며 최대한 실습 위주\n\n## 목차\n\n- [코딩애플 All-in-One 기초모듈](brain/Lecture/apple-html/all-in-one-basic)\n- [코딩애플 All-in-One 중급모듈](brain/Lecture/apple-html/all-in-one-mid)\n- [코딩애플 All-in-One 고급모듈](brain/Lecture/apple-html/all-in-one-last)","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-html/all-in-one-basic":{"title":"All-in-One 기초모듈","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/html-basics/' target='_blank'\u003eHTML/CSS All-in-one : 기초부터 Bootstrap, SASS, 고급 animation 까지\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## HTML\n\n\u003cbr\u003e\n\n### HTML 태그\n\n- 띄어쓰기를 하고 원하는 class 붙이면 클래스 2개 이상 가능\n\n```html\n\u003cdiv class=\"container text-center\"\u003e\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n### input 태그 name 속성\n\n- input 태그에 name 속성을 지정하면 서버에 name에 해당하는 변수로 데이터를 전송\n\n\n```html\n\u003cinput type=\"text\" name=\"age\" /\u003e\n\u003c!-- age라는 변수로 서버에 전송 --\u003e\n```\n\n\u003cbr\u003e\n\n- 서버에 데이터 전송할 때 방식 2개\n\n\t1. `\u003cinput type=\"submit\"\u003e`\n\t2. `\u003cbutton type=\"submit\"\u003e전송\u003c/button\u003e`\n\n\u003cbr\u003e\n\n### select 태그\n\n- 드롭다운 구현 가능\n\n```html\n\u003cselect\u003e\n\t\u003coption\u003e자장면\u003c/option\u003e\n\t\u003coption\u003e짬뽕\u003c/option\u003e\n\t\u003coption\u003e탕수육\u003c/option\u003e\n\u003c/select\u003e\n```\n\n\u003cbr\u003e\n\n### label 태그  \n\n- input 태그 체크박스 활용할 때 의미 없는 글자는 span 태그를 사용해도 되지만, label 태그를 이용해보자.\n\n- input태그의 id와 label 태그의 for를 동일하게 맞춰주면 label 태그의 글자를 클릭해도 체크박스가 선택된다.\n\n```html\n\u003cinput id=\"sub\" type=\"checkbox\" /\u003e \u003clabel for=\"sub\"\u003eSubscribe\u003c/label\u003e\n```\n\n\u003cbr\u003e\n\n### table\n\n- table 태그로 감싸며 thead 태그와 tbody 태그를 써주는 것이 보기 좋다.\n\n- 그리고 tr 태그로 행 먼저, 그 이후 td 태그로 열, 아래는 3행 3열 테이블\n\n```html\n\u003ctable\u003e\n\t\u003cthead\u003e\n\t\t\u003ctr\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\u003c/tr\u003e\n\t\u003c/thead\u003e\n\t\u003ctbody\u003e\n\t\t\u003ctr\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\u003c/tr\u003e\n\t\t\u003ctr\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\u003c/tr\u003e\n\t\u003c/tbody\u003e\n\u003c/table\u003e\n```\n\n- 셀 병합을 할때는 `\u003ctd colspan=\"4\"\u003e\u003c/td\u003e`와 같이 colspan에 합치기 원하는 숫자를 넣기\n\n- 추가로 html 테이블에서 td의 width를 설정하면 전체 열의 width가 변한다.\n\n\u003chr\u003e\n\n## CSS\n\n\u003cbr\u003e\n\n### float 속성\n\n- float는 요소를 **공중에** 붕 띄워서 왼쪽/오른쪽 정렬하는 속성\n\n- 공중에 붕 띄는 속성 때문에 다음에 오는 div 박스가 보이지 않는 경우 발생\n\n- `clear: both`를 이용해서 초기화 해줘야함\n\n```css\n.box_practice .article01 {\n\tfloat: left;\n}\n\n.box_practice .article02 {\n\tfloat: right;\n}\n\n.box_practice .footer {\n\tclear: both;\n}\n```\n\n\u003cbr\u003e\n\n\u003e **참고**\n\u003e \u003cbr\u003e\n\u003e float 속성으로 가로 정렬할 때 float 박스들을 감싸난 하나의 큰 div 박스를 만들고 \u003cbr\u003e\n\u003e 폭을 지정해주는게 좋다. 그래야 모바일에서 흘러넘치지 않는다.\n\n```html\n\u003cdiv\u003e\n\t\u003cdiv class=\"left-box\"\u003e\u003c/div\u003e\n\t\u003cdiv class=\"right-box\"\u003e\u003c/div\u003e\n\t\u003cdiv class=\"footer\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n### Selector 셀렉터\n\n- 셀렉터 사용 시 공백 말고 꺽쇠( `\u003e` )도 가능\n\n- 단, 꺽쇠 사용 시 4~5개 이상 연달아쓰는건 권장X 버그의 원인\n\n```html\n\u003cui class=\"navbar\"\u003e\n\t\u003cli\u003e\u003cspan\u003e안녕\u003c/span\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003c/li\u003e\n\u003c/ui\u003e\n```\n\n```css\n.navbar li \u003e span {\n\tcolor: red;\n}\n```\n\n\u003cbr\u003e\n\n- `nth-child()` 셀렉터는 여러 요소 중 원하는 n번째 요소에 스타일을 주기 위함이다.\n\n```css\n.cart-table td:nth-child(2) {\n\tcolor: red;\n}\n\n.cart-table td:nth-child(n + 2) {\n\tcolor: blue;\n}\n```\n\n- 위의 코드는 2번째에 나오는 td에만 color를 주는 것이고\n\n- 아래의 코드는 2번째 이후에 나오는 td들에 color를 주겠다는 것\n\n\u003cbr\u003e\n\n### background 속성\n\n- 그냥 이미지를 넣어도 되지만, background도 생각\n\n- `background-image: url(./img/img03.png);` 배경 이미지 설정 (이때, url 여러개 넣어서 배경 겹치기 가능)\n\n- `background-size: cover;` 배경 이미지 div 박스에 꽉차게\n\n- `background-size: contain;` 배경 이미지 잘리지 않게\n\n- `background-repeat: no-repeat;` 반복되는거 없애기\n\n- `background-position: center;` center를 기준으로 배경 채움\n\n- `background-attachment: fixed;` 스크롤 될 때 배경 동작 설정 방식\n\n- `filter: brightness(50%)` 배경에 보정 입히기 - 명도 (단, 안에 글씨 있으면 글씨도 필터가 입혀지니까 이는 조심하자.)\n\n\u003cbr\u003e\n\n### 배경에 검은색 틴트 주기\n  \n```css\n.main-background {\n\tbackground-image: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)),\n\turl(이미지경로~~);\n}\n```\n\n\u003cbr\u003e\n\n### margin collapse 현상\n\nmargin collapse 현상은, div 박스 두 개가 겹친 경우에 **박스 2개의 위쪽 테두리가 겹치면, margin도 합쳐지는 현상**을 의미한다.\n\n\u003cbr\u003e\n\n```html\n\u003cdiv class=\"main-background\"\u003e\n\t\u003ch4 class=\"main-title\"\u003eBuy Our Shoes!\u003c/h4\u003e\n\u003c/div\u003e\n```\n\n이 경우에서 박스 2개가 겹쳐지게 되어, main-title에 margin-top을 주면 margin이 합쳐진 현상이라 같이 내려가게 될 것이다. 해결방안으로는, 테두리가 안붙게 하면 된다. 부모 박스에 `padding: 1px`과 같은 조작을 취하면 된다.\n\n\u003cbr\u003e\n\n### 좌표 이동\n\n- `position` 속성 부여하여 좌표이동 가능해짐.\n\n- 특징 01 : 좌표 이동 가능\n\n- 특징 02 : float와 비슷하게 공중에 뜨는 원리\n\n- `position: relative` 내 원래 위치가 기준\n\n```css\n.main-button {\n\tposition: relative;\n\ttop: 100px; // 위쪽에서부터 100px\n\tleft: 100px; // 왼쪽에서부터 100px\n}\n```\n\n- `position: static` 좌표 이동 금지\n\n- `position: fixed` 현재 화면 (viewport) 기준으로 고정\n\n- navbar 같은거 스크롤 해도 상단에 고정시키면 좋으니까, 그럴 때 사용\n\n- `position: absolute` 내 부모 태그 중에 `position: relative` 가진 부모를 기준으로 한다.\n\n- `position: absolute` 요소를 **가운데 정렬**하는 방법\n\n```css\n.main-btn {\n\tposition: absolute;\n\tleft: 0;\n\tright: 0;\n\tmargin: auto;\n\twidth: 30%;\n}\n```\n\n\u003cbr\u003e\n\n### z-index\n\n- div 박스가 겹칠 때 우선순위를 두기\n\n- `z-index: 1`, `z-index: 5` 숫자가 클 수록 (높을 수록) 앞에 온다.\n\n\u003cbr\u003e\n\n### width의 영역에 관한 문제\n\n- width는 div 박스의 너비가 아니라 **width는 내부 content 영역의 너비를 의미한다.** padding이나 border에 width는 영향을 주지 않는다.\n\n- 해결하려면, content 부분만 width로 설정하는 것이 아니라, padding과 border를 모두 포함하라고 시키면 된다.\n\n- `box-sizing: border-box;` - width가 padding, border를 포함한다.\n\n- content-box는 padding과 border를 포함하지 않는 경우이다.\n\n- 아래의 예제로 box-sizing이 있고 없고를 비교해보기\n\n  \n```css\n.explain-box {\n\tposition: relative;\n\tmargin: auto;\n\tpadding: 20px;\n\ttext-align: center;\n\ttop: -80px;\n\tmax-width: 600px;\n\twidth: 80%;\n\theight: 40%;\n\tbackground-color: rgb(238, 237, 239);\n\tbox-sizing: border-box;\n}\n```\n\n\u003cbr\u003e\n\n### css 초기 설정시 편한 것, normalize\n\n```css\n\nbody {\n\tmargin: 0px;\n}\n\ndiv {\n\tbox-sizing: border-box;\n}\n\nhtml {\n\tline-height: 1.15; /* 기본 행간 높이 */\n}\n```\n\n혹은 크롬, 파이어폭스, 사파리와 같이 브라우저 호환성 이슈가 있을 때 css 파일에 추가하고 시작하면 좋은 설정들이 있다. (버튼의 크기나 이미지가 브라우저마다 다르거나 한 경우 때문에)\n\n\u003cbr\u003e\n\n\u003ca href='https://github.com/necolas/normalize.css/blob/master/normalize.css' target='_blank'\u003enormalize.css\u003c/a\u003e를 참고하도록 하자.\n\n\u003cbr\u003e\n\n### input type에 따른 css 셀렉터\n\n- 아래와 같이 지정하면 input type이 text인 아이들만 css 스타일링 가능\n\n```css\ninput[type='text'] {\n\tpadding: 10px;\n\tfont-size: 20px;\n\tborder: 1px solid black;\n}\n```\n\n\u003cbr\u003e\n\n### vertical-align 속성\n\n- inline/inline-block 요소 간의 세로정렬 할 때 vertical-align을 사용한다.\n\n- 테이블 사용 시 수직 정렬에도 사용 가능\n\n- pratice02.html에서 실패했던 이유는 ? div박스와 조작을 시도했기 때문\n\n- 해결책은 하나의 div 박스 내에서 img와 글자를 span태그로 묶어서 그 둘을 vertical-align 했으면 가능했을 듯하다.\n\n```html\n\u003cdiv\u003e\n\t\u003cimg\n\tsrc=\"https://mdn.mozillademos.org/files/12245/frame_image.svg\"\n\twidth=\"32\"\n\theight=\"32\"\n\t/\u003e\n\t\u003cspan style=\"vertical-align : middle;\"\u003e\n\timage with a default alignment.\u003c/span\u003e\n\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n### table 태그 border-radius 오류\n\n- border-collapse 속성을 table 태그에 적용했을 때 border-radius가 안먹는 오류가 있다.\n\n\u003cbr\u003e\n\n- 첫 번째 해결방안\n\n```css\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\n\n(왼쪽위에있는 td) {\n\tborder-top-left-radius: 5px;\n}\n```\n\n\u003cbr\u003e\n\n- 두 번째 해결방안\n\t- box-shadow 속성을 이용하여 테두리를 가짜로 만들어내는 편법\n\n```css\n\ntable {\n\tborder-collapse: collapse;\n\tborder-radius: 7px;\n\tborder-style: hidden;\n\tbox-shadow: 0 0 0 1px #666;\n}\n```\n\n\u003cbr\u003e\n\n### button 태그 같이 hover 할 때 마우스 커서\n\n- `:hover`로 pseudo-class를 하지 않아도 `cursor:pointer`와 같이 작성하면 올렸을 때 마우스 커서 바뀜\n \n```css\nbutton {\n\tpadding: 15px;\n\tfont-size: 20px;\n\tborder: none;\n\tcursor: pointer;\n}\n```\n\n\u003cbr\u003e\n\n### input 태그 focus 스타일 안먹힐 때\n\n- `input:focus`를 해서 border 속성을 지정했는데 색깔이 안먹는 경우가 있다.\n- 그럴때는 크롬 기본속성인 outline을 none으로 설정해주자.\n\n```css\n.cart-footer .input-test:focus {\n\toutline: none;\n\tborder: 2px solid rgb(2, 77, 163);\n}\n```\n\n\u003cbr\u003e\n\n### css의 다양한 pseudo-class\n\n```css\n/* 외우는법 hofa */\n\n:hover /*마우스를 올려놓을 때*/\n:focus /*클릭 후 계속 포커스 상태일 때*/\n:active /*클릭 중일 때*/\n\n:link /* 방문 전 링크 */\n:visited /* 방문 후 링크 */\n:any-link /*방문 전, 방문 후 링크 한번에 선택할 때*/\n\n:playing /*동영상, 음성이 재생중일 때*/\n:paused /*동영상, 음성이 정지시*/\n:autofill /*input의 자동채우기 스타일*/\n:disabled /*disabled된 요소 스타일*/\n:checked /*체크박스나 라디오버튼 체크되었을 때*/\n\n:blank /*input이 비었을 때*/\n:valid /*이메일 input 등에 이메일 형식이 맞을 경우*/\n:invalid /*이메일 input 등에 이메일 형식이 맞지 않을 경우*/\n:required /*필수로 입력해야할 input의 스타일*/\n\n:nth-child(n) /*n번째 자식 선택*/\n:first-child /*첫째 자식 선택*/\n:last-child /*마지막 자식 선택*/\n```\n\n\u003cbr\u003e\n\n### 코드 양이 줄어드는 class 작명법 (OOCSS, BEM)\n\n- **OOCSS (Object Oriented CSS)**\n\n- CSS 양이 줄어들고, 유지보수 편리\n\n- 뼈대용 class, 살점용 class 각각 제작\n\n- 뼈대 디자인을 먼저 분리해놓고 색깔과 같은 살점을 추가하는 방식\n\n```html\n\u003cbutton class=\"main-btn bg-red\"\u003e버튼1\u003c/button\u003e\n\u003cbutton class=\"main-btn bg-blue\"\u003e버튼2\u003c/button\u003e\n```\n\n```css\n.main-btn {\n\tpadding: 15px;\n\tfont-size: 20px;\n\tborder: none;\n\tcursor: pointer;\n}\n\n.bg-red {\n\tbackground: red;\n}\n\n.bg-blue {\n\tbackground: blue;\n}\n```\n\n\u003cbr\u003e\n\n- OOCSS를 극단적으로 여러 **Utility class**를 만들어 놓을 수 있다.\n\n```css\n.f-small {\n\tfont-size: 12px;\n}\n\n.f-mid {\n\tfont-size: 16px;\n}\n\n.f-lg {\n\tfont-size: 20px;\n}\n\n.bg-red {\n\tbackground: red;\n}\n\n.bg-blue {\n\tbackground: blue;\n}\n\n```\n\n```html\n\u003cbutton class=\"main-btn bg-red f-lg\"\u003e버튼\u003c/button\u003e\n```\n\n\u003cbr\u003e\n\n- **BEM (Block\\_\\_Element--Modifier)**\n\n- class 작명할 때 창의력이 부족한 경우 BEM 작명법을 이용할 수 있다.\n\n- `class = \"덩어리이름__역할--세부특징\"`\n\n```html\n\u003cdiv class=\"profile\"\u003e\n\t\u003cimg class=\"profile__img\" /\u003e\n\t\u003ch4 class=\"profile__title\"\u003e\u003c/h4\u003e\n\t\u003cp class=\"profile__content\"\u003e\u003c/p\u003e\n\t  \n\t\u003cbutton class=\"profile__button--red\"\u003e버튼1\u003c/button\u003e\n\t\u003cbutton class=\"profile__button--blue\"\u003e버튼2\u003c/button\u003e\n\u003c/div\u003e\n\n```\n\n- 사람마다 다르다. OOCSS를 쓰면 html이 더러워져서 추천하지 않는 사람도 있음\n\n- BEM도 Modifer는 빼고 Block\\_\\_Element까지만 쓰는 사람도 있음\n\n- 최근, React나 Vue로 HTML 만들면 굳이 OOCSS, BEM 굳이 안쓰는 경우가 많아서 깊게 익힐 필요 X\n\n- React나 Vue에서는 html 페이지 단위가 아닌, 작은 덩어리 (component) 단위로 개발하게 된다. 이때 profile과 같이 class 명이 중복되어도 컴포넌트끼리 스타일이 간섭되지 않게 코드 작성이 가능하다. 대표적으로, React의 styled-components 라이브러리를 사용하면 가능하다.","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-html/all-in-one-last":{"title":"All-in-One 고급모듈","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/html-basics/' target='_blank'\u003eHTML/CSS All-in-one : 기초부터 Bootstrap, SASS, 고급 animation 까지\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## Pseudo-element\n- pseudo-class (다른 상태일 때 스타일 줄 때) `.class:`\n- pseudo-element (내부의 일부분만 스타일 줄 때) `.class::`\n\n\u003cbr\u003e\n\n기초 모듈 수업에서 pseudo-class 가 무엇인지 학습했었다. `:hover`와 같이 특정 요소가 다른 상태일 때 (ex. 마우스 올렸을 때) 스타일 줄 수 있게 해주는 것이었다. pseudo-element는 콜론 2개 `::`를 입력하여 사용한다.\n\n```css\n/* 이러면 pseudo 클래스의 첫 번째 글자만 빨간색으로 바뀜! */\n.pseudo::first-letter {\n\tcolor: red;\n\tfont-size: 2rem;\n}\n```\n\n\u003cbr\u003e\n\n보통 `::after (내부 맨 뒤에 뭔가 추가)`나 `::before (내부 맨 앞에 뭔가 추가)`를 어느정도 자주 사용하는 편이다.  \n\n```css\n/* 이러면 pseudo 클래스 맨 뒤에 '안녕' 글자 생김 */\n.pseudo::after {\n\tcontent: '안녕';\n\tcolor: red;\n\tfont-size: 2rem;\n}\n```\n\n만약, float를 사용해서 `clear: both;`를 하고 싶은 경우에 pseudo-element를 이용해서 빈 div 박스를 추가해줄 수 있다. (즉, 귀찮게 html 맨 밑에 div 박스 추가하고 style 줄 필요 없다는 말이지만, 나는 앞으로 float 안쓰고 flex 같은거 쓸거니깐... 그래도 혹시 모르니 메모 !)\n  \n```css\n.product-container::after {\n\tcontent: ''; /* 그냥 내용 없는거 */\n\tdisplay: block;\n\tclear: both;\n\tfloat: none;\n}\n```\n\n\u003cbr\u003e  \n\n`input 태그의 type이 file`인 경우 화면에 `파일 선택` 버튼 말고 `선택된 파일 없음`이라는 글자가 나온다. 아래에서 설명한 shadow dom인데 이 경우 단순히 input 태그를 조작하여서 버튼 색깔을 변경할 수는 없다.\n\n```css\n/* 이러면 \"선택된 파일 없음\" 여기 배경색이 바뀜 */\n.input_file {\n\tbackground: skyblue;\n}\n\n/* 이렇게 해야 \"파일 선택\" 버튼의 배경색이 바뀜 */\n.input_file::file-selector-button {\n\tbackground: skyblue;\n}\n\n/* pseudo-element에 pseudo-class도 사용 가능 */\n\n.input_file::file-selector-button:hover {\n\tbackground: blue;\n}\n```\n\n\u003cbr\u003e\n\n- Pseudo-element 활용한 쓸데없는 짓들\n\n- CSS 만으로 버튼에 마우스 올리면 배경 어둡게하기 https://codepen.io/css-tricks/pen/dxyfA\n\n- CSS만으로 3D 느낌 리본모양만들기 https://codepen.io/team/css-tricks/pen/mVZGKa\n\n- ol 태그의 숫자 스타일링하기 https://www.456bereastreet.com/archive/201105/ styling_ordered_list_numbers/\n\n- table 반응형으로 만드는 여러가지 방법 https://css-tricks.com/responsive-data-tables/\n\n- CSS만으로 영문 폰트 만들기 https://yusugomori.com/projects/css-sans/fonts\n\n\u003chr\u003e  \n\n## Shadow DOM\n\n```html\n\u003cinput type=\"file\" /\u003e\n```\n\n이와 같은 코드 입력 시, 화면에 `파일 선택` 버튼 말고 `선택된 파일 없음`이라는 글자가 나온다. 분명 태그 하나만 사용했는데 2개를 사용한 것처럼 보인다. 이것은 **Shadow DOM**이라는 숨겨진 요소 때문이다.  \n\n\u003cbr\u003e\n\n크롬 개발자 도구 설정에서 Elements의 `Show user agent shadow DOM`을 체크한 이후 input 태그의 내부를 살펴보면 shadow-root가 있고 그 안에 보면 `pseudo=\"-webkit-file-upload-button\"`이 있을 것이다. 이것이 shadow DOM이다. input 태그 하나만 입력해도 span 태그인 선택된 파일 없음이 한 번에 입력되도록 개발자에게 편하려고 생긴 것이다.\n\n\u003cbr\u003e  \n\n그래서 결국, 버튼에 배경색을 주려면 위에서 했던 `.input_file::file-selector-button` 말고 어떻게 하지?\n\n\u003cbr\u003e\n\n**input [type=file]**\n\n```css\ninput[type='file']::-webkit-file-upload-button {\n\tbackground: black;\n\tcolor: white;\n}\n```\n\n크롬 개발자 도구 열어서 pseudo 부분을 pseudo-element 부분에다가 넣고 스타일링 하면 된다. 왜냐면 pseudo-element 역할 자체가 **내부의 일부분만 스타일 줄 때** 사용하는 것이니까 내부의 버튼에만 스타일을 주고싶은 거니까 이렇게 사용하는 것이다.\n\n\u003cbr\u003e\n\n추가로, `-webkit-`은 크롬, 사파리, Edge에서만 적용되는 스타일이다. Firefox는 `-moz`를 작성해야하고 Explorer는 `-ms-`를 사용한다. 즉, 브라우저마다 shadow DOM 까보면 살짝씩 다르다.\n\n\u003cbr\u003e\n\n\u003e [!note]  실제 파일 업로드 버튼 만드는 것\n\u003e\n\u003e 글자를 눌러도 버튼이 선택되게 스타일링한다.\n그리고 input태그는 display를 none 줘버린다.\n\n\n```html\n\u003clabel for=\"sub\"\u003e\n\t파일 업로드\n\t\u003cinput id=\"sub\" type=\"file\" style=\"display: none\" /\u003e\n\u003c/label\u003e\n```\n\n\u003cbr\u003e  \n\n**input placeholder**\n\ninput 태그의 `placeholder`도 div 박스 두 개의 형태 같지 않는가? shadow DOM인가? 까보면 역시 그렇다.\n\n```css\n/* 이러면 placeholder 안에 글자 색깔 빨간색으로 바뀜 */\ninput::-webkit-input-placeholder {\n\tcolor: red;\n}\n```\n\n\u003cbr\u003e\n  \n**input [type=range]**\n\nrange 또한 마찬가지이다. range는 id가 track과 thumb 두 개가 있음을 확인 가능하다. 그런데 아마 손잡이 thumb는 pseudo 어쩌구가 없어서 선택 어떻게 해야하나 의문이 들 것이다. 눌러서 밑에 보면 `user agent stylesheet`가 보일 것인데 **브라우저 기본 CSS**를 의미한다. 우리가 스타일 주지 않아도 기본적으로 보이는 스타일이다. 따라서, 여기 `input[type='range']::-webkit-slider-thumb` 부분을 복사해오고 조작하면 된다. 따옴표나 i 이런건 지우고 사용한다. 이때, apperance가 기본 값이 auto라서 none으로 바꾸고 사용해야 한다. 손잡이 thumb의 apperance만 바꾸면 안되고 range 자체의 apperance를 바꿔야 적용될 것이다.\n\n\u003cbr\u003e\n\n```css\ninput[type='range'] {\n\tappearance: none;\n\tbackground-color: lightgray;\n\tborder-radius: 1rem;\n}\n\ninput[type='range']::-webkit-slider-thumb {\n\tappearance: none;\n\tbackground-color: green;\n\twidth: 1rem;\n\theight: 1rem;\n\tborder-radius: 1rem;\n}\n```\n\n\u003cbr\u003e\n\n**progress**\n\n```css\nprogress {\n\t/*기본 배경은 없애주는게 좋습니다*/\n\t-webkit-appearance: none;\n\t-moz-appearance: none;\n\tappearance: none;\n\tbackground: white;\n\t\n\t/* IE10 호환성용 */\n\tcolor: red;\n}\n\nprogress::-webkit-progress-bar {\n\tbackground-color: lightgray;\n\tborder-radius: 1rem;\n}\n\nprogress::-webkit-progress-value {\n\tbackground-color: red;\n\tborder-radius: 1rem;\n}\n\n/*파이어폭스 호환성을 위해*/\nprogress::-moz-progress-bar {\n\tbackground-color: red;\n\tborder-radius: 2px;\n}\n```\n\n\u003chr\u003e\n\n## Sass\n\n- CSS를 개선한 CSS 전처리언어 (Preprocessor) = SASS\n\n- Sass에는 조건문, 반복문, 변수, 함수 존재\n\n- 즉, 문법이 존재한다는 의미 =\u003e 반복적인 부분 쉽게 처리 가능\n\n- SASS 파일은 `파일명.scss`\n\n- 웹 브라우저는 sass파일을 읽지 못하니까 css로 변환 작업이 필요하다. vscode extension에서 `Live Sass Compiler version 5 이상`을 설치한다. 그러면 vscode 하단에 `Watch Sass`가 보인다. 이를 누르면 scss에서 css로 변환이 된다.\n\n- 같이 생성되는 `.map`파일은 크롬 개발자도구 디버깅 용도이다. 크롬에서는 scss 파일을 읽는 것이 아니라 css 파일을 읽을 것이다. `.map` 파일이 있으면 크롬에서 css가 아닌 scss 파일로 분석해준다.\n\n\u003cbr\u003e\n\n1. 코드를 scss에 작성\n2. html에 파일 넣는건 css 파일 넣기\n\n\u003cbr\u003e\n\n\u003e [!note] 하단에 바가 안보여서 watch sass를 찾을 수 없다면?\n\u003e\n\u003e View - Appearance - Status bar 켜기\n\n\u003cbr\u003e\n\n파일 확장명에 따른 차이\n\n- sass 문법을 작성해서 만든 파일명은 2개가 있음\n- `.scss` : 중괄호 써야 하는거 (보통 이거 많이 사용)\n- `.sass` : 중괄호 안써도 되는거\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Sass 문법\n\n\u003cbr\u003e\n\n### 문법01. 값을 저장하고 사용하는 변수\n\n- 어려운 단어 기억해야할 때 변수 문법을 사용한다. `$변수명 : 저장해서 사용할 값;`\n- 규칙적인 스타일 만들 때도 변수를 사용하는 것은 도움이 된다.\n- 사칙연산 바로 가능 (단, %에서 px 빼는 행위는 하지 말고 같은 단위끼리 하자.)\n\n```css\n/* 기존 css 코드 */\n.background {\n\tbackground-color: #2a4cb2;\n}\n\n.box {\n\tcolor: #2a4cb2;\n}\n```\n  \n```scss\n// 변수 사용 scss 코드\n$메인컬러: #2a4cb2;\n\n.background {\n\tbackground-color: $메인컬러;\n}\n```\n\n```scss\n// scss 응용하기 좋은거\n$메인컬러: #2a4cb2;\n$서브컬러: #eeeeee;\n$기본사이즈: 16px;\n\n.background {\n\tbackground-color: $메인컬러;\n\tfont-size: $기본사이즈 - 2px;\n}\n\n.box {\n\tcolor: $서브컬러;\n\tfont-size: $기본사이즈 + 2px;\n}\n```\n\n위 코드는 font-size를 기본사이즈에서 빼고 더함으로써 **상대적인 크기**를 결정했다. 그래서 나중에 수정하기에 용이하다. 즉, 규칙적인 스타일 만들 때도 변수를 사용하는 것은 도움이 된다는 의미이다.\n\n\u003cbr\u003e  \n\n```scss\n// 괄호를 치는 것이 좋은 습관 !\n$기본사이즈: 16px;\n\n.box {\n\tfont-size: $기본사이즈 + 2px;\n\twidth: (100px * 2);\n\theight: (300px / 3);\n}\n```\n\n\u003cbr\u003e\n\n사실 CSS 기본 문법에도 변수 문법 이용 가능하고 사칙연산도 사용 가능하다. 근데 귀찮음\n\n\u003cbr\u003e  \n\n### 문법02. 셀렉터 대신 사용하는 Nesting\n\n- 관련있는 class들을 묶어서 사용할 때 편함\n- nesting 안에다가 또 nesting 가능하지만, 보통 2개 이상 중첩하지는 않음\n\n```css\n/* CSS 문법 */\n.navbar ul {\n\twidth: 100%;\n}\n\n.navbar li {\n\tcolor: black;\n}\n```\n\n```scss\n// sass 문법\n.navbar {\n\tul {\n\t\twidth: 100%;\n\t}\n\n\tli {\n\t\tcolor: black;\n\t}\n}\n```\n\n```scss\n// sass 문법으로 hover 사용법\n.navbar {\n\t:hover {\n\t\tcolor: blue;\n\t}\n}\n\n.navbar {\n\t\u0026:hover {\n\t\tcolor: blue;\n\t}\n}\n```\n\n- 위의 방식은 `.navbar :hover`\n- 밑의 방식은 `.navbar:hover`\n- 즉 `\u0026`기호를 붙히면 셀렉터를 스페이스바 없이 붙힐 수 있음\n\n\u003cbr\u003e\n\n### 문법03. 이미 있는 클래스를 확장하는 @extend\n\n- 반복되는 코드 없애고 싶을 때 사용\n- class 전체를 복사해주는 문법이 `@extend`\n- `%`는 `.` 대신 사용할 수 있는 임시 클래스\n- css에서 클래스로 컴파일하고 싶지 않을 때 사용\n- 컴파일 하고나면 `%` 안에 있는 것들은 모두 사라짐\n\n1. 중복된 스타일이 많으면 클래스로 묶는다\n2. `@extend`로 필요할 때 복사한다.\n\n```scss\n%btn {\n\twidth: 100px;\n\theight: 100px;\n\tpadding: 20px;\n}\n\n.btn-green {\n\t@extend %btn;\n\tcolor: green;\n}\n\n.btn-red {\n\t@extend %btn;\n\tcolor: red;\n}\n```\n\n```css\n/* 위의 scss에서 컴파일된 css 결과 */\n.btn-green,\n.btn-red {\n\twidth: 100px;\n\theight: 100px;\n\tpadding: 20px;\n}\n\n.btn-green {\n\tbackground: green;\n}\n\n.btn-red {\n\tbackground: red;\n}\n```\n\n\u003cbr\u003e\n\n### 문법04. 코드를 한 단어로 축약하는 @mixin\n\n- 약간 함수 같은 느낌\n- `@mixin`으로 선언, `@include`로 불러오기, `$ 변수 사용해서 파라미터`\n- `@extend`와 비슷해보이지만 파라미터 때문에 `@mixin`을 더 많이 사용함\n\n```scss\n@mixin 버튼기본디자인() {\n\tfont-size: 16px;\n\tpadding: 10px;\n}\n\n.btn-green {\n\t@include 버튼기본디자인();\n\tbackground: green;\n}\n```\n\n```scss\n@mixin 버튼기본디자인($구멍1, $구멍2) {\n\tfont-size: 16px;\n\tpadding: 10px;\n\tbackground: $구멍1;\n\tcolor: $구멍2;\n}\n\n.btn-green {\n\t@include 버튼기본디자인(green, black);\n}\n```\n\n```css\n/* 컴파일된 css 파일 */\n.btn-green {\n\tfont-size: 16px;\n\tpadding: 10px;\n\tbackground: green;\n\tcolor: black;\n}\n```\n\n만약, 글자 중간에 `$변수` 혹은 `$파라미터` 넣고 싶으면 `#{ $변수명 }`을 사용한다.\n\n```scss\n@mixin 폰트기본스타일($구멍1, $구멍2) {\n\tfont-size: $구멍1;\n\t#{ $구멍2 }: -1px;\n}\n\nh2 {\n\t@include 폰트기본스타일(40px, letter-spacing);\n}\n```\n\n```css\n/* 컴파일 된 css */\nh2 {\n\tfont-size: 40px;\n\tletter-spacing: -1px;\n}\n```\n\n\u003cbr\u003e\n\n### 문법05. 다른 파일에 있는 내용 가져오는 @use 문법\n  \n- 파이썬의 `@import`같은 느낌이다.\n- 예를 들어, 여러 파일에 공통적으로 사용되는 css 기본 세팅같은거 파일 저장해놓고 불러와서 사용\n- css 기본 문법에도 `@import` 있음 scss에서는 `@use` 쓰는거\n- 컴파일을 원하지 않는 파일은 `_파일명.scss`로 작명한다.\n- `@use '파일명'` 할 때 컴파일 안되게 언더바 붙힌 파일에서 언더바는 빼도 된다\n- 예를 들어, `sass01.scss` 파일에서 `_reset.scss` 파일 `@use`할 때, `@use 'reset'` 이까지만 적어도 되는거\n\n\u003cbr\u003e\n\n\u003e [!note] Memo\n\u003e\n\u003e 뭐 기본세팅 .scss 파일은 종속적인 파일이니까 굳이 매번 .css로 컴파일 할 필요가 없잖아? 그러니까 언더바(_) 붙혀서 컴파일 못하게 하자.\n\n\u003cbr\u003e\n\n파일을 불러오면 거기에 있던 `@mixin`, `$변수` 이런거 다 사용 가능\n\n1. 다른 파일의 `$변수` 사용\n\t- `파일명.$변수`\n\n2. 다른 파일의 `@mixin` 사용\n\t- `@include 파일명.mixin이름`\n\n\u003chr\u003e\n\n## HTML video, audio\n\n- `\u003cvideo src=\"영상.mp4\"\u003e\u003c/video\u003e`의 형태로 넣음\n- `\u003cvideo src=\"영상.mp4\" controls\u003e\u003c/video\u003e` 하면 재생버튼 생김 **controls**\n- 근데 영상 넣을때 `source`를 따로 넣는게 더 나\n\n\u003cbr\u003e\n\n**source 태그**를 이용해서 따로 넣는 방식의 장점은 **호환성을 챙길 수 있다**는 것이다. 비디오의 형식이 mp4, webM, mkv 등 브라우저마다 지원하는 비디오 확장자가 다르다. 따라서, 아래와 같은 코드로 작성하면 위에거 틀어보고 안되면 밑에거 틀어보세요~ 이런 말이다.  \n\n```html\n\u003c!-- 보통 용량이 작은 확장자부터 위에 작성한다. --\u003e\n\u003cvideo controls\u003e\n\t\u003csource src=\"영상-m.webm\" type=\"video/mp4\" /\u003e\n\t\u003csource src=\"영상-m.???\" type=\"video/mp4\" /\u003e\n\t\u003csource src=\"영상.mp4\" type=\"video/mp4\" /\u003e\n\u003c/video\u003e\n```\n\n\u003cbr\u003e\n\n**autoplay**는 크롬 브라우저에서 자동재생 정책상 그냥 `autoplay` 작성하면 안되고 `autoplay muted`해야 된다.\n\n```html\n\u003cvideo controls autoplay muted\u003e\n\t\u003csource src=\"영상.mp4\" type=\"video/mp4\" /\u003e\n\u003c/video\u003e\n```\n\n\u003cbr\u003e\n\n**preload**는 브라우저 로딩 시 영상을 미리 다운받을지, 말지, 적당히 받을지에 관한 속성 `\u003cvideo preload=\"metadata\"\u003e`  \n\n- `preload=\"none\"` : 미리 다운로드 X\n- `preload=\"auto\"` : 미리 다운로드 O\n- `preload=\"metadata\"` : 미리 다운로드 적당히, 초반 썸네일과 영상 초반부 약간 로딩. 제일 추천\n\n\u003cbr\u003e\n\n**poster**는 비디오 썸네일 결정 가능 `\u003cvideo poster=\"이미지.jpg\"\u003e\u003c/video\u003e`\n\n\u003cbr\u003e\n\n**loop**은 비디오 무한 재생 `\u003cvideo loop\u003e\u003c/video\u003e`\n\n\u003cbr\u003e\n\n**audio**도 마찬가지, `\u003caudio src=\"음악.mp3\" controls\u003e\u003c/audio\u003e` 추가로, autoplay 자동재생 기능은 애초에 안된다. 자바스크립트로 조작하면 가능\n\n\u003chr\u003e\n\n## 궁극의 가운데 정렬\n\n어떤 요소를 진짜 극한으로 가운데 정렬할 때 사용하는 방법\n\n```css\n/* 어떤 요소 위 빈 박스 */\n.box {\n\theight: 500px;\n\twidth: 100%;\n\toverflow: hidden;\n\tposition: relative;\n}\n\n.container {\n\tposition: absolute;\n\twidth: 100%;\n\ttop: 50%;\n\tleft: 50%;\n\ttransform: translate(-50%, -50%);\n\tz-index: 0;\n}\n```\n\n\u003chr\u003e\n\n## 애니메이션 만들기 심화 (@keyframes)\n\n[중급 모듈](brain/Lecture/apple-html/all-in-one-mid) 애니메이션 만들기에서 one-way 애니메이션 만드는 방법을 배웠었다. 그때는 a에서 b로만 가능했다. 아래와 같이 복잡한 애니메이션은 `@keyframes`로 구현한다. `transition`은 one-way 밖에 안되서이다.\n\n1. a -\u003e b -\u003e c\n2. a -\u003e b -\u003e a\n3. a -\u003e 1초정지 -\u003e b\n\n\u003cbr\u003e\n\n먼저, **transform**에 관하여 알아야한다.\n\n- `transform: rotate(숫자deg)` : 각도만큼 회전\n\n- `transform: translateX(숫자px)`: 숫자px 만큼 X축 좌표이동 (animation 줄 경우 margin-left 같은걸로 이동하는 것보다 부드럽게 이동함)\n\n- `transform: scale(숫자)` 숫자만큼 크기 변화 줌, 2라고 하면 2배 키워줌\n\n- `transform: skew(숫자deg)` : 각도만큼 비틀기\n\n\u003cbr\u003e\n\n**왜 복잡한 애니메이션을 만드는데 transform을 쓰면 좋다는 것인가?** 간단하다. 성능이 좋아서이다. 애니메이션이 느리고 버벅이면 역효과 일으키기 때문이다. 즉, `@keyframes`안에다가 transform을 안쓰고 margin을 쓰더라도 애니메이션을 만들 수 있겠지만, margin 변경은 transform에 비하여 느리다.\n\n\u003cbr\u003e\n\n**transform의 성능이 좋은 이유가 뭘까?** 웹브라우저는 HTML, CSS 코드를 2D 그래픽으로 바꿔주는 간단한 프로그램인데, 이때 브라우저가 그림 그리는 순서가 있다. 첫번째로 HTML, CSS를 쭉 읽으면서 Render Tree를 만든다. Render tree는 그림 그리기 전 CSS를 쭉 정리한 참고자료 느낌이다. 이걸보고 그림그리기 시작한다. 먼저 박스를 그리며 어디에 위치하는지 Layout을 잡고 다음으로 픽셀 하나하나에 색을 입히는 Paint를 하고 쓸데없는 Composite 단계의 css 속성들을 처리한다.\n\n\u003cbr\u003e\n\n정리하자면 1단계 Rander tree 그리면서 css 속성들 정리 2단계 Layout 잡기에 margin, padding, width, height 같은 속성들을 처리하고 3단계 Paint에서 background-color 같은거 처리하고 4단계 Composite 처리 단계에서 transform, opacity 같은거 처리한다.\n\n\u003cbr\u003e\n\n### 브라우저가 그림 그리는 순서 (렌더링 과정)\n\n1. Render tree\n\n2. Layout 잡기\n\n3. Paint 하기\n\n4. Composite 처리\n\n\u003cbr\u003e\n\n그러면, 만약 margin을 갑자기 변경했다고 하자. 그럼 브라우저는 margin을 변경하기 위하여 2단계 Layout 잡기 단계를 해야한다. 그러면 3단계, 4단계도 다시 해야하는 것이다. 즉, 다시 **렌더링** 된다는 말이다. 그러면 transform을 갑자기 변경하면? **4단계 composite 처리만 다시 하면 되니까 부담이 훨씬 덜하게 되는 것**이다. 결과적으로 transform의 성능이 margin보다 좋은 것이다. 특히, 자바스크립트가 너무 많은 사이트는 애니메이션을 항상 transform으로 줘야한다.\n\n\u003cbr\u003e\n\n추가로, **transform이 더 빠른 두 번째 이유**가 있다. 원래 웹 브라우저는 HTML, CSS 처리건 자바스크립트 실행이건 쓰레드 1개만 사용한다. 그런데, composite 처리 단계에 있는 css 속성들은 **다른 쓰레드에서 처리해준다.** 자바스크립트가 아무리 많아도 애초에 다른 쓰레드에서 처리하기 때문에 transform이 빠른 것이다.  \n\n\u003cbr\u003e\n\n다음으로, **keyframes**는 몇 퍼센트 진행했는지 진행도에 따라 나눠서 코드를 작성하면 된다. 그 이후, 사용하고자 하는 클래스에 `animation-name: 작명;` , `animation-duration: 몇초;`와 같은 식으로 작성하면 된다.\n\n```css\n@keyframes 작명 {\n\t0% {\n\n\t}\n\n\t50% {\n\t\n\t}\n\n\t100% {\n\t\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**animation 관련 속성**\n\n```css\n.box:hover {\n\tanimation-name: 움찔움찔;\n\tanimation-duration: 1s;\n\t/* 베지어 주기 (처음에 실행할 지 나중에 실행할 지) */\n\tanimation-timing-function: linear;\n\t/* 시작 전 딜레이 */\n\tanimation-delay: 1s;\n\t/* 몇회 반복할것인가 */\n\tanimation-iteration-count: 3;\n\t/* 애니메이션을 멈추고 싶은 경우 자바스크립트로 이거 조정 */\n\tanimation-play-state: paused;\n\t/* 애니메이션 끝난 후에 원상복구 하지말고 정지 */\n\tanimation-fill-mode: forwards; \n}\n```\n\n\u003cbr\u003e\n\n### 3D 애니메이션 (사진 뒤집기)\n  \n- 앞면, 뒷면 배치는 `position: absolute` 사용해야함\n\n- inner 자체를 뒤집어버리는게 나음\n\n- `transform: rotate()`를 사용하는 것이라 처음에 뒷면을 미리 뒤집어놔야함\n\n- 뒷면의 모습이 안보이게 `transform-style: preserve-3d;`와 `front의 z-index 우선순위 높이기`, `backface-visibility: hidden;`\n\n- 내용은 \u003ca href='https://github.com/Shin-Jae-Yoon/TILbefore/blob/master/Language/html_css/lecture/codding_apple/%EA%B3%A0%EA%B8%89%EB%AA%A8%EB%93%88/threeD_animation.html' target='_blank'\u003ethreeD_animation.html\u003c/a\u003e 참고\n\n\u003cbr\u003e\n\n### 애니메이션 성능 잡는 방법들\n\n1. `will-change` 사용\n\n```css\n.box {\n\twill-change: transform;\n}\n```\n\n애니메이션을 주는 `.box`가 약간 느리게 동작할 때 `will-change: 애니메이션 줄 속성`을 써놓으면 성능개선이 가능하다. 이는 **바뀔 내용을 미리 렌더링 해주는 속성**이기 때문이다. 애니메이션이 이상하게 버벅이면 사용하고 잘 작동하면 굳이 쓸 필요는 없다. 왜냐하면 많이쓰면 오히려 더 느려질 수 있기 때문이다. 이와 관련된 내용과 will-change에 관한 추가적인 내용은 \u003ca href='https://dev.opera.com/articles/ko/css-will-change-property/' target='_blank'\u003e여기\u003c/a\u003e에 있다.\n\n\u003cbr\u003e\n\n2. 하드웨어 가속\n\n애니메이션이 많아서 CPU만으로 연산이 불가능하면 GPU의 도움을 받으면 된다.\n\n```css\n.box {\n\ttransform: translate3d(0, 0, 0);\n}\n```\n\n이와 같이 쓰면 3D 이동도 가능한데, 이때 GPU를 사용해서 연산한다. 그래서 이걸 이용한 꼼수인데 `translate3d(0, 0, 0)`으로 사용하면 아무곳으로 이동하지 않는 3D 이동 명령을 주고 뒤에 필요한 transform을 적용한다면 GPU를 이용해서 box 클래스가 가진 transform 속성들을 연산하는 원리이다.\n\n\u003chr\u003e\n\n## CSS 스킬 심화\n\n### CSS Grid\n\n- `display: grid`는 격자 모눈종이가 있다면 색칠해나가는 방식으로 생각\n\n- 부모 div에 `display: grid`, `grid-template-columns: `, `grid-template-rows: ` 주면 자식들은 모눈종이가 된다.\n\n- rows는 가로칸 갯수, 사이즈 columns는 세로칸 갯수, 사이즈\n\n- `grid-gap: `은 격자 간격\n\n\u003cbr\u003e  \n\n가로 2칸, 세로 3칸짜리 모눈종이\n\n```html\n\u003cdiv class=\"grid-container\"\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\u003c/div\u003e\n```\n\n```css\n.grid-container {\n\tdisplay: grid;\n\tgrid-template-columns: 100px 100px 100px;\n\tgrid-template-rows: 100px 100px;\n}\n```\n\n![](brain/image/all-in-one-last-1.png)\n  \n\u003cbr\u003e\n\ngrid 컨테이너에서 사용하기 좋은 단위는 **fr(fraction)** 이다. 그리드 트랙 사이즈로 사용 되는 fr 단위는 유연한 단위로 그리드 컨테이너의 여유 공간을 비율로 나눠 설정한다. 퍼센트(%) 단위와 유사해 보일 수 있으나, 퍼센트 값과 다르게 길이가 아니다. **fr은 몇 배수**로 이해한다.\n\n\u003cbr\u003e\n\n```css\n/* 이러면 전체 가로에 대해 1배, 1배, 1배 */\n/* rows는 높이의 개념이라 height 속성이 있어야 fr 먹을거임 */\n.grid-container {\n\tdisplay: grid;\n\tgrid-template-columns: 1fr 1fr 1fr;\n\tgrid-template-rows: 100px 100px;\n}\n```\n\n\u003cbr\u003e\n\n**grid 이용한 레이아웃 만들 때**\n\n1. 내부 박스 크기 조절\n2. 그냥 부모 건드리기\n\n\u003cbr\u003e  \n\n**1번 방법**. 자식 div 높이와 폭을 조정하는 방법이다. 내부 박스에게 그냥 `grid-column`이나 `grid-row`를 줘본다.\n\n```css\n.grid-nav {\n\tgrid-column: 1 / 4;\n}\n```\n  \n`grid-column`은 세로 선을 의미한다. 이때 `display: grid`의 자식들에만 사용 가능하다. 따라서 여기서는 여러 div 박스를 의미한다. `1 / 4`가 의미하는 바는 세로선 1~4 만큼 차지해달라는 뜻이다.\n\n\u003cbr\u003e\n\n![](brain/image/all-in-one-last-2.png)\n\n```css\n.grid-nav {\n\tgrid-row: 1 / 3;\n}\n```\n\n`grid-row`은 가로 선을 의미한다. 이때 `display: grid`의 자식들에만 사용 가능하다. 따라서 여기서는 여러 div 박스를 의미한다. `1 / 3`가 의미하는 바는 가로선 1~3 만큼 차지해달라는 뜻이다.\n\n![](brain/image/all-in-one-last-3.png)\n\n\u003cbr\u003e\n\n이런식으로 작성하고 최종적으로 나머지 div박스 지운다.\n\n```html\n\u003cdiv class=\"grid-container\"\u003e\n\t\u003cdiv class=\"grid-nav\"\u003e\u003c/div\u003e\n\t\u003cdiv class=\"grid-sidebar\"\u003e\u003c/div\u003e\n\t\u003cdiv class=\"grid-content\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n```\n\n```css\n.grid-container {\n\tdisplay: grid;\n\tgrid-template-columns: 100px 100px 100px 100px;\n\tgrid-template-rows: 100px 100px 100px;\n}\n \n.grid-container div {\n\tborder: 1px solid black;\n}\n\n.grid-nav {\n\tgrid-column: 1 / 5;\n}\n\n.grid-sidebar {\n\tgrid-row: 2 / 4;\n}\n\n.grid-content {\n\tgrid-column: 2 / 5;\n\tgrid-row: 2 / 4;\n}\n```\n\n\u003cbr\u003e  \n\n**2번 방법**. 자식에 이름 쓰고 부모는 색칠하기\n\n```css\n.grid-nav {\n\tgrid-area: 헤더;\n}\n\n.grid-sidebar {\n\tgrid-area: 사이드;\n}\n```\n\n`grid-area: `는 자식에 이름짓는 속성이다. 그리고 이후에 `grid-template-areas: \" \" ` 형태로 배치해주면 된다. 배치할 때 기억자 같이 배치는 안되고 사각형 모양으로만 가능하다.\n\n```css\n.grid-container {\n\tdisplay: grid;\n\tgrid-template-columns: 100px 100px 100px 100px;\n\tgrid-template-rows: 100px 100px 100px;\n\tgrid-template-areas:\n\n\t'헤더 헤더 헤더 헤더'\n\t'사이드 . . .'\n\t'사이드 . . .';\n}\n```\n\n\u003cbr\u003e\n\n**Grid 숙제 관련**\n\n\u003cbr\u003e\n\n이미지 (img) 파일은 기본적으로 글자취급 받기 때문에 글자의 베이스라인처럼 이미지 밑에 하얀색 선이 거슬리게 나올 수 있다. 그때 반드시 `display: block;`을 줘서 없애도록 해보자!\n\n\u003cbr\u003e\n\n### CSS 스킬 sticky\n\n- 스크롤해도 상단에 고정하고자 하는 속성에 `position: sticky;`\n\n- 주고 나서 어느 위치에 고정될 지도 정해준다. ex) top, bottom\n\n- sticky는 마치 fixed와 유사하다.\n\n- fixed는 viewport에다가 div 박스나 이미지를 고정시킬 때 쓰는 속성이었다. 그래서 fixed 해버리면 스크롤 해도 그 화면에 딱 고정된다.\n\n- 즉, sticky는 조건부 fixed이다. 그냥 스크롤 하다가 sticky 부여된 녀석을 만났을 때 조건적으로 fixed 되는 것이다.\n\n- 부모 박스 넘어서면 sticky는 해제된다.\n\n```css\n.image {\n\tfloat: right;\n\twidth: 400px;\n\tposition: sticky;\n\ttop: 100px;\n}\n```\n\n정리하자면, `position: sticky` \n\n1. 스크롤을 할 만한 부모 박스가 있어야 함\n2. top 등 좌표속성과 함께 써야 제대로 보임\n","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-html/all-in-one-mid":{"title":"All-in-One 중급모듈","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/html-basics/' target='_blank'\u003eHTML/CSS All-in-one : 기초부터 Bootstrap, SASS, 고급 animation 까지\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 폰트 설정법\n\n- `font-family : '폰트'` 형식으로 설정한다.\n\n- 버그 없이 사용하려면 폰트의 영문명 사용\n\n- 폰트를 여러개 설정하는 이유는 안정석 확보를 위해서이다. 왼쪽부터 적용된다.\n\n- 아래 예시에서 gulim이 없어서 적용 안된다면 gothic으로 적용한다는 의미\n\n- 웹사이트 이용자의 컴퓨터에 설치가 된 폰트들을 적용할 수 있다.\n\n```css\nbody {\n\tfont-family: 'gulim', 'gothic';\n}\n```\n\n\u003cbr\u003e\n\n**사용자의 컴퓨터에 설치되지 않은 폰트를 사이트에서 이용하는 방법**\n\n- css 최상단에 `@font-face`로 적용할 폰트의 경로와 이름 작성\n\n- 웹 폰트용으로 나온 **woff**파일은 ttf에 비해 용량의 3분의 1 수준\n\n```css\n@font-face {\n\tfont-family: '폰트이름';\n\tsrc: url(폰트 저장 주소);\n}\n```\n\n\u003cbr\u003e\n\n**Google Fonts 사용**\n\n- 폰트 파일 없이, 구글 폰트를 직접 링크하는 방식\n\n- 구글이 호스팅해주는 폰트가 미리 정의된 css 파일을 가져다 사용하는 방식이다.\n\n- **내 사이트의 트래픽 절약 가능**\n\n- 크롬 브라우저가 이미 방문한 사이트는 캐싱해주기 때문에 많은 사람들이 이용할수록 더 빠르게 폰트를 이용 가능\n\n- html 적용 - `\u003clink\u003e` 부분\n\n- css 적용 - `@import` 부분\n\n\u003chr\u003e\n\n## 폰트 Anti-aliasing  \n\n- 폰트 앤티앨리어싱은 폰트를 부드럽게 보여주는 기술\n\n- 픽셀의 각진 부분을 부드럽게 바꾸는 방법\n\n- mac은 자동으로 앤티앨리어싱 해주지만, window는 아님\n\n- 글자에 각도를 주고 살짝 돌리면 됨\n\n```css\np,\nh4,\nh3,\nh2,\nh1,\nspan,\nbutton {\n\ttransform: rotate(0.03deg);\n}\n```\n\n\u003chr\u003e\n\n## flex\n\n- 가로 배치, 혹은 여러 배치에서 자주 사용할 flex 속성이다.\n\n- 부모 태그에 `display : flex;` 설정한다.\n\n- `justify-content: flex-start;` 좌측 정렬\n\n- `justify-content: flex-end;` 우측 정렬\n\n- `justify-content: flex-center;` 가운데 정렬\n\n- `justify-content: space-between;` 사이 사이 떨어뜨리게 꽉차게\n\n- 세로 배치 원하면, `flex-direction: column;`\n\n```css\n.flex-container {\n\tdisplay: flex;\n\tjustify-content: flex-start;\n}\n\n.flex-item {\n\twidth: 100px;\n\theight: 100px;\n\tbackground-color: gray;\n\tmargin: 5px;\n}\n```\n\n\u003cbr\u003e\n\n- flex에서 600px를 줬다고 하면, 실제 크기가 600px 되는 것이 아니라, 최대한 거기까지 키운다는 의미\n\n- width가 커서 밑으로 보내고 싶다면 `flex-wrap: wrap;` 속성 이용\n\n- flex 이용 시 상하 정렬은 `align-item: center;` 속성 이용\n\n```css\n/* 궁극적인 상하좌우 정렬 */\n\n.flex-container {\n\tdisplay: flex;\n\theight: 500px;\n\talign-items: center;\n\tjustify-content: center;\n}\n```\n\n\u003cbr\u003e\n\n- flex에서는 박스 크기를 px 말고 **비율**로 설정 가능하다.\n\n- `flex-grow` 속성은 몇 배수를 의미한다.\n\n- 아래의 예시는 1:2:1이다.\n\n```html\n\u003cdiv class=\"flex-container\"\u003e\n\t\u003cdiv class=\"flex-item\" style=\"flex-grow: 1\"\u003e1\u003c/div\u003e\n\t\u003cdiv class=\"flex-item\" style=\"flex-grow: 2\"\u003e2\u003c/div\u003e\n\t\u003cdiv class=\"flex-item\" style=\"flex-grow: 1\"\u003e3\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n- navbar 디자인 하고싶을 때 가운데를 붕 띄우고 싶으면 가운데만 비율주고 띄운다.\n\n```html\n\u003cdiv class=\"flex-container\"\u003e\n\t\u003cdiv class=\"flex-item\"\u003e1\u003c/div\u003e\n\t\u003cdiv class=\"flex-item\" style=\"flex-grow: 1\"\u003e2\u003c/div\u003e\n\t\u003cdiv class=\"flex-item\"\u003e3\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n![](brain/image/all-in-one-mid-1.png)\n\n- \u003ca href='https://studiomeal.com/archives/197' target='_blank'\u003e1분 코딩 css-flex\u003c/a\u003e\n- \u003ca href='https://studiomeal.com/archives/533' target='_blank'\u003e1분 코딩 css-grid\u003c/a\u003e\n\n\u003chr\u003e\n\n## HTML head 태그\n\n- head 태그에는 사이트 내에서 눈에 보이지 않는 중요한 정보들\n\n\u003cbr\u003e\n\n1. css 파일 첨부\n\t- link 태그 이용\n\t- 상대경로 방식, 절대경로 방식\n\n\u003cbr\u003e\n\n  \n\n2. 스타일 태그\n\t- css 파일과 유사하게 동작\n\t- body 태그 안에 있어도 동작하지만 html 파일 코드는 위에서 아래로 읽어나가는 방식이라서 body 태그에 뒀을 때 사이트 로딩 시 스타일이 깨질 수 있음\n\n\u003cbr\u003e\n\n3. 사이트 제목\n\t- 브라우저 탭에 뜨는 이름\n\n\u003cbr\u003e\n\n4. **meta 태그**\n\n```html\n\u003chead\u003e\n\t\u003cmeta charset=\"UTF-8\" /\u003e\n\t\u003cmeta name=\"description\" content=\"백엔드 마스터 신재윤입니다.\" /\u003e\n\t\u003cmeta name=\"keywords\" content=\"백엔드, backend, 개발자, 신재윤\" /\u003e\n\t\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n\u003c/head\u003e\n```\n\n- 4-1 : 사이트 인코딩 형식 지정 방법\n\n- 4-2 : 사이트 검색 결과 화면에 뜨는 글귀\n\n- 4-3 : 검색에 도움을 주는 키워드\n\n- description은 구글 검색 시 파란 제목으로 뜨는 글귀\n\n- keywords는 검색에 도움을 주는 키워드\n\n- 4-4 : 사이트 초기 줌 레벨이나 폭을 지정해주는 것\n\n- `width=device-width`는 모바일 기기의 실제 폭으로 렌더링 해주는 것\n\n- 실제 접속 시 스마트폰 기기의 실제 가로폭을 보고 렌더링하라는 명령어\n\n- `initial-scale=1`은 접속시의 화면 줌 레벨 설정\n\n\u003cbr\u003e\n\n5. open graph\n\n```html\n\u003chead\u003e\n\t\u003cmeta property=\"og:image\" content=\"/이미지경로.jpg\" /\u003e\n\t\u003cmeta property=\"og:description\" content=\"사이트설명\" /\u003e\n\t\u003cmeta property=\"og:title\" content=\"사이트제목\" /\u003e\n\u003c/head\u003e\n```\n\n- og 메타 태그는 facebook이 만든 태그\n\n- 카카오톡, 페이스북 같은 sns에 링크를 공유했을 때 뜨는 박스\n\n- 그 박스에 보이는 이미지, 사이트 제목, 사이트 설명\n\n![](brain/image/all-in-one-mid-2.png)\n\n\u003cbr\u003e  \n\n6. Favicon\n\n```html\n\u003chead\u003e\n\t\u003clink rel=\"icon\" href=\"아이콘경로.ico\" type=\"image/s-icon\" /\u003e\n\u003c/head\u003e\n```\n\n- 상단 탭 웹사이트 제목 옆에 뜨는 이미지 아이콘\n\n- ico 형식 대신 png도 가능, 하지만 ico가 호환성 best\n\n- 32 x 32 사이즈가 보편적\n\n- 웹 사이트를 바탕화면에 바로가기 추가했을 경우 뜨는 아이콘도 커스터마이징 가능\n\n- `rel=\"apple-touch-icon-precomposed\"` 이렇게 rel 속성을 조정\n\n- OS마다 요구하는 rel 속성이 달라지니까 그때그때 찾아서 적용\n\n- 혹은 favicon generator 검색하면 OS별로 알아서 만들어줌\n\n\u003chr\u003e\n\n## **반응형 웹**\n\n\u003cbr\u003e\n\nvw (viewport width)\n- 브라우저 폭에 비례\n\n\u003cbr\u003e\n\nvh (viewport height)\n- 브라우저 높이에 비례\n\n\u003cbr\u003e  \n\n**rem (기본 폰트사이즈에 비례)**\n\n- 보통 html 태그 폰트 사이즈는 기본 16px로 설정되어있다.\n\n- 10rem이라고 하면 160px이 되는 것이다.\n\n- 버튼이든 패딩이든 마진이든 전부 rem으로 크기지정하면 기본 font-size가 커져도 모든게 같이 커진다는 장점이 있다.\n\n- 요즘은 컨트롤 누르고 마우스휠 올리면... 다 같이 커지기는 한다\n\n\u003cbr\u003e\n\nem (내 폰트 사이즈의 몇배)\n\n- 만약 내 폰트 사이즈가 15px, width가 20em이면 300px이 되는 것이다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n반응형 웹사이트를 만들 때, html head 태그에 meta 태그를 반드시 추가해야한다. 느낌표 emmet 하면 들어가있기는 하다.\n\n```html\n\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n```\n\n\u003cbr\u003e\n\n기본적인 원리는 media query 문법이다. 아래 코드는 현재 브라우저 폭이 1200px 이하인 경우 저 내용을 적용해라는 의미이다.\n\n```css\n@media screen and (max-width: 1200px) {\n\t.main-title {\n\t\tfont-size: 30px;\n\t}\n}\n```\n\n반응형 웹에서 breakpoint 기준은 **1200px, 992px, 768px, 576px** 단위를 많이 사용한다. 보통 1200px 부터 태블릿, 768px부터 모바일 이런식으로 많이 사용한다. breakpoint는 4개 이상으로 넘어가면 복잡해진다.\n\n\u003chr\u003e\n\n## 크롬 개발자 도구 (디버깅)\n\n- css 스타일링을 바꿨는데 바뀌지 않는 오류가 있다면, 파일을 찾기보다 크롬 개발자 도구를 사용하자\n\n- **우선 적용중인 스타일을 맨 위에서 보여준다**\n\n- css의 !important 속성 (10000점)\n\n- html의 style 속성 (1000점)\n\n- css의 id 속성 (100점)\n\n- css의 class 속성 (10점)\n\n- html의 태그를 css에서 셀렉터 이용 (1점)\n\n\u003chr\u003e\n\n## Font Awesome\n\n평소에 자주 사용하던 폰트어썸 사이트, 간단한 아이콘을 폰트 취급하여 사용\n\n\u003cbr\u003e\n\n사용방법\n\n  1. 웹 Kit 방식 : 폰트 어썸 사이트에서 kit 생성하고 html head 파일에 삽입하는 방식. 서버 용량이 많지 않거나 귀찮을때 그냥 사용한다. 간단한 프로젝트에서 보통 많이 사용함.\n\n2. CDN 방식 : Content Delivery Network (콘텐츠 전송 네트워크) 방식으로 폰트 어썸이 호스팅하는 서버에서 아이콘들을 받아와서 사용하는 방식이다.\n\n\u003e [!note] Kit 방식 vs CDN 방식?\n\u003e\n\u003e 사실 kit 방식과 cdn 방식이 어떤 차이인지 모르겠다.\nkit 방식은 회원가입 후 발급받은 킷을 이용했고\ncdn 방식은 구글에 fontawesome cdn 검색해서 나오는\ncdnjs 사이트에서 그 링크를 이용했다.\ncdnjs에서 가져온 링크는 로그인 할 필요도 없이 바로\n사용할 수 있었다.\n\n\u003cbr\u003e\n\n3. css 파일 다운로드 : 위의 두 방식은 폰트어썸 측의 서버가 다운되면 나에게도 영향이 끼친다는 의미이다. 이를 방지하고자 css 파일을 다운로드 받고 사용하는 방식이 있다. 강의에서는 다운받은 zip 파일에서 css 폴더의 `all.css`, `all.min.css`, `webfonts 폴더` 빼고 모두 지웠다. 그리고 웹폰트 폴더에서도 용량이 적은 woff만 사용했다.\n\n\u003cbr\u003e\n\nFont Awesome 사용할 때 css 파일에서 font-size를 조절 혹은 html의 style 속성에서 font-size를 조절하곤 했는데, 간단한 약어로 아이콘 크기 조정, 회전, 애니메이션 효과, 아이콘 끼리 중첩 등이 가능했다. 보통 크기 조절은 간단하게 `\u003ci class=\"fa-solid fa-cart-shopping fa-3x\"\u003e\u003c/i\u003e`와 같이 `fa-1x` 부터 `fa-5x`까지 되는 것 같았다.\n\n\u003cbr\u003e\n\n- \u003ca href='https://nuknukhan.tistory.com/38' target='_blank'\u003eFontAwesome 스타일링 간단 사용법\u003c/a\u003e\n- \u003ca href='https://fontawesome.com/docs/web/style/styling' target='_blank'\u003eFontAwesome DOCS\u003c/a\u003e\n\n\u003chr\u003e\n\n## 애니메이션 만드는 원리\n\n\u003cbr\u003e\n\none-way 애니메이션 만드는 방법 \n\n1. 시작스타일 만들기\n2. 최종스타일 만들기\n3. 언제 최종스타일로 변하는지 (ex. 마우스로 올렸을 때)\n4. transition으로 애니메이션 속성 주기\n\n\u003cbr\u003e\n\ntransition 세부 속성\n\n```css\n.box {\n\ttransition-delay: 1s; /* 시작 전 딜레이 */\n\ttransition-duration: 0.5s; /* transition 작동 속도 */\n\ttransition-property: opacity; /* 어떤 속성에 transition 입힐 지 */\n\ttransition-timing-function: ease-in; /* 동작 속도 그래프 조정 */\n}\n```\n\n- \u003ca href='https://github.com/Shin-Jae-Yoon/TIL/blob/master/Language/html_css/lecture/codding_apple/%EC%A4%91%EA%B8%89%EB%AA%A8%EB%93%88/hw_responsive.css' target='_blank'\u003e애니메이션 실습 예제 -  hw_responsive\u003c/a\u003e\n- \u003ca href='https://github.com/Shin-Jae-Yoon/TIL/blob/master/Language/html_css/lecture/codding_apple/%EC%A4%91%EA%B8%89%EB%AA%A8%EB%93%88/hw2_animation.css' target='_blank'\u003e애니메이션 숙제 예제 hw2_animation\u003c/a\u003e\n\n\u003cbr\u003e\n\n흘러넘치는거 숨겨주는 `overflow: hidden` 속성 까먹지 말자. overflow 속성은 박스의 폭이나 높이를 초과하는 내부요소를 처리하기 위한 속성이다. 만약 `overflow: visible`하면 넘치는 부분 보여주고 `overflow: scroll`하면 넘치는 요소를 보기 위한 스크롤 바가 생성된다.\n\n\u003cbr\u003e\n\n추가로 다른 사이트에서 애니메이션 작동원리 보려면 크롬 개발자 도구에서 마우스로 찍은 후에 점 세개 눌러서 more tools에서 animations 탭을 보면 어떤 속성이 어느 정도의 시간에 거쳐서 변화하는지 보여준다.\n\n\u003chr\u003e\n\n## Bootstrap  \n\n- html, css 개발 속도를 빠르게 해주는 것\n- css와 js cdn을 복사해서 붙혀넣기 하면 사용할 수 있다. css는 head 태그, js는 body 태그\n- 유용한 키워드 : Navbar, Card, Carousel, Modal, Badge, Media Object, Shadow\n\n\u003cbr\u003e\n\n개발시간 단축하는 Utility class가 제공된다.  \n- container 클래스를 사용하면 여백 가진 박스가 생성된다.\n- margin-top 같은 경우 `mt-3`이라고 하면 margin-top이 3정도 들어간다. 1~5까지 있다.\n- padding-left와 right의 경우 `ps-5`, `pe-5`라고 한다. start와 end의 약자이다.\n- 가운데 정렬은 `text-center`하면 된다.\n- 폰트 사이즈는 `fs-3`로 하면된다. 1~6까지 있다.\n- width는 `w-50`으로 하면 된다. %수치라서 100%까지 된다.\n- 부트스트랩 홈페이지에서 Utilities에서 유틸리티 클래스 명을 찾을 수 있다.\n\n```html\n\u003cdiv class=\"container\"\u003e카드 같은거 ~\u003c/div\u003e\n\u003ch5 class=\"card-title mt-3\"\u003eCard title\u003c/h5\u003e\n\u003ch5 class=\"card-title text-center\"\u003eCard title\u003c/h5\u003e\n\u003ch5 class=\"card-title fs-5\"\u003eCard title\u003c/h5\u003e\n```\n\n\u003cbr\u003e  \n\n부트스트랩은 특히 **반응형 레이아웃**에 관한 개발속도를 향상시킨다. container 박스 안에 row와 col을 적절하게 배열하면 된다. 보통 한 행 기준 12칸으로 쪼개는데 `col-4`로 하면 정확하게 3등분 되는 것이다.\n\n```html\n\u003cdiv class=\"container\"\u003e\n\t\u003cdiv class=\"row text-center\"\u003e\n\t\t\u003cdiv class=\"col-4\"\u003e안녕하세요\u003c/div\u003e\n\t\t\u003cdiv class=\"col-4\"\u003e안녕하세요\u003c/div\u003e\n\t\t\u003cdiv class=\"col-4\"\u003e안녕하세요\u003c/div\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n여기서 반응형을 추가하는 방법은 **조건문**을 더하면 된다. 현재, 웹 사이즈에서는 가로로 배열되어있는데 모바일에서는 세로로 배열하고 싶다고 하자. 그때 `-md`를 달아본다. md는 768px 이상에서만 저 조건을 실행해달라는 의미이다. 추가적인 자료는 \u003ca href='https://getbootstrap.com/docs/5.1/layout/grid/' target='_blank'\u003eBootstrap 공식 문서\u003c/a\u003e에서 확인한다.\n\n\u003cbr\u003e\n\n반응형 웹을 디자인 할 때, 모바일 화면을 먼저 설계하는 것이 편하다.\n- \u003ca href='https://github.com/Shin-Jae-Yoon/TIL/blob/master/Language/html_css/lecture/codding_apple/%EC%A4%91%EA%B8%89%EB%AA%A8%EB%93%88/hw4_snsProfile.html' target='_blank'\u003ehw4_snsProfile 실습\u003c/a\u003e은 99% 부트스트랩으로 제작했음\n- 부트스트랩에서 flex의 shrink, grow가 헷갈린다? \u003ca href='https://studiomeal.com/archives/197' target='_blank'\u003e1분 코딩 css-flex\u003c/a\u003e, \u003ca href='https://darrengwon.tistory.com/130' target='_blank'\u003e티스토리 블로그\u003c/a\u003e 참고\n- 부트스트랩의 d-flex 등 다양한 레이아웃은 \u003ca href='https://espania.tistory.com/142' target='_blank'\u003e여기\u003c/a\u003e 참조\n\n\u003cbr\u003e\n\n### Bootstrap 수직정렬\n\n\u003cbr\u003e\n\n\u003ca href='https://github.com/Shin-Jae-Yoon/TIL/blob/master/Language/html_css/lecture/codding_apple/%EC%A4%91%EA%B8%89%EB%AA%A8%EB%93%88/bootstrap2.html' target='_blank'\u003ebootstrap2.html\u003c/a\u003e 예제에서 사진과 글자를 수직정렬할 때의 문제이다. css를 다룰 때 고질적으로 겪었던 오류이다. 부트스트랩의 `align-middle`을 아무리 써봐도 글자가 수직정렬 되지 않았다. 근본적인 해결책을 찾고자 한다.\n\n\u003cbr\u003e\n\n먼저, 글은 p 태그로 작성한 상태이다. \u003ca href='https://programmer-ririhan.tistory.com/83' target='_blank'\u003e티스토리 블로그 글\u003c/a\u003e에서 css를 통한 수직 정렬을 하는 vertical-align 속성은 block 요소가 아닌 inline 혹은 inline-block에서만 사용 가능하다는 점이다. 아차! 싶었다. p 태그는 display 기본 속성이 block 속성이다. 그래서 \u003ca href='https://getbootstrap.com/docs/5.1/utilities/vertical-align/' target='_blank'\u003eBootstrap docs Vertical alignment\u003c/a\u003e도 살펴보면, `To vertically center non-inline content (like \u003cdiv\u003es and more), use our flex box utilities.`라고 떡하니 나와있었다. block 속성은 flex box utilities를 이용하라고..\n\n\u003cbr\u003e\n\n또 vertical-align 속성에 대한 잘못된 지식이 있었음을 알 수 있었다. 하나의 div 박스가 있고 그 박스에 `text-align : middle;`속성을 줬을 때 가운데 정렬이 되었던 경험을 살려 `vertical-align: middle;`하면 되겠지~ 싶었는데 서로 다른 느낌이다. text-align은 말 그대로 박스 안의 가운데 정렬이 맞지만, vertical-align은 간단한 inline 내에서 높낮이 정도 조절하는 것이다. \u003ca href='https://developer.mozilla.org/ko/docs/Web/CSS/text-align' target='_blank'\u003etext-align MDN 공식문서\u003c/a\u003e에서 **블록 요소나 표의 칸 상자의 가로 정렬을 설정한다**고 떡하니 나와있고, \u003ca href='https://developer.mozilla.org/ko/docs/Web/CSS/vertical-align' target='_blank'\u003evertical-align MDN 공식문서\u003c/a\u003e에서 **inline 또는 table-cell box에서의 수직 정렬을 지정한다**고 떡하니 나와있다. 내가 가진 개념은 오개념이었다.\n\n\u003cbr\u003e\n\n\u003ca href='https://getbootstrap.com/docs/5.1/utilities/flex/#align-items' target='_blank'\u003eBootstrap docs align\u003c/a\u003e에서는 정의한다. `align-items-center`를 이용하여 flex 아이템들을 정렬시키든 `align-self-center`를 이용하여 정렬시키는 방법이 떡하니 나와있었다. 예제의 경우 `row` 클래스의 행 속성에 `align-items-center`를 이용하여 아이템들을 가운데 정렬 시키든가 혹은 `col`클래스의 열 속성에 `align-self-center`를 이용하여 가운데 정렬 시키든가 두 방법 중 하나를 선택하면 된다.\n\n\u003cbr\u003e\n\n추가로, flex 박스의 순서를 부여하고자 할 때는 `order`를 이용하도록 한다. 물론 order 클래스 역시 조건문을 달아서 반응형으로 제작 가능하다. `order-lg-3`의 형태로 !\n\n\u003cbr\u003e\n\n### Bootstrap pill badge  \n\n부트스트랩에서 알약 모양 bill badge 썼을 때 알약이 깨지는 경우에는 `box-sizing: border-box;` 확인하자\n\n\u003chr\u003e\n\n## CSS 레거시 코드 수정 방법\n\n원본 CSS 파일을 건들기 애매한 경우 CSS를 덮어쓰는 방법이 있다.\n\n1. 같은 클래스명 하단에 작성\n2. 우선순위 높이기\n3. specificity 높이기\n\n먼저, 1번의 방법을 설명하겠다. HTML 파일에서 main.css를 link하고 있다고 하자. 그러면 그 아래에 main2.css를 한 번 더 link 하는 방식이다.\n\n\n```css\n/* main.css */\n.custom {\n\tcolor: green;\n}\n\n/* main2.css */\n.custom {\n\tcolor: blue;\n}\n```\n\n이렇게 작성하면 결과적으로 색깔이 blue로 바뀔 것이다. **같은 class면 더 밑에 있는게 우선 적용되는 원리이다.** 즉, css 파일이 나뉘어져 있어도 밑에 있으면 더 우선적으로 적용되는 성질이다. media query도 밑에 작성하는 이유도 바로 이것이다.\n\n\u003cbr\u003e\n\n2번의 방법은 우선순위를 높이는 것이다. 위에서 **html의 style 속성 (1000점), css의 id 속성 (100점), css의 class 속성 (10점), html 태그 셀렉터 (1점)** 방법을 이용한다. 사실 10000점 짜리도 있다. `!important`가 붙은것은 무조건 최우선적으로 적용된다.\n\n```css\n.custom {\n\tcolor: red !important;\n}\n```\n\n그러나, 우선순위를 높이는 방식은 근본적인 해결방법이 아니다. 계속 우선순위를 높여갈 수 없지 않은가? 따라서 이 방법은 급할 때 사용하되 가능한 사용하지 않도록 한다.\n\n\u003cbr\u003e\n\n마지막으로 specificity 점수를 높이는 것이다. 클래스 명을 더 세부적으로 적어서 점수를 찔끔찔끔 올리는 방식이다.  \n\n```css\n/* 태그 셀렉터 1점 + class 10점 + class 10점 = 21점 */\ndiv.main-background .custom {\n\tcolor: green;\n}\n\n/* class 10점 = 10점 */\n.custom {\n\tcolor: red;\n}\n```\n\n\n따라서, .custom이 아래에 있다고 해도 위가 최종적으로 점수가 높기 때문에 위의 코드가 적용된다. 그러면 애초에 위처럼 누가 작성해놨다고 하면?\n\n```css\n/* 남이 짜놓은 레거시 코드, 21점 */\ndiv.main-background .custom {\n\tcolor: green;\n}\n\n/* 조금이라도 점수 올리기 위한 발악, 22점 */\ndiv.main-background p.custom {\n\tcolor: red;\n}\n```\n\n그래서, 처음부터 셀렉터를 너무 정확하게 적어놓으면 나중에 덮어쓰기 힘들 수 있다. 그래서 클래스명 하나를 작성하는 방식을 처음에 사용하도록 노력하자.\n\n\u003cbr\u003e\n\n**좋은 코드의 기준**\n\n1. 나중에 수정/관리가 쉬운 코드\n2. 확장성이 좋은 코드\n\n즉, 재활용 가능하고 확장해서 다른 class 만들기 쉽다면 좋은 css 코드라고 할 수 있다.","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-js/":{"title":"코딩애플 - JavaScript","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-js/apple-js":{"title":"Javascript 입문과 웹 UI 개발","content":"\n\u003cbr\u003e\n\n\u003e [!note] Javascript 입문과 웹 UI 개발 필기노트\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2022.07.26 ~ 2022.08.15\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e 자바스크립트의 기본적인 사용법에 대한 파악\n\n## 목차\n\n- [코딩애플 JS 입문과 웹 개발 01](brain/Lecture/apple-js/apple-js-01)\n- [코딩애플 JS 입문과 웹 개발 02](brain/Lecture/apple-js/apple-js-02)\n- [코딩애플 JS 입문과 웹 개발 03](brain/Lecture/apple-js/apple-js-03)\n- [코딩애플 JS 라이브러리](brain/Lecture/apple-js/js-library)","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-js/apple-js-01":{"title":"LEVEL 01","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/javascript-jquery-ui/' target='_blank'\u003eJavaScript 입문과 웹 UI 개발\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 자바스크립트 사용 목적\n\nJavaScript는 html 파일 내부에 숨어서 **html 조작과 변경**을 담당하는 언어이다.\n\n- 탭, 모달 등 웹페이지 UI 제작 가능\n- 유저가 입력한 데이터 검사 가능\n- 유저가 버튼 누르면 서버로 데이터 요청 가능 등\n\nscript 태그 안에 넣어서 작성한다. 물론 js 파일을 따로 만들어서 link 해도 된다. script 태그 안에 적은 코드는 **브라우저 새로고침시 1번 실행된다.**\n\n\u003cbr\u003e\n\n**`document.getElementById('id명').무엇을 = '어떻게';`** \u003cbr\u003e\n\n`document.getElementById('hi').innerHTML = 'JS 고수에요';` \u003cbr\u003e\n\n- document : 문서, html 문서를 의미\n- 마침표 : ~의\n- getElementById('hi') : 아이디가 hi인 html 요소 (element)를 가져와라, 셀렉터\n- innerHTML : HTML 내부에서\n- 그리고 'JS 고수에요'를 대입하라.\n  \n```javascript\n// 글자 색깔 빨간색으로 변경\ndocument.getElementById('id').style.color = 'red';\n\n// img의 src 변경\ndocument.getElementById('id').src = './img/주소';\n```\n\n\u003cbr\u003e\n\n**`document.getElementsByClassName('class명')\\[인덱스].무엇을 = '어떻게';`**\u003cbr\u003e\n\n`document.getElementsByClassName('hi')[0].innerHTML = 'JS 고수에요';`\n\n- class는 여러 개 나올 수 있어서 인덱싱 해줘야함\n\n\u003chr\u003e\n\n## querySelector\n\ngetElementsByClassName, getElementById와 같이 querySelector는 유용하다. css의 셀렉터 기능을 사용할 수 있게 해준다.\n\n```javascript\ndocument.querySelector('.test').innerHTML = '안녕';\ndocument.querySelector('#test').innerHTML = '안녕';\n```\n\n단, 클래스 사용 시 제일 최상단 요소만 선택되므로, 예를 들어, 두번째 요소를 선택하고 싶으면 querySelectorAll을 사용하고 인덱스를 줘야 한다.\n\n```html\n\u003cul class=\"list-group\"\u003e\n\t\u003cli class=\"list-group-item\"\u003eAn item\u003c/li\u003e\n\t\u003cli class=\"list-group-item\"\u003eA second item\u003c/li\u003e\n\t\u003cli class=\"list-group-item\"\u003eA third item\u003c/li\u003e\n\u003c/ul\u003e\n  \n\u003cscript\u003e\n\tdocument.querySelectorAll('list-group-item')[1].innerHTML = '두번째 아이템';\n\u003c/script\u003e\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### getElementById와 비교\n\n\u003ca href='https://www.measurethat.net/Benchmarks/ShowResult/11974' target='_blank'\u003e벤치마크 결과\u003c/a\u003e를 살펴보면, getElement가 querySelector보다 약 1.2배 빠른 것을 확인 가능하다. getElement가 성능이 좋은 것은 확실하다.\n\n\u003cbr\u003e\n\n하지만, id는 getElementById, class는 getElementByClassName 등 요소마다 다른 것을 사용하는 것은 querySelector를 이용하여 셀렉터를 취급하는 것보다 분명 피곤한 일이다. 또, querySelector는 `id, class, [data-*=\"\"], input[name=\"\"]`등 다양한 셀렉터를 사용할 수 있다.\n\n\u003cbr\u003e\n\nquerySelector가 성능이 약간 떨어질 수 있지만 생산성이 높다는 말이다. 실제로 조금 더 느리다고는 하지만, querySelector는 초당 약 7,000,000 건의 작업을 처리할 수 있다. querySelector도 충분히 빠르다는 말이다. 성능 때문에 querySelector를 지양하고 getElement를 사용하라는 건 조금 받아드리기 힘들다. 실제로, querySelector보다 느린 \u003ca href='https://w3techs.com/technologies/history_overview/javascript_library/all/y' target='_blank'\u003ejQuery의 시장 점유율\u003c/a\u003e을 보면 2022년 8월 17일 기준 77.4%이다. 느려서 querySelector를 쓰지 말아야 한다면, jQuery도 사용하지 말아야 하는 것 아닌가?\n\n\u003cbr\u003e\n\n물론, 생산성 측면에서 봤을 때 jQuery가 querySelector보다 훨씬 높으니까 조~금 어불성설일 수 있지만, 말하고자 하는 것은 속도때문에 querySelector를 포기해야 할 이유가 있는가 하는 것이다. 하나의 주장일 뿐이지만 나도 굳이 getElement를 쓰기 보다는 querySelector를 쓰는 것에 한 표 던진다.\n\n\u003chr\u003e\n\n## UI 만드는 법칙\n1. HTML/CSS로 미리 디자인 (필요하면 미리 숨김)\n\t- `display: none;` 이용\n2. 필요할때 보여주기 (자바스크립트 사용)\n\t- `display: block;` 이용\n\n이걸로 모달창, 드롭다운 메뉴 등 구현 가능\n\n\u003chr\u003e\n\n## 자바스크립트 function\n\n- 긴 코드 축약하고 싶을 때 사용\n- 긴 코드 재사용이 잦을 때 사용\n- 함수명 영어 작명 시\n\n1. 소문자 시작\n2. camelCase\n\n`open_alert()` **X**, `openAlert()` **O**\n\n```javascript\nfunction 작명(파라미터) {\n\tdocument.getElementById('alert').style.display = 파라미터;\n}\n```\n\n```html\n\u003cbutton class=\"alert-open\" onclick=\"작명('flex')\"\u003e띄우기\u003c/button\u003e\n```\n\n- 파라미터 내부에 문자는 `' '` 안, 숫자는 바로  \n\n\u003chr\u003e\n\n## 초창기 겪는 문제들, 오류들\n\n\u003cbr\u003e\n\n1. script 태그를 body 내부에서 상단에 작성한 경우\n\nscript 태그를 body 내부에서 상단에 작성하면 잘 안되는 경우가 있다. script 태그를 조작할 html의 하단에 코드를 작성하는 이유는 렌더링 과정에서 위에서 아래로 읽어가기 때문이다. 따라서 상단에 작성하면 렌더링이 늦을 수 있다.\n\n  \u003cbr\u003e\n\n2. 셀렉터 오타 주의\n\n셀렉터 오타로 자바스크립트 실행이 안되는 경우, 크롬 개발자 도구에서 console 탭에서 에러 타입을 보자. **어쩌구 of null**은 대부분 셀렉터 오타이다. \"style을 읽고 싶은데 왼쪽에 있는것이 null이다~\" 라는 형태의 오류가 자주 보일 것이다.\n\n\u003cbr\u003e\n\n3. 기본 문법 오타  \n\n대문자, 소문자 확인 잘하자. `getElementById`를 `getElementByid`로 작성하지 않았는가? 뭐 잘 안보이면 항상 크롬 개발자도구 console 탭을 확인하자.\n\n\u003chr\u003e\n\n## 이벤트리스너\n\nhtml 버튼 태그에 `onclick` 붙히면 좀 더럽지 않음? 그때 `addEventListener()`을 자바스크립트에서 구현하자. 클릭, 키 입력, 스크롤, 드래그 등 웹 페이지에 조작을 가하는 행위가 **이벤트**이다. 이벤트가 일어나길 귀 기울여서 기다리는 친구가 **이벤트 리스너**이다.\n\n- `'click'` : 마우스 클릭\n- '`mouseover`' : 마우스 갖다대는거\n- `'scroll'` : 마우스 스크롤\n- `'keydown'` : 키 입력\n\n\u003ca href='https://developer.mozilla.org/en-US/docs/Web/Events' target='_blank'\u003e그 외 수많은 이벤트 목록 참고\u003c/a\u003e\n\n```javascript\n셀렉터로찾은요소.addEventListener('event명', function () {\n// 실행할 코드\n});\n\ndocument.getElementById('alert2_close').addEventListener('click', function () {\n\tdocument.getElementById('alert2').style.display = 'none';\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 콜백함수  \n\n위에 addEventListener 사용할 때 첫번째 파라미터에는 event 요소가 들어가고, 두번째 파라미터 자리에 들어갔던 function()이 있을거임\n\n```javascript\n셀렉터로찾은요소.addEventListener('event명', function () {\n// 실행할 코드\n});\n```\n\n- 이 function()이 바로 콜백함수\n- 자바스크립트에서 코드를 순차적으로 실행하고 싶을 때 콜백함수를 자주 사용\n- 콜백함수 자리에 만든 함수 넣어도 됨. 단, `함수()`의 형태가 아닌 `함수`로 넣어야 오류 없이 작동할 것\n\n\u003chr\u003e\n\n## classList, toggle\n\nnavbar 같은 곳에서 주로 사용하는 버튼 눌렀을 때 등장하는 서브메뉴를 구현하려고 한다. 해당하는 UI 제작할 때는\n\n1. 미리 htmml/css 디자인 해놓고 `display: none;`으로 숨긴다.\n2. 버튼 누르면 display 속성 바꿔서 보여준다.\n\n이 경우 `document.getElementById('id').style.display = 'none'`과 같이 작성해도 되지만, class 탈부착식으로 만드는 것이 유지보수에 편리하기 때문이다.\n\n\u003cbr\u003e\n\n```css\n.list-group {\n\tdisplay: none;\n}\n\n.show {\n\tdisplay: block;\n}\n```\n\n다음과 같이 show 클래스를 list-group 클래스에 붙혔다 뗐다 하는 방식으로 만들면 될 것 같다. 이때 자바스크립트에서 html에 접근하여 클래스를 붙히는 기능을 해주는 것이 **classList**이다.\n\n```javascript\ndocument\n\t.getElementsByClassName('navbar-toggler')[0]\n\t.addEventListener('click', function () {\n\t\tdocument.getElementsByClassName('list-group')[0].classList.add('show');\n});\n```\n\n만약, 버튼을 한 번 더 누르면 서브메뉴를 숨기고 싶다면 if문, 변수문법을 사용해서 가능하다. 아직 안배웠으니까 쉬운 방법인 **toggle**을 이용한다.\n\n```javascript\ndocument\n\t.getElementsByClassName('navbar-toggler')[0]\n\t.addEventListener('click', function () {\n\tdocument.getElementsByClassName('list-group')[0].classList.toggle('show');\n});\n```\n\n이렇게 코드 작성 시, toggle 기능을 이용하여 show 클래스가 있다면 없애고 없다면 붙히는 방식이다.\n\n\u003chr\u003e\n\n## jQuery 라이브러리\n\n자바스크립트 코드가 길고 더러워서 HTMl 조작을 쉽게하는 라이브러리들이 대표적으로 jQuery, React, Vue이다. React와 Vue는 자바스크립트 숙련도를 요구하기 때문에 간단하게 jQuery를 배워본다. jQuery는 라이브러리일 뿐 새로운 문법이나 이런게 아니라 함수명만 짧아진다. 예를 들어, `document.querySelect`와 같은 셀렉터는 짧게 `$` 하나로 바뀌고 `addEventListener`는 짧게 `on` 하나로 바뀐다.\n\n\u003cbr\u003e\n\njQuery CDN을 이용하여 사용한다.\n\n```javascript\n\u003cscript\nsrc=\"https://code.jquery.com/jquery-3.6.0.min.js\"\nintegrity=\"sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=\"\ncrossorigin=\"anonymous\"\u003e\u003c/script\u003e\n```\n\n거의 모든 자바스크립트 라이브러리는 로딩 속도 때문에 `\u003cbody\u003e` 태그 끝나기 전에 넣는 것을 권장한다. jQuery 설치한 곳 **하단**에서 jQuery 문법을 사용 가능하다. 상단에 코드 짜고 안된다고 울지말고 제발 하단에다가 짜라. 강의에서는 편의상 그냥 head 태그 끝에 jQuery를 설치했다. 로딩속도는 조금 느리겠지만, 코드 보기에 좋으니깐 편의상~\n\n\u003cbr\u003e\n\n- `$` : querySelectorAll의 역할\n\n- `.eq()` : querySelectorAll의 인덱스 역할\n\n- `.html` : jQuery로 html의 내용 변경\n\n- `.css('속성', '값')` : jQuery로 css의 내용 변경\n\n- `.addClass('클래스명')` : jQuery로 클래스 부착\n\n- `.removeClass('클래스명')` : jQuery로 클래스 제거\n\n- `.toggleClass('클래스명')` : jQuery로 클래스 토글\n\n```javascript\ndocument.querySelector('.hello').innerHTML('바보');\n$('.hello').html('바보');\n\ndocument.querySelector('.hello').style.color = 'red';\n$('.hello').css('color', 'red');\n```\n\nquerySelector를 쓰면 인덱스 하나하나 지정하고 바꿔줘야해서 양이 늘어난다. (뭐, 클래스명 같게 하고 querySelectorAll 말고 querySelector 쓰면 되긴 함) 근데 jQuery를 쓰면 그냥 한꺼번에 바꿀 수 있다.\n\n```html\n\u003cp class=\"hello\"\u003e안녕\u003c/p\u003e\n\u003cp class=\"hello\"\u003e안녕\u003c/p\u003e\n\u003cp class=\"hello\"\u003e안녕\u003c/p\u003e\n```\n\n```javascript\ndocument.querySelectorAll('.hello')[0].innerHTML = '바보';\ndocument.querySelectorAll('.hello')[1].innerHTML = '바보';\ndocument.querySelectorAll('.hello')[2].innerHTML = '바보';\n  \n$('.hello').html('바보');\n```\n\n\u003cbr\u003e\n\njQuery 이벤트리스너 사용법\n\n```javascript\n$(\"#test-btn\").on(\"click\", function () {\n\t어쩌구~\n});\n```\n\nstyle의 display 속성을 none으로 바꿔도 되지만 jQuery는 편리한 것들을 제공해줌  \n\n- `.hide()` : 사라지게\n\n- `.fadeOut()` : 서서히 사라지게\n\n- `.slideUp()` : 줄어들며 사라지게\n\n- `.show()` : 보이게\n\n- `.fadeIn()` : 서서히 보이게\n\n- `.slideDown()` : 늘어나며 보이게\n\n- `.fadeToggle()` : 누를때마다 fade\n\n\u003chr\u003e\n\n## 모달(Modal) 창 제작 Tip\n\nModal창은 보통 페이지 맨 앞에, 모든 html 요소 제일 위에 존재하기 때문에 **html 맨 위에 적는 것**이 관습이다.  \n\n```css\n/* 모달창 국룰 세팅 */\n.modal {\n\tposition: fixed;\n\tz-index: 5;\n}\n```\n\n```html\n\u003cdiv class=\"black-bg\"\u003e\n\t\u003cdiv class=\"white-bg\"\u003e\n\t\t\u003ch4\u003e로그인하세요\u003c/h4\u003e\n\t\t\u003cbutton class=\"btn btn-danger\" id=\"close\"\u003e닫기\u003c/button\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cbutton id=\"login\"\u003e로그인\u003c/button\u003e\n\n\u003cscript\u003e\n$('#login').on('click', function () {\n\t$('.black-bg').addClass('show-modal');\n});\n\n$('#close').on('click', function () {\n\t$('.black-bg').removeClass('show-modal');\n});\n\u003c/script\u003e\n```\n\n\u003chr\u003e\n\n## UI에 애니메이션 추가\n  \n위의 예제 코드에서 addClass와 removeClass 대신에 fadeIn과 fadeOut을 넣으면 애니메이션을 넣을 수 있지만, 자바스크립트에 애니메이션을 넣는 것은 성능 때문에 좋은 관습은 아니고 css에 넣는 것이 좋다.\n\n- \u003ca href='/brain/Lecture/apple-html/all-in-one-mid' target='_blank'\u003eone-way-animation\u003c/a\u003e\n\n- \u003ca href='/brain/Lecture/apple-html/all-in-one-last' target='_blank'\u003eanimation 심화\u003c/a\u003e\n\n추가로, 애니메이션 제작 시 `display: none;` 보다 `visibility: hidden;`이 낫다.\n\n\u003cbr\u003e\n\n- 자바스크립트 (jQuery)로 애니메이션 넣은 코드\n\n```html\n\u003cbody\u003e\n\t\u003cdiv class=\"black-bg\"\u003e\n\t\t\u003cdiv class=\"white-bg\"\u003e\n\t\t\t\u003ch4\u003e로그인하세요\u003c/h4\u003e\n\t\t\t\u003cbutton class=\"btn btn-danger\" id=\"close\"\u003e닫기\u003c/button\u003e\n\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\n\t\u003cbutton id=\"login\"\u003e로그인\u003c/button\u003e\n\u003c/body\u003e\n  \n\u003cscript\u003e\n\t$('#login').on('click', function () {\n\t\t// fadeIn() 사용\n\t\t$('.black-bg').fadeIn();\n\t});\n\u003c/script\u003e\n```\n\n```css\n.black-bg {\n\twidth: 100%;\n\theight: 100%;\n\tposition: fixed;\n\tbackground: rgba(0, 0, 0, 0.5);\n\tz-index: 5;\n\tpadding: 30px;\n\t/* display: none 사용 */\n\tdisplay: none;\n}\n\n.show-modal {\n\t/* display: block 사용 */\n\tdisplay: block;\n}\n```\n\n\u003cbr\u003e\n\n- css로 애니메이션 적용한 코드  \n\n```html\n\u003cbody\u003e\n\t\u003cdiv class=\"black-bg\"\u003e\n\t\t\u003cdiv class=\"white-bg\"\u003e\n\t\t\t\u003ch4\u003e로그인하세요\u003c/h4\u003e\n\t\t\t\u003cbutton class=\"btn btn-danger\" id=\"close\"\u003e닫기\u003c/button\u003e\n\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\n\t\u003cbutton id=\"login\"\u003e로그인\u003c/button\u003e\n\u003c/body\u003e\n  \n\u003cscript\u003e\n\t$('#login').on('click', function () {\n\t\t// addClass() 사용\n\t\t$('.black-bg').addClass('show-modal');\n\t});\n\u003c/script\u003e\n```\n\n```css\n.black-bg {\n\twidth: 100%;\n\theight: 100%;\n\tposition: fixed;\n\tbackground: rgba(0, 0, 0, 0.5);\n\tz-index: 5;\n\tpadding: 30px;\n\n\t/* visibility, opacity, transition 사용 */\n\tvisibility: hidden;\n\topacity: 0;\n\ttransition: all 1s;\n}\n\n.show-modal {\n\t/* visibility, opacity 사용 */\n\tvisibility: visible;\n\topacity: 1;\n}\n```\n\n- 자바스크립트 (jQuery)로 애니메이션 넣은 서브메뉴바  \n\n```html\n\u003cscript\u003e\n\t$('.navbar-toggler').on('click', function () {\n\t\t$('.list-group').slideToggle();\n\t});\n\u003c/script\u003e\n```\n\n```css\n.list-group {\n\tdisplay: none;\n}\n```\n\n- css로 애니메이션 적용한 서브메뉴바\n\n```html\n\u003cscript\u003e\n\t$('.navbar-toggler').on('click', function () {\n\t\t$('.list-group').toggleClass('show-menubar');\n\t});\n\u003c/script\u003e\n```\n\n```css\n.list-group {\n\tdisplay: block;\n\theight: 0;\n\toverflow: hidden;\n\ttransition: all 1s;\n}\n\n.show-menubar {\n\theight: 210px;\n}\n```\n\n\u003chr\u003e\n\n## form태그 if/else\n\n- form 태그 다룰 때, 전송 버튼은 반드시 `type=\"submit\"` 해줄 것 명심하자. 일반 버튼은 `type=\"button\"` 이렇게 해야 오류가 없다.\n- form 태그는 서버로 유저정보 전송하려고 쓰는 것이다.\n- `\u003cform action=\"url~~~\"\u003e\u003c/form\u003e` 서버 경로 제대로 설정하자.\n\n\u003cbr\u003e\n\n### 조건문 (if-else)\n\n```javascript\nif (조건) {\n\t조건이 참일 때 실행할 코드\n} else {\n\t조건이 거짓일 때 실행할 코드\n}\n```\n\n- 조건 사용 시 비교연산자 `==, ===, !=, !==, \u003c, \u003c=, \u003e, \u003e=`\n- 조건 사용 시 boolean `true(1), false(0)` 이용\n- 참고로 `elif`는 파이썬임 `else if`가 자바스크립트\n- `else if`는 위의 조건이 참이면 실행 안되는 것임\n\n```javascript\nif (1 == 3) {\n\tconsole.log('맞아요1');\n} else if (1 == 1) {\n\tconsole.log('맞아요2');\n}\n\n// 출력 : 맞아요2\nif (3 == 3) {\n\tconsole.log('맞아요1');\n} else if (1 == 1) {\n\tconsole.log('맞아요2');\n}\n\n// 출력 : 맞아요1\n// 위에가 참이니까 맞아요2는 출력안되고 그냥 끝남\n\nif (1 == 1) {\n\tconsole.log('맞아요1');\n}\n\nif (2 == 2) {\n\tconsole.log('맞아요2');\n}\n\n// 출력 : 맞아요1\n// 출력 : 맞아요2\n```\n\n\u003cbr\u003e\n\n### 비교 연산자\n\n그냥 비교할 때는 `==`, `!=` 타입까지 맞춰서 비교할 때는 `===`, `!==`\n\n- 동등 연산자(`==`) : 두 피연산자의 자료형을 일치시킨 후 비교 수행\n- 부등 연산자(`!=`) : 두 피연산자의 자료형을 일치시킨 후 비교 수행\n- 일치 연산자(`===`) : 자료형 변환 없이 비교 수행\n- 불일치 연산자(`!==`) : 자료형 변환 없이 비교 수행\n\n\u003cbr\u003e\n\n### 논리 연산자\n\n- `\u0026\u0026` : AND\n- `||` : OR\n- `!` : NOT\n\n\u003chr\u003e\n\n## truthy, falsy 자료\n\n| truthy 자료 | falsy 자료 |\n| :---------: | :--------: |\n| 0 제외 숫자 | 0 |\n| '문자' | '' |\n| [] | null |\n| {} | undefined |\n| | NaN |  \n\n\u003chr\u003e\n\n## undefined, null\n\nundefined와 null은 '값이 없다' 라는 점에서 유사하지만 엄밀히 말하면 다른 개념이다. typeof 연산자로 타입을 확인해보면 undefined는 undefined 타입이, null은 object 타입이라고 표시된다.\n\n- undefiend : 변수는 존재하나, 어떠한 값으로도 할당되지 않아 자료형이 정해지지(undefined) 않은 상태\n\n- null : 변수는 존재하나, null 로 (값이) 할당된 상태. 즉 null은 자료형이 정해진(defined) 상태\n\n```javascript\nvar var1;\n//undefined (어떤 값도 할당되지 않아서 자료형을 알 수 없음)\n\nvar var2 = null;\n//null (null로 (값이) 할당되어서 자료형을 알 수 있음 - null의 자료형은 object)\n``` \n\n근데, `undefined == null`을 비교하면 true값이 나온다. 이는 위에서 설명한 비교연산자 때문이다. 엄격한 비교인지 엄격하지 않은 비교인지 때문이다.\n\n```javascript\nundefined == null; //true , 형변환 까지 해줘서 true가 나옴\nundefined === null; //false , 형변환을 하지 않아서 false가 나옴\n```\n\n\u003chr\u003e\n\n## if문 이용한 form 태그 \n\n```javascript\n// 물론 둘다 else if 말고 그냥 if 문들로 해도 됨\n// 근데 else if가 나은듯\n\ndocument\n\t.getElementsByTagName('form')[0]\n\t.addEventListener('submit', function (e) {\n\t\tif (document.getElementById('email').value == '') {\n\t\t\te.preventDefault();\n\t\t\talert('아이디를 입력 해주세요 !');\n\t\t} else if (document.getElementById('pw').value == '') {\n\t\t\te.preventDefault();\n\t\t\talert('비밀번호를 입력 해주세요 !');\n\t\t} else if (document.getElementById('pw').value.length \u003c 6) {\n\t\t\te.preventDefault();\n\t\t\talert('비밀번호를 6자리 이상 입력 해주세요 !');\n\t\t} else {\n\t\t\talert('정상적으로 제출되었습니다.');\n\t\t}\n});\n\n// jQuery 사용\n$('form').on('submit', function (e) {\n\tif (document.getElementById('email').value == '') {\n\t\te.preventDefault();\n\t\talert('아이디를 입력 해주세요 !');\n\t} else if (document.getElementById('pw').value == '') {\n\t\te.preventDefault();\n\t\talert('비밀번호를 입력 해주세요 !');\n\t} else if (document.getElementById('pw').value.length \u003c 6) {\n\t\te.preventDefault();\n\t\talert('비밀번호를 6자리 이상 입력 해주세요 !');\n\t} else {\n\t\talert('정상적으로 제출되었습니다.');\n\t}\n});\n```\n\n- getElementsByTagName 할 때도 인덱스 지정해줘야함\n\n- 제출버튼에 id 지정해줘도 되지만, form 태그의 이벤트를 submit으로 해줘도 됨\n\n- input의 값은 value로 가져옴\n\n- 전송을 원하지 않으면 function의 괄호 안에 `e`를 넣고 `e.preventDefault();` 해주면 됨\n\n\u003chr\u003e\n\n## input 이벤트  \n\n```javascript\ndocument.getElementById('email').addEventListener('input', function () {});\n\ndocument.getElementById('email').addEventListener('change', function () {});\n```\n\n- 불러온 id 태그가 input 태그일 때 addEventListener 이벤트에 input / change 준 경우\n\n- input 태그에 유저가 입력한 값이 변할 때 실행된다는 의미\n\n- 이벤트 input 일 때 : input 태그에 입력한 값이 바뀔 때마다 실행\n\n- 이벤트 change 일 때 : input 태그에 입력한 값이 바뀌고 **포커스를 잃을 때** 실행\n\n- 응용하면 비밀번호 6자리 이상 입력해야할 때 그것보다 작게 입력하고 있으면 계속 ui 띄우는 경우가 있겠네\n\n\u003chr\u003e\n\n## 변수 문법\n  \n\n```javascript\nvar 변수명 = 넣을자료;\n```\n\n변수를 사용하는 이유\n\n- 길고 복잡한 자료들 저장 가능\n- 특정 값을 기억하게 하려고 (count 같은거)\n- **좋은 관습 : 자주쓰는 셀렉터 변수에 넣어쓰기**\n\n\u003cbr\u003e\n\n변수는 **변수의 선언, 할당, 범위** 세 가지만 잘 기억하면 된다.  \n\n- 변수의 선언 : 변수 만들겠습니다.\n- 변수의 할당 : 변수에 자료 넣기\n- 변수의 범위\n- 함수 안에서 변수 만들면 사용가능 범위는 함수 내부 \u003cbr\u003e 함수 안에서 만든 변수를 함수 밖에서 사용하려고 하면 사용 불가능\n  \n```javascript\nvar 이름; // 변수의 선언\n이름 = 'kim'; // 변수의 할당\n\nvar 이름 = 'kim'; // 변수의 선언과 할당\n이름 = 'park'; // 변수의 재할당\n```\n\n```javascript\nfunction 함수() {\n\tvar 이름 = 'kim';\n\tconsole.log(이름);\n}\n// 출력 : kim\n\nfunction 함수() {\n\tvar 이름 = 'kim';\n}\n\nconsole.log(이름);\n// 출력 : Uncaught ReferenceError: 이름 is not defined\n```\n\n\u003cbr\u003e\n\n### var let const 차이\n\n| var | let | const |\n| :--------------------------------: | :-------------------------: | :-------------------------: |\n| 재선언O | 재선언X | 재선언X |\n| 재할당O | 재할당O | 재할당X |\n| 범위 function \u003cbr\u003e Function-scoped | 범위{ } \u003cbr\u003e {Block-scoped} | 범위{ } \u003cbr\u003e {Block-scoped} |\n\n- let 변수 : 재선언 불가\n\n- 코드가 길어지면 사용한 변수를 까먹고 또 만들 수 있다. \u003cbr\u003e let은 이것을 방지 가능\n\n```javascript\nlet 이름 = 'kim';\nlet 이름 = 'park';\n\n// 출력 : Uncaught SyntaxError: Identifier '이름' has already been declared\n```\n\n- const 변수 : 재선언 불가, 재할당 불가\n\n- 변하는 안되는 값을 보관할 때 좋다. 상수\n\n```javascript\nconst 이름 = 'kim';\n이름 = 'park';\n\n// 출력 : Uncaught TypeError: Assignment to constant variable.\n```\n\n- 추가로, let과 const는 function뿐만 아니라 중괄호 `{}` 내부는 모두 범위로 취급한다.\n\n```javascript\nif () {\n\tlet 이름;\n}\n\n// 이것도 밖에서 이름 사용 못함\n```\n\n\u003cbr\u003e\n\n### 문자 중간에 변수 쉽게 넣기\n\n- 백틱 기호를 사용한다.\n\n- 변수는 `${변수}`와 같이 담는다.\n\n```javascript\nlet a = '안녕';\nconsole.log('문자' + a + '문자');\nconsole.log(`문자${a}문자`);\n\n// 문자안녕문자\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-js/apple-js-02":{"title":"LEVEL 02","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/javascript-jquery-ui/' target='_blank'\u003eJavaScript 입문과 웹 UI 개발\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## setTimeout, setInterval\n\n\u003cbr\u003e\n\n### setTimeout\n\n- 몇 초 **후** 코드 실행하기 위한 자바스크립트 기본 내장 함수\n- 1000ms = 1초\n- 콜백함수자리에 만들어둔 함수 당연히 넣을 수 있음\n\n```javascript\nsetTimeout(function () {\n\t실행할코드;\n}, ms);\n\n// 콜백함수에 함수 넣으면?\nsetTimeout(알림창제거, 3000);\n\nfunction 알림창제거() {\n\tdocument.querySelectorAll('.alert')[0].style.display = 'none';\n}\n```\n\n- 대신 만든 함수 넣을 때 `함수()` 말고 `함수`만 넣으셈\n\n```javascript\nsetTimeout(알림창제거(), 3000);\n```\n\nsetTimeout은 함수로의 참조를 받아올 것이라 예상한다. 위의 `알림창제거()`는 함수를 실행시킨다. 그리고 실행의 결과가 setTimeout으로 전달된다. 우리가 코딩했던 것들을 살펴봤을 때, 알림창제거()의 결과는 undefined (아무것도 리턴하지 않는 함수)이다.그러므로 아무것도 스케쥴되지 않으니까 `알림창제거`만 넣어라.\n\n- 타이머를 변수에 담아서 사용 가능!\n\n```javascript\nlet 타이머 = setTimeout(어쩌구);\n```\n\n\u003cbr\u003e\n\n### setInterval\n\n- 몇 초 **마다** 코드 실행하기 위한 자바스크립트 기본 내장 함수\n\n```javascript\nsetInterval(function () {\n\t실행할코드;\n}, ms);\n```\n\n\u003cbr\u003e\n\n### clearTimeout\n\n- 타이머를 삭제하고 싶으면 타이머를 변수에 담고 clearTimeout 하면 된다.\n\n- `clearTimeout()`, `clearInterval()` 상호교환 가능하다. 허나, 명확성을 위하여 그렇게 하지말라고 \u003ca href='https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout' target='_blank'\u003e공식 문서\u003c/a\u003e에서 표기하고 있다.\n\n```javascript\nfunction 콘솔출력() {\n\tconsole.log('안녕');\n}\n\nlet 타이머 = setTimeout(콘솔출력, 1000);\nclearTimeout(타이머);\n```\n\n\u003chr\u003e\n\n## JS 문법 vs 브라우저 사용법\n\n- 자바스크립트 문법 : `if, var, function`\n\n- 브라우저 사용법 : `document.querySelector(), setTimeout(), alert()`\n\n- 자바스크립트 문법은 브라우저 사용할 경우 프로그래밍적인 기능을 더하고 싶을 때 사용하는 것이다. (ex. 조건 분기, 잠깐 보관, 코드가 길때 축약 등)\n\n- 웹 브라우저 사용법은 정확하게 **Web Browser API 사용법** 이라고 한다.  \n\n\u003chr\u003e\n\n## 정규식\n\n- 정규식(Regular Expression)  \n\n- 공백 검사 말고도 유저가 입력한게 이메일 형식인지 맞는지 검사하고 싶다면 정규식을 사용해보도록 하자.\n\n- \u003ca href='https://regexr.com/' target='_blank'\u003eregex test\u003c/a\u003e 사이트를 통해 표현이 맞는지 검사해보자.\n\n\u003cbr\u003e\n\n### includes()\n\n- 문자 검사하는 쉬운 방법이다.\n\n- 한계 : 왼쪽 문자에 한글이 들어있냐, 영어가 들어있냐, A로 끝나냐, 숫자가 1회 출현하냐 이런 것을 검사할 수 없다.\n\n```javascript\n'abc'.includes('a');\n// true\n\n'abc'.includes('d');\n// false\n```\n\n\u003cbr\u003e\n\n### 정규식 파헤치기\n\n- `/ /`안에 문자를 넣고 정규식을 사용한다.  \n\n```javascript\n/a/.test('abcde');\n// true\n```\n\n\u003cbr\u003e\n\n**정규식으로 범위 지정 가능**\n\n`/[a-z]/` : a ~ z 중 아무 글자 1개, 즉 범위 지정 가능\n\n```javascript\n/[a-z]/.test('abcde')\n// true\n\n/[a-z]/.test('바보')\n// false\n\n/[A-Z]/.test('abcde')\n// false\n\n/[A-Z]/.test('abcdA')\n// true\n```\n\n\u003cbr\u003e\n\n- `/[a-zA-z]/` : 아무 알파벳 1개\n\n- `/[ㄱ-ㅎ가-힣ㅏ-ㅣ]/` : 아무 한글문자 1개\n\n- `/[0-9]/` : 아무 숫자 1개\n\n- `/\\S/` : 아무 문자 **1개**, 특수기호까지 포함\n\n```javascript\n/[ㄱ-ㅎ가-힣]/.test('안녕')\n// true\n\n/[ㄱ-ㅎ가-힣]/.test('ㅏㅏㅏ')\n// false\n\n/[ㄱ-ㅎ가-힣ㅏ-ㅣ]/.test('ㅏㅏ')\n// true\n```\n\n\u003cbr\u003e\n\n\u003e [!note] Memo\n\u003e\n\u003e 주의할 게, 지금 문자 1개를 찾는 것이다. /a/는 a 문자 1개\"만\" 찾는 것이다. 여러 개 찾고 싶으면 /a+/ 형태로 +를 사용하자. +는 왼쪽 문자 반복 검색\n\n\u003cbr\u003e\u003cbr\u003e\n\n**정규식으로 시작`(^)`/끝문자`($)` 검사**  \n\n- `/^a/` : a로 문자 시작하냐\n\n- `/a$/` : a로 문자 끝나냐\n\n- `/a|b/` : a 또는(or) b 있냐\n\n- `/(a|b)/` : 괄호 사용 가능, 정규식에서 괄호는 묶어서 계산해줌\n\n\u003cbr\u003e\n\n**정규식으로 이메일형식 검사**\n\n- `.` : 정규식의 특별한 문법, 따로 dot을 사용하고 싶으면 `\\` 써주기\n\n- `+` : 왼쪽 문자 반복 검색\n\n```javascript\n/\\S@\\S\\.\\S/.test('aaa@bbb.ccc')\n// false\n// 모든문자 1개 + 골뱅이 + 모든문자 1개 + . + 모든문자 1개\n\n/\\S@\\S\\.\\S/.test('a@b.c')\n// true\n\n/\\S+@\\S+\\.\\S+/.test('aaa@bbb.ccc')\n// true\n```\n\n\u003chr\u003e\n\n## Carousel (캐러셀)\n\n- carousel, 회전목마라는 뜻인데 간단히 이미지 슬라이드라고 이해하자.\n- one-way 애니메이션 기반 UI 이다.\n\n1. 애니메이션 시작 전 화면 제작\n2. 애니메이션 종료 후 화면 제작\n3. 언제 종료화면으로 변할지 JS 코드짜기\n4. transition 추가\n\n\u003cbr\u003e\n\n1. **시작 전 화면**\n\n\n```css\n.slide-container {\n\twidth: 300vw;\n\tdisplay: flex;\n}\n\n.slide-box {\n\twidth: 100vw;\n} \n\n.slide-box img {\n\twidth: 100%;\n}\n```\n\n- 이런 느낌으로 컨테이너 전체 너비를 `캐러셀 이미지 개수 * 100vw` 정도로 해놓는다.\n- 그리고 박스의 폭 각각을 `100vw`로 설정한다.\n- 이미지 너비를 `100%`로 하고 박스에 꽉차게 설정한다.\n- 현재 슬라이드 컨테이너 너비가 300vw라서 좌우 스크롤이 생길 것이다. 그를 막기 위해 slide-container를 감싸는 div 박스를 하나 만들고 `style=\"overflow: hidden\"` 줘서 흐르는걸 숨겨준다.\n\n\u003cbr\u003e\n\n2. **시작 후 화면**\n\n- margin-left 속성을 줘도 되지만, 성능 때문에 `transform: translateX()` 속성을 사용하자. 현재 상황에서 `-100vw`를 해주면 전체적으로 왼쪽으로 이동하니 두번째 캐러셀 이미지가 보일 것이다.\n\n```css\n.slide-container {\n\twidth: 300vw;\n\tdisplay: flex;\n\ttransform: translateX(-100vw);\n}\n```\n\n\u003cbr\u003e\n\n3. 언제 종료화면으로 변할지 JS 코드 짜기\n\n- 버튼을 클릭했을 때 이미지에 translateX() 속성 주는 방식\n- 해당하는 캐러셀 이미지에 가도록 X축 조절하면 됨\n\n```javascript\ndocument\n\t.querySelector(\".slide-2\")\n\t.addEventListener(\"click\", function () {\n\t\tdocument.querySelector(\".slide-container\").style.transform =\n\t\t\"translateX(-100vw)\";\n});\n```\n\n\u003cbr\u003e\n\n4. **transition**\n\n```css\n.slide-container {\n\twidth: 300vw;\n\tdisplay: flex;\n\ttransition: all 1s;\n}\n```\n\n\u003cbr\u003e\n\n**이전 버튼과 다음 버튼을** 활용할 때는 현재 상테에 대한 변수를 하나 두고 그 변수 값을 조정하며 코드를 짜도록 하자.\n\n\u003chr\u003e\n\n## function() return 문법\n\n\u003ca href='/brain/Lecture/apple-js/apple-js-01' target='_blank'\u003eJS 입문과 웹 개발 01\u003c/a\u003e에서 설명한 자바스크립트 함수는 긴 코드를 축약하는 것과 파라미터를 추가해서 사용하는 것에 장점이 있었다. **return은 함수쓰고 그 자리에 뭔가 뱉고 싶으면 쓰는 것이다.**\n\n```javascript\nfunction 함수() {\n\treturn 123;\n}\n\n함수(); // 이 자리에 123 퉤! 하고 뱉음\n\n// 확인해보자\nvar 변수 = 함수();\nconsole.log(변수);\n```\n\n- 반환할 때 숫자, 문자, 수식 다 가능하다.\n\n- return은 함수종료 기능도 있다. return 밑에는 더이상 실행되지 않는다.\n\n\u003cbr\u003e\n\n\u003e [!note] 그래서 return 용도가 뭔데?\n\u003e\n\u003e  자료를 넣으면 다른 자료가 나오는 변환기를 만들고 싶을 때 사용\n  \n\u003cbr\u003e\n\n쇼핑몰을 만드는 예시에서 가격 밑에 부가세를 표현해주고 싶다고 하자. 그럼 함수를 만들고 가격(자료)을 넣으면 부가세(다른 자료) 나오는 계산기를 만들고 싶은 것이다.\n\n```javascript\nfunction 부가세(가격) {\n\treturn 가격 * 0.1;\n}\n\n부가세(50000); // 5000\n```\n\n`문자 -\u003e 문자 변환기`, `숫자 -\u003e true/false 변환기` 아무렇게나 제작 가능\n\n\u003chr\u003e\n\n## 자바스크립트 소수점 다루기\n\n자바스크립트에서 소수점 있는 숫자연산시 주의해야한다. 약간의 오차가 발생할 수 있다.\n\n\n```javascript\nconsole.log(55555 * 1.1);\n// 61110.50000000001\n\nconsole.log(1.1 + 0.3);\n// 1.4000000000000001\n```\n\n컴퓨터는 2진법으로 설계되어있기 때문에, `10 + 20`이라고 하면 숫자 10과 숫자 20을 더하는 것이 아니라 2진법으로 변환하여 `1010 + 10100`을 계산한다. 이때, 소수점을 2진법으로 변환 시 문제가 발생한다.\n\n\u003cbr\u003e\n\n`1.1 -\u003e 1.00011001100110011001100....` 이렇게 무한히 `1100`이 반복되는 모습을 확인가능하다. 무한한 숫자를 저장하기에 저장공간이 작아서 중간에 자르고 반올림 시켜버린다.\n\n\u003cbr\u003e\n\n매우 작은 오차라서 평소엔 무시해도 되지만, 조금 정확한 연산을 원한다면\n\n\n1. 애초에 소수점을 사용하지 말든가\n\n\t- 소수점을 전부 10곱해서 연산하고 10으로 나누기\n\n2. 소수점 정확하게 계산해주는 라이브러리 쓰든가\n\n3. 연산결과를 반올림해서 쓰든가\n\n\u003cbr\u003e\n\n### 소수점 반올림\n\n- `숫자.toFixed(몇째 자리 까지)`\n- 참고로 toFixed 붙혀주면 **문자로 반환됨**\n- 크롬 콘솔탭에서 색깔이 검은색이면 문자라고 생각하셈, 숫자는 파란색인듯\n\n```javascript\nconsole.log((55555 * 1.1).toFixed(1))\n// 61110.5\n\nconsole.log((55555 * 1.1).toFixed(2))\n// 61110.50\n```\n\n\u003chr\u003e\n\n## +(플러스) 연산자 특징\n\n- `'문자' + 123 =\u003e '문자123'`\n- `'문자' + '문자' =\u003e '문자문자'`\n- 숫자끼리 더하고 싶으면 `parseInt()`, `parseFloat()` 사용\n\n```javascript\nfunction 부가세(가격) {\n\tlet result = (가격 * 1.1).toFixed(1);\n\treturn result + 1;\n}\n\nconsole.log(부가세(55555));\n// 61110.51\n// toFixed 써서 result가 문자니까 문자 + 1 = 문자1이 된 것\n\nfunction 부가세(가격) {\n\tlet result = (가격 * 1.1).toFixed(2);\n\treturn parseFloat(result) + 1;\n}\n\nconsole.log(부가세(55555));\n// 61111.5\n```\n\n\u003chr\u003e\n\n## 부동소수점 부가 설명\n\n\u003ca href='https://youtu.be/-GsrYvZoAdA' target='_blank'\u003e코딩애플 유튜브 영상\u003c/a\u003e을 참조하여 정리했다. 모든 그림의 저작권은 \u003ca href='https://codingapple.com/' target='_blank'\u003e코딩애플\u003c/a\u003e님에게 있습니다. 추가로 참고하기 좋은 \u003ca href='https://codetorial.net/articles/floating_point.html' target='_blank'\u003e링크\u003c/a\u003e입니다.\n\n- 코드를 보면, `1.1 + 0.1`이 `1.2`와 동일하지 않고 약간 크다고 한다.\n\n```javascript\nconsole.log(1.1 + 0.1 == 1.2);\n// false\n\nconsole.log(1.1 + 0.1 \u003e 1.2);\n// true\n```\n\n### 1. RAM\n\n컴퓨터에서 5라는 숫자를 저장하려면 **RAM**에 저장한다. 0과 1의 이진수 형태로 저장하게 된다. 칸은 하나당 bit라고 한다.\n\n![](brain/image/apple-js-02-1.png)\n\n숫자는 보통 8칸 정도를 마련하여 저장한다. 더 큰 수를 저장하고 싶으면 16칸도 할당한다. 16칸은 (-32768 ~ 32767) 까지 저장 가능하다.\n\n\u003cbr\u003e\n\n### 2. 부동소수 표현 저장\n\n소수 저장은 아무렇게나 하는 것이 아니라, 덧셈이나 뺄셈과 같은 연산을 편하게 하기 위하여 \u003ca href='https://docs.microsoft.com/ko-kr/cpp/build/ieee-floating-point-representation?view=msvc-170' target='_blank'\u003eIEEE 표준 표현방식\u003c/a\u003e을 따른다. \u003cbr\u003e\n\n예를 들어, `5.125`라는 수를 저장하기 위하여 메모리에 넉넉히 32칸을 준비한다. 이때, 32비트를 사용하는 방식을 **단정도(single precision)** 라고 한다. **배정도 표현**에서는 64비트를 사용한다.\n\n- 맨 첫번째 칸 : 부호 저장 (양수 = 0, 음수 = 1)\n- 저장할 숫자를 2진법으로 변환 ( **5.125 -\u003e 101.001** )\n- 점을 왼쪽 끝까지 이동 ( **1.01001 * 2\u003csup\u003e2\u003c/sup\u003e** )\n- 01001 부분을 **mantissa**라고 하는데 여기는 맨 뒤 23칸에 밀어넣는다.\n- 지수 부분에 127을 더하고 앞에 8칸에 저장한다. (지수는 2\u003csup\u003e2\u003c/sup\u003e 에서 위에꺼를 의미. 2\u003csup\u003e4\u003c/sup\u003e이면 4가 지수)\n- 여기서 127은 bias이다. bias는 2\u003csup\u003ek-1\u003c/sup\u003e인데 여기서 k는 지수부의 비트 수인 8이다. (8칸)\n\n\u003cbr\u003e  \n\n단정도 표현은 **부호부 (1칸) + 지수부 (8칸) + 가수부 (23칸)** 으로 이루어진다.\n\n\u003cbr\u003e\n\n### 3. 순환소수 문제\n\n이러한 저장 방식에는 순환소수 문제가 있다. 예를 들어, `10진수 0.125`는 `2진수 0.001`로 깔끔하게 나누어떨어진다. 그런데, `10진수 0.1` 같은 숫자는 깔끔하게 떨어지지 않고 `2진수 0.000110011001100110011001100110011001...` 무한히 반복하게 된다. 이러한 경우 32칸에 저장할 수 없어서 뒷부분을 잘라버리고 저장한다. 그렇다면 자른 뒷 부분의 오차가 발생하게 되는 것이다. 한마디로 **정확히 0.1을 저장한 것이 아니라 0.1에 근접한 수를 저장한 것이다.**\n\n\u003cbr\u003e\n\n### 4. 문제 발생\n\n이 사소한 오차가 큰 문제인가? 실제로, 걸프전 당시 미군이 운영하던 패트리어트 (Patriot Missile Defense)라는 미사일 요격 장비가 있었는데, 미사일 요격에 실패하여 28명의 군인이 전사한 사건이 있었다. 패트리어트를 구동하기 위한 프로그램에서 **시간을 0.1초 단위로 측정했다.**\n\n\u003cbr\u003e\n\n여기서 패트리어트는 숫자 1개에 24칸을 사용했다. 그러면 0.1을 표현할 때 오차가 생기는게 단정도 표현 방식보다 더 컸을 것이다. 보통 1시간 마다 0.0034초 오차가 발생했다고 한다. 사소해보이지만, \u003ca href='http://nifty.stanford.edu/2003/pests/2002/lectures/07.1_FloatingPoint/Patriot.html' target='_blank'\u003e사고 report\u003c/a\u003e를 보면 해당 기기를 100시간 가동시키니 **0.34초** 오차가 발생했다. 이렇게 봐도 작아보이는가 ?\n\n\u003cbr\u003e\n\n1500 m/s 속력의 미사일 요격시 이 0.34초 오차 때문에 500m 정도 빗나갔다. 이래서 요격에 실패하여 비극을 일으킨 것이다.\n\n\u003cbr\u003e\n\n### 5. 결론\n\n그래서, 소수는 어디에 사용되는가? \u003cbr\u003e\u003cbr\u003e\n\n- 5-1. 정확히 계산해야하는 자료는 **정수**로 저장 \u003cbr\u003e\n\n돈 같은 경우 5.1 달러를 저장하고 싶으면 float를 사용하여 저장하면 안되고 **정수**의 형태로 저장해야 한다. 즉, 5.1달러가 아닌 5100센트로 저장해야 한다. \u003cbr\u003e\n\n\u003cbr\u003e\n\n- 5-2. 굳이 float 써야할 때는 **반올림 문법** \u003cbr\u003e\n\n```javascript\nprecision = Math.pow(10, precision)\nMath.ceil(num * precision) / precision\n```\n\n\u003cbr\u003e\n\n- 5-3. **double 자료형 사용**하여 더 정확하게 저장 \u003cbr\u003e\n\n숫자 1개당 32칸이 아닌 **64칸을 사용**한다. IEEE 부동소수 표현 설명에서 봤던 **배정도 표현**을 사용하는 것이다. 오차가 매우 작아지기 때문에 괜찮지만, 단점으로는 역시 메모리 용량을 2배 쓰는 것이니까 낭비일 수 있다.\n\n\u003chr\u003e\n\n## scroll 이벤트 활용\n\nwindow 객체를 활용하여 scroll 이벤트를 사용할 수 있다.\n1. 스크롤바 조작할 때마다 코드실행 가능\n2. 박스의 실제 높이 / 보이는 높이 구할 수 있음\n3. 스크롤 얼마나 했는지 스크롤양 구할 수 있음\n\n```javascript\nwindow.addEventListener('scroll', function() {\n\tthis.window.scrollY ~\n})\n```\n\n- 왼쪽이 스크롤 될 때 마다 안에 코드 실행해줌\n\n- 현재 그냥 html 페이지 그 자체를 의미하는건 window, DOM이 있다.\n\n- 스크롤 이벤트를 감지하고 싶으면 보통 window에 이벤트리스너 부착\n\n- 추가로 html에서 임의로 스크롤 만들거면 `overflow-y` 다루셈 혹은 `height 굉장히 큰 div박스` 만들던가\n\n![](brain/image/apple-js-02-2.png)\n\n- `window.scrollY` 하면 스크롤 얼마나 했는지 알려줌. 가로 스크롤은 `window.scrollX`\n- `window.scrollTo(x,y)`는 지정한 위치로 강제로 스크롤함. 원래는 반짝! 순간이동해야하는데 부트스트랩 쓰면 스크롤을 스무스하게 이동시키는게 자동 설정임 이거 해결하려면 css 파일 열어서 아래 코드 작성\n\n```css\n:root {\n\tscroll-behavior: auto;\n}\n```\n\n- `window.scrollBy(x,y)`는 현재 위치부터 강제로 스크롤함.\n\n\u003cbr\u003e\n\n### jQuery로 scroll 이벤트\n\n```javascript\n$(window).on('scroll', function() {\n\t$(window).scrollY ~\n})\n```\n- `$(window).scrollTop()` : jQuery 내장, 현재 스크롤바 위치 출력, scrollY랑 똑같은 기능인데 `scrollTop(숫자)` 하면 scrollTo 기능도 되는거임.\n\n\u003cbr\u003e\n\n### div 박스 스크롤바 내린 높이, 실제 높이\n\n1. div 박스는 scrollY 사용 불가능함. scrollY는 window에만 가능. 박스는 `scrollTop` 사용해야함. 실제 높이는 `셀렉터.scrollHeight` 사용\n\n2. 하지만, 스크롤을 끝까지 내려도 스크롤양과 실제높이가 같지 않을 수 있다. 이는 `scrollTop`의 특징 때문이다. 위에서부터 얼마나 스크롤바를 내렸는지 알려주기는 하지만, 전체를 내린 것은 아니기 때문이다. 현재 위치부터 내린 양을 계산하기 때문에 `눈에 보이는 div 박스 높이 + 스크롤양 = 실제높이`가 되는 것이다.\n\n3. 눈에 보이는 div 박스 높이도 css에 적힌 그 높이가 아니라 정확하게 구해보면 `clientHeight`를 사용하면 된다.\n\n![](brain/image/apple-js-02-3.png)\n\n```javascript\ndocument.querySelector(\".lorem\").addEventListener(\"scroll\", function () {\n\tlet 스크롤양 = document.querySelector(\".lorem\").scrollTop;\n\tlet 실제높이 = document.querySelector(\".lorem\").scrollHeight;\n\tlet 눈높이 = document.querySelector(\".lorem\").clientHeight;\n\n\tconsole.log(스크롤양, 실제높이, 눈높이);\n});\n```\n\n- `188.29 + 100 = 288?` 같이 약간 오차가 생길 수 있고 OS 마다 부정확해서 등호(`==`)를 이용하여 비교하기 보다 (끝까지 스크롤 내렸는지 비교하기 보다) **여유를 가지고 비교하는 것이 좋다.** 맨 밑에서부터 10px 정도 남기고 스크롤 했는지?처럼\n\n\u003cbr\u003e\n\n```javascript\nif (스크롤양 + 눈높이 \u003e 실제높이 - 10) {\n\talert(\"약관을 모두 읽으셨네요!\");\n}\n```\n\n- console을 찍어보면, clientHeight와 scrollHeight는 고정인데 scrollTop의 값이 변하는 것을 확인 가능. 즉, 위에 `눈에 보이는 div 박스 높이 + 스크롤양 = 실제높이`는 끝까지 내렸을 때 성립하는 공식임\n\n\u003cbr\u003e\n\n### div 박스말고 현재페이지 끝까지 스크롤 체크는?\n\n- html 문서의 그냥 html 태그의 높이를 이용하여 구한다.\n\n- 페이지의 scrollHeight는 페이지 로드가 다되고 나서야 정확해서 `\u003cbody\u003e` 끝나기 전에 넣는게 좋은 관습이다.\n\n```javascript\nwindow.addEventListener(\"scroll\", function () {\n\tlet 페이지실제높이 = document.querySelector(\"html\").scrollHeight;\n\tlet 페이지눈높이 = document.querySelector(\"html\").clientHeight;\n\tlet 페이지스크롤양 = document.querySelector(\"html\").scrollTop;\n\n\tif (페이지스크롤양 + 페이지눈높이 \u003e 페이지실제높이 - 10) {\n\t\talert(\"페이지 끝이지롱!\");\n\t}\n});\n```\n\n- `document.documentElement` 이거나 `document.querySelector('html')` 이거나 같음\n\n\u003cbr\u003e\n\n### scroll 내린 만큼 상단에 진행바 (스크롤퍼센트)\n\n- **스크롤퍼센트 = (페이지스크롤양 / (페이지실제높이 - 페이지눈높이)) * 100**\n\n```html\n\u003cdiv class=\"page_progress\"\u003e\u003c/div\u003e\n```\n\n- 고정시켜야해서 `position: fixed` 이런거 필요한데 navbar에 붙히는게 나은듯\n\n- navbar 맨위에 고정시킬 때 `position: fixed; width: 100%; z-index: 5;` 알지?\n\n```css\n.page_progress {\n\tdisplay: block;\n\tbackground-color: black;\n\twidth: 0%;\n\theight: 3px;\n\ttransition: all 0.1s;\n}\n```\n\n```javascript\nwindow.addEventListener(\"scroll\", function () {\n\tlet 페이지실제높이 = document.querySelector(\"html\").scrollHeight;\n\tlet 페이지눈높이 = document.querySelector(\"html\").clientHeight;\n\tlet 페이지스크롤양 = document.querySelector(\"html\").scrollTop;\n\tlet 스크롤퍼센트 = (페이지스크롤양 / (페이지실제높이 - 페이지눈높이)) * 100;\n\n\tthis.document.querySelector(\".page_progress\").style.width = 스크롤퍼센트 + \"%\";\n});\n```\n\n\u003cbr\u003e\n\n### scroll 다룰 때 주의점\n\n1. scroll 이벤트리스너 안의 코드는 1초에 60번 이상 실행됨\n\t- 컴퓨터에 부담을 줄 수 있어서 너무 많이 쓰면 안됨\n\n2. 바닥체크도 여러 번 중복으로 할 것\n\n\u003cbr\u003e\n\n### 결론\n\n- 페이지 스크롤 : `window.scrollY`\n- div 스크롤 : `.scrollTop`\n- div 실제높이 : `.scrollHeight`\n- div 화면높이 : `.clientHeight`\n- jQuery 페이지 스크롤 : `$(window).scrollTop()`\n\n\u003chr\u003e\n\n## for 반복문, 탭기능 만들기\n\n\u003cbr\u003e\n\n### 탭기능\n\n- 탭은 위에 버튼 누르면 그에 걸맞는 div 박스 내용 보이게 하는거\n\n- 역시 탭을 만들 때도 하나하나 display: none~ block~ 하는것보다 `show`라는 클래스 하나 만들어서 탈부착하는 방식으로 만들기\n\n```html\n\u003cdiv class=\"container mt-5\"\u003e\n\t\u003cul class=\"list\"\u003e\n\t\t\u003cli class=\"tab-button\"\u003eProducts\u003c/li\u003e\n\t\t\u003cli class=\"tab-button orange\"\u003eInformation\u003c/li\u003e\n\t\t\u003cli class=\"tab-button\"\u003eShipping\u003c/li\u003e\n\t\u003c/ul\u003e\n\n\t\u003cdiv class=\"tab-content\"\u003e\n\t\t\u003cp\u003e상품설명입니다. Product\u003c/p\u003e\n\t\u003c/div\u003e\n\n\t\u003cdiv class=\"tab-content show\"\u003e\n\t\t\u003cp\u003e스펙설명입니다. Information\u003c/p\u003e\n\t\u003c/div\u003e\n\n\t\u003cdiv class=\"tab-content\"\u003e\n\t\t\u003cp\u003e배송정보입니다. Shipping\u003c/p\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\n```\n\n```css\nul.list {\n\tlist-style-type: none;\n\tmargin: 0;\n\tpadding: 0;\n\tborder-bottom: 1px solid #ccc;\n\tdisplay: flex;\n}\n\n.tab-button {\n\tpadding: 10px 20px 10px 20px;\n\tmargin-right: -1px;\n\tmargin-bottom: -1px;\n\tcolor: grey;\n\ttext-decoration: none;\n\tcursor: pointer;\n}\n\n.orange {\n\tborder-top: 2px solid orange;\n\tborder-right: 1px solid #ccc;\n\tborder-bottom: 1px solid white;\n\tborder-left: 1px solid #ccc;\n\tcolor: black;\n\tmargin-top: -2px;\n}\n\n.tab-content {\n\tdisplay: none;\n\tpadding: 10px;\n}\n\n.show {\n\tdisplay: block;\n}\n```\n\n1. tab-button 누르면 모든 버튼에서 orange 클래스 제거\n2. 누른 버튼에 orange 클래스 부착\n3. 모든 tab-content에서 show 클래스 제거\n4. 누른 버튼의 tab-content에 show 클래스 부착\n\n- 해당하는 기능을 바닐라js로 짜든, jQuery로 짜든, 반복되는 부분이 굉장히 많이 나올 것이다. 이때, **자주쓰는 셀렉터는 변수에 넣어쓰자. 셀렉터 문법은 느리다.** 그리고 여기서 필요한 것이 반복문이다.\n\n\u003cbr\u003e  \n\n### for 반복문\n\n```javascript\nfor (let i = 0; i \u003c 3; i++\u003e) {\n\t반복할 코드 ~\n}\n```\n\n\u003cbr\u003e\n\n- 탭만들기를 예제로, 반복문 이용하여 코드 짜보면\n\n```javascript\nvar 탭버튼 = $(\".tab-button\");\nvar 탭내용 = $(\".tab-content\");\n\nfor (var i = 0; i \u003c 탭버튼.length; i++) {\n\t탭버튼.eq(i).on(\"click\", function () {\n\t탭버튼.removeClass(\"orange\");\n\t탭버튼.eq(i).addClass(\"orange\");\n\t탭내용.removeClass(\"show\");\n\t탭내용.eq(i).addClass(\"show\");\n\t});\n}\n```\n\n이러면, 코드가 잘 돌아가지 않을 것이다. **var가 아닌 let을 사용하면 잘 될 것이다.**\n\n\u003cbr\u003e\n\n### var가 제대로 작동 안한 이유\n\n1. 코드를 위에서부터 한줄한줄 차례로 해석함\n\n2. for문을 만나서 내부 코드를 반복실행 하려고함\n\n3. 이벤트리스너 만남. 이벤트리스너 내부의 코드는 바로 실행되는 코드가 아니고 이벤트가 발생해야 실행되는 코드임\n\n4. **이벤트리스너 내부 코드 실행되지 않고 넘어감**\n\n5. 이 상태로 반복문 3번 실행\n\n6. 한참 뒤 사용자가 버튼 클릭 (현재 `var i = 3`인 상태)\n\n7. `var i = 3`인 상태지만, var 범위는 for문 밖에도 적용이 됨\n\n8. 그래서 `eq(i)`에 3을 대입하려고 함. 하지만, 4번 버튼은 없으니까 에러\n\n\u003cbr\u003e\n\n![](brain/image/apple-js-02-4.png)\n\n\u003ca href='/brain/Lecture/apple-js/apple-js-01' target='_blank'\u003eJS 입문과 웹 개발 01\u003c/a\u003e에서에서 var와 let의 범위를 보면, **let은 block-scoped 범위**이다. 따라서, 반복문 안에서 선언한 var i는 반복문이 끝났음에도 i의 값에 영향을 끼치는 상태이지만, let은 반복문 안에서만 영향을 끼치고 밖에서는 영향을 끼치지 못해서 괜찮은 것이다. c언어에서 배웠던 상식적인 반복문 내부 변수 선언의 범위가 let인 것으로 생각하자.\n\n\u003cbr\u003e\n\n### 탭기능 함수 이용 축약\n\n- 아래의 코드를 함수로 축약해보자.\n\n```javascript\nlet 탭버튼 = $(\".tab-button\");\nlet 탭내용 = $(\".tab-content\");\n  \nfor (let i = 0; i \u003c 탭버튼.length; i++) {\n\t탭버튼.eq(i).on(\"click\", function () {\n\t\t탭버튼.removeClass(\"orange\");\n\t\t탭버튼.eq(i).addClass(\"orange\");\n\t\t탭내용.removeClass(\"show\");\n\t\t탭내용.eq(i).addClass(\"show\");\n\t});\n}\n```\n\n- 축약한 코드\n\n```javascript\nlet 탭버튼 = $(\".tab-button\");\nlet 탭내용 = $(\".tab-content\");\n\nfor (let i = 0; i \u003c 탭버튼.length; i++) {\n\t탭버튼.eq(i).on(\"click\", function () {\n\t\t탭열기();\n\t});\n} \n\nfunction 탭열기() {\n\t탭버튼.removeClass(\"orange\");\n\t탭버튼.eq(i).addClass(\"orange\");\n\t탭내용.removeClass(\"show\");\n\t탭내용.eq(i).addClass(\"show\");\n}\n```\n\n하지만, 이렇게 작성하면 함수 탭열기에 변수 i를 따로 선언한 적이 없기 때문에 코드가 제대로 돌아가지 않을 것이다. **축약할 코드에 변수가 있으면 변수를 파라미터로 바꿔야 잘 작동한다.**\n\n\u003cbr\u003e\n\n- 파라미터 넣은 코드\n\n```javascript\nlet 탭버튼 = $(\".tab-button\");\nlet 탭내용 = $(\".tab-content\");\n\nfor (let i = 0; i \u003c 탭버튼.length; i++) {\n\t탭버튼.eq(i).on(\"click\", function () {\n\t\t탭열기(i);\n\t});\n}\n\nfunction 탭열기(구멍) {\n\t탭버튼.removeClass(\"orange\");\n\t탭버튼.eq(구멍).addClass(\"orange\");\n\t탭내용.removeClass(\"show\");\n\t탭내용.eq(구멍).addClass(\"show\");\n}\n```\n\n\u003chr\u003e\n\n## 이벤트 버블링\n\nlesson.html의 로그인 모달창에서 검은 배경을 눌러도 닫히도록 코드를 짜보자.\n  \n```javascript\n// 검은배경 누르면 모달창 닫기 버튼\ndocument.querySelector(\".black-bg\").addEventListener(\"click\", function () {\ndocument.querySelector(\".black-bg\").classList.remove(\"show-modal\");\n});\n```\n\n이때, 검은 배경이 아닌 그냥 모달창 아무데나 눌러도 모달창이 닫히는 것을 확인할 수 있다. 이는 이벤트 버블링 때문이다. **모든 브라우저는 이벤트 버블링이 일어난다.**\n\n- 이벤트 버블링(event bubbling) : 이벤트가 **상위 html로 퍼지는** 현상  \n\n```html\n\u003cdiv class=\"black-bg\"\u003e\n\t\u003cdiv class=\"white-bg\"\u003e\n\t\t\u003ch4\u003e로그인하세요\u003c/h4\u003e\n\t\t\u003cform action=\"./success.html\"\u003e\n\t\t\t\u003cdiv class=\"my-3\"\u003e\n\t\t\t\t\u003cinput type=\"text\" class=\"form-control\" id=\"email\" /\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\n\t\t\t\u003cdiv class=\"my-3\"\u003e\n\t\t\t\t\u003cinput type=\"password\" class=\"form-control\" id=\"pw\" /\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\n\t\t\t\u003cbutton type=\"submit\" class=\"btn btn-primary\" id=\"send\"\u003e\n\t\t\t\t전송\n\t\t\t\u003c/button\u003e\n\t\n\t\t\t\u003cbutton type=\"button\" class=\"btn btn-danger\" id=\"close\"\u003e\n\t\t\t\t닫기\n\t\t\t\u003c/button\u003e\n\t\t\u003c/form\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\n```\n\n- white-bg 클릭 시 : white-bg, black-bg 2번 클릭한거임\n\n- h4 클릭 시 : h4, white-bg, black-bg 3번 클릭한거임\n\n현재, js 코드를 `black-bg` 클릭 시 모달창이 닫히도록 코드를 짜놨다. 그러면 만약 input 태그를 클릭했다고 하면 div.my-3도 눌리고 div.white-bg도 눌리고 div.black-bg도 눌린 효과가 되어서 결국 모달창이 닫히는 것이다.\n\n\u003cbr\u003e  \n\n맨 처음 누른 요쇼가 진짜 black-bg 이면 모달창이 닫히도록 코드를 짜면 된다.\n\n\u003cbr\u003e\n\n### 유용한 이벤트관련 함수들\n\n- 콜백함수 파라미터에 `e`를 넣어보자. 그러면 사용가능한 함수들이 있다.\n\n```javascript\ndocument.querySelector(\".black-bg\").addEventListener(\"click\", function (e) {\ndocument.querySelector(\".black-bg\").classList.remove(\"show-modal\");\n});\n```\n\n- `e.target;` : 이벤트 발생한 곳 (ex. 유저가 실제로 클릭한 곳)\n\n- `e.currentTarget;` : 이벤트리스너 달린 곳 (`=this`)\n\n- `e.preventDefault();` : 이벤트 기본동작 막아줌, 이벤트 발생 안한것처럼\n\n- `e.stopPropagation();` : 내 상위요소로 이벤트 버블링 막아줌\n\n\u003cbr\u003e\n\n최종본\n\n- javascript\n\n```javascript\ndocument.querySelector(\".black-bg\").addEventListener(\"click\", function (e) {\nif (e.target == document.querySelector(\".black-bg\")) {\ndocument.querySelector(\".black-bg\").classList.remove(\"show-modal\");\n}\n});\n```\n\n- jQuery\n\njQuery는 애초에 셀렉터끼리 비교가 불가능해서 `if ( $(e.target) == $('.black-bg') )`는 안된다. `is()`를 이용하여 `if ( $(e.target).is($(\".black-bg\")) )` 이렇게 작성하자.\n\n```javascript\n$(\".black-bg\").on(\"click\", function (e) {\n\tif ($(e.target).is($(\".black-bg\"))) {\n\t\t$(\".black-bg\").removeClass(\"show-modal\");\n\t}\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 이벤트버블링 응용\n\n- 탭기능 다르게 만들기 (이벤트리스너 1개만 사용)\n\n위에서 만들었던 탭기능은 반복문을 사용해서 이벤트리스너를 3개 사용했다. 이벤트리스너 1개를 쓸 때 마다 램 용량을 차지하기 때문에 성능적인 이점을 가지기 위하여 줄여보겠다.\n\n```html\n\u003cul class=\"list\"\u003e\n\t\u003cli class=\"tab-button\"\u003eProducts\u003c/li\u003e\n\t\u003cli class=\"tab-button orange\"\u003eInformation\u003c/li\u003e\n\t\u003cli class=\"tab-button\"\u003eShipping\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n해당하는 코드의 `.list` 1개에만 이벤트리스너를 부착한다고 하자. 이벤트버블링은 항상 일어나니까 `.tab-button` 무엇을 클릭하든 `.list`를 클릭한 효과가 생긴다.\n\n```javascript\n// 이벤트리스너 1개 버전\nlet 탭버튼 = $(\".tab-button\");\nlet 탭내용 = $(\".tab-content\");\n\nfunction 탭열기(구멍) {\n\t탭버튼.removeClass(\"orange\");\n\t탭버튼.eq(구멍).addClass(\"orange\");\n\t탭내용.removeClass(\"show\");\n\t탭내용.eq(구멍).addClass(\"show\");\n} \n\n$(\".list\").on(\"click\", function (e) {\n\tif ($(e.target).is(탭버튼.eq(0))) {\n\t\t탭열기(0);\n\t}\n\n\tif ($(e.target).is(탭버튼.eq(1))) {\n\t\t탭열기(1);\n\t}\n\n\tif ($(e.target).is(탭버튼.eq(2))) {\n\t탭열기(2);\n\t}\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Datasest\n\n- `data-자료이름=값`을 이용하여 html 태그에 몰래 정보숨기기 가능하다.\n\n- `셀렉터.dataset.자료이름`을 이용하여 숨겼던 자료 출력 가능\n\n```html\n\u003cli class=\"tab-button\" data-id=\"0\"\u003eProducts\u003c/li\u003e\n```\n\n```javascript\nconsole.log(document.querySelector('.tab-button').dataset.id)\n// 0\n```\n\n- dataset 이용하여 탭기능 코드 줄이기\n\n```html\n\u003cul class=\"list\"\u003e\n\t\u003cli class=\"tab-button\" data-id=\"0\"\u003eProducts\u003c/li\u003e\n\t\u003cli class=\"tab-button orange\" data-id=\"1\"\u003eInformation\u003c/li\u003e\n\t\u003cli class=\"tab-button\" data-id=\"2\"\u003eShipping\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n```javascript\n$(\".list\").on(\"click\", function (e) {\n\t탭열기(parseInt(e.target.dataset.id));\n});\n```\n\n- 내가 누른 것에 숨겨져있는 dataset이 id인 녀석의 값을 가져오는 것을 이용","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-js/apple-js-03":{"title":"LEVEL 03","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/javascript-jquery-ui/' target='_blank'\u003eJavaScript 입문과 웹 UI 개발\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## Array, Object\n\n\u003cbr\u003e\n\n### Array 자료형\n\n- `let 변수 = [];` 대괄호 이용, **순서O**\n\n- 변수 하나에 여러 자료 저장하는 쉬운 방법\n\n\n```javascript\nlet car = ['소나타', 50000, 'white'];\ncar[0] = ['아반떼'];\nconsole.log(car[0]);\nconsole.log(car[1]);\n\n// 아반떼\n// 50000\n```\n\n\u003cbr\u003e  \n\n- 순서 있으니까 **정렬 가능** (숫자 -\u003e 영어 -\u003e 한글 순)\n\n```javascript\nlet car = ['소나타', 50000, 'white'];\ncar.sort();\nconsole.log(car);\n// [50000, 'white', '소나타']\n```\n\n\u003cbr\u003e  \n\n- 순서 있으니까 중간에 **자르기 가능** (**슬라이싱**)\n- `slice(n, m)` : n부터 m 전까지\n\n```javascript\nlet car = ['소나타', 50000, 'white'];\nconsole.log(car.slice(1, 3));\n// [50000, 'white'] 1부터 2까지네\n```\n\n- 자료검색도 가능, 맨앞/맨뒤에 자료추가 가능\n\n\u003cbr\u003e  \n\n### Object 자료형  \n\n- `let 변수 = {key1: value1, key2: value2};` 중괄호 이용, **순서 X**\n\n- 이름을 **key**, 자료를 **value**라고 함.\n\n- `key: value` 형태로 저장가능한 것이 장점\n\n- 실제로 object 자료형에 저장되는 자료는 value만 저장되고 key는 이름일 뿐임\n\n```javascript\nlet car2 = {name: '소나타', price: 50000};\nconsole.log(car2);\n// { name: '소나타', price: 50000 }\n\nconsole.log(car2['name']);\nconsole.log(car2.name);\n// 소나타\n// 소나타\n\ncar2.price = 60000;\nconsole.log(car2.price);\n// 60000\n```\n\n\u003cbr\u003e  \n\n### array / object 차이\n\n- Array 자료형 : 순서대로 자료 저장 가능, `순서 개념 O`, `따라서 자료간 정렬 가능`\n\n- Object 자료형 : 자료에 이름 붙혀서 저장 가능 `순서 개념 X`, `따라서 인덱싱 불가`\n\nex) 쇼핑몰 제작 시, 상품 정보들을 10개, 20개 보관해야 한다고 하자. 뭐 쓸래? \u003cbr\u003e\n\nsol) object 쓰는게 좋을 듯. 예를 들어, 가격을 꺼낸다고 하면 몇 번째에서 꺼낼래? 순서보다 prcie 이름을 기억하고 자료를 꺼내는게 편함.\n\n\u003chr\u003e\n\n## 웹서비스 방식\n\n실제 웹서비스는 유저가 내 사이트에 접속했을 때 html 파일을 보내주는 것이 끝이다. 어떤 사람이 접속하면 나의 html 파일 보여주는 원리이다. 이때 **서버에서 유저에게 html 파일을 보내줄 때 방식이 두 가지가 있다.** html 파일을 어디에서 완성해주느냐에 따라 server-side / client-side로 나뉜다.\n\n1. **server-side rendering**\n\n**완성된 html 파일을 서버에서 보내는 방식**. 예를 들어, 쇼핑몰 상세페이지를 만든다고 하면 소나타, 50000원 이런식으로 미리 다 채워서 html 파일 만들고 보내준다. 서버가 html 파일 다 만들어야해서 서버가 귀찮다.\n\n\u003cbr\u003e\n\n2. **client-side rendering**\n\n**텅 빈 html 파일 + 데이터를 보내는 방식**. 이때 html 완성은 javascript하고 하도록 한다. 유저의 브라우저에서 js가 이리저리 일을 할 것 이다. 자동차 자리에 소나타 자료를 넣고 가격 자리에 50000원 넣고 이런식으로 클라이언트 단에서 html 파일을 완성해준다. 서버가 편하다. \u003cbr\u003e\n\nlevel3.html 실습에서 `let car2 = { name: '소나타', price: [50000, 3000, 4000]};` 여기에서 `document.querySelector('.car-price').innerHTML = car2.price[0]` 데이터를 car-price 클래스에 박아넣고 있었다. 이것이 client-side rendering을 하고 있는 거이다. 이때, **html에 데이터를 꽂는 행위를 데이터바인딩**이라고 한다. 데이터바인딩 쉽게 해주는 js 라이브러리가 바로 **jQuery, React, Vue** 등등 이다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Select 01 : 인풋 다루기\n\n기본적으로 ,`\u003cselect\u003e` 사용법은 \u003ca href='/brain/Lecture/apple-js/apple-js-01' target='_blank'\u003eJS 입문과 웹 개발 01\u003c/a\u003e에서 설명한 input 태그 사용법과 동일하다. input 대신 select를 사용하는 이유는, input은 자유로운 반면 **select는 선택지를 제공해줘서 데이터를 쉽게 관리**할 수 있기 때문이다.\n\n\u003cbr\u003e\n\ninput과 사용법이 비슷하기에 역시 **value**를 가져와서 처리할 수 있고 이벤트에 `input`, `change`를 사용가능하다. 아래 코드를 보면 select에 이벤트 발생 시 value를 가져와서 문자열을 비교해주고 해당하는 코드를 조작하고 있다. input 이벤트는 값에 변화가 생길 때마다, change 이벤트는 포커스를 잃을 때마다처럼 `\u003cinput\u003e` 에서 썼던 것과 동일하다.\n\n```html\n\u003cform class=\"container my-5 form-group\"\u003e\n\t\u003cp\u003e상품선택\u003c/p\u003e\n\t\n\t\u003cselect class=\"form-select mt-2\"\u003e\n\t\t\u003coption\u003e모자\u003c/option\u003e\n\t\t\u003coption\u003e셔츠\u003c/option\u003e\n\t\u003c/select\u003e\n\t\n\t\u003cselect class=\"form-select mt-2 form-hide\"\u003e\n\t\t\u003coption\u003e95\u003c/option\u003e\n\t\t\u003coption\u003e100\u003c/option\u003e\n\t\u003c/select\u003e\n\u003c/form\u003e\n```\n\n\u003cbr\u003e\n\n```javascript\ndocument.querySelectorAll('.form-select')[0].addEventListener('input', function () {\n\t// this는 여기서 이벤트리스너에 function() 썼으니까\n\t// e.currentTarget을 의미\n\n\tlet value = this.value;\n\tif (value == '셔츠') {\n\t\tdocument.querySelectorAll('.form-select')[1]\n\t\t\t\t.classList.remove('form-hide');\n\t} else {\n\t\tdocument.querySelectorAll('.form-select')[1]\n\t\t\t\t.classList.add('form-hide');\n\t}\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Select 02 : JS로 html 생성\n\n그러나, 위와 같이 하드코딩 해놓으면 **확장성**이 떨어진다. 만약, 셔츠 사이즈에 변동이 생겨 105나 110이 생겼다. 혹은 품절이 되었다면 그때마다 html 파일 열어서 수정할 것인가? 아니지 않느냐. html을 만들어놨다가 보여주기만 하는게 아니라 자바스크립트로 html을 조작, 생성 하는식으로 만들어야한다.\n\n\u003cbr\u003e\n\n1. 자바스크립트로 html 생성법 첫번째 (정통적, 요새 잘 안씀)\n\n\t- `document.createElement('')`로 html 자료 생성\n\n\t- 생성한 태그에 `.innerHTML`로 내용 첨부\n\n\t- 클래스명 짓고 싶으면 `.classList.add('')`\n\n\t- 마지막으로 해당하는 html document 가져와서 `appendChild()`\n\n\n```javascript\nlet a = document.createElement('p');\na.innerHTML = '안녕';\na.classList.add('p_test');\ndocument.querySelector('#test').appendChild(a);\n```\n\n\u003cbr\u003e\n\n2. 자바스크립트로 html 생성법 두번째 (최근 트렌드, 리액트에서도 이런거 본듯)\n\n\t- html 문서에서 짤 때 처럼 문자열에 만들어서 넣기\n\n\t- `insertAdjacentHTML()`는 문자형 HTML 추가해주는 함수\n\n\t- `beforeend`는 안에서 맨 밑에 추가하라는 의미\n\n```javascript\nlet 템플릿 = '\u003cp\u003e안녕!!\u003c/p\u003e';\ndocument.querySelector('#test').insertAdjacentHTML('beforeend', 템플릿);\n\n//jQuery 버전\n$('#test').append(템플릿);\n```\n\n\u003cbr\u003e\n\n1번과 2번 방법 모두 기존의 html에 **추가**하는 형식이라서 맨 뒤에 추가될거임. `innerHTML`써서 그냥 내용 다 엎어버리고 그걸로 대체해도 괜찮음. 1번이 2번보다 2배 빠르지만, 1번은 코드가 길고 귀찮으니까 2번을 더 많이씀. 사실, 0.0000x초 차이라서 크게 성능 하락 없음\n\n\u003cbr\u003e\n\n```html\n\u003cform class=\"container my-5 form-group\"\u003e\n\t\u003cp\u003e상품선택\u003c/p\u003e\n\t\u003cselect class=\"form-select mt-2\"\u003e\n\t\t\u003coption\u003e모자\u003c/option\u003e\n\t\t\u003coption\u003e셔츠\u003c/option\u003e\n\t\u003c/select\u003e\n\t\u003cselect class=\"form-select mt-2 form-hide\"\u003e\n\t\t\u003coption\u003e95\u003c/option\u003e\n\t\t\u003coption\u003e100\u003c/option\u003e\n\t\u003c/select\u003e\n\u003c/form\u003e\n```\n  \n\u003cbr\u003e\n\n```javascript\ndocument.querySelectorAll('.form-select')[0].addEventListener('input', function () {\n\t// this는 여기서 이벤트리스너에 function() 썼으니까\n\t// e.currentTarget을 의미\n\tlet value = this.value;\n\n\tif (value == '셔츠') {\n\t\tdocument.querySelectorAll('.form-select')[1]\n\t\t\t\t.classList.remove('form-hide');\n\n\t\tlet 셔츠 = `\u003coption\u003e95\u003c/option\u003e\n\t\t\t\t\t\u003coption\u003e100\u003c/option\u003e`;\n\n\t\tdocument.querySelectorAll('.form-select')[1].innerHTML = 셔츠;\n\n\t} else if (value == '바지') {\n\t\tdocument.querySelectorAll('.form-select')[1]\n\t\t\t\t.classList.remove('form-hide');\n\t\t\t\t\n\t\tlet 바지 = `\u003coption\u003e28\u003c/option\u003e\n\t\t\t\t\u003coption\u003e30\u003c/option\u003e`;\n\n\t\tdocument.querySelectorAll('.form-select')[1].innerHTML = 바지;\n\n\t} else {\n\t\tdocument.querySelectorAll('.form-select')[1]\n\t\t\t\t.classList.add('form-hide');\n\t}\n});\n```\n\n이렇게 하면 HTML 파일에 하드코딩 했다기보다 JS 조작을 통해 셔츠 사이즈를 다 날려버리고 바지 선택하면 바지 사이즈가 나오게 됨. 추가로, **JS에서 html 저렇게 만들 때 문자열 기호에 넣고 하면 엔터키 치면 안내려갈거임. 백틱 키 쓰셈**\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Select 03 : forEach, for in 반복문\n\n위에서 자바스크립트로 html 만들어서 html에 박는 것을 배웠다. 하지만 아직까지는 자바스크립트로 html 코드 그대로 짰으니까 여전히 하드코딩이다. 만약, 셔츠/바지 사이즈가 매일매일 달라진다면? **실제로 서버에서 데이터 가져와서 갯수만큼 option 태그 생성하도록 해보자.**\n\n- for 반복문 : `for (let i = 0; i \u003c 어쩌구; i++)`\n\n- forEach 반복문 : **Array 자료형** 뒤에 붙일 수 있는 기본 함수, 반복문 역할\n\n- for in 반복문 : **Object 자료형** 반복문 돌리고 싶을 때 사용\n\n\u003cbr\u003e\n\n\u003e [!note] Memo\n\u003e\n\u003e array 자료형이나 object 자료형의 자료를 전부 꺼내어서 사용하고 싶을 때 forEach, for in 반복문은 매우 유용하다. \u003cbr\u003e\n\u003e array 자료형에서 기본함수 .forEach() 말고 for in 같은 반복문 for of가 있다. 단, index를 얻지 못한다는 단점 있음  \n\n\u003cbr\u003e\n\n### forEach 반복문\n \n- forEach 반복문은 **콜백함수** 써줘야 한다.\n\n- 콜백함수에 파라미터 2개까지 넣을 수 있다.\n\n- 첫번째 파라미터 : **반복문 돌 때 마다 array 안에 있던 하나하나의 데이터**\n\n- 두번째 파라미터 : **반복문 돌 때 마다 0부터 1씩 증가하는 정수**  \n\n```javascript\nlet pants = [28, 30, 32];\npants.forEach(function () {\n\tconsole.log('안녕');\n});\n// 안녕\n// 안녕\n// 안녕\n\npants.forEach(function (a, i) {\n\tconsole.log(a); // 28 30 32\n\tconsole.log(i); // 0 1 2\n});\n\nfor (let pant of pants) {\n\tconsole.log(pant); // 28 30 32\n}\n```\n\n\u003cbr\u003e\n\n```javascript\n// 서버에서 보내준 데이터라고 가정\nlet shirts = [90, 95, 100, 105];\nlet pants = [28, 30, 32, 34];\n\ndocument.querySelectorAll('.form-select')[0].addEventListener('input', function () {\n\t// this는 여기서 이벤트리스너에 function() 썼으니까\n\t// e.currentTarget을 의미\n\tlet value = this.value;\n\tlet optionSelector = document.querySelectorAll('.form-select')[1];\n\n\tif (value == '셔츠') {\n\t\toptionSelector.classList.remove('form-hide');\n\t\toptionSelector.innerHTML = '';\n\n\t\t// for 반복문\n\t\tfor (let i = 0; i \u003c shirts.length; i++) {\n\t\t\toptionSelector.insertAdjacentHTML('beforeend',\n\t\t\t`\u003coption\u003e${shirts[i]}\u003c/option\u003e`);\n\t\t}\n\t\n\t\t// forEach 반복문\n\t\tshirts.forEach(function (data) {\n\t\t\toptionSelector.insertAdjacentHTML('beforeend',\n\t\t\t\t`\u003coption\u003e${data}\u003c/option\u003e`);\n\t\t});\n\t\t\n\t\t// forEach 반복문 arrow function 사용\n\t\tshirts.forEach((data) =\u003e {\n\t\t\toptionSelector.insertAdjacentHTML('beforeend',\n\t\t\t\t`\u003coption\u003e${data}\u003c/option\u003e`);\n\t\t});\n\t}\n});\n```\n\n\u003cbr\u003e\n\n### for in 반복문\n\n- object 자료 갯수만큼 반복문 돌리고 싶으면 사용 가능\n\n- key라고 작명한 부분은 object 자료형의 key 부분\n\n- key, value 모두 출력 가능\n\n```javascript\nlet obj = {name: 'shin', age: 27};\n\nfor (let key in obj) {\n\tconsole.log('안녕');\n}\n// 안녕\n// 안녕\n\nfor (let key in obj) {\n\tconsole.log(key);\n\tconsole.log(obj[key]);\n}\n// name\n// shin\n// age\n// 27\n```\n\n\u003chr\u003e\n\n## arrow function 맛보기\n\n- 함수 만드는 또다른 문법이 arrow function 이다.\n\n- 기본적으로 함수와 this 빼고 거의 동일한 역할을 한다.\n\n- **특히, 콜백함수 만들 때 자주 사용**\n\n- `function() {}`는 `() =\u003e {}`와 같다.\n\n- 심지어 파라미터가 1개라면 소괄호 생략하고 사용하기도 한다.\n\n`function(a) {}`는 `a =\u003e {}`와 같다.\n\n```javascript\nlet pants = [28, 30, 32];\n\npants.forEach(function (a) {\n\tconsole.log(a);\n});\n\npants.forEach((a) =\u003e {\n\tconsole.log(a);\n});\n```\n\n- 함수 표현식의 형태로 쓰는 사람도 있다.\n\n```javascript\nlet 함수1 = function () {\n\tconsole.log('안녕');\n};\n\nlet 함수2 = () =\u003e {\n\tconsole.log('안녕');\n};\n```\n\n\u003cbr\u003e\n\n함수 안에서 **this**를 사용해야할 경우 `함수`와 `화살표 함수`는 **기능적인 차이**가 존재한다.\n\n- `function()` : 함수 안에서 this를 알맞게 **재정의** 해줌\n\n- `arrow function` : 함수 안에서 this를 재정의하지 않고 **바깥에 있던 this를 그대로 사용**\n\n\u003cbr\u003e  \n\n위에서 사용했던 this를 살펴보겠다.\n\n```javascript\ndocument.querySelectorAll('.form-select')[0].addEventListener('input', function () {\n\t// this는 여기서 이벤트리스너에 function() 썼으니까\n\t// e.currentTarget을 의미\n\tlet value = this.value;\n});\n```\n\n현재 **function()** 을 썼기 때문에 함수 안에서 this가 재정의 되어서 `document.querySelectorAll('.form-select')[0].addEventListener`가 동작했을 때를 뜻하니까 `e.currentTarget`이 된다. 하지만, 만약 여기서 **화살표함수를 사용해버리면 함수 바깥의 this를 가져와서 사용하기 때문에 의도와 다르게 동작할 수 있다.** 따라서 주의가 필요하다.\n\n\u003cbr\u003e\n\n\u003e [!note] Memo\n\u003e\n\u003e 이벤트리스너 콜백함수 안에서 this를 사용해야하면 **arrow function 사용 시에 의도와 다르게 동작할 수 있으니까** 그런데서 사용하지말고 조심해서 사용하자. \u003cbr\u003e\n\u003e 참고로, 브라우저 환경의 전역객체는 **window** node 환경의 전역객체는 **global**이다. 예시 코드에서 밖에 특별한 this가 없다면, 화살표 함수를 썼을 때 this는 window를 뜻하게 된다.\n  \n\u003chr\u003e\n\n## Ajax\n\n먼저 \u003ca href='https://velog.io/@leehaeun0/Ajax-%EB%8A%94-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%9D%B8%EA%B0%80%EC%9A%94' target='_blank'\u003e링크\u003c/a\u003e 읽어보고 오기\n\n**서버**는 데이터 보내달라고 요청하면 데이터를 보내주는 것이다. 예를 들어, 네이버 웹툰 서버라고 하면 네이버 웹툰 달라고 하면 웹툰 보내주는 것이다. 서버는 데이터를 보내주기도 하고 유저 데이터를 받아서 DB에 저장하기도 하는 역할을 한다.\n\n1. 어떤 데이터인지 : 데이터의 url\n\n\t- 예를 들어, comic.naver.com 이라는 url\n\n\t- 데이터 url은 서버 개발자가 작성한 api 문서에 따라 요청한다.\n\n2. 어떤 방법으로 데이터를 요청할건지 : get인지, post인지 정확히\n\n\t- **get은 데이터 읽을 때, post는 데이터를 보낼 때**\n\n\u003cbr\u003e\n\nQ. 특정 url로 get 요청하는 법?  \n\n- 인터넷의 주소창에 url을 입력하는 것이 일종의 get 요청하는 것이다. 즉, **주소창이 get 요청하는 곳**이라고 이해하면 된다.\n\nQ. 특정 url로 post 요청하는 법?\n\n- `\u003cform action=\"/url\" method=\"post\"\u003e\u003c/form\u003e`태그를 이용한다. 전송버튼을 누르면 서버에 post 요청 하는 것이다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n### ajax의 등장\n\n단순히 get요청과 post요청하면 **브라우저가 새로고침이 된다는 것이 단점**이다. 새로고침이 매번 발생하면 불편하기 때문에 **새로고침 없이 get, post 요청할 수 있도록 ajax**가 등장하는 것이다. 예를 들어, 쇼핑몰의 경우에 상품더보기 버튼을 누르면 새로고침 없이 서버와 통신하여 새로운 상품 목록을 불러오는 것이다. \u003cbr\u003e\n\n참고로, ajax를 편하게 쓰고 싶을 때 사용하는 것이 axios 라이브러리 이다. 리액트나 뷰에서는 주로 axios 라이브러리를 사용할 것이다.\n\n\u003cbr\u003e\n\n- ajax로 get요청 하는 방법\n\n```javascript\n$.get('url~~');\n```\n\n예시로, `https://codingapple1.github.io/hello.txt`로 get요청 하면 인삿말 보내준다. 그리고, `.done()` 함수를 이용하면 get요청이 성공했을 때 콜백함수 실행시킬 수 있다.\n\n```javascript\n$.get('https://codingapple1.github.io/hello.txt').done(function (data) {\n\tconsole.log(data);\n});\n\n// '안녕하세요 반갑습니다요.'\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n- ajax로 post요청 하는 방법\n\n```javascript\n$.post('url~~', data);\n\n$.post('https://codingapple1.github.io/hello.txt', {name: 'kim'}).done(\n\tfunction (data) {\n\t\tconsole.log(data);\n\t}\n);\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n- ajax 실패시 특정 코드 실행 `.fail()`\n\n- 보통 **404 error**는 서버에 url이 없다는 오류\n\n```javascript\n$.get('https://codingapple1.github.io/hello.txt').done(function (data) {\n\tconsole.log(data);\n}).fail(function () {\n\tconsole.log('실패함');\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 브라우저 기본 함수 fetch\n\najax말고 브라우저 기본 함수를 써서 쌩 자바스크립트로 구현할 수도 있다.\n\n```javascript\n// ajax 사용\n$.get('https://codingapple1.github.io/price.json')\n.done(function (data) {\n\tconsole.log(data.price);\n}).fail(function () {\n\tconsole.log('실패함');\n});\n\n// fetch 사용\nfetch('https://codingapple1.github.io/price.json')\n.then((res) =\u003e res.json())\n.then((data) =\u003e {\n\tconsole.log(data.price);\n}).catch((error) =\u003e {\n\tconsole.log(error);\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### JSON 자료형\n\n서버와 클라이언트는 **문자자료만 주고 받을 수 있다.** object, array를 보내고 싶으면 \"\"를 쳐서 문자처럼 만들고 보내야한다. 이렇게 **따옴표 친 object, array 자료가 바로 JSON**이라고 한다.\n\n```javascript\n// object\n{price : 5000}\n\n// JSON\n\"{\"price\" : 5000}\"\n```\n\nJSON으로 변환하면 문자형 자료라서 원하는 자료만 뽑아쓰기 힘들다. 그래서 JSON자료를 다시 object나 array로 변환해서 사용하면 뽑아쓰기 편하다. fetch를 사용할 때 `((res) =\u003e res.json())`이 응답받은 response를 json으로 변환해주는 과정이다. ajax는 자동으로 변환해주기 때문에 신경쓰지 않았다.\n\n\u003chr\u003e\n\n## Array 자주 쓰는 함수\n\n\u003cbr\u003e\n\n### sort() 함수\n\n- `sort()` 함수는 **문자정렬**이다.\n\n- `sort()` 함수는 **원본을 변형**시킨다.\n\n- 문자가 아닌 숫자를 그냥 정렬하려고 하면 아래와 같이 원치 않는 결과가 나온다.\n\n```javascript\nlet 어레이 = [7, 3, 5, 2, 40];\n어레이.sort();\nconsole.log(어레이);\n\n// [2, 3, 40, 5, 7]\n```\n\n\u003cbr\u003e\n\narray **숫자 정렬**은 콜백함수를 사용하고 return 값을 따로 지정해줘야 한다. 아래와 같이 코드를 작성하면 **오름차순 숫자 정렬**이다.\n\n```javascript\nlet 어레이 = [7, 3, 5, 2, 40];\n어레이.sort(function (a, b) {\n\treturn a - b;\n});\n\nconsole.log(어레이);\n// [2, 3, 5, 7, 40]\n```\n\n\u003cbr\u003e\n\narray 안에 object가 있는 형태라면? ex) `[ {}, {}, {} ]` 그 경우 return 값이 `{} - {}`이니까 양수나 음수가 나오는 구조가 아니다. object의 value를 가져와서 비교해주고 return 해주면 되겠구나.\n\n\n```javascript\nlet 상품배열 = [\n\t{id: 0, price: 70000, title: 'Blossom Dress'},\n\t{id: 1, price: 50000, title: 'Springfield Shirt'},\n\t{id: 2, price: 60000, title: 'Black Monastery'},\n];\n\n상품배열.sort(function (a, b) {\n\treturn a.price - b.price;\n});\n\nconsole.log(상품배열);\n\n// [\n//    { id: 1, price: 50000, title: 'Springfield Shirt' },\n//    { id: 2, price: 60000, title: 'Black Monastery' },\n//    { id: 0, price: 70000, title: 'Blossom Dress' }\n// ]\n\n```\n\n\u003cbr\u003e\n\n### array 숫자 정렬 원리\n  \n1. 콜백함수의 a와 b는 array 안에 있던 자료들이다. ex) `7, 3`\n\n2. return 결과가 양수면 a를 오른쪽으로 보낸다.\n\n3. return 결과가 음수면 b를 오른쪽으로 보낸다. ex) `7 - 3 = 4` 양수니까, a가 b보다 크다는 의미이다. 따라서, a를 오른쪽으로 보낸다.\n\n\u003cbr\u003e\n\n### 문자 가나다순 정렬\n\n- 그냥 `.sort()` 사용\n\n```javascript\nlet 어레이2 = ['a', 'c', 'b'];\n어레이2.sort();\nconsole.log(어레이2);\n// ['a', 'b', 'c']\n```\n\n\u003cbr\u003e\n\n```javascript\nlet 어레이3 = ['a', 'd', 'c', 'b'];\n어레이3.sort(function (a, b) {\n\tif (a \u003e b) {\n\t\treturn 1;\n\t} else {\n\t\treturn -1;\n\t}\n});\nconsole.log(어레이3);\n```\n\n### 정렬 결론\n\n`sort()` 함수는 배열의 요소를 compareFunction에게 2개씩 반복해서 보낸 뒤, compareFunction이 반환하는 값을 기준으로 정렬한다. 보내는 요소들의 이름을 a, b라고 했을 때 기준은 아래와 같다.\n\n- `반환 값 \u003e 0` : b가 a보다 앞에 있어야 한다. **a가 우측으로 감**\n\n- `반환 값 \u003c 0` : a가 b보다 앞에 있어야 한다. **b가 우측으로 감**\n\n- `반환 값 = 0` : a와 b의 순서를 바꾸지 않는다\n\n자세한 설명은 \u003ca href='https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort' target='_blank'\u003e링크\u003c/a\u003e에서 참조하도록 하자.\n\n\u003cbr\u003e\u003cbr\u003e\n\n### filter() 함수\n\n- `filter()` 함수는 array 자료에서 원하는 것만 고르고 싶을 때 사용하는 함수\n\n- `filter()` 함수는 **원본을 변형시키지 않기 때문**에 결과를 변수에 저장해서 사용해야 한다.\n\n\n```javascript\nlet 어레이 = [7, 3, 5, 2, 40];\n\n// a는 array에 있던 자료들\nlet 새어레이 = 어레이.filter(function (a) {\n\treturn a \u003c 4;\n});\n\nconsole.log(어레이);\n// [7, 3, 5, 2, 40]\n\nconsole.log(새어레이);\n// [3, 2]\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### map() 함수\n\n- `map()` 함수는 array 자료 전부 변형할 때 사용하는 함수\n\n- `map()` 함수는 **원본을 변형시키지 않기 때문**에 결과를 변수에 저장해서 사용해야 한다.\n\n```javascript\nlet 어레이 = [7, 3, 5, 2, 40];\n\n// a는 array에 있던 자료들\nlet 새어레이 = 어레이.map(function (a) {\n\treturn a * 4;\n});\n\nconsole.log(새어레이);\n// [28, 12, 20, 8, 160]\n```\n\n\u003chr\u003e\n\n## DOM\n\n- DOM (Document Object Model)\n\n자바스크립트가 html을 어떻게 조작할까? 이는 DOM이 있기에 가능한데, DOM은 HTML을 파싱한 결과물이다. HTML은 단순 텍스트로 이루어진 문자열이라서 브라우저가 이해하도록 객체 자료구조로 변환시켜야 한다. document에 객체를 저장한다는 느낌이다.\n\n```html\n\u003cdiv style=\"color : red;\"\u003e안녕하세요\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n```javascript\nlet document = {\n\tdiv1 : {\n\t\tstyle : {color : 'red'};\n\t\tinnerHTML : '안녕하세요';\n\t}\n}\n```\n\n이런식으로 HTML 문서를 파싱해서 object 자료형으로 바꿔주는 것이다. (_실제 DOM의 형태가 저렇지는 않고 간단하게 설명한 것이다._) 실제로는 파싱하여 가장 최소단위인 토큰부터 토큰을 다시 노드로 바꾸는 등 복잡하다. 모던 자바스크립트 딥다이브 667페이지를 참조하자.\n\n\u003chr\u003e\n\n- script 태그 위치의 중요성\n\nHTML을 파싱하여 DOM을 생성하는 것은 위에서부터 아래로 차례로 읽어나가며 진행된다.\n\n```html\n\u003cscript\u003e\n\tdocument.getElementById('test').innerHTML = '안녕';\n\u003c/script\u003e\n\n\u003cp id=\"test\"\u003e임시글자\u003c/p\u003e\n```\n\n이 코드는 당연히 에러가 날 것이다. 위에서부터 읽어내려오며 파싱을 하고 있는데 아직 DOM에 추가하지도 않은 p 태그를 불러오려고 하니까.\n\n1. head의 script 태그\n\n2. body 마지막의 script 태그\n\n3. 외부 자바스크립트 파일\n\n\u003cbr\u003e\n\n뭔가 이상하다면 이 경우에 HTML이 파싱이 됐는지 안됐는지 잘 생각해보자. html 파일 내부의 script 태그에 자바스크립트 코드를 작성할 때는 웬만하면 body 끝에다가 작성하자. **HTML을 파싱하다가 script 태그를 만나면 HTML 파싱을 멈추고 자바스크립트 파싱을 하기 때문에, head에 작성하면 문제가 생긴다.**\n\n\u003cbr\u003e\n\n외부 자바스크립트 파일을 불러올 때 **src** 속성을 주는 이유가 바로 이때문이다. 위에서부터 차례대로 코드를 실행한다는 것은 **동기적**으로 실행하고 있다는 의미이다. HTML5 이후 추가된 script src 속성에는 `async`와 `defer`가 있다. 두 속성 다 비동기적으로 js 파일을 로드해온다. HTML을 파싱해오면서 동시에 js파일을 로드한다는 의미이다.\n\n- `\u003cscript async src=\"js파일\"\u003e\u003c/script\u003e`\n\n- HTML 파싱, js파일 로드 동시 -\u003e js파일 로드 다되면 HTML 파싱 멈추고 js 파싱, 실행\n\n- `\u003cscript defer src=\"js파일\"\u003e\u003c/script\u003e`\n\n- HTML 파싱, js파일 로드 동시 -\u003e HTML 파싱 끝나면 그때 js 파싱, 실행\n\n\u003chr\u003e\n\n코딩애플 강의에서는 자바스크립트 실행을 약간 나중으로 미루는 방법을 addEventListener 방식으로 소개했다. **이 코드는 HTML 전부 다 읽고 실행해주세요**라는 의미이다. 자바스크립트 파일을 어디에 작성하는지 위치를 내가 정할 수 없을 경우에 유용한 방법이기는 하지만, 개인적인 생각으로 잘 안쓸듯하다.\n\n```javascript\n// jQuery\n$(document).ready(function() {실행할 코드})\n\n// javascript\ndocument.addEventListener('DOMContentLoaded', function() {실행할 코드})\n```\n\n\u003cbr\u003e\n\n```html\n\u003cscript\u003e\n\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\tdocument.getElementById('test').innerHTML = '안녕';\n\t});\n\u003c/script\u003e\n\n\u003cp id=\"test\"\u003e임시글자\u003c/p\u003e\n```\n\n\u003cbr\u003e\n\n**load 이벤트리스너**를 사용하면, DOM 생성뿐만 아니라 이미지, css, js파일 로드 모두 체크 가능하다.\n\n```javascript\n셀렉터로찾은이미지.addEventListener('load', function () {\n\t// 이미지 로드 완료 시 실행할 코드\n});\n```\n\n하지만, 만약 외부 자바스크립트 파일에 load를 작성해놓으면 js파일보다 이미지가 더 먼저 로드되는 경우에는 이벤트 발생 체크를 못할 것이다.\n\n\n```javascript\n// jQuery\n$(window).on('load', function () {\n\t// document 안의 이미지, js 파일 포함 전부 로드가\n\t// 되었을 경우 실행할 코드\n});\n\nwindow.addEventListener('load', function () {\n\t// document 안의 이미지, js 파일 포함 전부 로드가\n\t// 되었을 경우 실행할 코드\n});\n```\n\n이렇게 window에 붙혀도 된다.\n\n\u003chr\u003e\n\n## localStorage\n\n\u003cbr\u003e\n\n쇼핑몰 장바구니 기능을 만든다고 하자. 장바구니에 물품을 담는다고 쳤을 때, 저장해야할 공간이 필요할 것이다. (현재 서버는 없다고 가정) 이때, 변수에 저장하는 것은 적합하지 않다. **변수는 브라우저 새로고침 시 초기화 되기 때문**이다. 그래서 생각한 방법이 **브라우저 안에 localStorage에 몰래 데이터를 저장하는 방법**이다.\n\n\u003cbr\u003e\n\n크롬의 개발자도구에서 Application에 가보면 Storage가 있다.\n\n- localStorage, sessionStorage\n\n- `key: value` 형태로 저장 가능\n\n- `localStorage` : 사이트 재접속해도 유지 (유저가 브라우저 청소하지 않는 이상)\n\n- `sessionStorage` : 사이트 나가면 자동 삭제\n\n- IndexedDB\n\n- 데이터가 크고 복잡할 때 구조화 시켜서 저장 시\n\n- Cookies\n\n- 유저의 인증 정보, 보통 로그인정보 저장\n\n- Cache Storage\n\n- 웹 사이트 접속했을 때 html css js 파일을 새로 다운받는 것이 아니라 하드에 몰래 저장하는 것\n\n\u003cbr\u003e\n\nlocalStorage, sessionStorage의 **용량은 약 5MB**, 그리고 array나 object 이런거는 저장 못하고 **문자/숫자만 저장 가능**하다. 문자만 5MB는 엄청난 양이다. 걱정 ㄴㄴ\n\n\u003cbr\u003e\n\n### localStorage 사용법\n\n- sessionStorage는 local만 session으로 바꿔주면 됨\n\n```javascript\n// 로컬스토리지에 데이터 저장\nlocalStorage.setItem('key', 'value');\n\n// 로컬스토리지 데이터 출력\nlocalStorage.getItem('key');\n\n// 로컬스토리지 데이터 삭제\nlocalStorage.removeItem('key');\n```\n\n\u003cbr\u003e\n\nlocalStorage에 array, object를 그냥 저장하면 깨져서 저장된다. 문자만 저장되니까.\n\n```javascript\nlocalStorage.setItem('num', [1, 2, 3]);\n// num 1, 2, 3\n// 대괄호가 사라지고 그냥 1, 2, 3만 저장된거\n```\n\n그래서 array, object 저장하고 싶으면 **JSON으로 변환해서 저장해야한다.** JSON은 문자 취급을 받기 때문이다.\n\n- `JSON.stringify()` : array/object -\u003e JSON\n\n- `JSON.parse()` : JSON -\u003e array/object\n\n```javascript\nlet arrTest = [1, 2, 3];\nlet newArrTest = JSON.stringify(arrTest);\n\nlocalStorage.setItem('num', newwArrTest);\nlet getArrTest = localStorage.getItem('num');\n\nconsole.log(JSON.parse(getArrTest));\n```\n\n\u003cbr\u003e\n\nlocalStorage에 저장된 데이터를 수정하는 함수는 없다. 따라서 아래의 과정을 수행한다.\n\n1. 자료를 꺼낸다\n\n2. 꺼낸 자료를 수정한다.\n\n3. 다시 localStorage에 수정한 자료를 넣는다.\n\n\u003cbr\u003e\n\n추가로, localStorage 내부에 값이 있나 없나 확인할 때 사용했는데 find와 findIndex 함수는 **배열**의 요소에 관한 함수이다.\n\n- `.find( (a) =\u003e {return } )`\n\n- `.findIndex( (a) =\u003e {return } )`\n\n둘다 콜백함수 써줘야하고, 나는 findIndex 함수 이용했음. findIndex 함수는 배열 내부 요소의 값에 없다면 -1을 return, 있다면 해당하는 인덱스 번호를 return\n\n```javascript\nlet outItem = JSON.parse(localStorage.getItem('cart'));\nlet outItemIndex = outItem.findIndex((a) =\u003e {\n\treturn a === storageItem;\n});\n\nif (outItemIndex === -1) {\n\toutItem.push(storageItem);\n\tlocalStorage.setItem('cart', JSON.stringify(outItem));\n\talert('장바구니에 등록되었습니다.');\n} else {\n\talert('장바구니에 이미 물품이 있습니다.');\n}\n```\n\n\u003chr\u003e\n\n## scroll 애니메이션 심화\n\nLEVEL2 scroll에서는 one-way 방식을 생각했다면, 이제는 간단한 1차함수를 도입한다.\n\n```javascript\nwindow.addEventListener('scroll', function () {\n\tlet 높이 = this.window.scrollY;\n\tlet y = (-1 / 500) * 높이 + 115 / 50;\n\tlet z = (-1 / 5000) * 높이 + 565 / 500;\n\n\tthis.document.querySelectorAll('.card-box')[0].style.opacity = y;\n\tthis.document.querySelectorAll('.card-box')[0].style.transform = `scale(${z})`;\n\tconsole.log(z);\n});\n```\n\n예를 들어, 스크롤 650px ~ 1150px 구간에 opacity를 1~0으로 조정하기를 원한다고 하면, 간단한 함수 개념을 도입한다.  \n\n```javascript\ny = 650 * a + b\ny = 1150 * a + b\n\n식 2개, 미지수 2개니까 값 구할 수 있음\n```\n\n\u003chr\u003e\n\n## 캐러셀 심화 (스와이프)  \n\n캐러셀을 드래그 했을 때 다음 사진으로 넘어가냐 마냐 하는 것은 마우스에 관련된 이벤트를 추가로 학습할 필요가 있다.\n\n- `mousedown` : 어떤 요소에 마우스버튼 눌렀을 때\n\n- `mouseup` : 어떤 요소에 마우스버튼 뗐을 때\n\n- `mousemove` : 어떤 요소 위에서 마우스 이동할 때\n\n\u003cbr\u003e\n\n추가적인 이벤트 관련 함수\n\n- `e.clientX` : 현재 마우스 X 좌표\n\n- `e.clientY` : 현재 마우스 Y 좌표\n\n\u003cbr\u003e\n\n모바일 관련  \n\n- `touchstart` : 터치 했을 때\n\n- `touchmove` : 터치하고 드래그 할 때\n\n- `touchend` : 터치 뗐을 때\n\n\u003cbr\u003e\n\n모바일 관련 이벤트 함수\n\n- `e.touches[0].clientX` : 손가락 여러 개 눌릴 수 있으니까 지정해줘야함\n\n- `e.changedTouches[0].clientX` : touchend에는 `touches[0]`이 아닌 `changedTouches[0]`을 해줘야 함\n\n실습 예제는 \u003ca href='/brain/Lecture/apple-js/apple-js-02' target='_blank'\u003eJS 입문과 웹 개발 02\u003c/a\u003e를 참고하도록 하자.\n\n\u003cbr\u003e\n\n드래그가 제대로 안된다면? HTML 기본 옵션 수정\n\n- `contextmenu=\"return false\"` : 우클릭 방지\n\n- `ondragstart=\"return false\"` : 드래그 방지\n\n- `onselectstart=\"return false\"` : 선택 방지\n\n```html\n\u003cbody ondragstart=\"return false\"\u003e\u003c/body\u003e\n```\n\n\u003chr\u003e\n\n## switch 문법  \n\n- switch는 if문과 비슷한 역할을 한다.\n\n- 소괄호 안에 특정 값을 넣어서 **조건 분기**를 일으키는 것이다.\n\n- 용도가 끝나면 `break`로 switch문을 빠져나간다.\n\n- 즉, break가 없다면 밑에 코드도 다 실행할 것\n\n- if는 다양한 조건식 가능하지만, switch는 변수 1개만 테스트 가능\n\n- `default`로 어떤 case에도 해당 안될 때를 지정할 수 있음\n\n```javascript\nlet 변수 = 2 + 2;\n\nswitch (변수) {\n\tcase 3:\n\t\talert('변수가 3이네요');\n\t\tbreak;\n\n\tcase 4:\n\t\talert('변수가 4이네요');\n\t\tbreak;\n\n\tdefault:\n\t\talert('아무것도 해당안됨');\n}\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/apple-js/js-library":{"title":"js-library","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/javascript-jquery-ui/' target='_blank'\u003eJavaScript 입문과 웹 UI 개발\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n\u003e[!note] 자바스크립트 라이브러리 \n\u003e 1. Swiper\n\u003e 2. Chart.js\n\u003e 3. Animate On Scroll\n\u003e 4. EmailJS\n\u003e 5. Lodash\n\u003e 6. React / Vue\n\u003e 7. Fullpage.js\n\n\u003cbr\u003e\n\n## Swiper\n\n\u003cbr\u003e\n\n![](brain/image/js-library-1.png)\n  \n부트스트랩의 캐러셀을 활용해도 괜찮지만, swiper를 이용하여 다양한 캐러셀 활용 가능. 이미지 lazy loading, 터치/드래그 가능 사실 쓸지는 의문\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Chart.js (추천)\n\n\u003cbr\u003e\n\n![](brain/image/js-library-2.png)\n\n웹페이지에 차트 도입할 때 싸용, 관리자 페이지, 어드민 페이지에서 통계 만들 때 유용할 듯. 이건 진짜 많이 사용할 예정\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Animate On Scroll (약간 추천)\n\n\u003cbr\u003e\n\n![](brain/image/js-library-3.png)\n\n스크롤 내리면 요소가 등장하는 애니메이션 사용할 때 좋음. \u003ca href='https://github.com/michalsnik/aos' target='_blank'\u003e깃허브 페이지\u003c/a\u003e에서 사용법 나와있음. 아래 코드 넣으면 설치 끝\n\n```html\n\u003chead\u003e\n\t\u003clink rel=\"stylesheet\" href=\"https://unpkg.com/aos@next/dist/aos.css\" /\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n\t\u003cscript src=\"https://unpkg.com/aos@next/dist/aos.js\"\u003e\u003c/script\u003e\n\t\u003cscript\u003eAOS.init();\u003c/script\u003e\n\u003c/body\u003e\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n## EmailJS\n  \n\u003cbr\u003e\n\n서버로 이메일 전송 하지만, 서버를 빌려서 자바스크립트만으로 이메일 전송 가능하게 해주는 라이브러리. \u003ca href='https://www.emailjs.com/docs/introduction/how-does-emailjs-work/' target='_blank'\u003e링크\u003c/a\u003e에서 시키는대로 하면 되지만, 나는 서버 만들거니까 별로 사용 안할듯\n\n\u003cbr\u003e\u003cbr\u003e  \n\n## Lodash\n\narray, object, 문자, 숫자 자료 등을 편하게 다루도록 기본 함수 제공해줌. 근데 안쓸듯\n\n\u003cbr\u003e\u003cbr\u003e\n\n## React, Vue (강력 추천, 따로 공부)\n\n컴포넌트 단위처럼 페이지가 많아서 라우팅 하고 이런거 UI 재활용 자주 해야하고 페이지 새로고침 없이 필요한 부분만 렌더링 하도록 동작하는 방식인 SPA(Single Page Application)을 만들 때 유용한 자바스크립트 라이브러리\u003cbr\u003e\n\n자바스크립트 기본부터 제대로 배우고 이용하는 것을 추천\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Fullpage.js\n\n웹페이지를 PPT처럼 만들어줌. 이것도 안쓸 예정","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/":{"title":"잔재미코딩 - Python","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny":{"title":"파이썬입문과 크롤링기초 부트캠프","content":"\n\u003cbr\u003e\n\n\u003e [!note] 파이썬입문과 크롤링기초 부트캠프 필기노트\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2022.03.25 ~ 2022.04.05\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e 머신러닝 전공 수업을 위하여 파이썬 간단하게 익히기\n\n## 목차\n\n- [잔재미코딩 - 01. 파이썬 입문](brain/Lecture/funny-python/funny01)\n- [잔재미코딩 - 02. 파이썬 변수, 출력](brain/Lecture/funny-python/funny02)\n- [잔재미코딩 - 03. 파이썬 String](brain/Lecture/funny-python/funny03)\n- [잔재미코딩 - 04. 파이썬 List](brain/Lecture/funny-python/funny04)\n- [잔재미코딩 - 05. 파이썬 Tuple](brain/Lecture/funny-python/funny05)\n- [잔재미코딩 - 06. 파이썬 Dictionary](brain/Lecture/funny-python/funny06)\n- [잔재미코딩 - 07. 파이썬 Set](brain/Lecture/funny-python/funny07)\n- [잔재미코딩 - 08. 파이썬 Bool](brain/Lecture/funny-python/funny08)\n- [잔재미코딩 - 09. 파이썬 Variable](brain/Lecture/funny-python/funny09)\n- [잔재미코딩 - 10. 파이썬 Condition](brain/Lecture/funny-python/funny10)\n- [잔재미코딩 - 11. 파이썬 For](brain/Lecture/funny-python/funny11)\n","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny01":{"title":"01 - 파이썬 입문","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. Python 학습의 이유\n\n\u003cbr\u003e  \n\nJava와 Javascript를 학습하며 프론트엔드와 백엔드 모두를 경험해보고자 언어를 학습 중인 상태였고, 코딩 테스트와 프로젝트를 대비하려고 했으나, 크롤링에 친숙하고 라이브러리의 강점을 가지며 쉬운 언어인 Python도 경험해보고 싶다는 생각을 항상 가지고만 있었다. 추가로, Web project를 진행하기 위해 백엔드 framework 학습의 필요성을 느끼고 있었다. \u003cbr\u003e\n\n현재의 나는 개인 토이 프로젝트나 소규모 프로젝트를 희망하는 상태이다. 대표적인 후보군으로는 spring, django, flask 등이 있었는데, Java 기반 framework인 spring은 대규모 프로젝트를 하지 않는 나의 입장에서는 맞지 않다고 느꼈다. 하지만, Python 기반 framework는 django와 flask라는 선택지가 있었다. django는 extension이 기본적으로 포함되어 서비스 사용 용도에 적합하고, flask는 extension이 기본적으로 포함되어 있지 않아서, 학습에 용이하다는 검색 결과를 얻었다. \u003cbr\u003e\n\n**따라서, flask를 학습하기로 마음 먹었고 그것을 위하여 python에 대한 학습이 필요하다고 느꼈다.**\n\n나아가, python을 이용하여 database 학습을 하려는 계획도 세웠다. 아직 Java를 제대로 사용하지 못하는 것도 있어서, 이참에 주력 언어를 python으로 정하겠다는 결심이 섰기 때문에 기초를 탄탄히 하고자 언어의 기본 문법을 학습하고자 한다.\n\n\u003chr\u003e\n\n## 02. Python 설치\n\n\u003cbr\u003e  \n\nPython은 고급 언어이기 때문에, 컴퓨터가 이해하도록 하기 위한 컴파일러가 필요하다. 따라서, 기본 Python을 https://www.python.org/downloads/ 에서 설치해주도록 한다. 설치하는 과정에서 PATH에 체크하여 환경 변수를 미리 추가한다. \n\nPython을 사용하기 위한 여러 가지 옵션이 있다.\n\n- anaconda의 주요 툴인 jupyter notebook 활용하기\n\n- pycharm, visual studio code 같은 텍스트 에디터 활용하기\n\n\u003cbr\u003e\n\n### mac 초기 설정\n\n1. \u003ca href='https://jjam89.tistory.com/228' target='_blank'\u003emac의 기본 python을 건드리지 않고 pyen를 사용하는 이유와 설치 방법\u003c/a\u003e\n2. \u003ca href='https://seorenn.github.io/note/pyenv-virtualenv.html#d3f541ab' target='_blank'\u003evirtualpyenv 사용 방법\u003c/a\u003e\n3. \u003ca href='https://carmack-kim.tistory.com/90' target='_blank'\u003evirtualpyenv activate 오류 발생 시\u003c/a\u003e\n4. \u003ca href='https://codenoyes.tistory.com/63' target='_blank'\u003emac에 jupyter notebook 설치\u003c/a\u003e\n\n\u003chr\u003e\n\n## 03. Python IDE\n\n\u003cbr\u003e\n\n### **anaconda - jupyter**\n\nanaconda는 파이썬 컴파일러, 주요 라이브러리, 주요 툴을 모아놓은 패키지이다. anaconda의 주요 툴 중 하나인 jupyter notebook을 활용하여 python을 사용할 수 있다.\n\n![](brain/image/funny01-1.png)\n\njupyter notebook의 장점은 코드를 작성함과 동시에 컴파일하여 가시적으로 결과를 확인 가능하다는 점이다. 그리고 마크다운을 이용하여 필요한 메모를 즉각적으로 작성할 수 있어서 학습에 용이하다고 생각했다. 따라서, 학습하는 과정에서 jupyter notebook을 사용하기로 했다.\n\n설치 방법은 https://www.anaconda.com/products/individual 페이지에서 다운로드하여 설치한다. 이때, python 최신 버전을 다운로드 한다. 왜냐하면, 구버전인 python 2와 신버전인 python 3는 약간의 문법적 차이가 있을 수 있다. python 2 에서는 `print len(something)`이 올바른 문법이라면 python 3 에서는 `print (len(something))`이 올바른 문법이기 때문에 최신 버전을 다운 받아서 사용하도록 하자.\n\n\u003cbr\u003e\n\n### **pycharm, vs code**\n\npycharm 혹은 visual studio code의 extension에서 python을 설치하여 텍스트 에디터를 사용하는 방법도 있다. 언어의 학습을 위해서 강의를 들을 때는 jupyter notebook을 사용하기로 했지만, 추후에 프로젝트나 여러 작업을 진행하기 위해서는 텍스트 에디터를 이용한 python의 사용법 또한 필요하다고 생각했다.  \n\nhtml, css, javascript를 사용하면서 익숙했던 visual studio code를 사용하기로 결정했다. 위의 python 설치 과정에서 PATH 추가만 제대로 했다면, visual studio code의 extension에서 python만 추가로 설치해주면 된다.\n\n파일의 확장명은 .py이고 윈도우에서는 터미널 창에 `python 파일이름.py` 리눅스나 mac의 경우에는 터미널 창에 `python3 파일이름.py`라고 버전을 명시해줘야 한다. 나는 wsl2를 이용하여 윈도우 환경에서 리눅스를 사용할 때도 있기 때문에 아래에서 윈도우와 wsl2의 사용 예시를 보여줬다.\n\n![](brain/image/funny01-2.png)\n\n![](brain/image/funny01-3.png)\n\n\u003chr\u003e\n\n## 04. jupyter사용 TIP\n\n- jupyter notebook file을 python3 형태로 만든다.\n\n- 코드를 작성하고 실행할 때는 기본적으로 `shift + enter` 키를 활용한다.\n\n- 해당하는 셀을 코드 블록으로 사용하려면 `Y` 마크다운 블록으로 사용하려면 `M`을 누른다.\n\n- 해당하는 셀의 위에 새로운 블록 생성은 `a` 아래에 새로운 블록 생성은 `b`를 누른다.\n\n- 해당하는 셀을 삭제하려면 `d + d`, 복사는 `C`, 붙혀넣기는 `V`를 누른다.\n\n- 기본적인 단축키 이외에도 필요한 단축키가 있다면 그때 그때 학습하도록 한다.","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny02":{"title":"02 - 변수,출력","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 파이썬의 데이터구조\n\n\u003cbr\u003e\n\n2장부터 파이썬의 기초와 자료형에 관하여 다룰 것이다. 파이썬의 자료형에는 `숫자형, 문자열 자료형, 리스트 자료형, 튜플 자료형, 딕셔너리 자료형, 집합 자료형, 불 자료형`이 있다. 이러한 자료형, 데이터를 효율적으로 나타내기 위한 특정 데이터 타입이 있는데 이를 데이터 구조라고 한다. 대표적으로 리스트, 튜플, 딕셔너리 등이 있다.\n\n- **데이터 구조**\n- 선언 + 입력\n- 읽기\n- 추가\n- 삭제\n- 수정\n\n\u003chr\u003e\n\n## 01. 출력과 입력  \n\n언어의 기본은 \"Hello World!\"를 출력함에 있다. Python은 대표적인 인터프리터 언어이므로, 소스 코드를 작성하면 줄마다 번역하고 실행할 수 있다. 인터프리터와 컴파일러에 관한 내용은 \u003ca href='https://jae-yoon.tistory.com/3' target='_blank'\u003e개발자 유니\u003c/a\u003e에 추가로 포스팅하였다. \n\n\u003cbr\u003e\n\n```python\nprint(\"Hello World!\")\nprint('Hello World!')\nprint(1)\n  \n출력 결과 : Hello World!\n출력 결과 : Hello World!\n출력 결과 : 1\n```\n\n\u003cbr\u003e\n\nC언어와 같이 문장의 끝에 `;`를 찍을 필요도 없고, 문자열은 `\"\"`든 `''`든 상관없었다. 다음은 숫자 출력에서 나누기에 관한 몇 가지 예시이다.\n\n\u003cbr\u003e  \n\n```python\nprint (15 / 7)\nprint (15 // 7)\nprint (15 % 7)\nprint (2 * 4)\nprint (2 ** 4 )\n  \n출력 결과 : 2.142857142857143\n출력 결과 : 2\n출력 결과 : 1\n출력 결과 : 8\n출력 결과 : 16\n```\n\n\u003cbr\u003e\n\n파이썬 에서는 `/`는 나누기, `//`는 몫, `%`는 나머지를 뜻하고 `*`는 곱하기, `**`는 제곱 수를 뜻한다. 위의 경에우는 2의 4승을 뜻하는 것이다.  \n\n**소수점 아래의 몇 번째 자리까지 표시**하는 예시를 출력하는 경우 여러가지 방법이 있는데, 그 중 세 가지 방법을 소개하겠다.\n\n\u003cbr\u003e  \n\n```python\nfloat_data_pi = 3.1415\nround (float_data_pi, 1)\n  \nfloat_data2_pi = 3.1415\nprint(\"%.1f\" % float_data2_pi)\n  \nfloat_data3_pi = 3.1415\nprint ( format(float_data3_pi, \".1f\") )\n  \n출력 결과 : 3.1\n출력 결과 : 3.1\n출력 결과 : 3.1\n```\n\n\u003cbr\u003e\n\n1. round() 함수 사용\n\n`round(값, 자릿수)` 함수는 반올림 함수이다. 그러나, 주의해야할 것은 **파이썬에서 반올림은 반올림 하려는 수가 올림, 내림 했을 때 동일하게 차이가 나는 경우에는 짝수 값으로 반올림한다는 것이다.** 이 말은, 예를 들어 `round(0.5)`를 한다면 1이 출력되어야 하지만, 실제로는 0이 출력된다. 0.5는 0에도 0.5만큼 차이, 1에도 0.5만큼 차이가 나기 때문에 짝수인 0의 값에 맞춰지게 되는 것이다. 이를 유의하자. 그리고 40.000과 같이 표현해주고 싶은 경우에는 round 함수를 사용하면 안된다. 알아서 잘라먹고 40.0으로 표현할 것이다.\n\n\u003cbr\u003e\n\n2. %.f 사용\n\n`print(\"%.원하는자릿수f\" % 값)`\n\n\u003cbr\u003e\n\n3. format() 함수 사용\n\n`format(값, \".원하는자릿수f\")` 혹은 `print(\"{:.원하는자릿수f}\".format(값))`\n\n추가적인 내용은 [[잔재미] String](brain/Lecture/funny-python/funny03)를 참조하라.\n\n\u003cbr\u003e  \n\n파이썬에서 입력은 `input()`함수를 사용하면 된다.\n\n```python\ndata = input()\nprint(data)\n  \n출력 : 사용자가 입력한 값\n```\n\n\u003cbr\u003e\n\n그런데, 여기서 주의해야할 점은 숫자 1을 입력했다고 해도 input의 타입이 문자열이기 때문에 정수로 인식하지 않는다. 따라서, 정수형 타입을 원한다면 형변환을 해줘야 한다.\n\n```python\ndata1 = input()\ndata2 = input()\n  \nprint( data1 + data2 )\nprint( data1 * data2 )\nprint( int(data1) + int(data2))\n  \n입력 값 : 1, 2\n출력 결과 : 12 ( 문자열이 붙혀진 형태 )\n출력 결과 : Type Error ( 문자열 곱하기 문자열의 형태니까 오류)\n출력 결과 : 3 ( 정수형으로 형변환 되어 더해진 형태)\n```\n\n\u003chr\u003e\n\n## 02. 변수, 데이터 타입\n\n\u003cbr\u003e\n\nPython에서 변수는 C, Java와 같이 먼저 변수형을 지정 안해줘도 된다. (int 같은 것을 안적어도 된다는 의미이다.) 변수에 값을 넣으면 변수형이 지정된다. 그리고 불리안 타입은 대문자를 사용해서 True, False와 같이 사용한다.\n\n```python\nage = 27\nname = \"신재윤\"\nheight = 177\nweight = 64\nfoot_size = 270\nglass = False\nmarriage = False\n```\n\n데이터 타입이 어떤 것인지를 확인해보려면 `print(type())`으로 확인할 수 있다.\n\n```python\nage = 27\nname = \"신재윤\"\nglass = False\n  \nprint(type(age))\nprint(type(name))\nprint(type(glass))\n\n출력 결과 : \u003cclass 'int'\u003e\n출력 결과 : \u003cclass 'str'\u003e\n출력 결과 : \u003cclass 'bool'\u003e\n```\n\n정리하자면, 파이썬에서의 데이터 타입은 아래와 같다. \u003cbr\u003e\u003cbr\u003e\n\n**Type**\n\n- 정수 : int\n\n- 부동소숫점 : float\n\n- 문자열 : str\n\n- Boolean : bool\n\n\u003cbr\u003e  \n\n타입 검사를 하기 위한 Tip\n\n```python\na = 1\nif (str(type(a)) == \"\u003cclass 'int'\u003e\"):\nprint(\"정수 타입이 맞습니다.\")\n```\n\n\u003chr\u003e\n\n## 03. print() 문의 옵션\n\n\u003cbr\u003e\n\n출력문에서 사용하는 print() 함수에는 옵션을 여러 가지 설정할 수 있다.\n\n1. sep(separation)\n\n단어 뜻 그대로 분리하여, 출력한다는 의미이다. 갈라놓을 문자를 지정할 수 있는데 이것을 `구분자`라고 한다.\n\n- `sep=' '` 형식으로 사용\n\n- 클론 기호`' '`를 사이에 두고 값을 출력\n\n```python\nprint('S','E','P', sep='@')\n출력 : S@E@P\n```\n\n\u003cbr\u003e\n\n```python\na, b = input().split(':')\nprint(a, b, sep=':')\n  \n입력 : 3:16\n출력 : 3:16\n```\n\n- 아무것도 없는 빈(empty) 문자는 그냥 `''`\n\n- join() 함수, 반복문 섞어서도 가능\n\n```python\n(a, b) = input().split(\"-\")\nprint(a, b, sep=\"\")\n  \na = input().split(\"-\")\nresult = ''.join(s for s in a)\nprint(result)\n  \n입력 : 000907-1121112\n출력 : 0009071121112\n```\n\n\u003cbr\u003e\n\n2. end\n\n단어 뜻 그대로 마지막이라는 의미이다. 줄바꿈을 하지 않고 이어서 출력하겠다는 뜻이다.\n\n```python\nprint(\"I like\", end=\" \")\nprint(\"money\")\n  \n출력 : I like money\n```\n  \n- end=' ' 사이에 무언가를 입력하면, sep와 비슷한 기능을 한다.(구분자를 사용할 수 있다) 첫번째 출력문과, 두번째 출력문 사이에 end에 넣어준 문자열이 출력된다.  \n\n```python\nprint(\"I like\", end=\" gold and \")\nprint(\"money\")\n  \n출력 : I like gold and money\n```\n\n\u003cbr\u003e\n\n3. format\n\nformat 함수를 이용한 print() 다루기는 [[잔재미] String](brain/Lecture/funny-python/funny03)에서 상세히 설명한다.\n\n- `.format() 이용`\n\n```python\nprint(\"{0}월{1}일 입니다.\".format(3,9))\n출력 : 3월 9일 입니다.\n```\n\n- `%` 이용 포맷팅 (가장 많이 사용할 듯)  \n\n```python\nprint(\"%s을 %d개 주세요.\" % (\"초콜렛\", 10))\n출력 : 초콜렛을 10개 주세요.\n```\n\n\u003cbr\u003e\n\n```python\nprint(\"%d + %d = %d\" % (1, 2, 3))\n출력 : 1 + 2 = 3\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny03":{"title":"03 - String","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 문자열 다루기 기본\n\n\u003cbr\u003e  \n\npython은 문자열을 다루는데 특화된 프로그래밍 언어이다. 간결하면서 사용성은 매우 뛰어나다. 따라서, 크롤링을 공부하기에 매우 좋은 언어이다. 변수에 문자열을 지정할 때, `\"내용\"` 따옴표를 한 개씩만 넣었을 경우, 다음 줄로 넘어가면 EOF, End Of Line으로 한 줄을 넘어갔다고 오류가 발생할 수 있다. 그럴 경우, 당황하지 말고 `\"\"\"내용\"\"\"`와 같이 따옴표를 세 개씩 넣어주자. 이스케이프 문자 `\\n`을 넣어서 표현할 수도 있으나, 따옴표를 연속적으로 쓰는 것이 깔끔하니 그렇게 사용하도록 하자.\n\n\u003cbr\u003e\n\n```python\ncontext = \"South Korean director Bong Joon-ho has won the Cannes film festival's most prestigious award. The Palme d'Or was awarded for his film Parasite, a dark comedy thriller exploring social class dynamics. The festival came to a close this evening after 11 days of previews of new films and documentaries.\"  \n\nprint(context)\n\n출력결과 : SyntaxError: EOL while scanning string literal\n```\n\n\u003cbr\u003e\n\n```python\ncontext = \"\"\"South Korean director Bong Joon-ho has won the Cannes film festival's most prestigious award.\nThe Palme d'Or was awarded for his film Parasite, a dark comedy thriller exploring social class dynamics.\nThe festival came to a close this evening after 11 days of previews of new films and documentaries.\"\"\"\n\nprint(context)\n출력결과 : context 안의 문자열\n```\n\n\u003cbr\u003e  \n\n문자열을 더하거나 곱할 수 있다. 더하는 것은 말 그대로 더하는 것이지만 곱하는 것은 문자열끼리 곱하는 것이 아닌, 반복을 의미한다.\n\n```python\nstring1 = \"Hello\"\nstring2 = \"World\"\nprint(string1 + string2)\nprint(string1 * string2)\nprint(string1 * 2)\n  \n출력결과 : HelloWorld\n출력결과 : TypeError: can't multiply sequence by non-int of type 'str'\n출력결과 : HelloHello\n```\n  \n\u003cbr\u003e\n\n문자열을 곱하는 것을 응용하면 아래와 같이 사용할 수 있다.\n\n```python\nprint(\"=\" * 20)\nprint(\"안녕하세요. 깔끔하죠?\")\nprint(\"=\" * 20)\n  \n출력결과 :\n====================\n안녕하세요. 깔끔하죠?\n====================\n```\n\n\u003cbr\u003e\n\n문자열 길이를 구하는 대표적인 함수는 `len()` 함수가 있다.\n  \n```python\nstring = \"나는 뛰어난 주니어 개발자입니다.\"\nprint(len(string))\n  \n출력결과 : 18\n```\n  \n\u003cbr\u003e\n  \n- **인덱스 (index)**\n\n- 인덱스는 특정 데이터를 가리키는 번호를 나타냄\n\n|p|y|t|h|o|n|\n|:--:|:--:|:--:|:--:|:--:|:--:|\n|0|1|2|3|4|5|\n|-6|-5|-4|-3|-2|-1|\n  \n\u003cbr\u003e\n\n```python\nsome_string = \"python\"\nprint(some_string[0])\nprint(some_string[1])\nprint(some_string[-1])\nprint(some_string[-6])\n  \n출력결과 : p\n출력결과 : y\n출력결과 : n\n출력결과 : p\n```\n  \n- **슬라이싱 (slicing)**\n\n- 시작 인덱스 ~ 해당 인덱스 직전의 인덱스까지 출력\n\n```python\nsome_string = \"python\"\nprint(some_string[3:5]\nprint(some_string[1:5])\nprint(some_string[1:2])\n  \n출력결과 : ho\n출력결과 : ytho\n출력결과 : y\n```\n  \n- 슬라이싱 응용\n\n```python\nsome_string = \"python\"\nprint(some_string[:6]) # 문자열 시작 ~ 지정 인덱스 전까지\nprint(some_string[0:]) # 지정 인덱스 ~ 문자열 끝까지\nprint(some_string[:]) # 문자열 전체\n  \n출력결과 : python\n출력결과 : python\n출력결과 : python\n```\n  \n- 슬라이싱 이용해서 문자열 나누기\n\n```python\ntoday = \"20220219Sunny\"\nyear = today[:4]\nday = today[4:8]\nweather = today[8:]\n  \nprint(year, day, weather)\n출력결과 : 2022 0219 Sunny\n```\n\n- 슬라이싱 이용해서 문자열 바꾸기\n\n기본적으로 문자열 자료형은 그 요솟값을 바꿀 수 없는 immutable한 자료형이다. 이것이 의미하는 바는, python이라는 문자열이 있을 때, 아래와 같이 변경할 수 없다는 의미이다. 하지만, 슬라이싱 방법을 이용하면 가능하다.\n\n  \n\n```python\nstring = \"python\"\npython[1] = \"i\"\n  \nprint(string)\n출력결과 : NameError: name 'python' is not defined\n```\n\n\u003cbr\u003e\n  \n```python\nstring = \"python\"\nnew_string = string[:1] + \"i\" + string[2:]\n\nprint(new_string)\n출력결과 : pithon\n```\n\n\u003chr\u003e\n\n## 02. 코드 이용 포매팅\n\n\u003cbr\u003e\n\n|코드|설명|\n|:--:|:--:|\n|%s|문자열(string)|\n|%c|문자 1개(character)|\n|%d|정수(integer)|\n|%f|부동소수(floating-point)|\n|%o|8진수|\n|%x|16진수|\n|%%|Literal % (문자 % 자체)|\n\n\u003cbr\u003e\n  \n1. 숫자나 문자열 직접 대입\n\n```python\nstring1 = \"I eat %d bananas.\" % 3\nstring2 = \"I eat %s bananas.\" % \"sweet\"\n\nprint(string1)\nprint(string2)\n  \n출력결과 : I eat 3 bananas.\n출력결과 : I eat sweet bananas.\n```\n\n2. 변수 대입  \n\n```python\nnumber = 3\nthree = \"3\"\nstring1 = \"I eat %d bananas.\" % number\nstring2 = \"I eat %d bananas.\" % three\nstring3 = \"I eat %c bananas.\" % three\nstring4 = \"I eat %s bananas.\" % three\n\nprint(string1)\nprint(string2)\nprint(string3)\nprint(string4)\n\n출력결과 : I eat 3 bananas.\n출력결과 : TypeError: %d format: a number is required, not str\n출력결과 : I eat 3 bananas.\n출력결과 : I eat 3 bananas.\n```\n\n3. 두 개 이상의 값 대입  \n\n```python\nnumber1 = 5\nnumber2 = 2\nfruit = \"bananas\"\nstring = \"I bought %d %s. But, %d %s were rotten.\" % (number1, fruit, number2, fruit)\n\nprint(string)\n출력결과 : I bought 5 bananas. But, 2 bananas were rotten.\n```\n  \n4. 포맷팅 연산자와 함께 % 문자 삽입하는 방법\n\n```python\nstring1 = \"Error is %d%.\" % 98\nstring2 = \"Error is %d%%.\" % 98\nprint(string1)\nprint(string2)\n\n출력결과 : ValueError: incomplete format\n출력결과 : Error is 98%.\n```\n\n\u003cbr\u003e\n\n**포맷 코드와 숫자 함께 사용하기**\n\n- 정렬과 공백\n\n```python\nstring1 = \"%10s\" % \"hi\"\nstring2 = \"%-10s\" % \"hi\"\n\nprint(string1)\nprint(string2)\n\n출력결과 : hi (10개의 공간에서 대입되는 값을 우측 정렬)\n출력결과 : hi (10개의 공간에서 대입되는 값을 좌측 정렬)\n```\n\n- 소숫점 표현\n\n```python\nstring1 = \"%0.4f\" % 3.42134234\nstring2 = \"%10.4f\" % 3.42134234\n\nprint(string1)\nprint(string2)\n\n출력결과 : 3.4213\n출력결과 : 3.4213 (숫자를 소숫점 네 번째 자리까지만 표시하고 전체 10개의 문자열 공간에서 오른쪽 정렬)\n```\n\n\u003chr\u003e\n\n## 03. format 이용 포매팅\n\n\u003cbr\u003e\n\n1. 숫자나 문자열 직접 대입\n  \n```python\nstring1 = \"I eat {0} bananas.\".format(3)\nstring2 = \"I eat {0} bananas.\".format(\"sweet\")\n\nprint(string1)\nprint(string2)\n  \n출력결과 : I eat 3 bananas.\n출력결과 : I eat sweet bananas.\n```\n\n2. 변수 대입  \n\n```python\nnumber = 3\nthree = \"3\"\nstring1 = \"I eat {0} bananas.\".format(number)\nstring2 = \"I eat {0} bananas.\".format(three)\nstring3 = \"I eat {0} bananas.\".format(\"three\") # 이건 변수 대입이 아니겠지.\n\nprint(string1)\nprint(string2)\n  \n출력결과 : I eat 3 bananas.\n출력결과 : I eat 3 bananas.\n출력결과 : I eat three bananas.\n```\n\n3. 두 개 이상의 값 대입  \n\n```python\nnumber1 = 5\nnumber2 = 2\nfruit = \"bananas\"\nstring1 = \"I bought {0} {1}. But, {2} {3} were rotten.\".format(number1, fruit, number2, fruit)\nstring2 = \"I bought {2} {1}. But, {0} {3} were rotten.\".format(number1, fruit, number2, fruit)\n\nprint(string1)\nprint(string2)\n\n출력결과 : I bought 5 bananas. But, 2 bananas were rotten.\n출력결과 : I bought 2 bananas. But, 5 bananas were rotten.\n```\n\n4. 이름으로 대입\n\n```python\nstring = \"I bought {number} {fruit}.\".format(number=5, fruit=\"bananas\")\nprint(string)\n  \n출력결과 : I bought 5 bananas.\n```\n\n5. 인덱스와 이름 혼용\n\n```python\nstring = \"I bought {0} {fruit}.\".format(5, fruit=\"bananas\")\nprint(string)\n  \n출력결과 : I bought 5 bananas.\n```\n\n6. 왼쪽 정렬, 오른쪽 정렬, 가운데 정렬  \n\n```python\n# 문자열의 자릿수는 10으로 한 것\nleft = \"{0:\u003c10}\".format(\"hi\")\nright = \"{0:\u003e10}\".format(\"hi\")\ncenter = \"{0:^10}\".format(\"hi\")\n\nprint(left)\nprint(right)\nprint(center)\n  \n출력결과 : hi\n출력결과 : hi\n출력결과 : hi\n```\n\n7. 공백 채우기, \"{0: '공백내용' '정렬방법' '자릿수'}\".format(\"문자열\")\n\n```python\nstring1 = \"{0:=^10}\".format(\"hi\")\nstring2 = \"{0:!\u003c10}\".format(\"hi\")\nprint(string1)\nprint(string2)\n\n출력결과 : ====hi====\n출력결과 : hi!!!!!!!!\n```\n  \n8. 소숫점 표현하기\n\n```python\npi = 3.141592\nstring1 = \"{0:0.4f}\".format(pi)\nstring2 = \"{0:10.4f}\".format(pi)\n\nprint(string1)\nprint(string2)\nprint(format(3.141592, \"0.4f\"))\n\n출력결과 : 3.1416\n출력결과 : 3.1416\n출력결과 : 3.1416\n```\n\n9. `{` `}` 문자 사용하기\n\n```python\nstring = \"I bought {fruit} and {{apple}}. {apple} is delicious.\".format(fruit=\"banana\", apple=\"Apple\")\n\nprint(string)\n\n출력결과 : I bought banana and {apple}. Apple is delicious.\n```\n\n\u003chr\u003e\n\n## 04. f 문자열 이용 포매팅\n\n- 참고 : f 문자열 포맷팅\n\npython version 3.6부터 사용 가능한 기능\n\n```python\nname = \"신재윤\"\nage = 27\nstring = f'나의 이름은 {name}입니다. 나이는 {age}입니다.'\n  \nprint(string)\nprint(f'나의 이름은 {name}입니다. 나이는 {age}입니다.')\nprint(f'나의 이름은 {name}입니다. 나이는 {age+3}입니다.')\n  \n출력결과 : 나의 이름은 신재윤입니다. 나이는 27입니다.\n출력결과 : 나의 이름은 신재윤입니다. 나이는 27입니다.\n출력결과 : 나의 이름은 신재윤입니다. 나이는 30입니다.\n```\n\n- 딕셔너리 이용 f 문자열 포맷팅\n\n```python\nd = {\"name\" : \"신재윤\", \"age\" : 27}\n\nprint(f\"나의 이름은 {d['name']}입니다. 나이는 {d['age']}입니다.\")\n출력결과 : 나의 이름은 신재윤입니다. 나이는 27입니다.\n```\n\n- f 문자열 포맷팅 이용 정렬\n\n```python\n# format 함수\nprint(\"{0:\u003c10}\".format(\"hi\"))\nprint(\"{0:\u003e10}\".format(\"hi\"))\nprint(\"{0:^10}\".format(\"hi\"))\n  \n# f 문자열 포맷팅\nprint(f'{\"hi\":\u003c10}')\nprint(f'{\"hi\":\u003e10}')\nprint(f'{\"hi\":^10}')\n  \n출력결과 : hi\n출력결과 : hi\n출력결과 : hi\n```\n\n- f 문자열 포맷팅 공백 채우기\n\n```python\n# format 함수\nprint(\"{0:=\u003c10}\".format(\"hi\"))\nprint(\"{0:!\u003e10}\".format(\"hi\"))\n  \n# f 문자열 포맷팅\nprint(f'{\"hi\":=\u003c10}')\nprint(f'{\"hi\":!\u003e10}')\n  \n출력결과 : hi========\n출력결과 : !!!!!!!!hi\n```\n\n- f 문자열 포맷팅 소숫점 표현하기  \n\n```python\npi = 3.141592\n  \n# format 함수\nprint(\"{0:0.4f}\".format(pi))\nprint(\"{0:10.4f}\".format(pi))\nprint(format(pi, \"0.4f\"))\n  \n# f 문자열 포맷팅\nprint(f'{pi:0.4f}')\nprint(f'{pi:10.4f}')\n\n출력결과 : 3.1416\n출력결과 : 3.1416\n```\n\n\u003chr\u003e\n\n## 05. 문자열 다양한 함수들\n\n\u003cbr\u003e\n  \n- count()\n\t- 문자 개수 세기\n- find()\n\t- 문자 위치 찾기\n- index()\n\t- 문자 위치 찾기\n- join()\n\t- 문자열 삽입\n- upper()\n\t- 소문자를 대문자로\n- lower()\n\t- 대문자를 소문자로\n- lstrip()\n\t- 왼쪽 공백 제거\n- rstrip()\n\t- 오른쪽 공백 제거\n- strip()\n\t- 양쪽 공백 제거\n- replace()\n\t- 문자열 변경\n- split()\n\t- 문자열 나누기\n  \n\u003cbr\u003e\n\n\u003e [!warning] 주의 !\n\u003e\n\u003e 주의할 것은, 함수를 사용한다 해도 문자열 자체의 내용이 바뀌는 것은 아니다. 예를 들어 replace()를 이용해서 문자열을 변경한다는 것은 `print(string).replace(\"a\", \"b\"))` 일 경우 출력하는 과정에서 `a`를 `b`로 치환해주는 개념인 것이지 string의 문자열 내용 자체가 바뀌는 것은 아니다.\n\n\u003cbr\u003e\n  \n**count()**\n\n```python\nstring = \"python\"\nprint(string.count('p'))\n  \n출력결과 : 1\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**find(), index()** \u003cbr\u003e\n\n`find()`는 없는 값을 찾으면 -1을 반환하지만, `index()`는 없는 값을 찾으면 오류 값을 반환한다.\n\n```python\nstring = \"Python is the best programming language.\"\nprint(string.find('t'))\nprint(string.find('k'))\nprint(string.index('t'))\nprint(string.index('k'))\n  \n출력결과 : 2\n출력결과 : -1\n출력결과 : 2\n출력결과 : ValueError: substring not found\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**join()** \u003cbr\u003e\n\n`join()`는 문자열 뿐만이 아니라 리스트나 튜플에도 사용 가능하다.\n\n```python\n# 문자열 사용 예시\nprint(\",\".join('abcd'))\n\n# 리스트 사용 예시\nprint(\",\".join(['a', 'b', 'c', 'd']))\n  \n출력결과 : a,b,c,d\n출력결과 : a,b,c,d\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**upper(), lower()**\n\n```python\nstring1 = \"hi\"\nstring2 = \"HI\"\n\nprint(string1.upper())\nprint(string2.lower())\n  \n출력결과 : HI\n출력결과 : hi\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**lstrip(), rstrip(), strip()**\n\n```python\nstring = \" hi \"\nprint(string.lstrip())\nprint(string.rstrip())\nprint(string.strip())\n\n출력결과 : hi\n출력결과 : hi\n출력결과 : hi\n  \n#-------------------------------#\n\nstring = \",,,hi,,,\"\nprint(string.strip())\nprint(string.strip(\",\"))\n  \n출력결과 : ,,,hi,,,\n출력결과 : hi\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**replace()** \u003cbr\u003e\n\n```python\nstring = \"Python is good programming language\"\nstring.replace(\"Python\", \"Java\")\n  \nprint(string.replace(\"Python\", \"Java\"))\nprint(string)\n  \n출력결과 : Java is good programming language\n출력결과 : Python is good programming language\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n\n**split()** \u003cbr\u003e\n\n괄호 안이 공백일 경우 \"탭\", \"스페이스\", \"엔터\" 기준으로 쪼갠다.\n\n```python\nstring = \"Python is good programming language\"\nprint(string.split())\n  \n출력결과 : ['Python', 'is', 'good', 'programming', 'language']\n  \n#-------------------------------#\n\nstring = \"a:b:c:d:e\"\nprint(string.split(\":\"))\n  \n출력결과 : ['a', 'b', 'c', 'd', 'e']\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny04":{"title":"04 - List","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 리스트 자료형이란?\n\n데이터 구조 - 리스트(list)라고 하는데, 여기서 데이터 구조란, 연관있는 데이터를 어떻게 컴퓨터로 효율적으로 다룰 수 있을 지에 관한 것이다.\n\n- 리스트\n\n- 여러 가지 관계가 있는 데이터를 하나의 변수로 다루는 방법\n\n- `[ ]`안에 `,`를 사용해서 데이터를 넣으면 된다.\n\n- 예시) `mydata = [1, 2, 'hello', 1.2]`\n\n- 각 데이터는 인덱스를 사용해서 다룰 수 있다.\n\n\u003cbr\u003e  \n\n- 리스트 선언 방법\n\t- 빈 배열을 만들 때는 `[]` 보다는 `list()`를 써주도록 하자.\n\n```python\na = list()\nb = []\nc = [1, 2, 3]\nd = ['Python', 'is', 'good']\ne = [1, 2, ['Python', 'is', 'good']]\n```\n  \n\u003cbr\u003e\n\n- 리스트 다루기 쉬운 방법 (간략한 버전)  \n\n1. 리스트 선언\n\n```\n- 리스트변수 = [ ]\n- 리스트변수 = list()\n- 리스트변수 = [데이터1, 데이터2, ...]\n```\n  \n2. 리스트 추가\n\n```\n- 리스트변수.append(데이터)\n- 리스트변수.insert(인덱스번호, 데이터)\n```\n\n3. 리스트 삭제\n\n```\n- 리스트변수.remove(데이터)\n- del 리스트변수[인덱스번호]\n```\n  \n4. 리스트 데이터 수정\n\n```\n- 리스트변수[인덱스번호] = 수정할 데이터\n```\n\n\u003chr\u003e\n\n## 02. 인덱싱과 슬라이싱\n\n리스트 역시 문자열과 동일하게 인덱싱과 슬라이싱을 할 수 있는데, 이를 잘 활용하여야 한다.  \n\n\u003cbr\u003e\n\n### 리스트의 인덱싱\n\n\u003cbr\u003e  \n\n```python\na = [1, 2, 3]\nprint(a[0] + a[2])\n  \n출력결과 : 4\n```\n\n\u003cbr\u003e\n\n```python\na = [1, 2, 3, ['a', 'b', 'c']]\nprint(a[0])\nprint(a[3])\nprint(a[-1])\n  \n출력결과 : 1\n출력결과 : ['a', 'b', 'c']\n출력결과 : ['a', 'b', 'c']\n```\n\n\u003cbr\u003e  \n\n- 이중 리스트\n\n**C언어의 2차원 배열 느낌도 생각하자. `list[][]`**\n\n```python\na = [1, 2, 3, ['a', 'b', 'c']]\nprint(a[3][0])\nprint(a[-1][0])\n  \n출력결과 : a\n출력결과 : a\n```\n  \n\u003cbr\u003e\n\n- 삼중 리스트\n\n```python\na = [1, 2, ['a', 'b', ['Python', 'is', 'good']]]\nprint(a[2][2][0])\n  \n출력결과 : Python\n```\n\n\u003cbr\u003e\n  \n### 리스트의 슬라이싱\n\n\u003cbr\u003e\n\n```python\na = [1, 2, 3, 4, 5]\nb = a[:2]\nc = a[2:]\n\nprint(b)\nprint(c)\n  \n출력결과 : [1, 2]\n출력결과 : [3, 4, 5]\n```\n\n- 중첩된 리스트 슬라이싱\n\n```python\na = [1, 2, 3, ['a', 'b', 'c'], 4, 5]\nprint(a[2:5])\nprint(a[3][:2])\n  \n출력결과 : [3, ['a', 'b', 'c'], 4]\n출력결과 : ['a', 'b']\n```\n\n\u003cbr\u003e\n\n### split()으로 리스트 다루기  \n\n\u003cbr\u003e\n\n\u003e 사용자로부터 주민등록번호를 입력 받고, 사용자가 남성인지 여성인지 출력하시오. (주민등록번호 뒷자리의 시작이 1이거나 3이면 남성, 2이거나 4이면 여성이다.)  \n\n```python\ndata = input(\"주민등록번호를 '-' 포함해서 입력하세요. \")\n  \nif (int(data.split('-')[1][0]) == 1) or (int(data.split('-')[1][0]) == 3):\n\tprint(\"남성입니다.\")\n\nelif (int(data.split('-')[1][0]) == 2) or (int(data.split('-')[1][0]) == 4):\n\tprint(\"여성입니다.\")\n\nelse:\n\tprint(\"잘못된 주민등록번호 입니다.\")\n```\n\n\u003chr\u003e\n\n## 03. 리스트 연산하기\n\n\u003cbr\u003e  \n\n```python\na = [1, 2, 3]\nb = [4, 5, 6]\n\n# 리스트 더하기\nprint(a + b)\n출력결과 : [1, 2, 3, 4, 5, 6]\n  \n# 리스트 곱하기 (반복)\nprint(a * 3)\n출력결과 : [1, 2, 3, 1, 2, 3, 1, 2, 3]\n  \n# 리스트 길이 구하기\nprint(len(a))\n출력결과 : 3\n```\n  \n- 리스트 연산 오류\n\n```python\na = [1, 2, 3]\nprint(a[2] + \"hi\")\nprint(str(a[2]) + \"hi\")\n  \n출력결과 : TypeError: unsupported operand type(s) for +: 'int' and 'str'\n출력결과 : 3hi\n```\n  \n\u003chr\u003e\n\n## 04. 수정, 삭제, 추가\n\n\u003cbr\u003e\n\n### 리스트 수정\n  \n\u003cbr\u003e\n\n```python\nlanguage = [\"python\", \"java\", \"c++\"]\nlanguage[2] = \"c\"\nprint(language)\n  \n출력결과 : ['python', 'java', 'c']\n```\n\n\u003cbr\u003e\n  \n### 리스트 삭제\n\n- del 함수 이용\n\n- 리스트의 인덱스를 가르켜서 내용 삭제\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3, 4, 5]\ndel a[1]\ndel b[:2]\n  \nprint(a)\nprint(b)\n  \n출력결과 : [1, 3]\n출력결과 : [3, 4, 5]\n```\n  \n\u003cbr\u003e\n\n- remove 함수 이용\n\n- 리스트의 내용을 가르켜서 삭제\n\n- 첫 번째로 나오는 내용이 삭제된다.\n\n```python\nlocation = ['서울시', '경기도', '서울시', '부산시']\nlocation.remove('서울시')\nprint(location)\n  \n출력결과 : ['경기도', '서울시', '부산시']\n```\n  \n\u003cbr\u003e\n  \n- pop 함수 이용\n\n- 리스트의 맨 마지막 요소를 뽑아오고 그 요소는 리스트에서 삭제\n\n```python\nlocation = ['서울시', '경기도', '서울시', '부산시']\nprint(location.pop())\nprint(location)\n  \n출력결과 : 부산시\n출력결과 : ['서울시', '경기도', '서울시']\n```\n\n\u003cbr\u003e  \n\n### 리스트 추가\n\n- append 함수 이용\n\n- append 함수는 하나의 요소만 추가 가능\n\n- 리스트의 맨 마지막에 추가\n\n```python\na = [1, 2, 3]\n\na.append(4)\nprint(a)\n  \na.append([5, 6])\nprint(a)\n\n출력결과 : [1, 2, 3, 4]\n출력결과 : [1, 2, 3, 4, [5, 6]]\n```\n\n\u003cbr\u003e  \n\n- insert 함수 이용\n\n- 지정한 인덱스에 요소 추가\n\n```python\na = [1, 2, 3]\n\na.insert(3, 4)\nprint(a)\n\na.insert(0, 5)\nprint(a)\n\n출력결과 : [1, 2, 3, 4]\n출력결과 : [5, 1, 2, 3, 4]\n```\n\n\u003chr\u003e\n\n## 05. 리스트 다양한 함수들\n  \n- sort()\n\t- 리스트 요소 순서대로 정렬\n- reverse()\n\t- 리스트 요소 역순으로 뒤집기 (순서대로 정렬하고 뒤집기 X)\n- index()\n\t- 리스트에 해당 값이 있으면 그 위치를 반환\n- find()\n\t- 리스트에 해당 값이 있으면 그 위치를 반환\n- count()\n\t- 리스트에 포함된 요소의 개수 세기\n- extend()\n\t- 리스트 확장\n  \n\u003cbr\u003e\n\n**sort(), reverse()**\n\n```python\na = [2, 1, 4, 3]\na.sort()\nprint(a)\n  \nb = [2, 1, 4, 3]\nb.reverse()\nprint(b)\n  \n출력결과 : [1, 2, 3, 4]\n출력결과 : [3, 4, 1, 2]\n```\n\n\u003cbr\u003e\n\n```python\n# 만약, 역순으로 순서대로 배치하고 싶으면, sort -\u003e reverse\na = [1, 8, 0, 9, 14]\na.sort()\na.reverse()\nprint(a)\n  \n출력결과 : [14, 9, 8, 1, 0]\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n\n**index()**\n\n```python\na = [1, 2, 3, 4]\nprint(a.index(1))\nprint(a.index(3))\nprint(a.index(5))\n  \n출력결과 : 0\n출력결과 : 2\n출력결과 : ValueError: 5 is not in list\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n\n**index()와 find() 비교**\n\n- 이 둘은 비슷한 역할을 하는 것 같지만, 조금 다르다.\n\n```python\n# index()의 경우\nletters = input()\nvar = letters.index('n')\n\nif var \u003e= 0:\n\tprint(\"입력한 문자에 n이 있습니다.\")\nelse:\n\tprint(\"입력한 문자에 n이 없습니다.\")\n\n출력결과 : n이 있으면 -\u003e 입력한 문자에 n이 있습니다.\n출력결과 : n이 없으면 -\u003e Value Error\n\n# find()의 경우\nletters = input()\nvar = letters.find('n')\n\nif var \u003e= 0:\n\tprint(\"입력한 문자에 n이 있습니다.\")\nelse:\n\tprint(\"입력한 문자에 n이 없습니다.\")\n\n출력결과 : n이 있으면 -\u003e 입력한 문자에 n이 있습니다.\n출력결과 : n이 없으면 -\u003e 입력한 문자에 n이 없습니다.\n```\n\n\u003cbr\u003e\n\n사용자가 입력한 것에 n이 있다면 정상적으로 \"입력한 문자에 n이 있습니다.\"라고 출력 되지만, n이 없는 경우, `index()`는 Value Error가 출력되고 `find()`는 정상적으로 값이 출력된다.\n  \n\n\u003cbr\u003e\n\n이는, [[잔재미] String](brain/Lecture/funny-python/funny03)에 기록되어있는 내용인데, `find()`는 없는 값을 찾으면 -1을 반환하지만, `index()`는 없는 값을 찾으면 오류를 반환하기 때문이다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n**count()**\n\n```python\na = [1, 2, 3, 1, 1, 5]\nprint(a.count(1))\n  \n출력결과 : 3\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n  \n**extend()**\n\n- 함수 안에는 리스트만 올 수 있다.\n\n- 원래의 리스트에 `()`안의 리스트를 더하는 것이다.\n\n```python\na = [1, 2, 3]\na.extend([4, 5])\nprint(a)\n  \n출력결과 : [1, 2, 3, 4, 5]\n```\n\n\u003cbr\u003e\n\n```python\na = [1, 2, 3]\nb = [4, 5]\na.extend(b)\nprint(a)\n  \n출력결과 : [1, 2, 3, 4, 5]\n```\n  \n\u003cbr\u003e\n\n- 리스트 연산 더하기와 유사함을 알 수 있다.\n\n```python\na = [1, 2, 3]\na += [4, 5]\nprint(a)\n  \n출력결과 : [1, 2, 3, 4, 5]\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny05":{"title":"05 - Tuple","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 튜플 자료형이란?\n\n\u003cbr\u003e\n\n튜플 자료형은 리스트 자료형과 매우 유사하다. 하나의 다른 점이 있는데 그것이 리스트 자료형과 튜플 자료형을 구분한다. `튜플 자료형은 값의 변경이 불가능하다는 점이다.` 리스트는 여러 가지 함수를 이용하여 리스트의 길이를 늘렸다가 줄였다가 하면서 값을 추가, 삭제, 수정을 하였는데 튜플은 그런 것이 불가능하고, 처음 선언한 그대로 사용해야 한다.  \n\n\u003cbr\u003e\n\n그러면, 상황에 맞춰서 가변적으로 변하는 리스트를 사용하는 것이 편하고 좋지 않냐고 물을 수 있다. 물론, 리스트를 훨씬 많이 사용하지만, 튜플이 필요한 경우가 있다. 간단하게 말하면 리스트는 동적배열이고 가변 객체이기 때문에 튜플보다 무겁고 오버헤드가 크다. 상황에 따라 정적배열이며 불변객체인 튜플을 사용하는 것이 퍼포먼스를 높이는 데 도움을 줄 수 있다. 자세한 내용은 \u003ca href='https://jae-yoon.tistory.com/4' target='_blank'\u003e개발자 유니\u003c/a\u003e에 추가로 포스팅하였다.\n\n\u003cbr\u003e\n\n- 튜플\n\t- 리스트와 유사하게, 여러 가지 관계가 있는 데이터를 하나의 변수로 다루는 방법\n\t- `( )`안에 `,`를 사용해서 데이터를 넣으면 된다.\n\t- 예시) `mydata = (1, 2, 3)`\n\n\u003cbr\u003e\n\n- **데이터 구조 : 튜플**\n\t- 선언 + 입력 : `변수명 = (1, 2, 3, 4)`\n\t- 읽기 : `변수명[인덱스번호]`\n\t- 추가 : 불가\n\t- 삭제 : 불가\n\t- 수정 : 불가\n\n\u003cbr\u003e\n\n- 튜플 선언 방법\n\n- 빈 배열을 만들 때는 `()`를 사용하겠지만, 사실상 튜플은 사용할 일 없다.\n\n```python\na = tuple()\nb = ()\nc = (1,) # tuple에 값이 하나일 경우 (값,) 이렇게 콤마를 넣어야한다.\nd = (1, 2, 3)\ne = 1, 2, 3 # 괄호를 생략해도 무방, 즉, 괄호가 없는 값의 나열은 튜플로 취급한다.\nf = ('a', 'b', ('ab', 'cd'))\n```\n\n\u003chr\u003e\n\n## 02. 튜플 다루기\n\n\u003cbr\u003e\n\n튜플도 데이터 구조이기 때문에 슬라이싱, 인덱싱 모두 가능하다.\n\n```python\na = (1, 2, 3, 'a', 'b')\nprint(a[:2])\n  \n출력결과 : (1, 2)\n```\n\n\u003cbr\u003e\n\n튜플끼리 더하기, 반복하는 표현인 `*`도 가능하다.\n\n```python\na = (1, 2, 3)\nb = (4, 5, 6)\n  \nprint(a + b)\nprint(a * 3)\nprint(len(a))\n  \n출력결과 : (1, 2, 3, 4, 5, 6)\n출력결과 : (1, 2, 3, 1, 2, 3, 1, 2, 3)\n출력결과 : 3\n```\n\n\u003cbr\u003e\n\n튜플은 리스트와 굉장히 유사하다고 했는데, 서로 간단하게 type을 변경할 수 있다.\n\n```python\ndata_tuple = (1, 2, 3)\nprint(type(data_tuple))\n출력결과 : tuple\n  \ndata_list = list(data_tuple)\nprint(type(data_list))\n출력결과 : list\n\ndata_tuple = tuple(data_list)\nprint(type(data_tuple))\n출력결과 : tuple\n```\n\n\u003chr\u003e\n\n## 03. 튜플 응용\n\n- 튜플을 이용한 값 변경\n\n우리가 흔히 변수에 대입되어 있는 값을 변경할 때는 `temp`라는 임시 변수를 두고 변경하는 경우가 많았다.\n\n```python\na = 1\nb = 2\n  \ntemp = a\na = b\nb = temp\n  \nprint(\"a의 값은 %d 입니다.\" % a)\nprint(\"b의 값은 %d 입니다.\" % b)\n  \n출력결과 : a의 값은 2 입니다.\n출력결과 : b의 값은 1 입니다.\n```\n\n\u003cbr\u003e\n\n하지만, 튜플 자료형을 이용하는 python에서는 이렇게도 가능하다.\n\n```python\na = 1\nb = 2\na, b = b, a\n\nprint(\"a의 값은 %d 입니다.\" % a)\nprint(\"b의 값은 %d 입니다.\" % b)\n  \n출력결과 : a의 값은 2 입니다.\n출력결과 : b의 값은 1 입니다.\n```\n\n그 이유는 `a, b = b, a`라고 하면 괄호가 생략된 형태의 튜플로 이해할 수 있기 때문이다. 실제로는 `(a, b) = (b, a)`인데, 튜플 하나가 하나의 변수로 취급되면서 내부의 값이 일대일로 대응하여 b는 a로, a는 b로 대입되기 때문이다.\n\n\u003cbr\u003e  \n\n- 이를 응용하면 함수의 return 값도 튜플을 이용해 하나 이상의 값을 반환할 수 있다.\n\n```python\ndef mul_return(a):\n\tb = a + 1\n\treturn a, b\n\nmul_return(1)\n출력결과 : (1, 2)\n```\n  \n`return a, b`는 사실상 `return (a, b)`와 동일한 것이다. `(a, b)`라는 튜플 하나를 반환하는 것이다.\n\n\u003cbr\u003e  \n\n- 추가적으로, 튜플을 가장 흔히 볼 수 있는 형태는 리스트 내부에 있는 형태이다.\n\n```python\ndata = [(1, 2), (3, 4), (5, 6)]\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny06":{"title":"06 - Dictionary","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 딕셔너리 자료형이란?  \n\n\u003cbr\u003e\n\n`{키 : 값}`의 대응 관계를 가지는 자료형이다. 연관 배열(Associative array) 또는 해시(Hash)라고도 한다. 리스트와 튜플과는 다르게 순차적이지 않고, 오직 키(Key)를 이용해 값(Value)를 얻어낸다.  \n\n**즉, 딕셔너리의 어떤 값을 찾기 위해 순차적으로 모든 키를 탐색할 필요 없이 해당하는 값의 키만 찾으면 된다는 의미이다.**\n  \n\u003cbr\u003e\n\n- **데이터 구조 : 딕셔너리 or 사전**\n\t- 선언 + 입력 : `변수명 = {}` 또는 `dict()` , `변수명 = {키:값}`\n\t- 읽기 : `변수명[키]`\n\t- 추가 : `변수명[새로운 키] = 새로운 값`\n\t- 삭제 : `del 변수명[삭제할 키]`\n\t- 수정 : `변수명[수정할 키] = 수정할 값`\n\n\u003chr\u003e\n\n## 02. 딕셔너리 다루기\n\n\u003cbr\u003e  \n\n딕셔너리를 다루기에 앞서 리스트, 튜플, 딕셔너리 빈 배열을 만드는 방법을 정리해보자면 아래와 같다.\n\n```python\ndata_list = list() # []\ndata_tuple = tuple() # ()\ndata_dict = dict() # {}\n```\n\n\u003cbr\u003e\n\n딕셔너리는 리스트와 튜플과는 다르게 순서가 없다고 했다. 그 말은, 인덱스를 이용해서 값을 뽑아내는 것이 불가능하고 오직, **딕셔너리의 키를 이용해서 값을 뽑아내는 것 말고는 방법이 없다는 말이다.**  \n\n\u003cbr\u003e\n\n- 딕셔너리 선언과 입력\n\n```python\ndata_dict = {'한국' : 'KR', '일본' : 'JP', '중국' : 'CN'}\nprint(data_dict['한국'])\n출력결과 : 'KR'\n\na = {1 : 'hi'}\nb = {'a' : [1, 2, 3]}\n```\n\n\u003cbr\u003e\n  \n- 딕셔너리 추가\n\n```python\ndata_dict = {'한국' : 'KR', '일본' : 'JP', '중국' : 'CN'}\ndata_dict['미국'] = 'US'\n  \nprint(data_dict)\n출력결과 : {'한국' : 'KR', '일본' : 'JP', '중국' : 'CN', '미국' : 'US'}\n```\n\n\u003cbr\u003e\n\n- 딕셔너리 삭제\n\n```python\ndata_dict = {'한국' : 'KR', '일본' : 'JP', '중국' : 'CN'}\ndel data_dict['한국']\n\nprint(data_dict)\n출력결과 : {'일본': 'JP', '중국': 'CN'}\n```\n\n\u003cbr\u003e  \n\n- 딕셔너리 수정\n\n```python\ndata_dict = {'한국' : 'KR', '일본' : 'JP', '중국' : 'CN'}\ndata_dict['한국'] = 'Korea'\n\nprint(data_dict)\n출력결과 : {'한국': 'Korea', '일본': 'JP', '중국': 'CN'}\n```\n  \n\u003chr\u003e\n\n## 03. 딕셔너리 응용  \n\n\u003cbr\u003e\n\n**딕셔너리 주의사항**\n\n\u003cbr\u003e\n\n1. 키가 중복되는 경우\n\n딕셔너리 다루기에서 딕셔너리는 키(Key)를 이용해 값(Value)를 얻어낸다고 하였다. 그러면 중복된 키가 존재한다면 어떻게 될까?\n\n키가 중복되면, 1개의 값을 제외하고 나머지 값은 무시된다. 키를 통해서 값을 얻는 딕셔너리의 특징 때문에 그러하다.\n\n```python\na = {1: 'a', 1: 'b', 1: 'c'}\nprint(a[1])\n  \n출력결과 : c\n```\n\n\u003cbr\u003e\n\n2. 키로 변하는 값을 설정할 수 없다.\n\n키(Key)는 값(Value)과는 다르게 변하지 않는 요소이다. 따라서, 리스트는 사용할 수 없지만 튜플은 사용할 수 있다. 리스트는 가변 객체이고 튜플은 불변 객체이기 때문이다.\n  \n```python\na = {[1, 2] : 'hi'}\nb = {(1, 2) : 'hi'}\n  \nprint(a)\nprint(b)\n  \n출력결과 : TypeError: unhashable type: 'list'\n출력결과 : {(1, 2): 'hi'}\n```\n\n\u003chr\u003e\n  \n## 04. 딕셔너리 다양한 함수\n\n\u003cbr\u003e  \n\n- keys()\n\t- 딕셔너리의 key 만을 모아서 dict_keys 객체를 반환\n- values()\n\t- 딕셔너리의 values 만을 모아서 dict_values 객체를 반환\n- items()\n\t- 딕셔너리의 keys와 values의 쌍을 튜플로 묶어서 dict_items 객체를 반환\n- clear()\n\t- 딕셔너리 안의 모든 요소 삭제\n- get()\n\t- 해당하는 key에 대응하는 value 반환\n- in\n\t- 해당하는 key가 딕셔너리 내부에 있는지 조사\n\n\u003cbr\u003e\u003cbr\u003e  \n\n**keys()**\n\n- 파이썬 2.7 버전 까지는 keys 함수를 사용할 경우 반환 값으로 dict_keys 객체가 아닌 리스트를 반환했다. 하지만, 리스트를 반환하기 위한 과정에서 메모리 낭비가 심해 파이썬 3.0 버전 이후에는 메모리 낭비를 줄이려고 dict_keys 객체를 반환한다. \u003cbr\u003e\u003cbr\u003e 반환 값으로 리스트가 필요한 경우에는 `list(a.keys())`를 사용하면 된다.\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\nprint(a.keys())\n  \n출력결과 : dict_keys([key1, key2, key3])\n  \n# type() 함수를 이용해서 봐도 리스트가 아닌 객체 타입임을 확인 가능\nprint(type(a.keys()))\n  \n출력결과 : \u003cclass 'dict_keys'\u003e\n```\n\n\u003cbr\u003e\n\n- 반복문을 이용해서 dict_keys 객체를 핸들링 할 수 있다. 리스트를 사용하는 것과 차이는 없지만, 리스트의 append, insert 같은 함수를 사용할 수는 없다.\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\n  \nfor key in a.keys():\n\tprint(key)\n\n출력결과 :\nkey1\nkey2\nkey3\n```\n\n- keys() 함수를 가장 많이 쓰는 형태는 아래이다.\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\n  \nfor key in a.keys():\n\tprint(a[key])\n\n출력결과 :\nvalue1\nvalue2\nvalue3\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**values()**\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\n  \nfor value in a.values():\n\tprint(value)\n\n출력결과 :\nvalue1\nvalue2\nvalue3\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**items()**\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\n  \nfor data in a.items():\n\tprint(data)\n\n출력결과 :\n('key1', 'value1')\n('key2', 'value2')\n('key3', 'value3')\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**clear()**\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\na.clear()\n  \nprint(a)\n출력결과 : {}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**get()**\n\n- get() 함수는 그냥 key를 이용해셔 value를 읽는 것과 동일한 역할을 한다.\n\n- 사용하는 이유는 존재하지 않는 key를 이용하여 value를 가져 오려고 할 때, 그냥 읽으면 오류를 반환하지만 `get() 함수를 이용해서 읽으면 none을 반환해준다.`\n\n```python\na = {'key1' : 'value1', 'key2' : 'value2'}\nprint(a[key3])\nprint(a.get('key3'))\n  \n출력결과 : NameError: name 'key3' is not defined\n출력결과 : None\n```\n  \n- 찾는 값이 없을 경우, None이 아닌 원하는 디폴트 값을 반환하도록 할 수 있다.\n  \n```python\na = {'key1' : 'value1', 'key2' : 'value2'}\nprint(a.get('key3', '해당하는 키가 없어요.'))\n\n출력결과 : 해당하는 키가 없어요.\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**in()**\n\n- 해당하는 키가 딕셔너리 안에 있는 지 조사하는 것이다.\n\n```python\na = {'key1' : 'value1', 'key2' : 'value2'}\nprint('key1' in a)\nprint('key3' in a)\nprint('value1' in a)\n  \n출력결과 : True\n출력결과 : False\n출력결과 : False # key가 아닌 value를 찾으니까 false로 나온다.\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny07":{"title":"07 - Set","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 집합 자료형이란?\n\n\u003cbr\u003e\n\n집합에 관련된 것을 쉽게 처리하기 위해 만든 자료형이다. 집합 자료형은 대표적인 특징이 두 가지가 있다.\n\n- 중복을 허용하지 않는다.\n- 순서가 없다.\n\n이 특징을 이용하여 `자료형의 중복을 제거하기 위한 필터 역할`로 사용할 수 있다. 또, 순서가 없다는 특징에서 리스트와 튜플처럼 인덱싱으로 접근할 수 없다. 딕셔너리와 비슷하다는 의미이다. 굳이 인덱싱으로 접근하고 싶다면 집합을 리스트나 튜플로 변환해서 사용하면 된다.\n\n\u003cbr\u003e\n\n- **데이터 구조 : 집합**\n\t- 선언 + 입력 : `변수명 = set()`, `변수명 = {데이터1, 데이터2, ... }`, `변수명 = set(데이터1)`, `변수명 = set({데이터1, 데이터2, ... })`\n\t- 읽기 : 그냥 읽어도 되고 반복문이나 조건문 이용\n\t- 추가 : 값 1개 추가 `add()`, 값 여러 개 추가 `update()`\n\t- 삭제 : `remove()`\n\n\u003chr\u003e\n\n## 02. 집합 다루기\n\n\u003cbr\u003e\n\n집합을 다루기에 앞서 리스트, 튜플, 딕셔너리, 집합 빈 배열을 만드는 방법을 정리해보자면 아래와 같다.\n\n```python\ndata_list = list() # []\ndata_tuple = tuple() # ()\ndata_dict = dict() # {}\ndata_set = set() # {}\n```\n\n`{}`는 딕셔너리와 동일하기 때문에 보통 빈 집합을 만들때는 `set()`을 주로 사용한다.  \n\n\u003cbr\u003e\n\n집합을 선언하는 것에는 여러 방법이 있다. 그 중 `{}`를 사용하는 방법을 딕셔너리와 헷갈리지 말자. 딕셔너리는 `{ 키 : 값 }`의 대응관계를 나타내줘야 하지만, 집합은 그냥 `{데이터1, 데이터2}` 이렇게 콤마로 나열해주면 된다.\n\n```python\ndata_set = set()\ndata_set1 = set({'data1', 'data2', 'data3'})\ndata_set2 = set(['data1', 'data2', 'data3'])\ndata_set3 = {'data1', 'data2', 'data3'}\n  \nprint(data_set)\nprint(data_set1)\nprint(data_set2)\nprint(data_set3)\n  \n출력결과 : set()\n출력결과 : {'data2', 'data3', 'data1'}\n출력결과 : {'data2', 'data3', 'data1'}\n출력결과 : {'data2', 'data3', 'data1'}\n```\n  \n\u003cbr\u003e\n\n집합을 읽을 때 그냥 읽어도 되지만 반복문을 이용해서 하나씩 읽을 수도 있다.\n\n```python\n# 반복문 이용\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\n  \nfor data in smartphone:\n\tprint(data)\n\n출력결과 :\n애플\n화웨이\nLG\n삼성\n  \n# 조건문 이용\nif '삼성' in smartphone:\n\tprint(smartphone)\n\n출력결과 : {'애플', '화웨이', 'LG', '삼성'}\n```\n\n\u003cbr\u003e \u003cbr\u003e\n\n1. 교집합\n\n`\u0026` 혹은 `s1.intersection(s2)` 사용\n\n```python\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\ntelevision = {'샤오미', '삼성', 'LG', '소니'}\n\n# 스마트폰, TV 둘 다 생산하는 업체\nprint(smartphone \u0026 television)\nprint(smartphone.intersection(television))\n  \n출력결과 : {'LG', '삼성'}\n출력결과 : {'LG', '삼성'}\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n\n2. 합집합\n\n`|` 혹은 `s1.union(s2)` 사용\n\n```python\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\ntelevision = {'샤오미', '삼성', 'LG', '소니'}\n  \n# 스마트폰 또는 TV를 생산하는 업체\nprint(smartphone | television)\nprint(smartphone.union(television))\n  \n출력결과 : {'샤오미', '삼성', '화웨이', 'LG', '애플', '소니'}\n출력결과 : {'샤오미', '삼성', '화웨이', 'LG', '애플', '소니'}\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n\n3. 차집합\n\n`-` 혹은 `s1.difference(s2)` 사용\n\n```python\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\ntelevision = {'샤오미', '삼성', 'LG', '소니'}\n  \n# 스마트폰만 생산하는 업체\nprint(smartphone - television)\nprint(smartphone.difference(television))\n  \n출력결과 : {'애플', '화웨이'}\n출력결과 : {'애플', '화웨이'}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n4. 대칭차집합\n\n`^` 사용, 전체에서 교집합을 뺀 것\n\n```python\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\ntelevision = {'샤오미', '삼성', 'LG', '소니'}\n\n# 스마트폰, TV 둘 다 생산하는 업체를 제외한 나머지\nprint(smartphone ^ television)\n  \n출력결과 : {'샤오미', '화웨이', '애플', '소니'}\n```\n\n\u003chr\u003e\n  \n## 03. 집합 다양한 함수들\n\n\u003cbr\u003e\n\n- add()\n\t- 값 1개 추가\n- update()\n\t- 값 여러 개 추가\n- remove()\n\t- 특정 값 제거\n- in()\n\t- 집합 내 특정 값 있는지 조사\n\n\u003cbr\u003e\n\n**add(), update(), remove()**\n\n```python\ns1 = set([1, 2, 3])\ns1.add(4)\nprint(s1)\n\n출력결과 : {1, 2, 3, 4}\n\ns2 = set([1, 2, 3])\ns2.update([4, 5, 6])\nprint(s2)\n\n출력결과 : {1, 2, 3, 4, 5, 6}\n\ns2.remove(5)\nprint(s2)\n\n출력결과 : {1, 2, 3, 4, 6}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**in()**\n\n```python\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\nprint('모토로라' in smartphone)\nprint('삼성' in smartphone)\n  \n출력결과 : False\n출력결과 : True\n```\n\n\u003chr\u003e\n\n## 04. 집합 응용\n  \n\u003cbr\u003e\n\n집합은 보통 \"`중복을 허용하지 않는다`\" 이 특성을 이용한다. 어떠한 리스트 자료형에 수백만 수천만의 데이터를 추가하다보면 중복이 발생할 수 있는데, 이 리스트를 집합으로 바꿨다가 다시 리스트로 바꾸면 중복된 데이터가 사라진다.\n\n```python\nsmartphone_list = ['애플', '삼성', '화웨이', '샤오미', '소니', 'LG', '애플', '삼성', '화웨이', '샤오미', '소니', 'LG', '애플', '삼성', '화웨이', '샤오미', '소니', 'LG', '애플', '삼성', '화웨이', '샤오미', '소니', 'LG', ]\n\ndata = set(smartphone_list)\nprint(data)\n\n출력결과 : {'샤오미', '삼성', '화웨이', 'LG', '애플', '소니'}\n# data를 다시 리스트로 바꿔서 사용하면 된다. list(data)\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny08":{"title":"08 - Bool","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 불 자료형이란?\n\n\u003cbr\u003e\n\n불 자료형은 참(True)과 거짓(False)를 다루는 자료형이다.\n\n- True : 참\n\n- False : 거짓\n\n\u003cbr\u003e  \n\n단순히 참과 거짓을 판별하는 것 이외에도 `자료형을 참과 거짓으로 판단할 수 있다.`\n\n- 문자열, 리스트, 튜플, 딕셔너리, 집합 등의 `값이 비어있으면 거짓, 있으면 참`\n\n- `0`은 False, `1`은 True\n\n- `None`은 False\n\n파이썬은 모든 것을 `객체`로 다룬다. 그 중 `NoneType` 클래스의 유일한 객체인 None은 값 자체가 없거나 존재하지 않거나 등의 경우를 의미한다. None에 대한 자세한 내용은 \u003ca href='https://jae-yoon.tistory.com/5' target='_blank'\u003e개발자 유니\u003c/a\u003e에 추가로 포스팅했다.\n  \n```python\nprint(type(None))\nprint(bool(None))\nprint(bool('None'))\n  \n출력결과 : \u003cclass 'NoneType'\u003e\n출력결과 : False # None은 False\n출력결과 : True # 이 None은 문자열 None이니까, True\n```\n\n\u003chr\u003e\n\n## 02. 불 자료형 다루기  \n\n\u003cbr\u003e\n\n- 리스트 내부에 값이 있으면 참이라는 것을 이용하여 반복문에 활용한 경우\n\n```python\na = [1, 2, 3, 4]\nwhile a :\n\tprint(a.pop())\n\n출력결과 :\n4\n3\n2\n1\n```\n  \n- 리스트 내부에 값이 있으면 True, 없으면 False를 이용하여 조건문에 활용한 경우\n\n```python\nif []:\n\tprint(\"참\")\nelse:\n\tprint(\"거짓\")\n\n출력결과 : 거짓\n  \nif [1, 2, 3, 4]:\n\tprint(\"참\")\nelse:\n\tprint(\"거짓\")\n\n출력결과 : 참\n```\n  \n- bool 값이 True 인지 False 인지 잘 모르겠으면 `bool()`을 사용하자\n\n```python\nprint(bool([1,2,3]))\nprint(bool([]))\nprint(bool(0))\nprint(bool(3))\n  \n출력결과 : True\n출력결과 : False\n출력결과 : False\n출력결과 : True\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny09":{"title":"09 - 변수심화","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 변수의 정확한 의미\n\n\u003cbr\u003e  \n\n`변수 = 값`의 형태로 계속 사용해왔다. `=(대입연산자, assignment)`는 우측의 값을 왼쪽 변수에 대입한다는 의미를 가진다. 조금 더 깊게 생각해보면, 파이썬은 모든 것을 객체로 다룬다고 했다.\n  \n쉽게 말해서, `우리가 지금까지 다뤄온 자료형은 객체라고 보면 된다.` 값을 생성하는 과정을 통해 자료형(객체)가 메모리에 공간을 할당받는다. 그러면 `변수가 값이 해당하는 메모리의 주소를 가리키게 된다.`  \n\n**마치, C언어의 포인터와 비슷한 느낌이다.** 실제로 변수에 값이 저장되는 것이 아니라 값이 저장되어 있는 메모리의 주소를 가리킬 뿐이다. 이를 코드로 확인해보면,\n\n```python\na = [1, 2, 3]\nprint(id(a))\n  \nb = a\nprint(id(b))\n  \n출력결과 : 140539428263424\n출력결과 : 140539428263424\n```\n  \n\u003cbr\u003e\n\na 변수에 리스트를 저장했고, a를 b에 대입한 것의 각각 메모리 주소를 확인해보면 동일한 것을 알 수 있다. 변수는 단지 메모리의 주소를 가리키는 것이기 때문이다.\n\n```python\na = [1, 2, 3]\nb = a\nprint(a is b)\n  \n출력결과 : True\n```\n  \n\u003cbr\u003e\n\n`a is b`가 뜻하는 바는 a와 b가 동일한 가 보다는 조금 더 정확하게 `a와 b가 가리키는 객체가 동일한가?`로 이해할 수 있다. 서로 가리키는 객체가 동일하기에 True가 반환된다. 이를 증명해보면,  \n\n\u003cbr\u003e\n  \n```python\na = [1, 2, 3]\nb = a\n  \na[1] = 4\n  \nprint(a)\nprint(b)\n  \n출력결과 : [1, 4, 3]\n출력결과 : [1, 4, 3]\n```\n  \n\u003cbr\u003e\n\n`a = [1, 2, 3]`인 상태를 b에 대입하고 난 이후에 a의 인덱스 값을 바꿨다. 그 이후에 b를 출력해보면 b 역시 바뀐 것을 알 수 있다. 즉, a라는 공간에 리스트를 넣어서가 아닌, `리스트 객체가 저장된 메모리의 주소를 a가 가리키기 떄문에, 또 b가 가리키기 때문에 이런 결과가 나타나는 것이다.`\n\n\u003chr\u003e\n\n## 02. 변수 다루기 응용\n\n\u003cbr\u003e\n\n값을 가져오면서 주소는 다르게 변수 복사도 가능하다. `즉, A라는 객체의 값을 가져오면서 새로 생성한 B라는 객체에 A의 값을 넣겠다는 의미이다.` A 객체의 값을 변경하더라도 B 객체는 애초에 다른 객체기 때문에 영향을 끼치지 않는다. 메모리 주소를 확인해봐도 주소가 다르다.\n\n\u003cbr\u003e\n\n- `[:]`을 사용하는 방법\n\n```python\na = [1, 2, 3]\nb = a[:]\na[1] = 4\n  \nprint(a)\nprint(b)\n  \n출력결과 : [1, 4, 3]\n출력결과 : [1, 2, 3]\n  \n# 서로 다른 메모리를 가리키는 것을 확인 가능하다.\nprint(id(a))\nprint(id(b))\n  \n출력결과 : 140011803112896\n출력결과 : 140011802234432\n```\n  \n\u003cbr\u003e\n\n- `copy 모듈`을 사용하는 방법\n  \n```python\nfrom copy import copy\n\na = [1, 2, 3]\nb = copy(a)\n\na[1] = 4\nprint(a)\nprint(b)\n  \n출력결과 : [1, 4, 3]\n출력결과 : [1, 2, 3]\n  \nprint(id(a))\nprint(id(b))\n  \n출력결과 : 139811777411136\n출력결과 : 139811777409472\n```\n\n\u003cbr\u003e\n\n- 리스트의 경우 `copy()` 함수 사용  \n\n```python\na = [1, 2, 3]\nb = a.copy()\na[1] = 4\n\nprint(a)\nprint(b)\n\n출력결과 : [1, 4, 3]\n출력결과 : [1, 2, 3]\n```\n\n\u003cbr\u003e\n\n- 다른 객체를 가리키는지 확인하려면 그냥 `is` 쓰면 되기는 한다.\n\n```python\na = [1, 2, 3]\nb = a.copy()\nc = a\n  \nprint(b is a)\nprint(c is a)\n  \n출력결과 : False\n출력결과 : True\n```\n\n\u003cbr\u003e\n\n- 변수 만들 때 `변수 = 값` 말고도 튜플, 리스트, 여러 개 대입 등도 가능하다.\n\n```python\na, b = ('hello', 'world')\n[c, d] = ['I', 'am']\ne = f = 3\n  \nprint((a, b))\nprint([c, d])\nprint(e, f)\n  \n출력결과 : ('hello', 'world')\n출력결과 : ['I', 'am']\n출력결과 : 3 3\n```\n\n\u003cbr\u003e\n\n- [[잔재미] Tuple](brain/Lecture/funny-python/funny05)에서 설명한 내용인데 이를 이용하여 변수를 손쉽게 바꿀 수 있다. 파이썬의 강력한 특징이다.\n\n```python\na = 'hello'\nb = 'world'\n\na, b = b, a\nprint(b, a)\n\n출력결과 : hello world\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny10":{"title":"10 - Condition","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 조건문 (if문)\n\n\u003cbr\u003e\n\n조건문은 어떠한 조건이 주어졌을 때, 그 조건에 해당한다면 명령어를 실행, 해당하지 않는다면 다른 명령어를 실행하는 구조이다. 즉, `참과 거짓을 판단하는 문장`으로 이해해도 무방하다. 다른 언어에서 많이 배웠으니 특별한 건 없다.\n\n\u003cbr\u003e\n\n```python\nif 조건문:\n\t수행할 문장1\nelif 조건문:\n\t수행할 문장2\n\t\t수행할 문장2-2\n\t\t수행할 문장2-3\nelse:\n\t수행할 문장3\n```\n\n\u003cbr\u003e  \n\n파이썬의 조건문에서 주의할 점은 조건 끝에 `:` 세미 콜론을 반드시 붙이는 것과 수행할 문장을 `들여쓰기` 하는 것이다. 내가 배웠던 C나 Java처럼 `{ }`로 묶는 것이 아니라 익숙하지 않을 것이다.\n\n\u003cbr\u003e\n\n들여쓰기에 관해서는 `탭(Tab)`으로 할 지 `공백(Space bar)`로 할 지는 의견이 갈린다. 나는 보통 탭을 사용하지만, 최근 파이썬 커뮤니티의 트렌드는 `공백(Space bar) 4번`을 쓰는 것을 권장한다고 한다. 그래서 나는 VScode 들여쓰기를 스페이스바 4번으로 설정해놨다.  \n\n\u003chr\u003e\n## 02. value와 data type 비교\n\n\u003cbr\u003e\n\n다른 언어에서도 값(value)과 자료형(data type)을 비교하는 방법이 존재한다. 자바 스크립트의 경우 `===` 연산자를 통해 간단하게 확인할 수도 있고, 자바의 경우 `equals()`를 통해 객체의 값이 같은지 확인할 수도 있다.  \n\n파이썬에서는 **값(Value)을 비교하는 경우는 `==`를 사용**하고, **객체(Object)를 비교하는 경우는 `is`를 사용**한다. 예시를 통해 자세히 살펴보겠다.  \n\n\u003cbr\u003e\n\n- 값이 다르고, 객체도 다른 경우\n\n```python\na = 1\nb = 2\n\nif a == b:\n\tprint(\"a와 b의 값이 동일\")\nelse:\n\tprint(\"a와 b의 값이 다름\")\n\nif a is b:\n\tprint(\"a와 b의 객체 같음\")\nelse:\n\tprint(\"a와 b의 객체 다름\")\n\n출력결과 : a와 b의 값이 다름\n출력결과 : a와 b의 객체 다름\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n- 값이 똑같고, 객체도 같은 경우 (1)\n\n```python\na = 1\nb = 1\n\nif a == b:\n\tprint(\"a와 b의 값이 같음\")\nelse:\n\tprint(\"a와 b의 값이 다름\")\n\nif a is b:\n\tprint(\"a와 b의 객체 같음\")\nelse:\n\tprint(\"a와 b의 객체 다름\")\n\n출력결과 : a와 b의 값이 같음\n출력결과 : a와 b의 객체 같음\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n- 값이 똑같고, 객체도 같은 경우 (2)\n\n```python\na = [1, 2, 3]\nb = a\n\nif a == b:\n\tprint(\"a와 b의 값이 같음\")\nelse:\n\tprint(\"a와 b의 값이 다름\")\n\nif a is b:\n\tprint(\"a와 b의 객체 같음\")\nelse:\n\tprint(\"a와 b의 객체 다름\")\n\n출력결과 : a와 b의 값이 같음\n출력결과 : a와 b의 객체 같음\n```\n\n\u003cbr\u003e\n\n- **값은 같은데, 객체가 다른 경우**\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\n  \nif a == b:\n\tprint(\"a와 b의 값이 같음\")\nelse:\n\tprint(\"a와 b의 값이 다름\")\n\nif a is b:\n\tprint(\"a와 b의 객체 같음\")\nelse:\n\tprint(\"a와 b의 객체 다름\")\n\n출력결과 : a와 b의 값이 같음\n출력결과 : a와 b의 객체 다름\n```\n\n\u003chr\u003e\n\n## 02. 조건부 표현식 (삼항연산자)\n\n\u003cbr\u003e\n  \n삼항연산자는 조건문이 길어지는 것을 한 문장으로 줄여서 가독성이 좋고 편의상 사용하는 것을 뜻한다. 보통 다른 언어에서는 아래와 같은 형식을 지원한다.\n\n- `[condition] ? [true_value] : [false_value]`\n\n- 조건(condition)이 참이면 `:`의 왼쪽을 실행, 거짓이면 우측을 실행한다.  \n\n\u003cbr\u003e\n\n\n```c++\n#include \u003cstdio.h\u003e\n  \nint main()\n{\n\tint num1 = 5;\n\tint num2;\n\t\n\tnum2 = num1 ? 100 : 200;\n\t// num1이 참이면 num2에 100을 할당, 거짓이면 num2에 200을 할당\n\n\tprintf(\"%d\\n\", num2);\n\t// 100: num1이 5이므로 참. num2에는 100이 할당됨\n\t\n\treturn 0;\n}\n```\n\n\u003cbr\u003e  \n\n하지만, 파이썬에서는 위와 같은 형태를 지원하지 않는다.  \n\n- `[true_value] if [condition] else [false_value]`\n\n- 영어식 표현으로 조금 더 직관적으로 이해 가능하다.\n\n\u003cbr\u003e\n\n  \n\n```python\na = 10\nprint(\"짝수\") if a % 2 == 0 else print(\"홀수\")\n\n출력결과 : 짝수\n```\n\n\u003cbr\u003e\n\n```python\narr = [1, 30, 20, -10, 10, 0, 24, 60, 3, -29]\nmin_value = arr[0]\nmax_value = arr[0]\n  \nfor val in arr:\n\tmin_value = val if val \u003c min_value else min_value\n\tmax_value = val if val \u003e= max_value else max_value\n  \n\tprint(f\"min_value : {min_value}\")\n\tprint(f\"max_value : {max_value}\")\n\n출력결과 : min_value : -29\n출력결과 : max_value : 60\n```\n\n\u003cbr\u003e\n\n참고로, 삼항 연산자도 중첩하여 elif를 표현하는 것이 가능하기는 한데, 그냥 사용 안하는 것이 더 직관적이므로 조건이 늘어나면 그냥 if문을 사용하자.\n\n\u003chr\u003e\n\n## 03. 특이한 조건문  \n\n\u003cbr\u003e\n\n파이썬은 문자, 리스트를 다루는 것에 강점을 가진 언어이다 보니 특이한 조건문을 지원한다. 해당하는 값이 안에 존재하면 True 없다면 False를 반환해준다.\n\n\u003cbr\u003e\n\n| in | not in |\n| -- | -------|\n| x in 문자열 | x not in 문자열 |\n| x in 리스트 | x not in 리스트 |\n| x in 튜플 | x not in 튜플 |\n  \n\u003cbr\u003e\n\n```python\nprint(1 in [1, 2, 3])\n출력결과 : True\n  \nprint(1 not in [1, 2, 3])\n출력결과 : False\n```\n\n\u003cbr\u003e  \n\n```python\npocket = ['paper', 'cellphone', 'money']\n\nif 'money' in pocket:\n\tprint(\"택시를 타고 가라\")\nelse:\n\tprint(\"걸어가라\")  \n\n출력결과 : 택시를 타고 가라\n```\n\n\u003cbr\u003e\n\n- 조건문의 참과 거짓에 따라 아무것도 안하게 하려면 `pass`를 사용한다.\n\n```python\npocket = ['paper', 'cellphone', 'money']\nif 'money' in pocket:\n\tpass\nelse:\n\tprint(\"돈이 없으면 카드를 내야지\")\n\n출력결과 :\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/funny-python/funny11":{"title":"11 - for문","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. for문 기본 구조\n\n- 리스트, 튜플, 문자열 이용\n\n```python\nfor 변수 in (리스트, 튜플, 문자열):\n\t실행문1\n\t실행문2\n\n\t...\n```\n\n\u003cbr\u003e\n\n- range() 이용\n\n```python\nfor 변수 in range(정수):\n\tprint(변수)\n```\n\n가장 기본적인 두 가지 구조이다. range()이용은 아래에서 다루도록 하고 다양한 예시를 통하는 것이 이해가 빨라서 여러 가지 예시를 들겠다.\n\n\u003cbr\u003e\n  \n- 리스트  \n\n```python\ntest_list = ['one', 'two', 'three']\n  \nfor i in test_list:\n\tprint(i)\n  \n[출력]\none\ntwo\nthree\n```\n\n\u003cbr\u003e\n\n- 튜플 응용  \n\n```python\na = [(1,2), (3,4), (5,6)]\n\nfor (first, last) in a:\n\tprint(first + last)\n\n[출력]\n3\n7\n11\n```\n\n\u003cbr\u003e  \n\n```python\nscore = [90, 25, 67, 45, 80]\nstudent_number = 0\n  \nfor i in score:\n\tstudent_number = student_number + 1\n\n\tif i \u003e= 60:\n\t\tprint(\"%d번 학생은 합격입니다.\" % student_number)\n\telse:\n\t\tprint(\"%d번 학생은 불합격입니다.\" % student_number)\n\n[출력]\n1번 학생은 합격입니다.\n2번 학생은 불합격입니다.\n3번 학생은 합격입니다.\n4번 학생은 불합격입니다.\n5번 학생은 합격입니다.\n```\n\n\u003cbr\u003e\n\n- continue 이용\n\n반복문 수행 도중 continue 만나면 그 즉시 다음 반복으로 진행한다. 아래의 예시에서 점수 변수 i가 60보다 작으면 조건이 참이니까 continue를 만나서 print()를 실행하지 않고 다음으로 넘어간다. 만약 60보다 크다면 조건문 입장에서는 거짓이니까 continue를 실행하지 않고 아래의 print()문을 실행하는 것이다.  \n\n```python\nscore = [90, 25, 67, 45, 80]\nstudent_number = 0\n  \nfor i in score:\n\tstudent_number = student_number + 1\n\tif i \u003c 60:\n\t\tcontinue\n\tprint(\"%d번 학생 축하합니다. 합격입니다. \" % student_number)\n```\n\n\u003chr\u003e\n\n## 02. for문과 range 함수  \n\nfor문을 쓸 때 리스트, 튜플, 문자열 외에도 간단히 숫자를 이용한 반복을 원할 때가 있다. 그때 사용하는 것이 `range()` 함수이다.\n\n- `range(10)`의 형태는 0 이상 10 미만의 숫자를 포함하는 range 객체 생성\n\n- `range(1,10)`의 형태는 1이상 10 미만의 숫자를 포함하는 range 객체 생성  \n\n```python\nsum = 0\n\nfor i in range(1, 11):\n\tsum = sum + i\n\tprint(sum)\n\n[출력]\n55\n```\n\n\u003cbr\u003e\n\n- 배열의 길이를 range()에 적용시킨 예제\n\n```python\nscore = [90, 25, 67, 45, 80]\nfor student_number in range(len(score)):\n\tif score[student_number] \u003c 60:\n\t\tcontinue\n\tprint(\"%d번 학생 축하합니다. 합격입니다.\" % (student_number + 1))\n```\n\u003cbr\u003e\n\n- range() 이용 구구단, 이중 for문\n\n`print('')` 공백 print()문 넣음으로 인해 줄바꿈 효과 넣은 것\n\n```python\nfor i in range(2,10): # ①번 for문\n\tfor j in range(1, 10): # ②번 for문\n\t\tprint(i * j, end=\" \")\n\tprint('')\n\n[출력]\n2 4 6 8 10 12 14 16 18\n3 6 9 12 15 18 21 24 27\n4 8 12 16 20 24 28 32 36\n5 10 15 20 25 30 35 40 45\n6 12 18 24 30 36 42 48 54\n7 14 21 28 35 42 49 56 63\n8 16 24 32 40 48 56 64 72\n9 18 27 36 45 54 63 72 81\n```\n\n\u003chr\u003e\n\n## 03. 리스트 안에 for문 넣기 (리스트 내포)\n  \n리스트 내포하는 방법은 `[표현식 for 항목 in 반복가능객체 if 조건문]` 이다. 조건이 필요하지 않다면 `if 조건문` 부분은 빼도 된다.\n\n\u003cbr\u003e  \n\n- 리스트 내포 전\n\n```python\na = [1, 2, 3, 4]\nresult = []\n\nfor num in a:\n\tresult.append(num * 3)\n\tprint(result)\n\n[출력]\n[3, 6, 9, 12]\n```\n\n\u003cbr\u003e  \n\n- 리스트 내포 후\n\n```python\na = [1, 2, 3, 4]\nresult = [num * 3 for num in a]\nprint(result)\n  \n[출력]\n[3, 6, 9, 12]\n```\n\n\u003cbr\u003e\n\n- 조건문 포함 리스트 내포\n\n```python\na = [1, 2, 3, 4]\nresult = [num * 3 for num in a if num % 2 == 0]\nprint(result)\n\n[출력]\n[6, 12]\n```\n\n\u003cbr\u003e\n\n- 리스트 내포 구구단 (이중 for문)\n\n```python\nresult = [x * y for x in range(2, 10)\n\t\t\t\tfor y in range(1, 10)]\nprint(result)\n\n[출력]\n\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45, 6, 12, 18, 24, 30, 36, 42, 48, 54, 7, 14, 21, 28, 35, 42, 49, 56, 63, 8, 16, 24, 32, 40, 48, 56, 64, 72, 9, 18, 27, 36, 45, 54, 63, 72, 81]\n```","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/kim-spring/":{"title":"김영한 - Spring","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/kim-spring/spring-basic/":{"title":"스프링 입문","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/kim-spring/spring-basic/spring-basic":{"title":"스프링 입문 - 목차","content":"\n\u003cbr\u003e\n\n\u003e [!note] 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2023.02.16 ~ 진행중\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e 기본적인 Spring 프레임워크에 대한 파악\n\n## 목차\n\n- [스프링 입문 : 섹션0 - 섹션3](brain/Lecture/kim-spring/spring-basic/spring-basic-01)","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/kim-spring/spring-basic/spring-basic-01":{"title":"스프링 입문 : 섹션0-섹션3","content":"\n\u003e 해당 게시글은 김영한님 \u003ca href='https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8' target='_blank'\u003e스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술\u003c/a\u003e강좌의 섹션0부터 섹션3까지 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 프로젝트 환경설정\n\n\u003cbr\u003e\n\n### 프로젝트 생성\n\n1. https://start.spring.io/ 스프링 프로젝트 생성\n\t- 프로젝트 생성\n\t- Project : Gradle\n\t\t- Spring Boot : (SNAPSHOT), (M~)는 정식 버전 아니니까 아무 것도 없고 숫자만 써진 버전으로 설정\n\t\t- Language : Java\n\t\t- Packaging : Jar\n\t\t- Java : 11\n\t- Project Metadata\n\t\t- Group : 보통 기업 도메인명 적어줌. 임의로 hello 적음\n\t\t- Artifact : 프로젝트명\n\t- Dependencies\n\t\t- 어떤 라이브러리를 당겨와서 사용할 것이냐\n\t\t- Spring Web 추가\n\t\t- Thymeleaf 추가 (프리마커 쓰는 회사도 있음)\n\n\u003cbr\u003e\n\n2. 인텔리제이로 프로젝트 오픈\n\n- 자바11로 프로젝트 생성했으니, 인텔리제이도 세팅 변경\n\t- 프로젝트 JDK 설정\n\t\t- File - Project Structure - Project Settings - Project\n\t\t- SDK : 11 Oracle OpenJDK version 11.0.16\n\t\t\t- Language level : SDK default\n\t\t- Platform Settings - SDKs - 1.8이 아닌 11로 설정\n- Gradle JDK 설정\n\t- File - Build, Execution, Deployment - Build Tools - Gradle\n\t\t- Build and run using : Gradle -\u003e IntelliJ (속도향상)\n\t\t- Run tests using : Gradle -\u003e IntelliJ (속도향상)\n\t\t- Gradle JVM : 11 Oracle OpenJDK\n\n\u003cbr\u003e\n\n3. 프로젝트 내용물 설명\n\n- gradle/wrapper : gradle 관련하여 사용하는 폴더\n- src : 기본적으로 main/test 두 갈래 생성\n- src/test : 최근 트렌드인 test 코드 관련, Junit5 기반\n- src/main/resources : 실제 java 코드 제외한 xml, properties, html 등 나머지 전부\n- gitignore : github에 올릴 때 제외할 파일들\n- gradlew, bradlew.bat, settings.gradle : 그래들 설정 관련\n- build.gradle : 예전에는 실제로 타이핑하고 코드 짰으나, 최근에는 start.spring.io와 같은 스프링부트 덕에 설정 파일이 제공됨\n\n\n```java\nplugins {\n\t// 선택한 스프링부트 버전과 자바 언어 등\n\tid 'org.springframework.boot' version '2.7.4'\n\tid 'io.spring.dependency-management' version '1.0.14.RELEASE'\n\tid 'java'\n} \n\ngroup = 'hello'\nversion = '0.0.1-SNAPSHOT'\n// 자바 11버전을 의미\nsourceCompatibility = '11'\n\nrepositories {\n\t// mavenCentral이라는 공개된 사이트에서 라이브러리 다운 받아오기\n\tmavenCentral()\n}\n\ndependencies {\n\t// start.spring.io에서 설정했던 의존관계\n\timplementation 'org.springframework.boot:spring-boot-starter-thymeleaf'\n\timplementation 'org.springframework.boot:spring-boot-starter-web'\n\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ntasks.named('test') {\n\tuseJUnitPlatform()\n}\n```\n\n\u003cbr\u003e\n  \n4. 생성한 프로젝트 실행\n\n\t- src/main/java/hello/hellospring/HelloSpringApplication.java 메인 메서드 그냥 실행\n\t- `@SpringBootApplication` 애노테이션이 있는 것이 스프링부트 실행 파일\n\t- `localhost:8080` 들어가서 Whitelabel Error Page 뜨면 성공\n\n  \n\n```java\npackage hello.hellospring;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloSpringApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(HelloSpringApplication.class, args);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n5. 스프링부트 실행 오류\n\n\t- 8080포트 이미 열려있어서 안되는 경우\n\t- cmd 관리자 권한으로 실행\n\t- `netstat -ano | findstr 8080`으로 열려있는 포트 확인\n\t- `taskkill /F /pid [process_id]`로 8080포트 닫기\n\n\u003cbr\u003e\n\n### 라이브러리 살펴보기\n\n- Maven, Gradle 같은 빌드 툴은 의존관계를 관리해준다. 실제 우리가 추가한 의존관계는 `Spring Web, Thymeleaf`인데, 외부 라이브러리를 확인해보면 수많은 라이브러리가 다운받아져있다. **의존관계에 따라 자기가 필요한 라이브러리들을 알아서 당겨온다.**\n\n- 인텔리제이 우측에 작은 Gradle 클릭해보면, 여러 의존관계 살펴볼 수 있음\n\n\u003cbr\u003e\u003cbr\u003e\n\n**compileClassPath : 스프링 부트 라이브러리**\n\n- spring-boot-starter-web\n\t- spring-boot-starter-tomcat : 웹서버\n\t- spring-webmvc : 웹 MVC\n- spring-boot-starter-thymeleaf : 타임리프 템플릿 엔진 (View)\n\t- spring-boot-starter\n\t\t- spring-boot\n\t\t\t- spring-boog-core\n\t\t- spring-boot-starter-logging\n\t\t\t- logback\n\t\t\t- slf4j\n\n\u003cbr\u003e\n\n- 톰캣은 WAS(Web-Application-Server)이다.\n\n\t- 예전에는 서버에 톰캣같은 웹서버를 설치해놓고 거기에 자바 코드를 밀어놓는 식으로 개발했음. 웹서버와 개발 라이브러리가 완전히 분리되어 있었음\n\n\t- 최근에는 소스 라이브러리에서 이런 웹서버를 알아서 들고있음(임베디드, 내장) 그래서 자바 메인 메서드만 실행해도 따로 설정 필요없이 웹서버가 뜬다. 8080포트로 들어갈 수도 있음\n\n- 실무에서, `system.out.println()` 방식으로 출력하지 않고 log를 사용한다.\n\n\t- 심각한 로그를 따로 관리하거나, 로그 파일이 관리가 됨\n\n\t- slf4j는 인터페이스이고 logback은 실제 로그를 어떤 구현체로 출력할 지\n\n\t- 최근에는 slf4j + logback 조합을 보통 사용한다. 성능도 빠르고 지원하는 기능 많음\n\n\u003cbr\u003e\u003cbr\u003e\n\n**testCompileClasspath : 테스트 라이브러리**\n\n- spring-boot-starter-test\n\t- junit : 테스트 프레임워크 (최근에는 junit 5버전 사용, 핵심)\n\t- mockito : 목 라이브러리\n\t- assertj : 테스트 코드 작성을 더 쉽게 해주는 라이브러리\n\t- spring-test : 스프링 통합 테스트 지원\n\n\u003cbr\u003e\u003cbr\u003e\n\n### View 환경설정\n\n**Welcome Page 만들기** \u003cbr\u003e\n\n`resources/static/` 경로에 `index.html` 파일을 추가하면, welcome page의 기능을 한다. 이는 단순한 정적 페이지이다.\n\n```html\n// resources/static/index.html\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\t\u003chead\u003e\n\t\t\u003ctitle\u003eHello\u003c/title\u003e\n\t\t\u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /\u003e\n\t\u003c/head\u003e\n\t\u003cbody\u003e\n\t\tHello\n\t\t\u003ca href=\"/hello\"\u003ehello\u003c/a\u003e\n\t\u003c/body\u003e\n\u003c/html\u003e\n```\n\n- \u003ca href='https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.welcome-page' target='_blank'\u003espring boot docs - welcomepage\u003c/a\u003e\n\n- \u003ca href='https://spring.io/guides/gs/serving-web-content/' target='_blank'\u003e스프링 공식 튜토리얼\u003c/a\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n**thymeleaf 템플릿 엔진** \u003cbr\u003e\n\n템플릿 엔진을 사용하여, 동적인 페이지를 구현할 수 있다.\n\n- \u003ca href='https://www.thymeleaf.org/index.html' target='_blank'\u003ethymeleaf official hompage\u003c/a\u003e\n\n- \u003ca href='https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.template-engines' target='_blank'\u003e스프링부트 템플릿 엔진 메뉴얼\u003c/a\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n웹 어플리케이션에서 첫 번째 진입점이 바로 **Controller, 컨트롤러**이다.\n\n1. `hello/hellospring/controller` 패키지 생성\n\n2. 패키지에 `HelloController.java` 생성\n\n3. `resources/templates/hello.html` 생성\n\n\n```java\n// src/main/java/hello/hellospring/controller/HelloController.java\npackage hello.hellospring.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Controller\npublic class HelloController {\n\n\t@GetMapping(\"hello\")\n\tpublic String hello(Model model) {\n\t\tmodel.addAttribute(\"data\", \"hello!!\");\n\t\treturn \"hello\";\n\t}\n}\n\n```\n\n- `@GetMapping(\"hello\")` : get/post 방식 말할 때 그 get이다. `localhost:8080/hello`와 mapping\n\n- model의 속성으로 키 : data, 값 : hello!!를 넘긴다.\n\n- `return \"hello\"`로 `/resources/templates/hello`를 찾아서 렌더링 함\n\n\u003cbr\u003e\n\n```html\n// resources/templates/hello.html\n\u003c!DOCTYPE html\u003e\n\u003chtml xmlns:th=\"http://www.thymeleaf.org\"\u003e\n\t\u003chead\u003e\n\t\t\u003ctitle\u003eHello\u003c/title\u003e\n\t\t\u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /\u003e\n\t\u003c/head\u003e\n\t\u003cbody\u003e\n\t\t\u003cp th:text=\"'안녕하세요. ' + ${data}\"\u003e안녕하세요. 손님\u003c/p\u003e\n\t\u003c/body\u003e\n\u003c/html\u003e\n```\n\n- `http://www.thymeleaf.org`를 추가함으로써 타임리프 문법 사용 가능\n\n![](brain/image/spring-basic-01-1.png)\n\n1. 웹 브라우저에서 `localhost:8080/hello`로 get 요청\n2. 내장된 톰캣이 웹서버의 역할을 하여 받아서 controller로 전달\n3. 스프링이 컨트롤러에 맵핑된 `hello`가 있나 찾아봄.\n4. controller인 helloController의 메서드가 실행된다. 이때 스프링이 Model을 만들어서 model을 controller에 넣어준다.\n5. controller는 이 model에다가 키 : data, 값 : hello!!를 넣는다.\n6. `/resources/templeates/hello`를 찾고 model을 화면에 넘기면서 화면을 렌더링해라\n\t- 즉, 컨트롤러에서 리턴 값으로 문자를 반환하면 뷰 리졸버( viewResolver )가 화면을 찾아서 처리하게 된다.\n\t- 뷰 리졸버는 View를 찾아주고 템플릿 엔진 연결시켜주는 녀석\n\t- 찾을 때, 스프링 부트 템플릿 엔진 기본 viewName에 매핑\n\t- `resources:templates/` + {ViewName} + `.html`\n\n\u003cbr\u003e\u003cbr\u003e\n\n**서버 재시작 없이 View 파일 리로드**\n\n1. `build.gradle`에 의존성 추가 (spring-boot-devtools 라이브러리 설치해준 것)\n\t- `developmentOnly 'org.springframework.boot:spring-boot-devtools'`\n2. `/resources/application.properties`에 아래 코드 추가 (필수는 아님)\n\n```java\nspring.devtools.livereload.enabled=true\nspring.devtools.restart.enabled=true\n```\n\n3. File - Settings - Advanced Settings - Compiler에서 `Allow auto-make to start~` 체크\n\n4. File - Settings - Build, Execution~ - Compiler에서 `Build project automatically` 체크\n\n이제 View 파일 수정하면 한 5초 뒤에 서버가 알아서 리로드 되면서 크롬 가서 새로고침 해보면 확인 가능하다. 만약, 새로고침 없이 보고 싶으면 크롬 확장 프로그램 Livereload 설치하셈\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 빌드하고 실행하기\n\n빌드하고자 하는 프로젝트 폴더로 이동하고 거기서 마우스 우클릭으로 `Git Bash Here` 혹은 `터미널에서 열기` 클릭! WSL2 java 관련 설정은 [Java Settings](brain/Java/java-settings) 참고\n\n1. `./gradlew build`\n2. `cd build/libs`\n3. `java -jar hello-spring-0.0.1-SNAPSHOT.jar`\n\n이러면 서버 실행 완료된 것! 종료 하려면 `Ctrl + C`\n\n- 빌드 폴더 깔끔하게 지우기 `./gradlew clean`\n\n\u003chr\u003e\n\n## 스프링 웹 개발 기초\n\n웹을 개발한다는 것은 크게 3가지 방법이 있다.\n\n- 정적 컨텐츠 : welcomepage처럼 서버에서 하는 것 없이 파일을 그대로 웹 브라우저에게 내리는 것\n\n- MVC와 템플릿 엔진 : jsp, php가 흔히 말하는 템플릿 엔진인데 html을 그냥 주는 것이 아니라 서버에서 프로그래밍 해서 html을 동적으로 바꿔서 내리는 것. 이 작업을 하기 위하여 Model, View, Controller 패턴으로 개발\n\n- API : JSON 형식으로 데이터를 전달해주는 방식\n\n\u003cbr\u003e\n\n사실 정적 컨텐츠 방식을 제외하면, 이렇게 생각하면 된다.\n\n- MVC 방식처럼 View를 찾아서 템플릿 엔진을 통해 화면을 렌더링해서 HTML을 변환하여 HTML 파일을 웹 브라우저에 넘겨주는 방식, **HTML을 내리냐**\n\n- API를 사용하여 **데이터를 바로 내리냐**\n\n\u003cbr\u003e\n\n### 정적 컨텐츠\n\n스프링 부트는 정적 컨텐츠를 \u003ca href='https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.static-content' target='_blank'\u003e제공\u003c/a\u003e하고 있다. `/resources/static` 폴더에 아무 html 파일을 만들면 그대로 반환해준다. 만약 `hello-static.html` 파일을 만들었다면, `localhost:8080/hello-static.html`로 들어가면 나온다.\n\n![](brain/image/spring-basic-01-2.png)\n\n  \n\n1. 웹브라우저에서 `localhost:8080/hello-static.html`로 get 요청\n\n2. 내장 톰캣 서버가 요청을 받고 스프링에게 넘김\n\n3. 스프링은 컨트롤러 쪽에서 `hello-static`과 맵핑된 컨트롤러 있나 찾아봄\n\n4. 없으면 `resources: statc/hello-static.html`을 찾고 있으면 반환해줌\n\n\u003cbr\u003e\n\n### MVC와 템플릿 엔진\n\nMVC : Model, View, Controller\n\n과거에는 컨트롤러와 뷰를 따로 분리하지 않고 JSP 같은걸로 뷰에 모든 걸 다했다. 이것이 **Model 1 방식**이다. 하지만, 지금은 MVC 패턴으로 많이 한다. 그 이유는 **관심사의 분리, 역할과 책임** 때문이다.\n\nView는 화면을 그리는 것에 모든 역량을 집중해야 하고, Controller나 Model과 관련된 부분은 비즈니스 로직과 관련있거나 내부적인 걸 처리하는 것에 집중해야 한다.\n\n\u003cbr\u003e\n\n`HelloController.java`에 내용 추가\n\n```java\n@GetMapping(\"hello-mvc\")\npublic String helloMvc(@RequestParam(\"name\") String name, Model model) {\n\tmodel.addAttribute(\"name\", name);\n\treturn \"hello-template\";\n}\n```\n\n- `hello-mvc` get 요청에 맵핑\n\n- 외부, 웹에서 파라미터를 받기 위하여 `@RequestParam()`을 사용\n\n- 당연히 Model은 넘겨줘야지\n\n- `addAttribute`에서 파라미터로 넘어온 name을 넘긴다.\n\n\u003cbr\u003e\n\n`resources/templates/hello-static.html`\n\n```html\n\u003chtml xmlns:th=\"http://www.thymeleaf.org\"\u003e\n\t\u003cbody\u003e\n\t\t\u003cp th:text=\"'hello ' + ${name}\"\u003ehello! empty\u003c/p\u003e\n\t\u003c/body\u003e\n\u003c/html\u003e\n```\n\n- 템플릿 엔진으로써 잘 동작하면 th:text의 값인 `'hello ' + ${name}`로 우측의 내용(hello! empty)이 치환이 된다.\n\n\u003cbr\u003e\n\n타임리프 템플릿의 장점은 html을 쓰고 서버 없이 파일을 열어서 껍데기를 볼 수 있는 것이다. `템플릿 파일명 우클릭 - Copy Path/References.. - Absolute Path 복사`하고 웹 브라우저 링크에 치면 볼 수 있다.\n\n\u003cbr\u003e\n\n여기까지 하고 `localhost:8080/hello-mvc`를 입력하면!? `Required request parameter 'name' for method parameter type String is not present]`라는 오류가 콘솔창에 뜬다. 파라미터를 입력해주지 않았기 때문이다. 인텔리제이에서 필요한 파라미터가 무엇인지 볼 때 `Ctrl + P`를 누르면 뜬다.\n\n![](brain/image/spring-basic-01-3.png)\n\n`boolean required() default true`인 것으로 보아 반드시 값이 필요한게 디폴트 설정이다. 따라서, 웹 브라우저 창에 `localhost:8080/hello-mvc?name=name에 들어갈 문자열`을 넣어주면 된다. 그러면 결과로 `'hello ' + ${name}`이니까 `hello name에 들어갈 문자열`이라는 모습이 보일 것이다.\n\n![](brain/image/spring-basic-01-4.png)\n  \n다시 한번, **달러($) 사인에 들어가는 것은 Model에서 뽑아온 key에 해당하는 value이다.** `model.addAttribute(\"name\", name);`이라고 했으니까 `name`이라는 key에서 `name`이라는 value를 가져오는 것!\n\n\u003cbr\u003e\n\n![](brain/image/spring-basic-01-5.png)\n\n1. 웹브라우저에서 `localhost:8080/hello-mvc`로 get 요청\n\n2. 내장 톰캣 서버가 요청을 받고 스프링에게 넘김\n\n3. 스프링은 컨트롤러 쪽에서 `hello-mvc`와 맵핑된 컨트롤러 있나 찾아봄\n\n4. 있으니까 `hello-template`으로 넘기고 `model(name:문자열)`을 넘김.\n\n5. 뷰 리졸버 (viewResolver)가 return의 `hello-template`와 같은`templates/hello-template.html`를 찾아서 타임리프 템플릿 엔진에 처리해달라고 넘김\n\n6. 템플릿 엔진이 렌더링해서 변환한 HTML 파일을 웹 브라우저에 반환\n\n\u003cbr\u003e\n\n### API\n\nMVC 방식과는 다르게 (HTML 파일을 내리는 방식과는 다르게) API는 데이터를 바로 내리는 방식이다. \n\n\u003cbr\u003e\n\n`HelloController.java`에 내용 추가\n\n```java\n@GetMapping(\"hello-string\")\n@ResponseBody\npublic String helloString(@RequestParam(\"name\") String name) {\n\treturn \"hello \" + name;\n}\n```\n\n- `hello-string` get 요청에 맵핑\n\n- `@ResponseBody`의 body는 html의 `\u003cbody\u003e\u003c/body\u003e`를 의미하는 것이 아니라 HTTP의 `헤더부와 바디부`를 의미하는 것이다. HTTP의 응답 body에 이 내용을 직접 넣어주겠다는 의미이다.\n\n- 템플릿 엔진과는 다르게 view 이런게 없어서 저 return 문자가 그대로 내려간다.\n\n![](brain/image/spring-basic-01-6.png)\n\n이렇게 페이지 소스보기 해보면 html 태그 같은거 안뜨고 **문자 데이터 자체**가 그대로 왔다. 그러면, 본격적으로 api를 사용해보도록 하자. 객체를 만들어서 JSON 형식(`key : value`)으로 데이터를 보내보자.\n\n\u003cbr\u003e\n\n`HelloController.java`에 내용 추가\n\n```java\n@GetMapping(\"hello-api\")\n@ResponseBody\npublic Hello helloApi(@RequestParam(\"name\") String name) {\n\tHello hello = new Hello();\n\thello.setName(name);\n\treturn hello;\n}\n\nstatic class Hello {\n\tprivate String name;\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t  \n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n```\n\n- static은 기억나지? 힙에 올리는게 아니라 그냥 클래스 변수로 만들어서 올리고 아무데서나 사용할 수 있게 만들었던거\n\n- private으로 해놨으니까 getter, setter 만들어준거고.\n\n- helloApi에서 hello 객체 만들고 setName으로 들어온 리퀘스트 파라미터인 name 넣어준거고!\n\n- 마지막으로 hello 객체를 반환해줌\n\n![](brain/image/spring-basic-01-7.png)\n\n![](brain/image/spring-basic-01-8.png)\n\n1. 웹브라우저에서 `localhost:8080/hello-api`로 get 요청\n2. 내장 톰캣 서버가 요청을 받고 스프링에게 넘김\n3. 스프링은 컨트롤러 쪽에서 `hello-api`와 맵핑된 컨트롤러 있나 찾아봄\n4. 있네. 근데 `@ResponseBody` 애노테이션이 붙어있네?\n\t- 저게 없으면, viewResolver에게 던져서 view에 맞는 템플릿 엔진 연결해줬잖아\n\t- 얘는 HTTP body 응답에 이걸 그대로 넘겨야겠구나 라고 생각\n\t- 근데, 문자였으면 바로 넣어서 주면 끝인데, 객체일 경우는 어떻게 해야할까?\n\t- 객체가 오면, 기본 default가 json 방식으로 데이터를 만들어서 HTTP 응답에 반환하겠다가 기본 정책!\n5. `viewResolver`가 아닌, `HttpMessageConverter`가 동작\n6. 단순 문자면 `StringConverter`가 동작. 객체이면 `JsonConverter`가 동작\n7. 이것을 응답으로 웹 브라우저에 \n\n\u003cbr\u003e\n\n- 기본 문자처리 : `StringHttpMessageConverter`\n- 기본 객체처리 : `MappingJackson2HttpMessageConverter`\n\t- 객체를 json으로 변환해주는 유명한 라이브러리 대표적인 2개\n\t\t- Jackson version 2\n\t\t- Gson (구글에서 만든거)\n\t- 스프링은 기본적으로 잭슨 라이브러리를 채택!\n- 참고 : 클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보를 조합해서 `HttpMessageConverter`가 선택된다. 예를 들어, 클라이언트 쪽에서 XML을 요청하면 서버 쪽에서 XML 라이브러리를 끼워넣고 XML로 보낼 수 있다는 말이다. 근데 그냥 마음 편하게 json으로 하자 ^^ 다 json으로 한다.","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Lecture/kim-springboot/":{"title":"김영한 - SpringBoot/JPA","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/brain/Spring/":{"title":"Spring","content":"","lastmodified":"2023-03-15T12:59:54.127610282Z","tags":null},"/project":{"title":"Project","content":"","lastmodified":"2023-03-15T12:59:54.287608372Z","tags":null}}