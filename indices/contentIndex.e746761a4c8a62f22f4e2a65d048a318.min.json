{"/about":{"title":"About","content":"","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain":{"title":"Brain","content":"","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/":{"title":"_index","content":"","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Book/":{"title":"도서","content":"","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/dinosaur/":{"title":"운영체제 - 공룡책","content":"","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/dinosaur/chap01":{"title":"01. 서론","content":"\n# Chapter 01 - 운영체제 서론\n\n\u003cbr\u003e\n\n\u003e 해당 게시글은 **운영체제 - 공룡책** 교재와 인프런의 \u003ca href='https://www.inflearn.com/course/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EB%A3%A1%EC%B1%85-%EC%A0%84%EA%B3%B5%EA%B0%95%EC%9D%98' target='_blank'\u003e주니온 님의 운영체제 공룡책 강의\u003c/a\u003e를 함께 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 주니온 강의\n\n### 컴퓨터, 정보 기초\n\n운영체제(Operating System)는 컴퓨터 하드웨어를 작동시키는 소프트웨어라고 하는데, 여기서 **컴퓨터라는 것은 어떤 것을 의미하나 ?**\n- ==**정보(Information)**==을 처리하는 기계\n\n\u003cbr\u003e\n\n**정보라는 것은 어떤 것을 의미하나?**\n- 클로드 섀넌이 정보에 대하여 수학적으로 정의하였는데, a quantitative representation that measures the uncertainty 라고 하였다.\n- 즉, ==**불확실한 상황을 측정하고 이를 수치화하여 표현한 것**==이 정보이다.\n\n\u003cbr\u003e\n\n$$\nI(x) = -log_2 P(x)\n$$\n\n이는, **어떤 사건 $x$의 정보량 = 사건 $x$가 발생할 확률에 $-log_2$ 한 것**을 의미한다.\n- 예를 들어, 동전을 던져서 앞면과 뒷면이 나올 확률이 $\\frac{1}{2}$이라고 하자.\n- $I(동전 던진 사건의 정보량) = -log_2 2^{-1} = 1$\n- 정리하자면, ==**$\\frac{1}{2}$의 사건이 되는 단위, 정보의 최소 단위 bit (binary digit)가 되는 것**==이다. \n\t- 0과 1이 왜 최소 단위 1bit인지 이제 감 잡히나?\n\t- $2^{3} = 8$bits 는 1byte !\n\n\u003cbr\u003e\n\n**컴퓨터는 정보를 어떻게 처리하나?**\n- 정보의 처리는 정보의 상태 변환 (0 → 1, 1 → 0)을 의미\n- 부울 대수 (Boolean Algebra)인 NOT, AND, OR과 같은 조작을 위한 스위치를 만들기 위해 물리적인 소자 트랜지스터를 이용가능\n- 논리 게이트를 이용하여 여러 정보의 처리 가능\n- 논리 회로 : 논리 게이트가 모인 \u003ca href='http://www.ktword.co.kr/test/view/view.php?no=3597' target='_blank'\u003e집적 회로\u003c/a\u003e (IC, Intergrated Circuit)\n\t- 무어의 법칙 : 논리 게이트 집적도가 1년 6개월 마다 2배씩 증가\n\t- 황의 법칙 : 메모리가 1년에 2배씩 증가\n\t- 하드웨어의 발전은 양자간섭현상, 양자중첩현상에 의해 이미 거의 한계에 다다름\n- 정보의 저장은 플립-플롭을 이용하여, 전송은 데이터 버스 혹은 RF(무선)를 이용하여\n\n\u003cbr\u003e\n\n**본질적인 컴퓨터의 정보 처리 방법**\n- 덧셈 : 반가산기, 전가산기\n- 뺄셈 : 2의 보수 표현법\n- 곱셈, 나눗셈 : 덧셈과 뺄셈의 반복\n- 실수 연산 : 부동 소수점 표현법\n- 함수 : GOTO\n\n\u003cbr\u003e\n\n**그렇다면, 컴퓨터는 만능인가?**\n- NOT, AND, OR 게이트만으로 모든 계산을 할 수 있는 **범용성(universality) 있는 기계**\n- NAND 게이트만으로도 모든 계산을 할 수 있음\n- **범용 컴퓨터(general-purpose computer)**  : 특정한 목적을 가지고 만들어진 것은 컴퓨터라고 하지 않고, 소프트웨어가 하고자 하는 것들을 하드웨어가 지원하는 범용적인 형태라면 범용성 있는 컴퓨터, universality를 가지고 있다고 한다.\n\n\u003cbr\u003e\n\n### 튜링머신\n\n**모든 컴퓨터의 할아버지는 튜링 머신**\n\n![](brain/image/chap01-1.png)\n\n- 튜링 머신에 대한 자세한 설명은 \u003ca href='https://ttl-blog.tistory.com/743' target='_blank'\u003e링크\u003c/a\u003e 참조\n- 저장장소가 없다면 유한 오토마타, 저장장소가 스택이라면 푸시다운 오토마타\n- 튜링 머신은 임시 저장소가 테이프인 \u0008오토마타\n\n\u003cbr\u003e\n\n### 폰 노이만\n\n**모든 컴퓨터의 아버지는 폰 노이만**\n\n![](brain/image/chap01-2.png)\n\n- 오토마타인 튜링 머신과는 다르게 ==**메모리에 프로그램을 저장하는 내장형(stored-program) 컴퓨터**==이면서 RAM으로 부터 명령어를 fetch, CPU에서 execute 하는 ==**fetch-execute 사이클 컴퓨터**==를 최초 개발한 사람이 폰 노이만\n- 이런 것을 ==**폰 노이만 아키텍처**==라고 함\n\t- 명령어 집합인 [ISA (Instruction Set Architecture)](brain/CS/CA/ISA)로 컴퓨터를 운영하는 것\n\n\u003cbr\u003e\n\n### 프로그램\n\n**프로그램(program)은 뭔데?**\n- 프로그램 : ==**컴퓨터의 하드웨어에게 특정 task를 수행시키는 명령어들의 집합**==\n\n\u003cbr\u003e\n\n==**그래서, 운영체제도 프로그램인가?**==\n- 컴퓨터 위에서 항상 실행 중인 프로그램\n- 시스템 서비스를 애플리케이션 프로그램에 제공\n- 운영체제가 하는 일\n\t- 프로세스 관리 (가장 중요)\n\t- 리소스\n\t- 유저 인터페이스 (I/O 관련)\n\t- 기타 등등\n\n\u003cbr\u003e\u003chr\u003e\n\n## 공룡책\n\n==**운영체제(Operating System)는 컴퓨터 하드웨어를 관리하는 소프트웨어**==\n- 목적 : 사용자가 프로그램을 편리하고 효율적으로 수행할 수 있는 환경을 제공하도록\n- 책임 : ==**자원들을 프로그램에 할당하는 것**==\n\n\u003cbr\u003e\n\n### 시스템 구성요소\n\n![](brain/image/chap01-3.png)\n\n\u003cbr\u003e\n\n**컴퓨터 시스템 구성요소**는 \"H/W + O/S + Application + User\" 로 구성된다.\n- H/W : 기본 계산용 자원 제공\n- Application : 계산 문제 해결을 위하여 자원이 어떻게 사용될지 정의\n- O/S : ==**Application 간 하드웨어 사용을 제어하고 조정**==\n\n\u003cbr\u003e\n\n**1. 하드웨어 기반의 컴퓨터 자원들 (computing resources)**\n\n\"CPU, memory(HDD/RAM), I/O devices\" 정도가 있는데, 하드웨어 기반의 컴퓨터 자원들은 이정도가 거의 전부이다. 이중 memory의 RAM은 CPU에 들어가는 명령어들을 버퍼링 시켜준다. 이 과정이 어떻게 발생하는지 간단히 알아보자.\n\n\u003cbr\u003e\n\n**1-1. HDD → CPU** : HDD에 컴파일 된 명령어가 저장되어 있는데, 이것을 CPU에 직접 올려서 실행시키는 데는 너무 오래 걸린다.\n\n![](brain/image/chap01-4.png)\n\n\u003cbr\u003e\n\n**1-2. HDD → RAM → CPU** : 따라서, RAM을 거치게 되는데, 이때 HDD에 저장된 소프트웨어 일부를 떼어내서 RAM에 올리는 작업을 한다. 일부를 떼어낼 때 페이지(page) 단위로 작업하기 때문에 이를 페이징 기법(paging) 이라고 한다.\n\n![](brain/image/chap01-5.png)\n\n\u003cbr\u003e\n\n**1-3. RAM과 컴퓨터 실행 속도의 연관성** : HDD에 저장된 소프트웨어를 더블클릭하여 실행해서 프로세스 형태로 RAM에 올린다. CPU가 (1), (2)처럼 명령어를 실행하는 동안 I/O devices가 HDD-\u003eRAM 으로 계속 올려주는 작업이 동시다발적 (concurrency)으로 일어나고 있다. **따라서, CPU가 보는 RAM은 마치 무한해 보인다**\n\n추가로, HDD -\u003e RAM -\u003e CPU 순서로 갈수록 속도는 빨라지며 용량은 작아진다. 용량이 작아지기 때문에 HDD에 저장된 소프트웨어의 크기가 크다면 페이징 기법으로 쪼개서 넘겨주는 것이다. **즉, RAM의 용량이 작으면 컴퓨터 실행 속도가 느리다는 것이다. 용량이 작기 때문에 페이지를 잘게 쪼개야 하고, 그렇게 되면 I/O 과정이 너무 많아지면서 느려지는 것이다. 이 말은, RAM 용량이 크다면 페이징을 크게 크게 할 수 있다는 의미이고, RAM은 컴퓨터의 실행 속도에 큰 영향을 끼친다는 뜻이다**\n\n![](brain/image/chap01-6.png)\n\n\u003cbr\u003e\n\n**2. 운영체제 (Operating System)**\n\n운영체제가 반드시 실행되어야 컴퓨터가 돌아가는데 그러면 운영체제도 RAM에 올려야 할까? 답은 YES이다. HDD에서 RAM으로 올릴 때 더블클릭해서 실행중인 프로세스 형태로 만들어서 올려야 하는데 우리가 더블클릭 하는 과정 없이 전원만 켜도 운영체제가 RAM에 올라가는 것은 어떤 원리일까?\n\n![](brain/image/chap01-7.png)\n\n제조사에서는 ROM(Read Only Memory)라는 수정이 불가능하고 읽기만 가능한 것을 만들어 놓는다. 이것을 이용한다.  \n\n- (1) 컴퓨터 전원을 킴\n- (2) ROM의 명령어들이 실행\n    - (2-1) I/O 하드웨어가 잘 연결되어 있는지 확인\n    - (2-2) HDD에 저장되어있는 운영체제를 RAM에 적재하기\n- (3) RAM에 올라간 운영체제를 CPU에 밀어넣으면 운영체제가 구동\n\n\u003cbr\u003e\n\n**3. 응용 프로그램 (Application Program)**\n\n유저가 컴퓨터를 사용하는 과정에서 발생하는 다양한 컴퓨팅 문제들을 해결하기 위해 시스템 리소스(자원)들이 사용되는 방식을 정의하는 것이다. 응용 프로그램에는 워드 프로세서, 컴파일러, 웹 브라우저, 데이터베이스 시스템, 게임 등이 이에 속한다.\n\n- 사용자가 사용하는 응용 프로그램 : **user level program**\n- OS가 사용하는 응용 프로그램 :  **system level program**\n\n\u003cbr\u003e\n\n**4. 사용자 (User)**\n\n사용자의 입장에서 운영체제가 없다면 GUI(Graphical User Interface)가 없기 때문에 실행하기가 힘들 것이다. 사용자가 편리하게 사용할 수 있도록 입출력 등을 쉽게 하기 위하여 그래픽으로 인터페이스를 제공해주는 것이다.\n\n또한, 사용자가 직접적으로 컴퓨터 하드웨어와 통신할 수 없다. 응용 프로그램을 반드시 거쳐야 한다.\n\n\u003cbr\u003e\n\n### 운영체제가 할 일\n\n운영체제가 하는 일은 크게 ==사용자 관점==과 ==시스템 관점==에 따라 나뉜다.\n\n- 사용자 관점 : **사용자의 용이성**을 위해 설계됨. 성능은 약간만 신경쓰고 자원의 이용에는 전혀 신경을 쓰지 않는다. 즉, 인터페이스 관련하여 집중!\n- 시스템 관점 : ==**자원 할당자(resource allocator), 자원 관리자, 제어 프로그램**==\n\n\u003cbr\u003e\n\n시스템 관점에서의 운영체제가 하는 일이 매우 중요하다. 자원에 대하여 서로 상충할 수 있는 요청들에 대하여, **운영체제는 어느 요청에 자원을 할당할지를 결정한다.**\n\n제어 프로그램으로써의 관점은 컴퓨터의 부적절한 사용을 방지하기 위하여 **입출력 장치와 사용자 프로그램을 제어한다.** 특히 **입출력 장치의 제어와 작동에 깊이 관여한다.**\n\n\u003cbr\u003e\n\n\u003e [!note] 정리하자면 ! \u003cbr\u003e\n\u003e 예를 들어, 응용 프로그램들이 네트워크에 연결되려면 NIC에 있는 buffer에 쓰는 과정을 거쳐야 한다. 최근 하드웨어 자원들은 성능이 좋아져서 동시적으로 concurrency 하게 접근한다. 그런데, 시스템 자원은 한정적 이지만 응용 프로그램은 매우 매우 매우 많다. 이때 여러 응용 프로그램들이 동시적으로 한정적인 시스템 자원인 buffer에 write 하면 어떻게 될까?\n\u003e \u003cbr\u003e\u003cbr\u003e\n\u003e 분명 충돌이 일어나서 옳지 않은 데이터가 buffer에 기록될 것이다. 따라서, 접근 제어하는 과정이 필요하다. **동시에 여러 개의 프로세스가 자원을 공유할 때 하나의 프로세스만 read/write 가능하도록 제어한다.** 이러한 것을 가능하게 하는 것이 바로 **운영체제**이다.\n\n\u003cbr\u003e\n\n### 커널과 운영체제의 차이\n\n운영체제는 \"커널 + 시스템 프로그램\"의 구성으로 이루어진다.\n- 커널 : 컴퓨터에서 항상 실행되는 중요한 프로그램\n- 시스템 프로그램 : OS와 관련되어 있지만, 반드시 커널의 일부일 필요는 없는 프로그램\n\n\u003cbr\u003e\n\n즉, 운영체제가 더 큰 범위이고 커널은 운영체제의 범위 중 핵심적인 부분이다.\n\n|                    | 운영체제(Operating System)                                                                 | 커널(Kernel)                                                                                   |\n| ------------------ | ------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------- |\n| 개념               | 컴퓨터 시스템을 관리하고 조작하는 소프트웨어의 집합체                                      | 운영체제의 핵심 부분으로, 하드웨어와 응용 프로그램 사이에서 직접적인 상호 작용을 담당하는 부분 |\n| 범위               | 운영체제는 시스템 전체를 관리하고 사용자 및 응용 프로그램과 상호 작용하는 모든 기능을 포함 | 운영체제의 핵심 부분으로, 하드웨어와 직접적인 상호 작용을 담당                                 |\n| 역할               | 높은 수준의 기능을 제공하며 시스템 관리, 응용 프로그램 실행 등 다양한 역할을 수행          | 운영체제의 기능을 구현하고 하드웨어와의 접점 역할                                              |\n| 구조               | 여러 컴포넌트와 모듈로 구성될 수 있음                                                      | 운영체제 내에서 가장 핵심적인 부분                                                             |\n| 직접적인 상호 작용 | 사용자 및 응용 프로그램과의 상호 작용을 통해 시스템을 관리                                 | 하드웨어와 직접적으로 상호 작용하여 하드웨어 자원을 제어하고 관리                                                                                               |\n\n정리하자면, ==운영체제는 시스템 전체를 관리하고 사용자와 응용 프로그램에 다양한 서비스를 제공==하는 반면, ==커널은 운영체제의 핵심 부분으로 하드웨어와 직접적으로 상호 작용하여 시스템 기능을 제공하고 관리==\n\n\u003cbr\u003e\n\n### 컴퓨터 시스템의 구성\n\n컴퓨터 시스템의 구성(Computer-System Organization)은 크게 인터럽트(Interrupts), 저장장치 구조(Storage Structure), 입출력 구조 (I/O Structure)로 살펴보겠다.\n\n\u003cbr\u003e\n\n![](brain/image/chap01-9.png)\n\n\u003ca href='/brain/Book/dinosaur/chap01/#컴퓨터-정보-기초'\u003e위에서\u003c/a\u003e 언급한 범용성 (universality) 있는 현대의 범용 컴퓨터 시스템(general-purpose computer system)은 ==**CPU + 장치 컨트롤러**==로 구성된다. 추가로,  ==**버스**==를 통해 CPU와 여러 장치 컨트롤러가 연결된다. 그림과 같이 OS에는 장치 컨트롤러마다 ==**장치 드라이버**==를 가지고 있다.\n\n==CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁하게 되는데, 공유 메모리를 질서 있게 액세스하기 위하여 메모리 컨트롤러는 메모리에 대한 액세스를 동기화 한다.==\n\n\u003cbr\u003e\n\n\u003e [!note] 버스와 시스템 버스  \u003cbr\u003e\n\u003e 버스는 데이터 이동을 위한 통로로, 컴퓨터 시스템에는 많은 버스가 있을 수 있지만, 시스템 버스는 주요 구성요소 사이의 주요 통신 경로이다.\n\n\n\u003cbr\u003e\n\n\u003e [!note] 입출력을 수행하는 프로그램 예시 \u003cbr\u003e\n\u003e 1. 장치 드라이버가 장치 컨트롤러의 적절한 레지스터 값에 적재 \u003cbr\u003e\n\u003e 2. 장치 컨트롤러가 레지스터의 내용 검사 \u003cbr\u003e\n\u003e 3. 수행할 작업을 결정한 장치 컨트롤러가 장치에서 로컬 버퍼로 데이터 전송 시작 \u003cbr\u003e\n\u003e 4. 장치 컨트롤러가 장치 드라이버에게 작업 완료 알림 \u003cbr\u003e\n\u003e 5. 장치 드라이버가 데이터 또는 데이터에 대한 포인터를 반환하여 OS의 다른 부분에 제어 넘김\n\n\u003cbr\u003e\n\n**1. 인터럽트(Interrupts)**\n\n입출력 수행 프로그램 예시의 4번 과정에서 **장치 컨트롤러가 장치 드라이버에게 작업 완료 사실을 어떻게 알릴까?** 바로, 인터럽트를 통해 이루어진다. 인터럽트는 ==**H/W와 O/S 상호작용의 핵심적인 부분이다.**==\n\n![](brain/image/chap01-10.png)\n\n- CPU가 인터럽트 되면, 하던 일을 즉시 중단하고 고정된 위치로 실행 옮김\n\t- 고정된 위치는 인터럽트를 위한 서비스 루틴이 위치한 시작 주소 가짐\n- 인터럽트 서비스 루틴이 실행\n- 인터럽트 서비스 루틴 실행 완료 이후, CPU는 인터럽트 되었던 연산 재개\n\t- 이때 인터럽트에 의해 중단되었던 연산이 인터럽트가 발생되지 않았던 것처럼 다시 시작하기 위해 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 하고 복귀하기 전에 상태를 복원해야 함\n\n\u003cbr\u003e\n\n인터럽트는 매우 빈번하게 발생하기에 빠르게 처리되어야 한다.\n- 인터럽트 루틴에 대한 포인터들의 테이블 이용 가능\n- 중간 루틴 둘 필요 없이, 테이블을 통하여 간접적으로 인터럽트 루틴 호출 가능\n- 포인터들의 테이블은 첫 100개 정도의 위치인 하위 메모리에 저장되는데, 여기에 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 있음\n\t- 이 주소의 배열을 ==**인터럽트 벡터**==라고 함\n\n\u003cbr\u003e\n\n**1-1. 인터럽트 작동원리**\n\nCPU 하드웨어에 ==**인터럽트 요청 라인(interrupt request line)**==이라는 선이 있다.\n- 마스크 불가능 인터럽트 라인 (nonmaskable interrupt)\n- 마스킹 가능 인터럽트 라인 (maskable)\n\t- 장치 컨트롤러가 서비스를 요청하기 위해 사용\n\n| 마스크 불가능 인터럽트 라인                                                                                                                                                                                                                                                              | 마스킹 가능 인터럽트 라인 |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------- |\n| 발생한 인터럽트를 무시하거나 차단할 수 없는 형태의 인터럽트이다. \u003cbr\u003e\u003cbr\u003e 복구할 수 없는 메모리 오류처럼 시스템 내의 중요한 이벤트나 상태 변화를 나타내며, CPU는 이러한 인터럽트가 발생하면 반드시 처리해야 한다. \u003cbr\u003e\u003cbr\u003e 대표적으로 하드웨어 오류나 외부 장치의 상태 변화와 같은 상황에서 발생할 수 있다. | CPU가 특정한 조건을 충족하는 경우에만 해당 인터럽트를 처리하도록 할 수 있는 인터럽트이다. \u003cbr\u003e\u003cbr\u003e 이 경우 CPU는 인터럽트를 무시하거나 처리할 수 있으며, 이를 위해 인터럽트 마스크(interrupt mask) 기능을 사용하여 특정 인터럽트를 활성화하거나 비활성화시킬 수 있다. \u003cbr\u003e\u003cbr\u003e 이는 시스템의 유연한 제어를 가능하게 해주며, 우선순위에 따라 인터럽트를 처리하는 것이 가능하게 한다.                          |\n\n\u003cbr\u003e\u003cbr\u003e\n\nCPU는 인터럽트 요청 라인을 통해 인터럽트를 감지한다.\n- 하나의 명령어 실행 완료 → 인터럽트 라인을 통해 인터럽트 감지\n- 인터럽트 번호 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용하여 ==**인터럽트 핸들러 루틴(interrupt-handler routine)**==으로 점프\n- 인덱스와 관련된 주소에서 실행 시작\n- 인터럽트 처리기는 작업 중에 변경될 상태 저장, 인터럽트 원인 확인, 필요한 처리 수행, 상태 복원 수행, `return_from_interrupt` 명령어 실행하여 CPU를 인터럽트 전 실행 상태로 되돌림\n\n\u003cbr\u003e\n\n기본 인터럽트 기법 : 장치 컨트롤러가 서비스할 준비가 될 때와 같은 비동기 이벤트에 CPU가 대응할 수 있게 해줌\n\n![](brain/image/chap01-11.png)\n\n- 발생 (raise) : 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트 발생시킴\n- 포착 (catch) : CPU가 인터럽트 요청 라인을 통해 인터럽트 포착\n- 디스패치 (dispatch) : CPU에서 인터럽트 핸들러로 디스패치\n- 지우기 (clear) : 인터럽트 핸들러가 장치를 서비스하고 인터럽트 지움\n\n\u003cbr\u003e\n\n최신 OS는 더욱 정교한 인터럽트 처리 기능을 위해 ==**인터럽트 컨트롤러 하드웨어**==에 의해 아래와 같은 기능들이 제공됨\n- 중요한 처리 중에 **인터럽트 처리를 연기할 수 있어야 함**\n- 장치의 **적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법 필요**\n- 우선순위가 높은 인터럽트, 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 **다단계 인터럽트 필요**\n\n\u003cbr\u003e","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/dinosaur/dinosaur":{"title":"운영체제 -공룡책","content":"\n\u003cbr\u003e\n\n\u003e [!note] 운영체제 - 공룡책 필기노트\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2023.08.07 ~ 진행중\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e 운영체제 Deep Dive\n\n\u003cbr\u003e\n\n\u003cimg class=\"book\" src=\"https://image.yes24.com/goods/89496122/XL\"\u003e\n\n\u003cbr\u003e\n\n## 목차\n\n1. [Part 1 개관 - Chapter 01 서론](brain/Book/dinosaur/chap01)","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/":{"title":"Do it! 자바 프로그래밍","content":"","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/chap01":{"title":"01.자바 프로그래밍","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 01 - 자바 프로그래밍\n\n\u003cbr\u003e\n\n## Java 특징\n\n\u003cbr\u003e\n\n### 01. 플랫폼(프로그램이 실행되는 환경)에 영향을 받지 않음\n\n**한 번 작성하면, 어디서든 돌아간다. write once, run anywhere** \u003cbr\u003e\n\n자바 소스 코드 (`.java`) -\u003e 자바 컴파일러 -\u003e 바이트 코드 (`.class`) -\u003e 자바 가상머신 (JVM) -\u003e 각 운영체제에서 실행\n\n\u003cbr\u003e\n\n- 자바 가상 머신 (Java Virtual Machine, JVM)은 자바 프로그램 실행 환경을 만들어주는 소프트웨어\n\n- 자바 코드를 **컴파일**하여 `.class` 바이트 코드로 만들면 바이트 코드가 JVM에서 실행\n\n- 현재 사용하는 컴퓨터의 OS에 맞는 자바 실행 환경 (Java Runtime Environment, JRE)이 설치되어 있으면 JVM이 설치되어 있는 것\n\n- JIT(Just In Time) 컴파일러는 실행 시점에 기계어 코드를 생성하는데, 같은 코드가 반복되면 매번 기계어 코드를 새로 생성하지 않고 이전에 만든 기계어를 재사용함.\n\n- JIT 컴파일러는 운영체제에 맞게 바이트 실행 코드로 한 번에 변환하여 실행해서 이전의 자바 해석기(Java Interpreter) 방식보다 성능이 10~20배 좋음\n\n\n\u003cbr\u003e\n\n### 02. 객체지향 언어라서 유지보수가 쉽고 확장성이 좋음\n\n객체지향프로그래밍은 일의 순서대로 프로그래밍 하는 것 X, **여러 객체의 협력을 통해 프로그램을 구현하는 것, 각 객체의 상호 관계를 이용하여 프로그래밍 하는 것이다.**. 쇼핑몰 사이트 예시에서 회원, 상품, 주문, 배송 등이 객체.\n\n\u003cbr\u003e\n\n\n### 03. 프로그램이 안정적임\n\n- C, C++과는 다르게 포인터를 사용하지 않아서, 메모리 직접 제어 불가능. 메모리를 직접 제어할 경우 위험할 수 있지만, 그렇지 않으니까 안정적임.\n\n- 동적 메모리 수거를 프로그래머가 하지 않고 **가비지 컬렉터(Garbage Collector)** 이용하여 메모리 효율적으로 관리\n\n\u003e [!note] Garbage Collector?\n\u003e\n\u003e 가비지 컬렉터란, 이름 그대로 쓰레기를 수집하는 기능. 여기서 쓰레기란 더이상 사용하지 않는 메모리를 의미한다. C, C++에서는 필요 없는 메모리 사용 해제를 프로그래머가 직접 하지만, 자바는 가비지 컬렉터가 사용하지 않는 동적 메모리를 주기적으로 수거\n\n\u003cbr\u003e\n\n### 04. 풍부한 기능을 제공하는 오픈소스\n\n\n특정 기능을 대부분 개발자가 직접 개발하여 사용하는 기존의 다른 언어와는 달리 자바는 기본 기능을 제공하는 클래스, 뿐만 아니라 자료구조, 네트워크, 입출력, 예외 처리 등에 최적화 된 **알고리즘 라이브러리를 제공하는 자바 개발 키트(Java Development Kit, JDK)가 있음**.\n\n\u003chr\u003e\n\n## Hello Java\n\n\u003cbr\u003e\n\n이클립스든 인텔리제이이든 `new project`로 project 생성을 한다. 그러면서 워크스페이스를 지정하는 것이다.\n\n- 프로젝트(project) : 개발자가 만드는 하나의 프로그램 단위\n\n- 클래스(class) : 객체를 소스 코드로 나타낸 것\n\n- 패키지(package) : 프로그램 소스의 묶음으로 클래스를 만드는 데 만드시 필요, 패키지 이름은 항상 소문자로 쓴다.\n\n\u003cbr\u003e\n\nsrc 폴더 -\u003e package 생성 -\u003e class 생성의 순서로 만든다. 이때\n\n\n```java\npackage hello;\n  \npublic class HelloJava {\n\tpublic static void main(String[] args) {\n\tSystem.out.println(\"Hello, JAVA\");\n\t}\n}\n```\n\n추가로, build 결과물인 class 파일이 저장되는게 이클립스는 bin 폴더, 인텔리제이는 out 폴더인 것 같음","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/chap02":{"title":"02.변수와 자료형","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 02 - 변수와 자료형\n\n\u003cbr\u003e\n\n## Java 변수\n\n### Java 변수 선언, 초기화\n\n- 초기화 : 변수의 선언과 동시에 값을 대입\n\n```java\npackage chapter2;\n\npublic class Variable1 {\n\tpublic static void main(String[] args) {\n\t\tint level; // 변수 선언\n\t\tlevel = 10; // 변수에 값 대입\n\t\tSystem.out.println(level);\n\t  \n\t\tint level2 = 10; // 초기화\n\t\tSystem.out.println(level2);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n- 변수 이름 정하기\n\n|제약사항|예시|\n|------|---|\n|영문자, 숫자 사용 \u003cbr\u003e 특수문자는 `$`, `_`만| g_level (O), count100 (O)\u003cbr\u003e _master (O), $won (O)|\n|숫자로 시작 불가|27day (X), 1abc (X)|\n|예약어 사용 불가|while, int, break, ... |\n\n\u003cbr\u003e\n\n\n- 변수를 선언한다 = 선언한 변수 이름으로 어떤 위치에 있는 메모리를 얼마만큼의 크기로 사용하겠다.\n\n- 1byte = 8bits\n\n\n| |정수형|문자형|실수형|논리형|\n|:---:|:-----:|:-----:|:-----:|:-----:|\n|1바이트|byte|-|-|boolean|\n|2바이트|short|char|-|-|\n|4바이트|int|-|float|-|\n|8바이트|long|-|double|-|\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Java 자료형\n\n\u003cbr\u003e\n\n### 정수형\n\n- **자바에서 정수 값 연산 시 4바이트를 기본 단위로 사용. 모든 정수 값을 기본으로 int형으로 처리.** 따라서 다른 자료형이라면 그를 표시해야함.\n\n```java\nint num1 = 12345678900;\nlong num2 = 12345678900;\n// num1은 int 범위 벗어나서 오류\n// num2도 오류. java는 정수를 int로 처리하니까\n  \nlong num3 = 12345678900L;\n// long 자료형으로 처리하라고 컴파일러에게 알려주는\n// 식별자 L이나 l을 사용하여 알려줘서 오류 X\n```\n\n\u003cbr\u003e\n\n### 문자형\n\n- **자바의 기본 인코딩 방식은 모든 문자를 2바이트로 표현하는 UTF-16**\n\n- 자바에서는 따옴표(`''`)와 쌍따옴표(`\"\"`) 구분하자. 따옴표가 **문자형, char**, 쌍따옴표가 **문자열, string**인 듯 하다.\n\n- 아스키 코드 : 영문자, 소문자, 특수 문자 등을 나타내는 문자 세트, 1바이트만 사용\n\n- 유니코드(unicode) : 영어 이외에 한글이나 다른 언어 문자는 복잡하고 다양해서 2바이트 이상을 사용하게 됨. 그래서 각 언어의 표준 인코딩을 정의해놓은 것. 유니코드의 1바이트는 아스키 코드 값과 호환되면서 그 밖의 문자를 2바이트나 그 이상의 조합으로 표현. **자바는 유니코드에 기반하여 문자를 표현. 따라서, 자바의 문자 자료형인 char형은 2바이트 사용**\n\n```java\nchar myChar = 'A';\n// 문자 그대로 저장되는 것이 아니라\n// 문자에 해당하는 정수 값(아스키 코드 값)이 저장\n```\n\n\u003cbr\u003e\n\n### 문자형 - 유니코드\n\n유니코드를 표현하는 인코딩 방법은 **UTF-8**, **UTF-16**이 있음 \u003cbr\u003e\n\n**자바의 기본 인코딩 방식은 모든 문자를 2바이트로 표현하는 UTF-16** \u003cbr\u003e\u003cbr\u003e\n\n모두 2바이트로 표현하니까 알파벳 같은 자료(1바이트 자료)를 저장하는 경우 낭비가 있을 수 있음. 반면에, UTF-8은 각 문자마다 1바이트에서 4바이트를 사용하여 문자를 나타내는 방식임. 따라서, UTF-8은 UTF-16에 비해 메모리 낭비가 적고 전송 속도가 빠름. 이러한 특성으로 인터넷에서 많이 사용 (예를 들어, HTML emmet 해보면 UTF-8로 나옴)\n\n\u003cbr\u003e\n\n- `\\u`를 붙히고 뒤에 유니코드를 적는다.\n\n- \u003ca href='https://www.unicode.org/charts/PDF/UAC00.pdf' target='_blank'\u003e한글 유니코드\u003c/a\u003e에서 코드 참조\n\n```java\npackage chapter2;\n  \npublic class ExQ5 {\n\tpublic static void main(String[] args) {\n\t\tchar ch = '\\uAE00';\n\t\tSystem.out.println(ch);\n\t}\n}\n// 글\n```\n\n\u003cbr\u003e\n\n### 실수형\n\n- 부동 소수점 방식 사용\n\n- `0.1`은 `1.0 X 10^-1`로 표현 가능. 1.0이 가수, 10이 밑수, 제곱수가 지수\n\n- **자바에서 실수는 double형을 기본으로 사용**\n\n- 기본이 double이니까 float 사용하면 식별자 `F` 또는 `f`를 붙혀야함\n\n\u003cbr\u003e\n\n- float형 : 부호 1비트, 지수부 8비트, 가수부 23비트 = 총 32비트(4바이트)\n\n- double형 : 부호 1비트, 지수부 11비트, 가수부 52비트 = 총 64비트(8바이트)\n\n\n```java\npublic class DoubleEx2 {\n\tpublic static void main(String[] args) {\n\t\tdouble dnum = 1;\n\t  \n\t\tfor (int i = 0; i \u003c 10000; i++) {\n\t\t\tdnum = dnum + 0.1;\n\t\t}\n\t\t\n\t\tSystem.out.println(dnum);\n\t}\n}\n  \n// 1001.000000000159\n```\n\n\n정확하게 1001로 떨어지지 않는 이유는 순환소수 문제이다. 다음 [코딩애플 자바스크립트 LEVEL2](brain/Lecture/frontend/apple-js/apple-js-02.md)의 부동소수점 부가 설명을 참고하도록 하자.\n\n\u003cbr\u003e\n\n### 논리형\n\n- `boolean 변수명`\n\n- boolean형 변수는 1바이트 값으로 저장, true / false만 가짐\n\n\n\u003cbr\u003e\n\n### 자료형 추론\n\n- 자바 10부터 생긴 문법\n\n- 자바스크립트에 var 같은 거임. 자료형을 정확히 명시 안하고도 변수를 사용가능한 것\n\n- **지역 변수 자료형 추론(local variable type inference)** 라고 한다. 변수에 대입되는 자료를 보고 컴파일러가 추측 가능\n\n\u003cbr\u003e\n\n단, 자바스크립트의 var과는 다르다. 자바스크립트의 var는 재선언, 재할당 모두 가능했지만, **자바의 var는 재선언이 불가능**하다. 추가로, var로 자료형 없이 변수를 선언하려면 **지역 변수만 가능**하다. 지역 변수는 프로그램의 `{}`의 내에서 사용할 수 있는 변수이다. 즉, 자바스크립트의 var은 function 스코프였는데, 자바의 var는 block 스코프이다.\n\n```java\nvar i = 10; // int i = 10으로 컴파일\nvar j = 10.0; // double j = 10.0으로 컴파일\nvar str = \"hello\"; // String str = \"hello\"로 컴파일\n```\n\n\u003chr\u003e\n\n## Java 상수\n\n- 자바스크립트에서는 const 썼는데, **자바에서는 final 예약어 사용**\n\n- 재선언, 재할당 당연히 불가. 처음에 할당 안하고 써도 오류\n\n```java\nfinal double PI = 3.14;\nfinal int MAX_NUM = 100;\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter2;\n  \npublic class Constant {\n\tpublic static void main(String[] args) {\n\t\tfinal int MAX_NUM = 100;\n\t\tfinal int MIN_NUM;\n\t\t  \n\t\tMIN_NUM = 0; // 사용하기 전에 초기화 한 것, 초기화 안하면 오류 발생\n\t\t  \n\t\tSystem.out.println(MAX_NUM);\n\t\tSystem.out.println(MIN_NUM);\n\t}\n}\n\n```\n\n\u003chr\u003e\n\n## Java 리터럴\n\n- 리터럴(literal)은 프로그램에서 사용하는 모든 숫자, 문자, 논리값을 일컫는 말\n\n- 리터럴 혹은 리터럴 상수라고 함\n\n리터럴은 **프로그램이 시작할 때 시스템에 같이 로딩되어 특정 메모리 공간인 상수 풀(constant pool)에 놓인다.** 예를 들어, `int num = 3;`에서 값인 3이 메모리 공간 어딘가에 존재해야, num 변수에 그 값을 복사할 수 있다. **즉, 숫자가 변수에 대입되는 과정은 일단 숫자 값이 어딘가 메모리에 써져 있어야 하고, 이 값이 다시 변수 메모리에 복사되는 것이다.**\n\n![](brain/image/chap02-1.png)\n\n\u003cbr\u003e\n\nlong형에서 식별자 L을 사용해주는 이유가 이때문이다. 자바에서 정수를 표현하는 메모리의 기본 크기는 4바이트인데, 상수 풀에서도 마찬가지다. 리터럴은 int형으로 처리되는데 long형은 4바이트 크기에 들어갈 수 없어서 8바이트로 처리하라고 컴파일러에게 알려주어야 한다. 이 때문에 **이 리터럴은 long형으로 저장되어야 한다는 의미로 리터럴 뒤에 식별자 L 이나 l을 붙혀주는 것**이다.\n\n\u003chr\u003e\n\n## Java 형 변환\n\n형 변환 기본 원칙 (작고 덜 정밀 -\u003e 크고 더 정밀은 자동)\n\n1. **바이트 크기가 작은 자료형 -\u003e 큰 자료형** : 자동으로 형 변환\n\n2. **덜 정밀한 자료형 -\u003e 더 정밀한 자료형** : 자동으로 형 변환\n\n![](brain/image/chap02-2.png)\n\n\u003cbr\u003e\n\n### 묵시적 형 변환 (자동)\n\n- 바이트 크기가 작은 자료형 -\u003e 큰 자료형으로 대입하는 경우\n\n\n```java\nbyte bNum = 10;\nint iNum = bNum;\n```\n\n1바이트 -\u003e 4바이트이므로 자료 손실 없이 다 저장됨. 남은 3바이트는 0으로 채워짐\n\n\u003cbr\u003e\n\n- 덜 정밀한 자료형 -\u003e 더 정밀한 자료형으로 대입하는 경우\n\n```java\nint iNum2 = 20;\nfloat fNum = iNum2;\n```\n\n4바이트 -\u003e 4바이트이지만, float 자료형이 더 정밀하게 표현가능해서 변환됨\n\n\u003cbr\u003e\n\n- 연산 중 자동 형 변환\n\n```java\nint iNum = 20;\nfloat fNum = iNum;\ndobule dNum;\ndNum = fNum + iNum;\n```\n\n대입 전 float + int 해서 float형으로 먼저 되고, float -\u003e double로 형 변환 됨.\n\n\u003cbr\u003e\n\n### 명시적 형 변환 (강제)\n\n- 바이트 크기가 큰 자료형 -\u003e 작은 자료형\n\n```java\nint iNum = 10;\nbyte bNum = (byte)iNum;\nSystem.out.println(bNum);\n// 10\n  \nint iNum2 = 1000;\nbyte bNum2 = (byte)iNum2;\nSystem.out.println(bNum2);\n// -24\n```\n\n4바이트 -\u003e 1바이트이므로 자료 손실 발생 가능하다. \u003cbr\u003e\n\n예를 들어, 10은 1바이트에 표현 가능하니까 자료손실 X \u003cbr\u003e\n\n하지만, 1000의 경우 byte 범위 (-128~127) 벗어나니까 자료손실 O\n\n\n\u003cbr\u003e\n\n- 더 정밀한 자료형 -\u003e 덜 정밀한 자료형\n\n\n```java\ndouble dNum = 3.14;\nint iNum = (int)dNum;\n  \nSystem.out.println(dNum);\nSystem.out.println(iNum);\n// 3.14\n// 3\n```\n\n더 정밀 -\u003e 덜 정밀이니까 자료 손실 발생 가능. 실수의 소수점 이하 부분이 생략되고 정수 부분만 대입되는 것을 확인 가능\n\n\u003cbr\u003e\n\n\n- 연산 중 형 변환\n\n\n```java\npackage chapter2;\n  \npublic class ExplicitConversion {\n\tpublic static void main(String[] args) {\n\t\tdouble dNum1 = 1.2;\n\t\tfloat fNum2 = 0.9F;\n\t\t  \n\t\tint iNum3 = (int)dNum1 + (int)fNum2;\n\t\tint iNum4 = (int)(dNum1 + fNum2);\n\t\tSystem.out.println(iNum3);\n\t\tSystem.out.println(iNum4);\n\t}\n}\n\n// 1\n// 2\n```\n\n형 변환이 언제 이루어지는 지도 key point. 위에는 형 변환을 하고 더하기 때문에 소수점 아래를 버려버리면 `1 + 0 = 1`의 결과가 나오고, 아래에는 더한 이후 형 변환을 하기 때문에 `1.2 + 0.9 = 2.1을 소수점 아래 버리면 2`이다.","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/chap03":{"title":"03.자바의 연산자","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 03 - 자바의 여러 가지 연산자\n\n\u003cbr\u003e\n\n\n## Java 기본 연산자\n\n### 항과 연산자\n\n\u003cbr\u003e\n\n| 연산자 | 설명 | 예시 |\n| :---------: | :-----------------: | :----------------: |\n| 단항 연산자 | 항이 한 개인 연산자 | ++num |\n| 이항 연산자 | 항이 두 개인 연산자 | num1 + num2; |\n| 삼항 연산자 | 항이 세 개인 연산자 | ( 5 \u003e 3 ) ? 1 : 0; |\n\n\u003cbr\u003e\n\n\n추가로, `/`는 몫, `%`는 나머지 !\n\n```java\nint num1 = 10;\nint num2 = 4;\n  \nnum1 / num2 = 2; // 몫\nnum1 % num2 = 2; // 나머지\n```\n\n\u003cbr\u003e\n\n### 논리 연산 주의점\n\n- AND(`\u0026\u0026`) 연산 : 둘다 true여야 결과가 true라서 앞에꺼 하나라도 false가 나오면 뒤에 문장을 실행 안하고 false로 확정짓고 넘어감\n\n- OR(`||`) 연산 : 둘 중 하나만 true여도 겨로가가 true라서 앞에꺼 하나라도 true가 나오면 뒤에꺼 실행 안하고 true로 확정짓고 넘어감\n\n**논리 곱, 논리 합 연산 시 두 항을 모두 실행하지 않더라도 결과 값을 알 수 있는 경우에, 나머지 항이 실행되지 않는 것을 단락 회로 평가(Short Circuit Evaluation; SCE)라고 한다.**\n\n```java\npackage chapter03;\n\npublic class pr03_OperationEx3 {\n\tpublic static void main(String[] args) {\n\t\tint num1 = 10;\n\t\tint i = 2;\n\t\t  \n\t\tboolean value = ((num1 = num1 + 10) \u003c 10) \u0026\u0026 ((i = i + 2) \u003c 10);\n\t\tSystem.out.println(value);\n\t\tSystem.out.println(num1);\n\t\tSystem.out.println(i);\n\t\t\n\t\tvalue = ((num1 = num1 + 10) \u003e 10) || ((i = i + 2) \u003c 10);\n\t\tSystem.out.println(value);\n\t\tSystem.out.println(num1);\n\t\tSystem.out.println(i);\n\t}\n}\n\n// false\n// 20\n// 2 논리 곱, 앞 항 거짓이라서 뒷 항 실행 안되고 i값 그대로\n// true\n// 30\n// 2 논리 합, 앞 항 참이라서 뒷항 실행 안되고 i값 그대로\n```\n\n\u003cbr\u003e\n\n### 조건 연산자\n\n\u003cbr\u003e\n\n| 연산자 | 기능 | 예시 |\n| :--------------------: | :-------------------------------------------------------: | :--------------------------: |\n| 조건식 ? 결과1 : 결과2 | 조건식이 참이면 결과 1, \u003cbr\u003e 조건식이 거짓이면 결과2 선택 | int num = (5 \u003e 3) ? 10 : 20; |\n\n\u003cbr\u003e\n\n```java\npackage chapter03;\n\npublic class pr04_OperationEx4 {\n\tpublic static void main(String[] args) {\n\t\tint num = 10;\n\t\tboolean isEven;\n\t\tisEven = (num % 2 == 0) ? true : false;\n\t\tSystem.out.println(isEven);\n\t}\n}\n\n// true\n```\n\n\u003chr\u003e\n\n## Java 비트 연산자\n\n### 비트 논리 연산자\n\n- `\u0026` : AND 연산자\n\n```java\nnum1 : 0 0 0 0 0 1 0 1 // 5\n\u0026 num2 : 0 0 0 0 1 0 1 0 // 10\n------------------------\nresult : 0 0 0 0 0 0 0 0 // 0\n  \n// 5 \u0026 10 = 0\n```\n  \n- `|` : OR 연산자\n  \n```java\nnum1 : 0 0 0 0 0 1 0 1 // 5\n| num2 : 0 0 0 0 1 0 1 0 // 10\n------------------------\nresult : 0 0 0 0 1 1 1 1 // 15\n  \n// 5 | 10 = 15\n```\n\n- `^` : XOR 연산자, 같으면 0, 다르면 1\n  \n```java\nnum1 : 0 0 0 0 0 1 0 1 // 5\n^ num2 : 0 0 0 0 1 0 1 0 // 10\n------------------------\nresult : 0 0 0 0 1 1 1 1 // 15\n\n// 5 ^ 10 = 15\n```\n\n- `~` : 반전 연산자, 부호 비트가 1이면 음수인거 까먹지 말기  \n\n```java\nnum : 0 0 0 0 0 1 0 1 // 10\n------------------------\n~ num : 1 1 1 1 1 0 1 0 // -11\n// ~10 = -11\n```\n  \n\u003cbr\u003e\n\n### 비트 이동 연산자\n\n- `\u003c\u003c` : 좌측 시프트 연산자, 왼쪽으로 비트 이동, 뒷부분인 오른쪽에 0 채우기  \n\n```java\nnum : 0 0 0 0 0 1 0 1 // 5\nnum \u003c\u003c 2 : 0 0 0 1 0 1 0 0 // 20\n```\n\n왼쪽으로 n비트 이동한다는 것은 **기존 값 \\* n\u003csup\u003e2\u003c/sup\u003e** 이다.\n\n따라서, `5 \u003c\u003c 2`는 5 \\* 2\u003csup\u003e2\u003c/sup\u003e = 20이다.\n\n\u003cbr\u003e\n\n- `\u003e\u003e` : 우측 시프트 연산자, 오른쪽으로 비트 이동, 앞부분인 왼쪽에 0 채우기, 추가로 기존 값의 부호비트와 동일\n\n```java\nnum : 0 0 0 0 1 0 1 0 // 10\nnum \u003e\u003e 2 : 0 0 0 0 0 0 1 0 // 2\n```\n  \n왼쪽으로 n비트 이동한다는 것은 **기존 값 / n\u003csup\u003e2\u003c/sup\u003e** 이다.\n\n따라서, `10 \u003e\u003e 2`는 10 / 2\u003csup\u003e2\u003c/sup\u003e = 2이다.\n\n\u003cbr\u003e\n\n- `\u003e\u003e\u003e` : 우측 시프트 연산자, 오른쪽으로 비트 이동, 앞부분인 왼쪽에 0 채우기, \u003e\u003e와 다른점은 얘는 기존 값의 부호비트와 상관 없이 무조건 0이 채워짐","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/chap04":{"title":"04.제어문","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 04 - 자바의 제어문\n\n\u003cbr\u003e\n\n## Java 조건문\n\n### Java if문\n\n\u003cbr\u003e\n\n```java\nif (조건식1) {\n\t수행문1;\n}\n\nelse if (조건식2) {\n\t수행문2;\n}\n\nelse {\n\t수행문3;\n}\n```\n\n\u003cbr\u003e\n\n- if문 내부 수행하는 문장이 1개면 중괄호`{}` 없어도 됨. 하지만, 코드 가독성이 좋게 하려면 쓰는 것을 추천\n\n```java\nif (조건식1) 수행문1;\n```\n\n\u003cbr\u003e\n\n### Java switch-case문\n\n- break의 역할은 switch문 밖으로\n\n- break 안쓰면 해당하는 case부터 아래로 쭈욱 실행\n\n\n```java\nswitch(조건) {\n\tcase 값1 : 수행문1;\n\t\tbreak;\n\t  \n\tcase 값2 : 수행문2;\n\t\tbreak;\n\t  \n\tcase 값3 : 수행문3;\n\t\tbreak;\n\t  \n\tdefault : 수행문4;\n\t// 주어진 값이 case에 해당하지 않을 시 default 실행\n}\n```\n\n\u003cbr\u003e\n\n- case문 동시 사용\n\n- 1, 3, 5, 7, 8, 10, 12월은 31일 까지\n\n- 4, 6, 9, 11월은 30일 까지\n\n- 2월은 28일 까지\n\n```java\ncase 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 : day = 31;\n\tbreak;\n\ncase 4 : case 6 : case 9 : case 11 : day = 30;\n\tbreak;\n\t\ncase 2 : day = 28;\n\tbreak;\n```\n\n\u003cbr\u003e\n\n- 자바7부터 case 값에 정수 말고 문자열도 사용 가능\n\n- 이전에는 원래 `equals()` 메서드를 이용해서 비교했어야함\n\n```java\nif (medal.equals(\"Gold\")) {\n\t...\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter04;\n  \npublic class pr04_SwitchCase2 {\n\tpublic static void main(String[] args) {\n\t\tString medal = \"Gold\";\n\t\t  \n\t\tswitch(medal) {\n\t\t\tcase \"Gold\":\n\t\t\t\tSystem.out.println(\"금메달입니다.\");\n\t\t\t\tbreak;\n\t\t\tcase \"Silver\":\n\t\t\t\tSystem.out.println(\"은메달입니다.\");\n\t\t\t\tbreak;\n\t\t\tcase \"Bronze\":\n\t\t\t\tSystem.out.println(\"동메달입니다.\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"메달이 없습니다.\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n\u003chr\u003e\n\n## Java 반복문\n\n### while문\n\n\u003cbr\u003e\n\n```java\nwhile(조건식) {\n\t수행문1;\n\t// 조건식 참이면 수행\n}\n  \n// 무한루프\nwhile(true) {\n\t수행문2;\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter04;\n  \npublic class pr05_WhileExample1 {\n\tpublic static void main(String[] args) {\n\t\tint num = 1;\n\t\tint sum = 0;\n\t\t  \n\t\twhile (num \u003c= 10) {\n\t\t\tsum += num;\n\t\t\tnum++;\n\t\t}\n\t\tSystem.out.println(\"1부터 10까지의 합 = \" + sum);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### do-while문\n\n\u003cbr\u003e\n\n```java\n// 수행문1을 일단 1번 실행, 그 이후 while 조건식 참이면 실행\n\ndo {\n\t수행문1;\n\t...\n} while (조건식);\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter04;\n\npublic class pr06_DoWhileExample {\n\tpublic static void main(String[] args) {\n\t\tint num = 1;\n\t\tint sum = 0;\n  \n\t\tdo {\n\t\t\tsum += num;\n\t\t\tnum++;\n\t\t} while(num \u003c= 10);\n\t\tSystem.out.println(\"1부터 10까지의 합 = \" + sum);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### for문\n\n\u003cbr\u003e\n\n```java\nfor (int i = 0; i \u003c= 10; i++) {\n\t수행문~\n}\n```\n  \n\u003cbr\u003e\n\n### for문 요소 생략하기\n\n\u003cbr\u003e\n\n**초기화식 생략**\n\n- 이미 변수 초기화 해서 중복으로 초기화할 필요 없을 때\n\n```java\nint i = 0;  \n\nfor ( ; i \u003c 5; i++) {\n\t...\n}\n```\n\n\u003cbr\u003e\n\n**조건식 생략**\n\n- 어떤 연산 결과 값이 나왔을 때 바로 for문 수행 멈추고 싶을 때\n\n- 조건식 생략하고 if문과 break 활용\n\n\n```java\nfor (i = 0; ; i++) {\n\tsum += i;\n\tif (sum \u003e 200) break;\n}\n```\n\n\u003cbr\u003e\n\n**증감식 생략**\n\n- 증감식 연산이 복잡하거나 다른 변수의 연산 결과 값에 좌우될 때\n\n```java\nfor ( i = 0; i \u003c 5; ) {\n\t...\n\ti = (++i) % 10;\n}\n```\n\n\u003cbr\u003e\n\n**요소 모두 생략**\n\n- 무한 루프\n\n```java\nfor ( ; ; ) {\n\t// 무한루프\n}\n```\n\n**구현 예시**\n\n```java\npackage chapter04;\n  \npublic class pr07_forExample {\n\tpublic static void main(String[] args) {\n\t\t// 초기화식 생략\n\t\tint i = 0;\n\t\tfor ( ; i \u003c 5; i++) {\n\t\t\tSystem.out.println(\"초기화식 생략 예제 \" + \"반복횟수 = \" + i);\n\t\t}\n\t  \n\t\t// 조건식 생략\n\t\tint j;\n\t\tint sum = 0;\n\t\tfor ( j = 0; ; j++ ) {\n\t\t\tsum += j;\n\t\t\tSystem.out.println(\"조건식 생략 예제 더하는 중, 반복횟수 = \" + j);\n\t\t\tif (sum \u003e 200) break;\n\t\t}\n\t\tSystem.out.println(\"조건식 생략 예제 끝난 후 합 = \" + sum);\n\t  \n\t\t// 증감식 생략\n\t\tfor (int k = 0; k \u003c 5; ) {\n\t\t\tk = (++k) % 10;\n\t\t\tSystem.out.println(k);\n\t\t}\n\t  \n\t\t// 요소 모두 생략\n\t\t// for ( ; ; ) {\n\t\t// 무한루프 입니다.\n\t\t// }\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### continue문\n\n- continue문은 반복문과 함께 씀\n\n- 반복문 안에서 continue문 만나면 **이후 문장 수행 X**\n\n- 그 이후 for문 처음으로 돌아가서 **증감식 수행**\n\n- 사용 용도 : 반복문 수행 중 특정 조건에서는 수행하지 않고 건너뛰고 싶을 때\n\n```java\npackage chapter04;\n  \npublic class pr09_ContinueExample {\n\tpublic static void main(String[] args) {\n\t\tint sum = 0;\n\t\tfor (int i = 1; i \u003c= 100; i++) {\n\t\t\tif ( i % 2 == 0 ) continue;\n\t\t\tsum += i;\n\t\t}\n\t\tSystem.out.println(\"1부터 100까지 홀수의 합은 = \" + sum);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### break문\n\n실제로 어디에 사용하냐를 보이겠음. 0부터 시작해서 숫자를 1씩 늘리면서 합을 계산할 때 숫자를 몇까지 더하면 100이 넘는지 알고 싶다고 하자.\n\n```java\npackage chapter04;\n  \npublic class pr10_BreakExample1 {\n\tpublic static void main(String[] args) {\n\t\tint sum = 0;\n\t\tint num = 0;\n\t\t  \n\t\tfor (num = 0; sum \u003c 100; num++) {\n\t\t\tsum += num;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"num : \" + num);\n\t\tSystem.out.println(\"sum : \" + sum);\n\t}\n}\n  \n// num : 15\n// sum : 105\n```\n\nnum이 아닌 sum의 조건에 따라 코드가 진행되다 보니, num이 증감된 상태에서 sum의 조건을 만나 올바르지 않은 답이 나오는 것을 볼 수 있음.\n\n```java\npackage chapter04;\n\npublic class pr11_BreakExample2 {\n\tpublic static void main(String[] args) {\n\t\tint sum = 0;\n\t\tint num = 0;\n\t\t\n\t\tfor (num = 0; ; num++) {\n\t\t\tsum += num;\n\t\t\tif (sum \u003e= 100)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(\"num : \" + num);\n\t\tSystem.out.println(\"sum : \" + sum);\n\t}\n}\n\n// num : 14\n// sum : 105\n``` \n\n\u003ca href='/brain/Book/do-it-java/chap04/#for문-요소-생략하기'\u003e조건식 생략\u003c/a\u003e의 스킬을 이용하였고 for문 내부에 조건을 걸어줌으로써 break 시켜서 반복문을 아예 빠져나가게 했음\n\n\u003cbr\u003e\n\n- break 문의 위치\n\n```java\nwhile(조건식1) {\n\twhile(조건식2) {\n\t\tif (조건식) // 조건에 해당하는 경우\n\t\t\tbreak; // 내부 반복문만 빠져나옴\n\t}\n}\n```\n\n중첩 반복문을 사용하는 경우 break를 사용하면 해당 반복문만 빠져나온다. 즉, 내부 반복문만 빠져나오고 외부 반복문은 계속 수행한다.\n\n\u003cbr\u003e\n\n### break, continue 차이\n\n- break문은 break; 를 적어준 곳에서 해당 조건문 블록과 그 밖의 반복문 자체를 탈출한다.\n\n- continue문은 해당 조건문 블록을 탈출하여 아래 명령문은 실행하지 않고, 다음 반복문 실행절차를 수행한다.\n\n\u003cbr\u003e\n\n### 연습문제 2번\n\n\n```java\npackage chapter04;\n\npublic class ex02_Q2 {\n\tpublic static void main(String[] args) {\n\t\tint dan, times;\n\t\t\n\t\t// 내가 짠 코드\n//\t\tfor (dan = 1; dan \u003c= 9; dan++) {\n//\t\t\tfor (times = 1; times \u003c= 9; times++) {\n//\t\t\t\tif (dan % 2 == 0) {\n//\t\t\t\t\tSystem.out.println(dan + \" X \" + times + \" = \" + (dan * times));\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\t  \n\t\t// 정답 코드\n\t\tfor (dan = 1; dan \u003c= 9; dan++) {\n\t\t\tif (dan % 2 != 0) continue;\n\t\t\tfor (times = 1; times \u003c= 9; times++) {\n\t\t\t\tSystem.out.println(dan + \" X \" + times + \" = \" + (dan * times));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n내가 짠 코드는 결국 두번째 for문까지 와서 일단 다 돌려야 한다. \u003cbr\u003e\u003cbr\u003e\n\n하지만 정답 코드는 continue문을 이용해서 홀수면 밑에 for문을 수행하지 않고 바로 다음 반복문으로 넘어가도록 설계했기 때문에 더 좋은 코드이다.\n\n\u003cbr\u003e\n\n### 연습문제 3번\n\n\u003cbr\u003e\n\n```java\npackage chapter04;\n\npublic class ex03_Q3 {\n\tpublic static void main(String[] args) {\n\t\tint dan, times;\n\n        // 내가 짠 코드\n//\t\tfor (dan = 1; dan \u003c= 9; dan++) {\n//\t\t\tfor (times = 1; times \u003c= dan; times++) {\n//\t\t\t\tSystem.out.println(dan + \" X \" + times + \" = \" + (dan * times));\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\t\n\t\t// 정답 코드\n\t\tfor (dan = 1; dan \u003c= 9; dan++) {\n\t\t\tfor (times = 1; times \u003c= 9; times++) {\n\t\t\t\tif (dan \u003c times) break;\n\t\t\t\t\tSystem.out.println(dan + \" X \" + times + \" = \" + (dan * times));\n\t\t\t}\n\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n이건 내가 짠 코드대로 짤 것 같은데 정답코드처럼 break 문을 이용할 수도 있다. 이건 내가 적은 방법이 더 좋은듯 \u003cbr\u003e\u003cbr\u003e\n\n\n연습문제 4번, 5번은 백준 별찍기 5번, 7번이니까 그거 참조","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/chap05":{"title":"05.클래스와 객체 (1)","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 05 - 클래스와 객체 (1)\n\n\u003cbr\u003e\n\n|용어|설명|\n|:--:|:--:|\n|객체|객체 지향 프로그램의 대상, 생성된 인스턴스|\n|클래스|객체를 프로그래밍하기 위해 코드로 만든 상태|\n|인스턴스|클래스가 메모리에 생성된 상태|\n|멤버 변수|클래스의 속성, 특성|\n|메서드|멤버 변수를 이용하여 클래스의 기능을 구현|\n|참조 변수|메모리에 생성된 인스턴스를 가리키는 변수|\n|참조 값|생성된 인스턴스의 메모리 주소 값|\n\n\u003cbr\u003e\n\n## 클래스와 객체\n\n### 객체 지향 프로그래밍 기본 컨셉  \n\n- 절차 지향 프로그래밍 : 일어나는 일을 시간 순서으로 프로그래밍\n\n- 객체 지향 프로그래밍 : 객체를 만들고 객체 사이에 일어나는 일을 구현하는 프로그래밍\n\n\u003cbr\u003e\n\n### 클래스 (Class)\n\n- 객체 지향 프로그램은 클래스를 기반으로 프로그래밍\n\n- 클래스 : 객체의 속성과 기능을 구현\n\n- 클래스를 정의한다 : 객체를 클래스로 구현한다\n\n- 멤버 변수 : 객체의 속성\n\n- 메서드 : 객체의 기능\n\n\u003cbr\u003e\n\nStudent 클래스를 생각했을 때, 학번, 이름, 학년, 사는 곳 등 선언하는 클래스의 속성을 **멤버 변수**라고 한다.\n\n```java\n(접근 제어자) class 클래스 이름 {\n\t멤버 변수;\n\t메서드;\n}\n\npublic class Student {\n\tint studentID;\n\tString studentName;\n\tint grade;\n\tString address;\n}\n```\n\n- 접근 제어자가 public인 경우 `클래스 이름 = 자바 파일 이름` 이어야 한다.\n\n- 클래스 외부에는 package 선언, import 문장 외에 아무 것도 선언 X\n\n- 클래스 코딩 컨벤션 : 클래스 이름은 대문자로 시작\n\n\u003chr\u003e\n\n## 클래스 살펴보기\n\n### 멤버 변수\n\n- 멤버 변수(member variable) = 속성(property) = 특성(attribute)\n\n- 클래스형 = 객체 자료형 = 참조 자료형\n\n\u003cbr\u003e\n\n변수의 자료형 = 기본 자료형 + 참조 자료형\n\n- 기본 자료형 : int, long, float, double 등\n\n- 참조 자료형 : JDK에서 제공하는 String, Date 혹은 내가 만든 Student 등\n\n\u003cbr\u003e\n\n### 메서드\n\n- 메서드(method) = 멤버 함수(member function)\n\n```java\npackage classpart;\n  \npublic class Student {\n\t// 멤버 변수 - 클래스의 속성\n\tint studentID;\n\tString studentName;\n\tint grade;\n\tString address;\n\t  \n\t// 메서드 - 클래스의 기능\n\tpublic void showStudentInfo() {\n\t\tSystem.out.println(studentName + \",\" + address);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### 패키지\n\n- 패키지 : 클래스 파일의 묶음, 계층 구조 가질 수 있음\n\n- 계층 구조를 잘 구성해야 소스코드 관리, 유지 보수 수월\n\n\n```java\npackage domain.student.view;\n  \npublic class StudentView {\n\n}\n```\n\n위 코드에서 `클래스 이름 = StudentView` 이지만, `클래스 전체 이름 = domain.student.view.StudentView`이다. **클래스 이름이 같아도 패키지 이름이 다르면 클래스 전체 이름이 다른 것이므로 다른 클래스이다.**\n\n\u003chr\u003e\n\n## 메서드 (method)\n\n- 메서드는 함수(function)의 한 종류\n\n\u003cbr\u003e\n\n### 함수란?\n\n- **하나의 기능**을 수행하는 일련의 코드\n\n- 함수는 어떤 **기능**을 수행하도록 미리 구현해 놓고 필요할 때마다 호출해서 사용\n\n\u003cbr\u003e\n\n### 함수의 입력과 반환\n\n- 함수는 이름, 입력 값, 결과 값을 가짐\n\n- Input이 있으면 Output이 있다는 말\n\n- 매개변수(parameter) : 함수의 **입력**으로 받는 변수\n\n- 반환 값 : 입력의 결과로 반환해주는 함수의 결과\n\n\u003cbr\u003e\n\n### 함수 정의하기\n\n\u003cbr\u003e\n\n```java\nint add(int num1, int num2) {\n\tint result;\n\tresult = num1 + num2;\n\treturn reslt;\n}\n```\n\n- `int` : 함수 반환형\n\n- `add` : 함수 이름\n\n- `(int num1, int num2)` : 매개변수\n\n\u003cbr\u003e\n\n매개변수가 필요 없는 함수도 있음. 함수 실행하면 함수를 수행한 결과 값만 있음\n\n```java\nint getTenTotal() {\n\tint i;\n\tint total = 0;\n\tfor (i = 1; i \u003c= 10; i++) {\n\t\ttotal += i;\n\t}\n\treturn total;\n}\n```\n\n\u003cbr\u003e\n\n반환 값 없는 함수\n\n- 반환 값 없어도 위치 비우지말고 return은 쓰기\n\n- 반환형에 **void** 표시\n\n- return은 함수 수행을 종료하는 명령어로 이해\n\n```java\nvoid printGreeting(String name) {\n\tSystem.out.println(name + \"님 안녕하세요\");\n\treturn; // 반환 값 없음\n}\n```\n\n\u003cbr\u003e\n\n### 함후 호출과 스택 메모리\n\n\n- 스택(stack) : 함수를 호출하면 그 함수만을 위하여 할당되는 메모리 공간\n\n- 자료가 상자처럼 쌓임, LIFO(Last In First Out)\n\n![](brain/image/chap05-1.png)\n\n![](brain/image/chap05-2.png)\n\n- 지역변수 : num1, num2 혹은 n1, n2 같이 함수 내부에서만 사용하는 변수\n\n- 지역변수는 스택 메모리에 생성\n\n\u003cbr\u003e\n\n### 함수의 장점\n\n1. 기능을 나누어 코드를 효율적으로 구현\n\n2. 기능별로 함수 구현해 놓으면 같은 기능 매번 코드로 안짜고 함수 호출하면 됨\n\n3. **오류 수정 디버깅 작업 편함**, 하나의 기능이 함수로 구현되어 있으니까 오류가 난 기능만 찾아서 수정하면 됨\n\n하나의 함수에 여러 기능이 섞여 있으면, 함수의 장점을 활용할 수 없음. **이름에 맞는 하나의 기능을 구현하는 함수를 작성하자.**\n\n\u003cbr\u003e\n\n### 메서드는 클래스 기능을 구현\n\n위에서 설명한건 프로그래밍 언어적인 면에서 함수의 기능이다. 자바의 클래스 내부에는 클래스의 속성인 멤버 변수, 클래스의 기능인 멤버 함수(메서드)가 있다. 메서드는 함수에 객체지향 개념이 포함된 용어\n\n\u003cbr\u003e\n\n```java\npackage classpart;\n  \npublic class Student {\n\tint studentID;\n\tString studentName;\n\tint grade;\n\tString address;\n\t  \n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n\t  \n\tpublic void setStudentName(String name) {\n\t\tstudentName = name;\n\t}\n}\n```\n\n- `getStudentName()` : 학생 이름 반환하는 메서드\n\n- `setStudentName()` : 학생 이름을 멤버 변수에 대입하는 메서드\n\nsetStudentName() 메서드는 Student 클래스를 사용하는 다른 코드에서 학생 이름을 새로 지정하거나 바꿔준다. **studentName 값을 지정하는 set 기능을 제공하는 것이다.**\n\n\u003chr\u003e\n\n## 클래스와 인스턴스\n\n### 클래스 사용과 main() 함수\n\n**프로그램을 시작하는 main() 함수** \u003cbr\u003e\n\n`main() 함수` : 자바 가상 머신(JVM)이 프로그램을 시작하기 위해 호출하는 함수, 클래스 내부에 만들지만, 클래스의 메서드는 아니다.\n\n\u003cbr\u003e\n\nmain() 함수에서 클래스 사용하는 방법\n\n- 만든 클래스 내부에 main() 함수 만들기\n\n- 외부에 테스트용 클래스 만들어서 사용\n\n\u003cbr\u003e\n\n**Student 클래스 내부에 main() 만들어서 사용**\n\n```java\npackage chapter05;\n\npublic class Student {\n\tint studentID;\n\tString studentName;\n\tint grade;\n\tString address;\n\t  \n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n\t  \n\tpublic static void main(String[] args) {\n\t\tStudent studentAhn = new Student(); // Student 클래스 생성\n\t\tstudentAhn.studentName = \"안연수\";\n\t\t  \n\t\tSystem.out.println(studentAhn.studentName);\n\t\tSystem.out.println(studentAhn.getStudentName());\n\t}\n}\n\n// 안연수\n// 안연수\n```\n\n- 클래스 내부에 main() 함수를 만들면 이 클래스가 프로그램의 시작 클래스\n\n- 클래스가 제대로 수행되는지 알아보기 위해 클래스 내부에 main() 함수 만들고 직접 실행할 수 있음\n\n- 하지만, 이렇게 모든 클래스 내부에 main()을 포함시키지는 않음. 귀찮으니까\n\n\u003cbr\u003e\n\n**main() 함수를 포함한 실행 클래스 따로 만들기**\n\n\n```java\npackage chapter05;\n  \npublic class StudentTest {\n\tpublic static void main(String[] args) {\n\t\tStudent studentAhn = new Student(); // Student 클래스 생성\n\t\tstudentAhn.studentName = \"안승연\";\n\t  \n\t\tSystem.out.println(studentAhn.studentName);\n\t\tSystem.out.println(studentAhn.getStudentName());\n\t}\n}\n  \n// 안연수\n// 안연수\n```\n\n- Student 클래스를 만들지 않은 것이 아니다. 같은 패키지 내부에 아까 Student 클래스를 만들어놨으니 당연히 불러와서 사용할 수 있는 것\n\n- 이 말은 패키지가 다르다면, 사용할 수 없다는 말이다. 그럴때는 **import문을 사용해서 함께 사용하기를 원하는 클래스를 불러와야 한다.**\n\n\u003cbr\u003e\n\n### new 예약어로 클래스 생성\n\n- 클래스를 사용하려면 클래스를 생성해야 함\n\n- 클래스가 생성된다는 것 = 클래스를 실제 사용할 수 있도록 **메모리 공간(힙 메모리)에 올린다는 의미**\n\n- 인스턴스 : 실제로 사용할 수 있도록 생성된 클래스\n\n- 참조 변수 : 인스턴스를 가리키는 클래스형 변수\n\n\u003cbr\u003e\n\n```java\n클래스형 변수이름 = new 생성자;\nStudent studentAhn = new Student();\n```\n\n1. `Student` 클래스 자료형으로\n\n2. `studentAhn` 변수를 선언하고\n\n3. `new Student();`로 Student 클래스를 생성하여\n\n4. `studentAhn`에 대입한다\n\n\t- studentAhn = 참조 변수\n\t- studentAhn이 생성된 인스턴스를 가리킴\n\n\u003cbr\u003e\n\n### 인스턴스와 참조 변수\n\n- 객체 : 의사나 행위가 미치는 대상\n\n- 클래스 : 객체를 코드로 구현한 것\n\n- 인스턴스 : 클래스가 메모리 공간(힙 공간)에 생성된 상태\n\n생성된 클래스의 인스턴스도 객체라고 함\n\n![](brain/image/chap05-3.png)\n\n\u003cbr\u003e\n\n**인스턴스 여러 개 생성**\n\n```java\npackage chapter05\n  \npublic class StudentTest1 {\n\tpublic static void main(String[] args) {\n\t\tStudent student1 = new Student(); // 첫 번째 학생 생성\n\t\tstudent1.studentName = \"안연수\";\n\t\tSystem.out.println(student1.getStudentName());\n\t\tStudent student2 = new Student(); // 두 번째 학생 생성\n\t\tstudent2.studentName = \"안승연\";\n\t\tSystem.out.println(student2.getStudentName());\n\t}\n}\n  \n// 안연수\n// 안승연\n```\n\n\u003cbr\u003e\n\n**참조 변수 사용하기**\n\n- 참조 변수를 사용하여, 인스턴스의 멤버 변수와 메서드 참조가능\n\n- 이때, `도트(.)` 연산자 사용\n\n```java\nstudentAhn.studentName = \"안연수\"; // 멤버 변수 사용\nSystem.out.println(studentAhn.getStudentName()); // 메서드 사용\n```\n\n\u003cbr\u003e\n\n### 인스턴스와 힙 메모리\n\n- 인스턴스가 가지고 있는 멤버 변수를 **힙 메모리**에 저장\n\n- 클래스 생성자를 하나 호출하면 인스턴스가 힙 메모리에 생성됨\n\n```java\nStudent studentAhn = new Student();\n```\n\n![](brain/image/chap05-4.png)\n\n- studentAhn 변수는 **지역 변수**, 따라서 **스택 메모리에 저장**\n\n- 지역 변수인 studentAhn에 생성된 인스턴스를 대입하는 것 = studentAhn에 인스턴스가 생성된 힙 메모리의 주소를 대입한다.\n\n\u003cbr\u003e\n\n```java\nStudent student1 = new Student();\nStudent student2 = new Student();\n```\n\n![](brain/image/chap05-5.png)\n\n- 생성된 다른 인스턴스는 당연히 다른 힙 메모리 공간을 차지\n\n- 클래스가 생성될 때마다 인스턴스는 다른 힙 메모리 공간 차지\n\n- **즉, 멤버 변수를 저장하는 공간이 매번 따로 생긴다는 의미**\n\n- 따라서, 클래스에 선언한 멤버 변수를 다른 말로 **인스턴스 변수**라고 부름\n\n\u003cbr\u003e\n\n**힙 메모리**\n\n힙(heap)은 동적 메모리(dynamic memory) 공간이다. 객체가 생성될 때 사용하는 공간이 힙이다. 힙은 동적으로 할당되고 사용이 끝나면 메모리를 해제해 줘야 한다. 자바는 가비지 컬렉터(garbage collector)가 자동으로 메모리를 해제해 준다.\n\n\u003cbr\u003e\n\n**참조 변수와 참조 값**\n  \n참조 변수(ex.student1, student2)는 힙 메모리에 생성된 인스턴스(ex.Student 클래스)를 가리킨다. 참조 변수에 실제로 어떤 내용이 있는지 출력하겠다.\n\n\u003cbr\u003e\n\n```java\npackage chapter05;\n  \npublic class StudentTest2 {\n\tpublic static void main(String[] args) {\n\t\tStudent student1 = new Student();\n\t\tstudent1.studentName = \"안연수\";\n\t\t  \n\t\tStudent student2 = new Student();\n\t\tstudent2.studentName = \"안승연\";\n\t  \n\t\tSystem.out.println(student1);\n\t\tSystem.out.println(student2);\n\t}\n}\n  \n// chapter05.Student@1b6d3586\n// chapter05.Student@4554617c\n```\n\n- 힙 메모리에 생성된 **인스턴스의 메모리 주소**는 **참조 변수**에 저장 됨\n\n- `클래스 이름@주소 값`\n\n- `주소 값` = `해시 코드(hash code) 값`\n\n- 해시 코드 값은 자바 가상 머신(JVM)에서 객체가 생성되었을 때, **생성된 객체에 할당하는 가상 주소 값**\n\n- 즉, `student1`이 참조 변수, `주소 값`이 참조 값\n\n\u003chr\u003e\n\n## 생성자\n\n\u003cbr\u003e\n\n```java\npackage constructor;\n  \npublic class Person {\n\tString name;\n\tfloat height;\n\tfloat weight;\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage constructor;\n  \npublic class PersonTest {\n\tpublic static void main(String[] args) {\n\t\tPerson personLee = new Person();\n\t}\n}\n```\n\n- 클래스의 멤버 변수는 메서드에 의해 값이 변경될 수도 있지만, 처음 클래스를 생성할 때 값을 정해야 하는 경우도 있음\n\n- 생성자 : 클래스 처음 생성 시, 멤버 변수나 상수를 초기화하는 것\n\n\u003cbr\u003e\n\n**디폴트 생성자** \n\n디폴트 생성자(default constructor) : 생성자가 없는 클래스는 클래스 파일을 컴파일할 때 자바 컴파일러에서 자동으로 생성자를 만들어주는데, 이때, 자동으로 만들어진 생성자\n  \n\u003cbr\u003e\n\n```java\npackage constructor;\n\npublic class Person {\n\tString name;\n\tfloat height;\n\tfloat weight;\n\t\n\t// 자바 컴파일러가 자동으로 제공하는 디폴트 생성자\n\tpublic Person() {}\n}\n```\n\n\u003cbr\u003e\n\n### 생성자 만들기\n\n필요한 경우, 프로그래머가 직접 생성자 구현할 수 있음.\n\n1. 멤버 변수에 대한 값들을 매개변수로 받음\n\n2. 인스턴스가 생성될 때, 멤버 변수 값들을 초기화\n\n즉, 인스턴스가 생성됨과 동시에 멤버 변수의 값을 지정하고 인스턴스를 초기화하기 위해 생성자를 직접 구현해서 사용하기도 함.\n\n\u003cbr\u003e\n\n**생성자 직접 구현한 경우**\n\n- 프로그래머가 직접 구현한 새로운 생성자는 문자열 String형 매개변수를 입력받아서 이름을 지정함.\n\n```java\npackage constructor;\n\npublic class Perseon {\n\tString name;\n\tfloat height;\n\tfloat weight;\n\t  \n\tpublic Person(String pname) {\n\t\tname = pname;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**생성자를 구현하여 디폴트 생성자 없는 경우**\n\n```java\npackage constructor;\n\npublic class PersonTest {\n\tpublic static void main(String[] args) {\n\t\tPerson personLee = new Person();\n\t}\n}\n```\n\n오류 발생. 위에서 String 문자열 하나를 매개변수로 받도록 하는 생성자를 만들면서, **default 생성자가 없음**. 뭐, 쓰고싶으면 디폴트 생성자 하나 만들어서 사용하면 됨\n\n\u003cbr\u003e\n\n**생성자를 구현하고 디폴트 생성자도 구현**\n\n```java\npackage constructor;\n  \npublic class Perseon {\n\tString name;\n\tfloat height;\n\tfloat weight;\n\t  \n\tpublic Person() {}\n\t\n\tpublic Person(String pname) {\n\t\tname = pname;\n\t}\n}\n```\n\n이 경우, 클래스를 실행하면 **두 생성자 중 하나를 선택해서 사용 가능**. 보안 수업 생각해보면 라이브러리 불러와서 쓸 때 import로 막 받아와서 쓰잖음? 그게 클래스를 불러와서 사용할 수 있는거. 그때 그냥 `new keygenerator()` 이런식으로 쓰기도 하지만 매개변수로 값을 넣어서도 쓸 수 있었음. 이는 라이브러리 열어보면 생성자가 여러 개 정의되어 있는 것을 확인가능 !\n\n\u003cbr\u003e\n\n### 생성자 오버로드\n\n- 클래스에 생성자가 두 개 이상 제공되는 경우가 **생성자 오버로드(constructor overload)**\n\n- 매개변수가 있는 생성자를 추가한다고 해서 디폴트 생성자를 꼭 추가해야 하는 것은 아님\n\n\u003cbr\u003e\n\n\u003e [!note] Memo\n\u003e\n\u003e 객체 지향 프로그램에서 메서드 이름이 같고 매개변수만 다른 경우를 \"오버로드\"라고 함\n\n\u003cbr\u003e\n\n학생이 생성될 때 반드시 학번이 있어야 한다면, 아래 처럼 생성자 제공 가능\n\n```java\npublic class Student {\n\tint studentID;\n\t  \n\tpublic Student(int studentID) {\n\t\tthis.studentID = studentID;\n\t}\n}\n```\n\n- 학번을 매개변수로 입력받아, Student 클래스를 생성하는 생성자를 추가함\n\n- 학생을 생성할 때 학번이 꼭 필요하니까, 그냥 만들면 안만들어짐\n\n\u003cbr\u003e\n\n### this 맛보기\n\n\u003cbr\u003e\n\n```java\npublic class Student {\n\tint studentID;\n  \n\tpublic Student(int studentID) {\n\t\tstudentID = studentID\n\t}\n}\n```\n\n- 현재, 인스턴스 변수인 studentID와 매개변수로 전달받은 studentID가 있음\n\n- 나의 마음은 앞의 studentID은 인스턴스 변수로, 뒤의 studentID는 매개변수로 전달받은 것으로 생각할 수 있다. 하지만, 컴파일러는 그렇게 하지 못한다.\n\n```java\npublic class Student {\n\tint studentID;\n  \n\tpublic Student(int mystudentID) {\n\t\tstudentID = mystudentID\n\t}\n}\n```\n\n- 그럼 인스턴스 변수와 매개변수로 전달받은 변수의 이름을 바꾸면 된다. 위에서 pname 사용한 것처럼. 그러나, 이렇게하면 인생이 피곤하지 않을까? 그래서 this 투입\n\n```java\npublic class Student {\n\tint studentID;\n\n\tpublic Student(int studentID) {\n\t\tthis.studentID = studentID;\n\t}\n}\n```\n\n- 매개변수로 전달받은 것은 studentID. 납득하지?\n\n- this는 인스턴스 자기 자신을 가리킨다. 이거 지금 내가 만든 클래스라서 명확하게 인스턴스랑은 다른거 아닌가?라고 생각하고 삐딱선 탄 것 같은데.. 그냥 객체 자기 자신을 가리킨다고 생각하자.\n\n\u003cbr\u003e\n\n\u003e [!note] Tip !\n\u003e\n\u003e 추가로, 정보 은닉과 관련된 이야기인데, 어떤 멤버 변수들은 외부 클래스에서 값을 지정하지 못하는 경우도 있다. (ex. `personLee.name = \"이소룡\"` 이런거 안된다는 말) public이냐 private이냐 등등 접근제어자 신경 안쓸거면 **매개변수가 있는 생성자를 구현하고 이를 사용하는 것이 편리한 경우가 많다.**\n\n\u003chr\u003e\n\n## 참조 자료형\n\n- 자료형 = 기본 자료형(int, float 등) + 참조 자료형(String, Date, Student 등)\n\n- 즉, 필요하다면 클래스를 분리하여 참조 자료형으로 다른 클래스를 참조하여 코드를 짤 수 있음\n\n- 참조 자료형은 프로그래머가 필요에 의해 만든 클래스 or JDK에서 제공하느 클래스를 사용할 수 있음\n\n```java\npackage reference;\n\npublic class Subject {\n\tString SubjectName;\n\tint scorePoint;\n}\n\npublic class Student3 {\n\tint studentID;\n\tString studentName;\n\tSubject korean;\n\tSubject math;\n}\n```\n\n\u003chr\u003e\n\n## 정보 은닉\n\n### 접근 제어자\n\n접근 제어자(access modifier)는 **클래스 내부의 변수/메서드/생성자에 대한 접근 권한을 지정**할 수 있는 예약어이다.\n\n- public : public으로 선언한 변수나 메서드는 **외부 클래스에서 접근 가능**\n\n- private : private으로 선언한 변수나 메서드는 **외부 클래스에서 접근 불가능**\n\n\n```java\npackage hiding;\n  \npublic class Student {\n\tint studentID;\n\tprivate String studentName;\n\tint grade;\n\tString address;\n\t  \n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n\t\n\tpublic void setStudentName(String studentName) {\n\t\tthis.studentName = studentName;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage hiding;\n  \npublic class StudentTest {\n\tpublic static void main(String[] args) {\n\t\tStudent studentLee = new Student();\n\t\tstudentLee.studentName = \"이상원\";\n\t\t  \n\t\tSystem.out.println(studentLee.getStudentName());\n\t}\n}\n```\n\nStudent 클래스의 studentName 변수의 접근 제어자를 private으로 바꾸고 StudentTest 클래스에서 studentName을 접근하려고 하니 바로 오류가 출력된다. `studentLee.studentName = \"이상원\";` 여기부터 바로 오류 출력\n\n접근 제어자가 public일 때는 외부 클래스인 StudentTest에서 접근 가능했지만, private으로 바뀌자 접근이 불가능해졌다.\n\n\u003cbr\u003e\n\n### get(), set() 메서드\n\nprivate으로 선언한 studentName 변수를 외부 코드에서 사용하려면 어떻게?\n\n- studentName 변수를 사용할 수 있도록 public 메서드를 제공해야 함\n\n- 그것이 바로 `get()`, `set()` 메서드.\n\n- 값을 얻는 get() 메서드를 getter, 값을 저장하는 set() 메서드를 setter 라고도 함\n\n\u003cbr\u003e\n\n```java\npackage hiding;\n\npublic class Student {\n\tint studentID;\n\tprivate String studentName;\n\tint grade;\n\tString address;\n\t\n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n\t\n\tpublic void setStudentName(String studentName) {\n\t\tthis.studentName = studentName;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage hiding;\n\npublic class StudentTest {\n\tpublic static void main(String[] args) {\n\t\tStudent studentLee = new Student();\n\t\t// studentLee.studentName = \"이상원\";\n\t\tstudentLee.setStudentName(\"이상원\");\n\t\t  \n\t\tSystem.out.println(studentLee.getStudentName());\n\t}\n}\n```\n\n- studentName 변수에 직접 값을 대입하는 방식 (X)\n\n- public인 setStudentName() 메서드를 활용하여 값 대입\n\n\u003cbr\u003e\n\n### 정보 은닉이란?\n\n그래서 변수를 public으로 선언하고 접근하는 것과 private으로 선언하고 public인 메서드로 접근하는 것의 차이가 뭔데? 어차피 접근하는거 똑같은데\n\n\u003cbr\u003e\n\n```java\npublic class Mydate {\n\tpublic int day;\n\tpublic int month;\n\tpublic int year;\n}\n```\n\n\u003cbr\u003e\n\n```java\npublic class MydateTest {\n\tpublic static void main(String[] args) {\n\t\tMydate date = new Mydate();\n\t\tdate.month = 2;\n\t\tdate.day = 31;\n\t\tdate.year = 2022;\n\t}\n}\n```\n\n당연히 Mydate 클래스에 변수들을 전부 public으로 선언했으니까 막 접근해서 값 대입 가능하다. 그러나, 2월은 알다시피 28일이나 29일까지인데 31을 넣어버렸다. **public으로 선언하면 접근이 제한되지 않으니까 정보의 오류가 발생할 수 있다.**\n\n그래서, 단순히 값을 변수에 대입하는 형태가 아니라, 메서드 형태로 값을 대입하도록 하면 if문과 같은 제어문을 넣어서 잘못된 값인지 아닌지 알려줄 수 있다.  \n\n```java\npublic class Mydate {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\t  \n\tpublic setDay(int dau) {\n\t\tif (month == 2) {\n\t\t\tif (day \u003c 1 || day \u003e 28) {\n\t\t\t\tSystem.out.println(\"오류입니다.\");\n\t\t\t} else {\n\t\t\t\tthis.day = day;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\u003cbr\u003e\n\n|접근 제어자|설명|\n|:--:|:--:|\n|public|외부 클래스 어디에서나 접근 O|\n|protected|같은 패키지 내부, 상속 관계의 클래스에서만 접근 O, 그외 X|\n|아무것도 없는 경우| default, 같은 패키지 내부에서만 접근 O|\n|private|같은 클래스 내부에서만 접근 O|","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/chap06":{"title":"06.클래스와 객체 (2)","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 06 - 클래스와 객체 (2)\n\n\u003cbr\u003e\n\n## this 예약어\n\n### 자신의 메모리를 가리키는 this\n\nthis : 생성된 인스턴스 자기 자신을 가리키는 예약어\n\n```java\npackage chapter06;\n  \nclass BirthDay {\n\tint year;\n\tint month;\n\tint day;\n\npublic void setYear(int year) {\n\tthis.year = year;\n}\n  \npublic void printThis() {\n\tSystem.out.println(this);\n}\n}\n  \npublic class ThisExample {\n\tpublic static void main(String[] args) {\n\tBirthDay bDay = new BirthDay();\n\t\tbDay.setYear(2022);\n\t\tSystem.out.println(bDay);\n\t\tbDay.printThis();\n\t}\n}\n\n// chapter06.BirthDay@1b6d3586\n// chapter06.BirthDay@1b6d3586\n```\n\n![](brain/image/chap06-1.png)\n\n- 참조 변수 (bDay)를 출력한 결과 `클래스 이름@메모리 주소`\n\n- printThis() 메서드를 실행하여 this 출력한 결과 `클래스 이름@메모리 주소`\n\n- 힙 메모리에 생성된 인스턴스를 가리키는 것을 확인 가능\n\n\u003cbr\u003e\n\n보통, 하나의 자바 파일에 하나의 클래스가 있는 것이 대부분이지만, 하나의 파일에 여러 클래스가 존재할 수 있다. 하지만 그때 public 클래스는 \"1개\" 뿐이라는 것을 명심! 간단한 클래스를 활용하는 경우 하나의 파일에 여러 클래스가 있을 수 있다.\n\n\u003cbr\u003e\n\n### 생성자에서 다른 생성자를 호출하는 this\n\n```java\npackage chapter06;\n  \nclass Person {\n\tString name;\n\tint age;\n  \n\tPerson() {\n\t\tthis(\"이름 없음\", 1);\n\t}\n  \n\tPerson(String name, int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n}\n  \npublic class CallAnohterConst {\n\tpublic static void main(String[] args) {\n\t\tPerson noName = new Person();\n\t\tSystem.out.println(noName.name);\n\t\tSystem.out.println(noName.age);\n\t}\n}\n\n// 이름 없음\n// 1\n```\n\n- 현재, `Person()` 디폴트 생성자, `Person(String, int)` 생성자 2개 존재\n\n- 클래스 생성 시 `Person()` 디폴트 생성자 이용 : 디폴트 생성자가 호출되는 경우에는 초깃값으로 \"이름 없음\"과 1을 대입하려고 this로 다른 생성자 호출한 것\n\n- `Person(String, int)` 생성자는 매개변수 넣고 똑같이 사용하면 됨\n  \n\u003cbr\u003e\n\n**주의 !!** this로 다른 생성자 호출 시 this 코드 이전에 다른 코드 넣으면 오류 발생. 디폴트 생성자에서 생성이 완료되는 것이 아니라, this를 사용해 다른 생성자를 호출하기 때문에 this를 활용한 문장이 가장 먼저 와야함.\n\n\u003cbr\u003e\n\n### 자신의 주소를 반환하는 this\n\n인스턴스 주소 값을 반환할 때 this를 사용하고 반환형은 클래스 자료형을 사용하면 된다.\n\n```java\npackage chapter06;\n\nclass Person {\n\tPerson returnItSelf() {\n\t\treturn this;\n\t}\n}\n  \npublic class CallAnohterConst {\n\tpublic static void main(String[] args) {\n\t\tPerson noName = new Person();\n\t\tPerson p = noName.returnItSelf();\n\t\tSystem.out.println(p);\n\t\tSystem.out.println(noName);\n\t}\n}\n  \n// chapter06.Person@1b6d3586\n// chapter06.Person@1b6d3586\n```\n\n\u003chr\u003e\n\n## 객체 간 협력\n\n결국, 객체지향 프로그래밍은 객체를 정의하고 객체 간 협력을 기반으로 만든다.\n\n- 학생 class (이름, 학년, 가진 돈)\n\n- 버스 class (버스 번호, 승객 수, 수입)\n\n- 지하철 class (노선 번호, 승객 수, 수입)\n\n- 학생 -\u003e 버스 : 버스를 탄다.\n\n- 학생 -\u003e 지하철 : 지하철을 탄다.\n\n즉, 객체가 필요한 멤버 변수를 선언하고, 생성자를 정의하고 객체 사이의 협력 기능을 구현한다. \"학생이 지하철을 탄다\"는 **학생 객체의 입장에서 사용한 문장**이다. **지하철 객체의 입장에서 생각해보면, 지하철에 학생이 탄다**이다.\n\n**두 객체에서 서로 다른 일이 발생하는 것이므로 이를 각각의 클래스에 메서드로 구현한다.** 각 객체의 입장을 잘 생각해서 코드를 짜자. 코드는 \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter06/Student.java' target='_blank'\u003eStudent 클래스\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter06/Bus.java' target='_blank'\u003eBus 클래스\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter06/Subway.java' target='_blank'\u003eSubway 클래스\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter06/Taxi.java' target='_blank'\u003eTaxi 클래스\u003c/a\u003e, 테스트 클래스인 \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter06/TakeTrans.java' target='_blank'\u003eTakeTrans 클래스\u003c/a\u003e를 참조한다.\n\n\u003chr\u003e\n\n## static 변수\n\n### 변수를 여러 클래스에서 공통으로 사용하려면?\n\n\u003cbr\u003e\n\n```java\npublic class Student {\n\tpublic int studentID;\n\tpublic String studentName;\n\tpublic int grade;\n\tpublic String address;\n}\n```\n\n위와 같은 학생 클래스가 예시로 있다. 만약 학생이 입학할 때 (=클래스가 생성되면) 학번이 자동으로 부여되도록 만들고 싶다. 생성된 인스턴스는 학번을 순서대로 가져야 한다.\n\n이러한 경우, 각 인스턴스마다 따로 생성되는 변수가 아닌, **클래스 전반에서 공통으로 사용할 수 있는 기준 변수**가 있어야 한다.\n\n\u003e 클래스에서 공통으로 사용하는 변수를 **static 변수**로 선언한다.\n\n\u003cbr\u003e\n\n### static 변수의 정의와 사용 방법\n\nstatic 변수는 정적 변수이다. 클래스 내부에 선언하고 자료형 앞에 static 예약어 사용\n\n```java\nstatic int serialNum;\n```\n\nstatic 변수 (= 정적 변수)는 클래스 내부에 선언하지만, 다른 멤버 변수처럼 인스턴스가 생성될 때마다 새로 생성되는 변수가 아니다. static 변수는 프로그램이 실행되어 메모리에 올라갔을 때 딱 한 번 메모리 공간이 할당된다. 이 값은 **모든 인스턴스가 공유한다.**\n\nstatic으로 선언한 변수는 인스턴스 생성과 상관없이 **먼저 생성**되고 그 값을 모든 인스턴스가 공유하게 된다. 이러한 이유로 클래스스에 기반한 변수라고 하며 **클래스 변수**라고도 한다.\n\n- static 변수 = 정적 변수 = 클래스 변수\n\n- 딱 한 번 메모리 공간 메서드 영역에 할당\n\n- 모든 인스턴스가 이 값을 공유\n\n\u003cbr\u003e\u003cbr\u003e\n\n**메모리 영역 정리** \n\n- JVM은 메모리를 할당받고 용도에 따라 여러 영역으로 나누어 관리\n\n- 대표적으로 3가지 (메서드 영역, 호출 스택, 힙)\n\n- 메서드 영역 : 클래스파일(`.class`) 읽어서 분석하고 클래스에 대한 정보, 클래스 데이터, 클래스 변수 등\n\n- 호출 스택 : 메서드의 작업에 필요한 메모리 공간 제공, 지역 변수, 매개변수 등\n\n- 힙 : 인스턴스가 생성되는 공간, 인스턴스 변수\n\n\u003cbr\u003e\n\n```java\npackage chapter06;\n  \npublic class StudentStatic {\n\tpublic static int serialNum = 1000;\n\tpublic int studentID;\n\tpublic String studentName;\n\tpublic int grade;\n\tpublic String address;\n\n\tpublic StudentStatic() {\n\t\tserialNum++;\n\t\tstudentID = serialNum;\n\t}\n  \n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n  \n\tpublic void setStudentName(String studentName) {\n\t\tthis.studentName = studentName;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter06;\n  \npublic class StudentStaticTest {\n\tpublic static void main(String[] args) {\n\t\tStudentStatic studentLee = new StudentStatic();\n\t\tstudentLee.setStudentName(\"이지원\");\n\t\tSystem.out.println(studentLee.serialNum);\n\t\tSystem.out.println(studentLee.studentName + \" 학번 : \" + studentLee.studentID);\n\t\t  \n\t\tStudentStatic studentSon = new StudentStatic();\n\t\tstudentSon.setStudentName(\"손수경\");\n\t\tSystem.out.println(studentSon.serialNum);\n\t\tSystem.out.println(studentSon.studentName + \" 학번 : \" + studentSon.studentID);\n\t}\n}\n  \n// 1001\n// 이지원 학번 : 1001\n// 1002\n// 손수경 학번 : 1002\n```\n\n\u003cbr\u003e\n\n### 클래스 변수\n\nstatic 변수 = 정적 변수 = 클래스 변수는 인스턴스를 생성할 때마다 만들어지는 것이 아니다. 인스턴스 생성과는 별개이고 **인스턴스보다 먼저 생성되어 메서드 영역에 저장**된다. 그래서 위에 코드를 인스턴스말고 **클래스 이름으로 직접 참조**하도록 하여 serialNum을 가져올 수 있다.\n\n```java\npackage chapter06;\n  \npublic class StudentStaticTest {\n\tpublic static void main(String[] args) {\n\t\tStudentStatic studentLee = new StudentStatic();\n\t\tstudentLee.setStudentName(\"이지원\");\n\t\t// 인스턴스 생성 안하고 그냥 가져올 수 있음\n\t\tSystem.out.println(StudentStatic.serialNum);\n\t\tSystem.out.println(studentLee.studentName + \" 학번 : \" + studentLee.studentID);\n\t\t\n\t\tStudentStatic studentSon = new StudentStatic();\n\t\tstudentSon.setStudentName(\"손수경\");\n\t\t// 인스턴스 생성 안하고 그냥 가져올 수 있음\n\t\tSystem.out.println(StudentStatic.serialNum);\n\t\tSystem.out.println(studentSon.studentName + \" 학번 : \" + studentSon.studentID);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### 클래스 메서드\n\nstatic 변수를 위한 메서드도 있다. 이것을 **static 메서드** 혹은 **클래스 메서드**라고 한다.\n\n- 외부 클래스에서 serialNum 직접 참조 못하게 private으로 선언\n\n- private으로 바꿨으니 StudentStaticTest 클래스에서 접근 못하니까 직접 참조 불가\n\n- serialNum에 대한 get(), set() 생성\n\n- get()으로 참조하기\n\n```java\npackage chapter06;\n\npublic class StudentStaticMethod {\n\tprivate static int serialNum = 1000;\n\tint studentID;\n\tString studentName;\n\tint grade;\n\tString address;\n\t  \n\tpublic StudentStaticMethod() {\n\t\tserialNum++;\n\t\tstudentID = serialNum;\n\t}\n\t  \n\tpublic String getStudentName() {\n\t\treturn studentName;\n\t}\n\t  \n\tpublic void setStudentName(String studentName) {\n\t\tthis.studentName = studentName;\n\t}\n\t  \n\tpublic static int getSerialNum() {\n\t\treturn serialNum;\n\t}\n\t\n\tpublic static void setSerialNum(int serialNum) {\n\t\tStudentStaticMethod.serialNum = serialNum;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter06;\n  \npublic class StudentStaticMethodTest {\n\tpublic static void main(String[] args) {\n\t\tStudentStaticMethod studentLee = new StudentStaticMethod();\n\t\tstudentLee.setStudentName(\"이지원\");\n\t\tSystem.out.println(StudentStaticMethod.getSerialNum());\n\t\tSystem.out.println(studentLee.studentName + \" 학번 : \" + studentLee.studentID);\n\t\t  \n\t\tStudentStaticMethod studentSon = new StudentStaticMethod();\n\t\tstudentSon.setStudentName(\"손수경\");\n\t\tSystem.out.println(StudentStaticMethod.getSerialNum());\n\t\tSystem.out.println(studentSon.studentName + \" 학번 : \" + studentSon.studentID);\n\t}\n}\n```\n\nstatic 메서드 또한 static 변수처럼 **인스턴스 참조 변수가 아닌 클래스 이름으로 직접 호출할 수 있음**. 다음으로, `getSerialNum()` 메서드를 더 살펴보겠다.\n\n```java\npublic static int getSerialNum() {\n\tint i = 10;\n\tstudentName = \"이지원\";\n\treturn serialNum;\n}\n```\n\n- `int i = 10`은 메서드 내부에서 선언한 **지역 변수**이다. `getSerialNum()` 메서드 내부에서만 사용 가능하다.\n\n- `return serialNum;`은 serialNum이 static 변수라서 static 메서드에서 사용 가능하다.\n\n- 그러나, `studentName`은 인스턴스 변수라서 인스턴스가 생성될 때 만들어지는 변수라서 아직 인스턴스를 생성하고 이런 상태가 아니라서 사용할 수 없다. 오류발생\n\n\u003e 클래스 메서드, 클래스 변수는 인스턴스가 생성되지 않아도 클래스를 직접 참조하여 사용 가능하다.\n\n\u003cbr\u003e\n\n정리하자면, **클래스 메서드 내부에서 지역 변수와 클래스 변수는 사용할 수 있지만, 인스턴스 변수는 사용할 수 없다.** 반대로, 일반 메서드에서 클래스 변수를 사용하는 것은 문제 없다.\n\n- 일반 메서드 : 인스턴스 생성될 때 호출되는 메서드, 클래스 변수는 이미 만들어져있어서 호출 가능\n\n- 클래스 메서드 : 이미 만들어져있는 클래스 변수는 사용 가능, 하지만 인스턴스 변수는 아직 생성 안되었으니까 사용 불가능 !\n\n\u003chr\u003e\n\n## 변수 유효 범위\n\n변수는 어디에 어떻게 선언되느냐에 따라 **유효범위(scope)** 가 달라진다.\n\n\u003cbr\u003e\n\n### 지역 변수 유효범위\n\n- 지역 변수(로컬 변수, local variable)는 함수나 메서드 내부에 선언, 함수 밖에서 사용 못함\n\n- 지역 변수가 생성되는 메모리는 **스택(stack)**\n\n- 함수가 호출될 때 스택에 생성되었다가 함수가 반환되면 할당되었던 메모리 공간 해제하면서 없어짐\n\n\u003cbr\u003e\n\n### 멤버 변수 유효범위\n\n- 멤버 변수(인스턴스 변수)는 클래스의 어느 메서드에서나 사용 가능\n\n- 멤버 변수가 생성되는 메모리는 **힙(heap)**\n\n- 힙에 생성된 인스턴스가 가비지 컬렉터(garbage collector)에 의해 수거되면 메모리에서 사라진다. 따라서 클래스 **내부**의 여러 메서드에서 사용할 변수는 멤버 변수로 선언하는 것이 좋음\n\n\u003cbr\u003e\n\n### 정적 변수 유효범위\n\n- 정적 변수(static 변수, 클래스 변수)는 private이 아니라면 클래스 외부에서도 객체 생성(인스턴스 생성)과 무관하게 사용 가능\n\n- 정적 변수가 생성되는 메모리는 **메서드 영역**\n\n- 메서드 영역 (책에서는 데이터 영역이라고 표현)에는 상수, 문자열, static 변수가 생성된다. 따라서 클래스 생성과 상관 없이 처음부터 메모리에 올라가는 것\n\n- 프로그램 실행이 끝난 뒤 메모리에서 내려가면 그때 static 변수가 소멸된다. 즉, 프로그램의 시작부터 끝까지 메모리에 상주하므로, 너무 큰 변수를 static으로 선언하는 것은 좋지 않다.\n\n\u003cbr\u003e\n\n### 변수 유형에 따른 용도\n\n![](brain/image/chap06-2.png)\n\n- 클래스의 여러 메서드에서 사용할 변수\n\n이러한 상황에 지역 변수로 선언하면, 다른 메서드에서 사용할 일이 있을 때 지역 변수를 메서드의 매개변수로 전달해야해서 매우 번거로움\n\n\u003cbr\u003e\n\n모든 변수를 멤버 변수나 static 변수로 선언하면 메모리가 낭비되고 코드의 가독성 떨어짐. 따라서, 정답은 없으니까 상황에 맞게 효율적으로 프로그래밍 해야함.\n\n\u003cbr\u003e\n\n- [x] 함수에서 기능 구현을 위해 잠시 사용 -\u003e 지역 변수\n\n- [x] 클래스의 속성을 나타내고 각 인스턴스 마다 다른 값 가짐 -\u003e 멤버 변수\n\n- [x] 여러 인스턴스에서 공유해서 사용하도록 한 번만 생성 -\u003e 정적 변수\n\n\u003chr\u003e\n\n## static 응용 - 싱글톤 패턴\n\n### 디자인 패턴이란?\n\n- 객체지향 프로그램을 구현할 때 더 유연하고 재활용성이 높은 프로그램을 만들 수 있도록 정리한 내용\n\n- 프로그램 특성에 따른 설계 유형을 이론화 한 것\n\n- 자바에만 한정 짓는 것이 아닌 다른 객체 지향 언어에도 적용 가능\n\n\u003cbr\u003e\n\n### 싱글톤 패턴이란?\n\n프로그램 구현 시, 여러 개의 인스턴스가 필요한 경우, 단 하나의 인스턴스만 필요한 경우가 있는데, **인스턴스를 단 하나만 생성하는 디자인 패턴을 싱클톤 패턴(singleton pattern)** 이라고 함.\n\n여기서 살펴볼 싱글톤 패턴은 **static을 응용하여 프로그램 전반에서 사용하는 인스턴스를 하나만 구현하는 방식**\n\n\u003cbr\u003e\n\n예시\n\n- 어떤 회사의 직원들을 객체 지향 프로그램으로 구현\n\n- 회사는 하나, 직원은 여러명\n\n- 회사 객체는 **단 하나만 생성**\n\n- 직원 인스턴스는 여러 개 생성\n\n\u003cbr\u003e\n\n### 싱글톤 패턴으로 회사 클래스 구현\n\n1. 생성자를 private으로 만들기\n\n\t- 컴파일러가 만들어주는 디폴트 생성자는 항상 public\n\n\t- 생성자가 public이면 외부 클래스에서 인스턴스 여러 개 생성 가능\n\n\t- 싱글톤 패턴에서는 생성자를 **반드시** 명시적으로 만들고 접근 제어자 private으로\n\n```java\npackage chapter06.singleton;\n  \npublic class Company {\n\tprivate Company() {}\n}\n```\n\n\u003cbr\u003e\n\n2. 클래스 내부에 static으로 유일한 인스턴스 생성\n  \n\t- 1단계에서 private으로 바꿔서 외부 인스턴스를 생성 못하게 바꿨음\n\n\t- 하지만, 프로그램에서 사용할 인스턴스 **단 하나**는 필요\n\n\t- 싱글톤 패턴으로 만든 클래스 내부에서 **하나의 인스턴스 생성**\n\n\t- 이 인스턴스가 프로그램 전체에서 사용할 유일한 인스턴스\n\n```java\npackage chapter06.singleton;\n  \npublic class Company {\n\tprivate static Company instance = new Company();\n\tprivate Company() {}\n}\n```\n\n\u003cbr\u003e\n\n3. 외부에서 참조할 수 있는 public 메서드 생성\n\n\t- private으로 선언한 유일한 인스턴스를 외부에서 사용할 수 있도록 설정\n\n\t- 위 작업을 위해 public 메서드 생성하고 유일하게 생성한 인스턴스 반환\n\n\t- 인스턴스를 반환하는 메서드는 반드시 **static**으로 선언\n\n\t- static 선언 이유 : 인스턴스 생성과 상관없이 호출해야해서\n\n```java\npackage chapter06.singleton;\n  \npublic class Company {\n\tprivate static Company instance = new Company();\n\tprivate Company() {}\n\t  \n\tpublic static Company getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Company();\n\t\t}\n\t\t\n\t\treturn instance;\n\t}\n}\n```\n\n이는 마치 private 변수 선언했을 때, 외부에서 사용하려고 public get() 메서드 구현한 것과 동일한 모습이다.\n\n\u003cbr\u003e\n\n4. 실제로 사용하는 코드 생성\n\n\t- 외부 클래스에서 Company 생성 불가능한 상태\n\n\t- 따라서, static으로 제공되는 getInstance() 메서드를 호출\n\n\t- `Company.getInstance();`로 호출하면 반환값으로 유일한 인스턴스 받음\n\n\t- 아래 코드는 같은 주소인지 확인하여 유일한 인스턴스가 맞는지 증명하는 코드\n\n```java\npackage chapter06.singleton;\n  \npublic class CompanyTest {\n\tpublic static void main(String[] args) {\n\t\tCompany myComapny1 = Company.getInstance();\n\t\tCompany myCompany2 = Company.getInstance();\n\t\tSystem.out.println(myComapny1 == myCompany2);\n\t}\n}\n  \n// true\n```","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/chap07":{"title":"07.배열과 ArrayList","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 07 - 배열과 ArrayList\n\n\u003cbr\u003e\n\n## 배열이란?\n\n### 배열 선언과 초기화\n\n\u003cbr\u003e\n\n```java\n자료형[] 배열이름 = new 자료형[개수];\n자료형 배열이름[] = new 자료형[개수];\nint[] studentsID = new int[10];\n```\n\n뭘 사용해도 되지만, 두잇자바 교재에서는 위 방식을 채택함\n\nint형이니까 4바이트 이므로, 10칸 선언했으니 40바이트가 배열 전체의 크기이다. **선언한 자료형과 배열 길이에 따라 메모리가 할당**된다. 이때 **선언과 동시에 요소의 값이 초기화**된다.\n\n- 정수형 : 0\n\n- 실수형 : 0.0\n\n- 객체 : null\n\n\u003cbr\u003e\n\n**배열 선언 방법**\n\n- 개수 생략, 초기화 요소의 개수만큼 배열이 생성\n\n```java\nint[] studentIDs = new int[] {101, 102, 103};\n```\n\n- 위 케이스에서 `new int[]` 부분 생략 가능 (초기화 개수만큼 배열 생성)\n\n```java\nint[] studentIDs = {101, 102, 103};\n```\n\n- 위 케이스에서 new int 안에 개수 넣으면 오류 발생\n\n```java\n// 이거 오류 발생 !!!!!!\nint[] studentIDs = new int[3] {101, 102, 103};\n```\n\n- 배열 자료형을 먼저 선언하고 초기화 하는 경우, new int 생략 불가\n\n```java\nint[] studentIDs;\nstudentIDs = new int[] {101, 102, 103};\n```\n\n\u003cbr\u003e\n\n### 배열 사용하기\n\n인덱스에 값 저장하거나 인덱스에서 값 뽑아오는거 말함\n\n- 배열의 물리적 위치 : 메모리에서 배열이 실제로 저장되는 곳\n\n- 배열의 논리적 위치 : 이론상 배열 위치\n\n이게 무슨 말이냐면, 배열 이외의 자료구조는 논리적으로 바로 옆에 붙어있다고 해도 실제 메모리 위치는 아예 다를 수도 있음.\n\n하지만, 배열은 논리적 위치에서 사용하는 실제 값도 바로 이웃한 메모리에 위치함. 예를 들어, 5칸짜리 배열이 있으면 그 5칸은 실제의 물리적 위치에서도 이웃하게 붙어있음. 주소값 출력 찍어보면 바로 암\n\n\u003cbr\u003e\n\n### 전체 배열 길이와 유효한 요소 값\n\n- 배열 사용할 때 처음 선언한 배열 길이만큼 값을 저장해서 사용하는 경우는 많지 않음\n\n- `전체 배열길이 != 현재 배열에 유효한 값이 저장되어 있는 배열 요소 개수`\n\n```java\npublic class ArrayTest {\n\tpublic static void main(String[] args) {\n\t\tdouble[] data = new double[5];\n\t\tdata[0] = 10.0;\n\t\tdata[1] = 20.0;\n\t\tdata[2] = 30.0;\n\t\t  \n\t\tfor (int i = 0; i \u003c data.length; i++) {\n\t\t\tSystem.out.println(data[i]);\n\t\t}\n\t}\n}\n  \n// 10.0\n// 20.0\n// 30.0\n// 0.0\n// 0.0\n```\n\n전체 배열 길이 5에서 유효한 값은 3까지임. 그러면 유효한 값까지만 출력해보는 프로그램은 어떻게 만들까?\n\n```java\npublic class ArrayTest2 {\n\tpublic static void main(String[] args) {\n\t\tdouble[] data = new double[5];\n\t\t// 유효한 값이 저장된 배열 요소 개수를 저장할 변수\n\t\tint size = 0;\t  \n\t\tdata[0] = 10.0; size++;\n\t\tdata[1] = 20.0; size++;\n\t\tdata[2] = 30.0; size++;\n\t\t  \n\t\t// 유효한 값이 저장된 배열 요소 개수만큼 반복문 실행\n\t\tfor(int i = 0; i \u003c size; i++) {\n\t\t\tSystem.out.println(data[i]);\n\t\t}\n\t}\n}\n  \n// 10.0\n// 20.0\n// 30.0\n```\n\n- 이렇게 추가적인 변수를 통하여 유효한 값만 뽑아올 수 있다.\n\n- ArrayList 객체 배열은 이런 부분을 미리 구현해서 메서드로 제공해줌 ㅎ\n\n\u003cbr\u003e\n\n### 문자 저장 배열 만들기\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\n  \npublic class CharArray {\n\tpublic static void main(String[] args) {\n\t\tchar[] alphabets = new char[26];\n\t\tchar ch = 'A';\n\t\t  \n\t\tfor(int i = 0; i \u003c alphabets.length; i++, ch++) {\n\t\t\talphabets[i] = ch;\n\t\t}\n\t\t  \n\t\tfor(int i = 0; i \u003c alphabets.length; i++) {\n\t\t\tSystem.out.println(alphabets[i] + \", \" + (int)alphabets[i]);\n\t\t}\n\t}\n}\n```\n\n- 알파벳 문자는 실제 메모리에 아스키 코드 값으로 저장됨\n\n- 예를 들어, 아스키 코드값 65는 대문자 'A'임\n\n- 아스키 코드값을 1씩 증가시키면 A, B, C .. 이렇게 증가\n\n\u003cbr\u003e\n\n### 객체 배열 사용\n\n- 기본 자료형(int, double 등)이 아닌 참조 자료형으로 선언하는 방법\n\n- 참조 자료형 변수는 클래스형으로 선언한 변수를 의미\n\n```java\n// Book 클래스\npackage chapter07;\n  \npublic class Book {\n\tprivate String bookName;\n\tprivate String author;\n\t  \n\tpublic Book () {};\n\t  \n\tpublic Book(String bookName, String author) {\n\t\tthis.bookName = bookName;\n\t\tthis.author = author;\n\t}\n\t  \n\tpublic String getBookName() {\n\t\treturn bookName;\n\t}\n\t  \n\tpublic void setBookName(String bookName) {\n\t\tthis.bookName = bookName;\n\t}\n\t  \n\tpublic String getAuthor() {\n\t\treturn author;\n\t}\n\t  \n\tpublic void setAuthor(String author) {\n\t\tthis.author = author;\n\t}\n\t  \n\tpublic void showBookInfo() {\n\t\tSystem.out.println(bookName + \", \" + author);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\n// BookArray 클래스\npackage chapter07;\n  \npublic class BookArray {\n\tpublic static void main(String[] args) {\n\t\tBook[] library = new Book[5];\n\t\t  \n\t\tfor(int i = 0; i \u003c library.length; i++) {\n\t\t\tSystem.out.println(library[i]);\n\t\t}\n\t}\n} \n\n// null\n// null\n// null\n// null\n// null\n```\n\n- `Book[] library = new Book[5];`은 Book 클래스의 인스턴스가 5개 생성된 것이 아님\n\n- 인스턴스를 생성하면 그 인스턴스를 가리키는 주소 값이 있는데, 인스턴스 주소 값을 담을 공간 5개를 생성한다는 의미\n\n- 그래서 Book 클래스 주소를 담을 공간 5개를 만들었고, 비어있으니까 null이 출력되는 것\n\n\u003cbr\u003e\n\n```java\n// BookArray2 클래스\npackage chapter07;\n  \npublic class BookArray2 {\n\tpublic static void main(String[] args) {\n\t\tBook[] library = new Book[5];\n\t\t  \n\t\tlibrary[0] = new Book(\"태백산맥\", \"조정래\");\n\t\tlibrary[1] = new Book(\"데미안\", \"헤르만 헤세\");\n\t\tlibrary[2] = new Book(\"어떻게 살 것 인가\", \"유시민\");\n\t\tlibrary[3] = new Book(\"토지\", \"박경리\");\n\t\tlibrary[4] = new Book(\"어린왕자\", \"생택쥐페리\");\n\t\t  \n\t\tfor (int i = 0; i \u003c library.length; i++) {\n\t\t\tlibrary[i].showBookInfo();\n\t\t}\n\t\t  \n\t\tfor (int i = 0; i \u003c library.length; i++) {\n\t\t\tSystem.out.println(library[i]);\n\t\t}\n\t}\n}\n  \n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것 인가, 유시민\n// 토지, 박경리\n// 어린왕자, 생택쥐페리\n// chapter07.Book@1b6d3586\n// chapter07.Book@4554617c\n// chapter07.Book@74a14482\n// chapter07.Book@1540e19d\n// chapter07.Book@677327b6\n```\n\n- 참조 변수 library에 5칸의 인스턴스 주소값을 담을 공간을 생성\n\n- 이후 Book 클래스에 매개변수로 값을 담은 상태\n\n- 그 이후 showBookInfo 메서드로 내용을 출력해보고\n\n- 그 이후 참조 변수에 저장된 주소 값을 출력해봄\n\n\u003cbr\u003e\n\n### 배열 복사하기\n\n- 기존 배열과 똑같은 배열을 만들고 싶거나, 자료가 꽉 차서 더 큰 배열을 만들어 **기존 배열에 저장된 자료를 가져오고 싶을 때** 복사해보자\n\n- `01. for문을 사용하여 각 요소 값을 반복해서 복사`\n\n- `02. System.arraycopy() 메서드 이용`\n\n`System.arraycoppy(src, srcPos, dest, destPost, length) `매개 변수 형식\n\n\u003cbr\u003e\n\n|매개변수|설명|\n|-------|-----|\n|src|복사할 배열 이름|\n|srcPos|복사할 배열의 첫 번째 위치|\n|dest|복사해서 붙여 넣을 대상 배열 이름|\n|destPost|복사해서 대상 배열에 붙여 넣기를 시작할 첫 번째 위치|\n|length|src에서 dest로 자료를 복사할 요소 개수|\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\n\npublic class ArrayCopy {\n\tpublic static void main(String[] args) {\n\t\tint[] array1 = {10, 20, 30, 40, 50};\n\t\tint[] array2 = {1, 2, 3, 4, 5};\n\t\tSystem.arraycopy(array1, 0, array2, 1, 4);\n\t\t\n\t\tfor(int i = 0; i \u003c array2.length; i++) {\n\t\t\tSystem.out.println(array2[i]);\n\t\t}\n\t}\n}\n\n// 1\n// 10\n// 20\n// 30\n// 40\n```\n\n- 복사할 대상 배열의 전체 길이 \u003c 복사할 요소 개수 = 오류\n\n\u003cbr\u003e\n\n### 객체 배열 복사\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\n  \npublic class ObjectCopy1 {\n\tpublic static void main(String[] args) {\n\t\tBook[] bookArray1 = new Book[3];\n\t\tBook[] bookArray2 = new Book[3];\n\t\t  \n\t\tbookArray1[0] = new Book(\"태백산맥\", \"조정래\");\n\t\tbookArray1[1] = new Book(\"데미안\", \"헤르만 헤세\");\n\t\tbookArray1[2] = new Book(\"어떻게 살 것인가\", \"유시민\");\n\t\tSystem.arraycopy(bookArray1, 0, bookArray2, 0, 3);\n\t\t\n\t\tfor (int i = 0; i \u003c bookArray2.length; i++) {\n\t\t\tbookArray2[i].showBookInfo();\n\t\t}\n\t}\n}\n```\n\n- 여기서 의문, bookArray2 배열의 인스턴스를 따로 만든건 아니고 주소 값 저장할 공간만 만들어놨는데 어떻게 출력이 잘 될까? (사실 벌써 감 오지? 주소 값 가리키는 포인터 개념이니까 ㅎ)\n\n\u003cbr\u003e\n\n**얕은 복사(shallow copy)**\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\n  \npublic class ObjectCopy1 {\n\tpublic static void main(String[] args) {\n\t\tBook[] bookArray1 = new Book[3];\n\t\tBook[] bookArray2 = new Book[3];\n\t\t\n\t\tbookArray1[0] = new Book(\"태백산맥\", \"조정래\");\n\t\tbookArray1[1] = new Book(\"데미안\", \"헤르만 헤세\");\n\t\tbookArray1[2] = new Book(\"어떻게 살 것인가\", \"유시민\");\n\t\tSystem.arraycopy(bookArray1, 0, bookArray2, 0, 3);\n\t\t  \n\t\tfor (int i = 0; i \u003c bookArray2.length; i++) {\n\t\t\tbookArray2[i].showBookInfo();\n\t\t}\n\t\t  \n\t\tSystem.out.println(\"bookArray2[0]의 내용을 변경\");\n\t\tbookArray2[0].setBookName(\"나목\");\n\t\tbookArray2[0].setAuthor(\"박완서\");\n\t\t  \n\t\tSystem.out.println(\"--- bookArray1 출력 ---\");\n\t\tfor (int i = 0; i \u003c bookArray1.length; i++) {\n\t\t\tbookArray1[i].showBookInfo();\n\t\t}\n\t}\n}\n\n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n// bookArray2[0]의 내용을 변경\n// --- bookArray1 출력 ---\n// 나목, 박완서\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n```\n\n- `bookArray2[0]`의 요소 값을 변경했는데, `bookArray[1]`의 요소 값도 같이 바뀜\n\n- 객체 배열의 요소에 저장된 값 = 인스턴스의 주소 값\n\n- 객체 배열의 요소에 저장된 값 != 인스턴스 자체\n\n- 객체 배열을 복사할 때 인스턴스를 따로 생성하는게 아니라 **기존 인스턴스의 주소 값만 복사**하기 때문에 이런 일 발생\n\n\u003cbr\u003e\n\n**깊은 복사(deep copy)**\n\n- `System.arraycopy()` 메서드 사용 / 객체 배열 복사하면 **항상 인스턴스 주소가 복사됨**\n\n- 인스턴스를 따로 관리하고 싶으면 직접 인스턴스를 만들고 값을 복사해야함\n\n- 즉, 인스턴스 생성 -\u003e 배열 복사가 되어야 함\n\n```java\nbookArray2[0] = new Book();\nbookArray2[1] = new Book();\nbookArray2[2] = new Book();\n  \nfor (int i = 0; i \u003c bookArray1.length; i++) {\n\tbookArray2[i].setBookName(bookArray1[i].getBookName());\n\tbookArray2[i].setAuthor(bookArray1[i].getAuthor());\n}\n```\n\n\u003cbr\u003e\n\n- 전체 코드\n\n```java\npackage chapter07;\n  \npublic class ObjectCopy2 {\n\tpublic static void main(String[] args) {\n\t\tBook[] bookArray1 = new Book[3];\n\t\tBook[] bookArray2 = new Book[3];\n\t\t  \n\t\tbookArray1[0] = new Book(\"태백산맥\", \"조정래\");\n\t\tbookArray1[1] = new Book(\"데미안\", \"헤르만 헤세\");\n\t\tbookArray1[2] = new Book(\"어떻게 살 것인가\", \"유시민\");\n\t\t  \n\t\tbookArray2[0] = new Book();\n\t\tbookArray2[1] = new Book();\n\t\tbookArray2[2] = new Book();\n\t\t  \n\t\tfor (int i = 0; i \u003c bookArray1.length; i++) {\n\t\t\tbookArray2[i].setBookName(bookArray1[i].getBookName());\n\t\t\tbookArray2[i].setAuthor(bookArray1[i].getAuthor());\n\t\t}\n\t\t  \n\t\tSystem.out.println(\"--- 인스턴스 생성 이후 값 복사한 bookArray2 ---\");\n\t\tfor (int i = 0; i \u003c bookArray2.length; i++) {\n\t\t\tbookArray2[i]. showBookInfo();\n\t\t}\n\t\t  \n\t\tbookArray1[0].setBookName(\"나목\");\n\t\tbookArray1[0].setAuthor(\"박완서\");\n\t\tSystem.out.println(\"--- bookArray1 ---\");\n\t\tfor (int i = 0; i \u003c bookArray1.length; i++) {\n\t\t\tbookArray1[i].showBookInfo();\n\t\t}\n\t\t  \n\t\tSystem.out.println(\"--- bookArray2에 변경 끼쳤나 확인 ---\");\n\t\tfor (int i = 0; i \u003c bookArray2.length; i++) {\n\t\t\tbookArray2[i]. showBookInfo();\n\t\t}\n\t}\n}\n\n// --- 인스턴스 생성 이후 값 복사한 bookArray2 ---\n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n// --- bookArray1 ---\n// 나목, 박완서\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n// --- bookArray2에 변경 끼쳤나 확인 ---\n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n```\n\n\u003cbr\u003e\n\n### 향상된 for문과 배열\n\n- 배열의 처음에서 끝까지 모든 요소를 참조할 때 사용하면 편리함\n\n- **향상된 for문**은 배열 요소 값을 순서대로 하나씩 가져와서 변수에 대입\n\n```java\nfor(변수 : 배열) {\n\t반복 실행문;\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\n  \npublic class EnhancedForLoop {\n\tpublic static void main(String[] args) {\n\t\tString[] strArray = {\"Java\", \"Android\", \"C\", \"JavaScript\", \"Python\"};\n\t  \n\t\tfor(String language : strArray) {\n\t\t\tSystem.out.println(language);\n\t\t}\n\t}\n}\n  \n// Java\n// Android\n// C\n// JavaScript\n// Python\n```\n\n\u003chr\u003e\n\n## 다차원 배열  \n\n### 이차원 배열\n\n\u003cbr\u003e\n\n```java\n// 둘다 2 X 3 행렬\nint[][] arr = new int[2][3];\nint[][] arr = {{1, 2, 3}, {4, 5, 6}};\n```\n  \n- 이차원 배열은 중첩 for문 활용\n\n- `arr.length` : 행의 길이\n\n- `arr[0].length` : 열의 길이\n\n```java\npackage chapter07;\n  \npublic class TwoDimension {\n\tpublic static void main(String[] args) {\n\t\tint[][] arr = {{1, 2, 3}, {4, 5, 6}};\n\t\t  \n\t\tfor (int i = 0; i \u003c arr.length; i++) {\n\t\t\tfor (int j = 0; j \u003c arr[i].length; j++) {\n\t\t\t\tSystem.out.print(arr[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n  \n// 1 2 3\n// 4 5 6\n```\n\n\u003chr\u003e\n\n## ArrayList 클래스 활용\n\n### 기존 배열의 단점, 그리고 ArrayList\n\n1. 항상 배열 길이를 정하고 시작\n\n2. 당연히 배열 길이는 가변적으로 변할 것\n\n3. 혹은 중간에 배열 값이 빠지게 되면, 중간에 요소 비우면 안되니까 수정해야함\n\n그래서 자바는 객체 배열 더 쉽게 사용하게 ArrayList로 멤버 변수, 메서드 제공\n\n### ArrayList 클래스 주요 메서드\n\n\u003cbr\u003e\n\n|메서드|설명|\n|------|----|\n|boolean add(E e)|요소 하나를 배열에 추가. E는 요소의 자료형|\n|int size()|배열에 추가된 요소 전체 개수 반환|\n|E get(int index)|배열의 index 위치에 있는 요소 값 반환|\n|E remove(int index)|배열의 index 위치에 있는 요소 값 제거하고 그 값 반환|\n|boolean isEmpty()|배열이 비어 있는지 확인|\n  \n\u003cbr\u003e\n\n추가\n\n- `add() 메서드` : 배열 길이와 상관없이 객체 추가 (배열 요소 개수가 부족하면 배열 크기 자동으로 키워줌 + 배열 중간에 요소 값 제거 되면 그 다음 요소 값 하나씩 앞으로 당겨줌)\n\n\u003cbr\u003e\n\n### ArrayList 클래스 활용\n\n\u003cbr\u003e\n\n```java\nArrayList\u003cE\u003e 배열 이름 = new ArrayList\u003cE\u003e();\n```\n  \n- 어떤 자료형 객체를 사용할 지 선언할 수 있음\n\n- ArrayList 클래스는 util 패키지에 있음. 쓰려면 import 해와야겠지?\n\n- `\u003cE\u003e`는 제네릭 자료형\n\n- `\u003c\u003e` 안에 객체의 자료형 쓰면 됨\n\n- 예를 들어서, 위에서 한 Book 클래스형을 자료형으로 쓴다면\n\n```java\nArrayList\u003cBook\u003e library = new ArrayList\u003cBook\u003e();\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter07;\nimport java.util.ArrayList;\n  \npublic class ArrayListTest {\n\tpublic static void main(String[] args) {\n\t\tArrayList\u003cBook\u003e library = new ArrayList\u003cBook\u003e();\n\t\t  \n\t\tlibrary.add(new Book(\"태백산맥\", \"조정래\"));\n\t\tlibrary.add(new Book(\"데미안\", \"헤르만 헤세\"));\n\t\tlibrary.add(new Book(\"어떻게 살 것인가\", \"유시민\"));\n\t\tlibrary.add(new Book(\"토지\", \"박경리\"));\n\t\tlibrary.add(new Book(\"어린왕자\", \"생텍쥐페리\"));\n\t\t  \n\t\tfor (int i = 0; i \u003c library.size(); i++) {\n\t\t\tBook book = library.get(i);\n\t\t\tbook.showBookInfo();\n\t\t}\n\t\t\n\t\tSystem.out.println();\n\t\t  \n\t\tSystem.out.println(\"--- 향상된 for문 사용 ---\");\n\t\tfor(Book book : library) {\n\t\t\tbook.showBookInfo();\n\t\t}\n\t}\n}\n\n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n// 토지, 박경리\n// 어린왕자, 생텍쥐페리\n\n// --- 향상된 for문 사용 ---\n// 태백산맥, 조정래\n// 데미안, 헤르만 헤세\n// 어떻게 살 것인가, 유시민\n// 토지, 박경리\n// 어린왕자, 생텍쥐페리\n```\n\n\u003cbr\u003e","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/chap08":{"title":"08.상속과 다형성","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 08 - 상속과 다형성\n\n\u003cbr\u003e\n\n## 상속이란?\n\n- 객체 지향 프로그래밍의 중요한 특징인 상속(inheritance)\n\n- B클래스가 A클래스를 상속받으면 B클래스는 A클래스의 멤버 변수, 메서드 사용 가능\n\n- 유지 보수, 프로그램 수정, 새로운 내용 추가에 굉장히 유연한데 그것이 상속 덕분 !\n\n\u003cbr\u003e\n\n### 클래스의 상속\n\n![](brain/image/chap08-1.png)\n\n- (상위 클래스) A 클래스\n\n\t- A 클래스가 B 클래스에게 상속한다.\n\n- (하위 클래스) B 클래스\n\n\t- B 클래스가 A 클래스를 상속받는다.\n\n- **화살표 방향**\n\n\t- `상속받는 클래스` -\u003e `상속하는 클래스`\n\n\t- `하위 클래스` -\u003e `상위 클래스`\n\n\t- `자식 클래스` -\u003e `부모 클래스`\n\n\u003cbr\u003e\n\n**클래스 상속 문법**\n\n```java\nclass B extends A {\n  \n}\n```\n\n- A가 가지고 있는 속성이나 기능을 추가로 **확장**하여 B 클래스 구현\n\n- 일반적인 클래스 A에서 더 구체적인 클래스 B가 구현된다.\n\n\u003cbr\u003e\n\n### 상속을 사용하여 고객 관리 프로그램 구현\n\n- Customer 클래스\n\n```java\npackage Chapter08;\n  \npublic class Customer {\n\tprivate int customerID; // 고객 아이디\n\tprivate String customerName; // 고객 이름\n\tprivate String customerGrade; // 고객 등급\n\tint bonusPoint; // 적립 포인트\n\tdouble bonusRatio; // 적립 비율\n\t\n\tpublic Customer() {\n\t\tcustomerGrade = \"SILVER\";\n\t\tbonusRatio = 0.01;\n\t}\n\t\n\tpublic int calcPrice(int price) {\n\t\tbonusPoint += price * bonusRatio;\n\t\treturn price;\n\t}\n\t\n\tpublic String getCustomerInfo() {\n\t\treturn customerName + \" 님의 등급은 \" + customerGrade + \"이며, 보너스 포인트는 \" + bonusPoint + \"입니다.\";\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**Customer 클래스 설명**\n\n\u003cbr\u003e\n\n|멤버 변수|설명|\n|:------:|----|\n|customerID|고객 아이디|\n|customerName|고객 이름|\n|customerGrade|고객 등급\u003cbr\u003e기본 생성자에서 지정되는 기본 등급은 Silver|\n|bonusPoint|\u0026nbsp;고객의 보너스 포인트\u003cbr\u003e- 고객이 제품을 구매할 경우 누적되는 보너스 포인트|\n|bonusRatio|\u0026nbsp;보너스 포인트 적립 비율\u003cbr\u003e- 고객이 제품을 구매할 때 구매 금액의 일정 비율이 보너스 포인트로 적립됨. 이때 계산되는 적립 비율\u003cbr\u003e- 기본 생성자에서 지정되는 적립 비율은 1%이다. 즉, 10,000원 짜리를 사면 100원이 적립|\n\n- 모든 멤버 변수 private으로 선언 안해도 됨\n\n- 외부에 노출하고 싶지 않은 멤버 변수나 메서드만 private으로 생성 !\n\n\u003cbr\u003e\n\n|메서드|설명|\n|:----:|----|\n|Customer()|기본 생성자. 고객 한 명이 새로 생성되면 등급은 실버, 적립 비율 1%|\n|calcPrice(int price)|제품에 대해 지불해야 하는 금액 계산 후 반환. 할인되지 않으면 가격 그대로 반환. 가격에 대한 보너스 포인트 비율을 적용하여 보너스 포인트 적립|\n|getCustomerInfo()|고객 정보 출력. 고객 이름/등급/적립된 포인트|\n\n\u003cbr\u003e\n\n지금까지는 단순한 객체 지향 프로그램. 여기서 특별한 상황 부여\n\n\u003cbr\u003e\n\n\u003e [!note] 예제 시나리오\n\u003e \n\u003e 고객이 점점 늘어나고 파내가 많아져서 단골 고객 생김. 단골 고객은 회사 매출에 큰 기여를 하는 우수 고객이라 좋은 혜택을 주고 싶음. 우수 고객 등급은 VIP이고 아래와 같은 혜택 제공\n\u003e - 제품 살 때 항상 10% 할인\n\u003e - 보너스 포인트 5% 적립\n\u003e - 담당 전문 상담원 배정\n\n\u003cbr\u003e\n\n기존의 Customer 클래스에 VIP 고객 추가로 구현해도 됨. 그러나, 단점\n\n1. Customer 클래스 코드 복잡해짐\n\n2. 일반 고객 인스턴스 생성할 때도 불편\n\n3. 한마디로 낭비가 발생\n\n따라서, VIPCustomer 클래스를 따로 구현하기로 결정. 대신, Customer 클래스와 겹치는 부분이 있을 것임 (예를 들어, 멤버 변수 customerID, customerGrade, bonusPoint, bonusRatio) 겹치는 부분은 상속 받아서 구현하는게 훨씬 편할 것 !!\n\n\u003cbr\u003e\n\n**그러나, 상속 시 문제점**\n\n1. Customer 클래스의 멤버 변수를 private으로 선언해놔서 외부 클래스에서 접근 불가\n\n2. VIP 고객에게 제공하는 혜택인 할인율과 세일 가격을 어떻게 적용할지?\n\n- 두 번째 문제는 \u003ca href='/brain/Book/do-it-java/chap08/#메서드-오버라이딩'\u003e메서드 오버라이딩\u003c/a\u003e에서 해결\n\n\u003cbr\u003e\n\n**첫 번째 문제 해결 - proteted**\n\n이전에 [클래스와 객체 (1)](brain/Book/do-it-java/chap05)의 정보은닉에서 배운 접근제어자 protected를 이용하자. protected 예약어는 상위 클래스에 작성한 멤버 변수, 메서드 중 외브 클래스에서 사용할 수는 없지만 (private의 기능) 하위 클래스에서는 사용할 수 있도록 하는 것 ! 따라서, Customer 클래스의 private을 protected로 바꾸면 VIPCustomer 클래스에서 사용할 수 있고, 추가로 외부 클래스에서 사용할 수 있도록 get(), set() 메서드를 구현해놓으면 VIPCustomer 클래스도 자연스레 상속받는다.\n\n- Customer 클래스\n\n```java\npackage Chapter08;\n  \npublic class Customer {\n\tprotected int customerID; // 고객 아이디\n\tprotected String customerName; // 고객 이름\n\tprotected String customerGrade; // 고객 등급\n\tint bonusPoint; // 적립 포인트\n\tdouble bonusRatio; // 적립 비율\n\t  \n\tpublic Customer() {\n\t\tcustomerGrade = \"SILVER\";\n\t\tbonusRatio = 0.01;\n\t}\n\t  \n\tpublic int calcPrice(int price) {\n\t\tbonusPoint += price * bonusRatio;\n\treturn price;\n\t}\n\t  \n\tpublic String showCustomerInfo() {\n\t\treturn customerName + \" 님의 등급은 \" + customerGrade + \"이며, 보너스 포인트는 \" + bonusPoint + \"입니다.\";\n\t}\n\t  \n\tpublic int getCustomerID() {\n\t\treturn customerID;\n\t}\n\t  \n\tpublic void setCustomerID(int customerID) {\n\t\tthis.customerID = customerID;\n\t}\n\t\n\tpublic String getCustomerName() {\n\t\treturn customerName;\n\t}\n\t  \n\tpublic void setCustomerName(String customerName) {\n\t\tthis.customerName = customerName;\n\t}\n\t\n\tpublic String getCustomerGrade() {\n\t\treturn customerGrade;\n\t}\n\t  \n\tpublic void setCustomerGrade(String customerGrade) {\n\t\tthis.customerGrade = customerGrade;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n- VIPCustomer 클래스\n\n```java\npackage Chapter08;\n\n// VIPCustomer 클래스는 Customer 클래스를 상속 받음\npublic class VIPCustomer extends Customer {\n\tprivate int agentID; // VIP 고객 상담원 ID\n\tdouble saleRatio; // VIP 할인율\n\t  \n\tpublic VIPCustomer() {\n\t\tcustomerGrade = \"VIP\";\n\t\tbonusRatio = 0.05;\n\t\tsaleRatio = 0.1;\n\t}\n\t  \n\tpublic int getAgentID() {\n\t\treturn agentID;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n- CustomerTest 클래스\n\n```java\npackage Chapter08;\n\npublic class CustomerTest {\n\tpublic static void main(String[] args) {\n\t\tCustomer customerLee = new Customer();\n\t\tcustomerLee.setCustomerID(10010);\n\t\tcustomerLee.setCustomerName(\"이순신\");\n\t\tcustomerLee.bonusPoint = 1000;\n\t\tSystem.out.println(customerLee.showCustomerInfo());\n\t\t  \n\t\tVIPCustomer customerKim = new VIPCustomer();\n\t\tcustomerKim.setCustomerID(10020);\n\t\tcustomerKim.setCustomerName(\"김유신\");\n\t\tcustomerKim.bonusPoint = 10000;\n\t\tSystem.out.println(customerKim.showCustomerInfo());\n\t}\n}\n  \n// 이순신 님의 등급은 SILVER이며, 보너스 포인트는 1000입니다.\n// 김유신 님의 등급은 VIP이며, 보너스 포인트는 10000입니다.\n```\n\n\u003chr\u003e\n\n## 클래스 생성과 형 변환\n\n- 하위 클래스 생성 시 상위 클래스의 생성자가 **먼저 호출**\n\n\u003cbr\u003e\n\n### 하위 클래스가 생성되는 과정\n\n![](brain/image/chap08-2.png)\n  \n- 단순히 생각해보면, 하위 클래스에서 상위 클래스의 변수나 메서드를 사용할 수 있다는 것은 이미 저장하고 있는 메모리가 존재한다는 말이다.\n\n- 이를 테스트 해보고 싶으면, 각 클래스 생성자에 출력문 찍어보고 테스트\n\n```java\npublic Customer() {\n\tcustomerGrade = \"SILVER\";\n\tbonusRatio = 0.01;\n\tSystem.out.println(\"Customer() 생성자 호출\");\n}\n```\n\n\u003cbr\u003e\n\n```java\npublic VIPCustomer() {\n\tcustomerGrade = \"VIP\";\n\tbonusRatio = 0.05;\n\tsaleRatio = 0.1;\n\tSystem.out.println(\"VIPCustomer() 생성자 호출\");\n}\n```\n\n\u003cbr\u003e\n\n```java\n// Customer() 생성자 호출\n// VIPCustomer() 생성자 호출\n// 김유신 님의 등급은 VIP이며, 보너스 포인트는 10000입니다.\n```\n\n\u003cbr\u003e\n\n### super - 부모를 부르는 예약어\n\n- super는 하위 클래스에서 상위 클래스로 접근할 때 사용\n\n- 하위 클래스는 상위 클래스의 주소(참조 값)를 알고 있음.\n\n- 상위 클래스의 생성자를 호출할 때도 super를 사용\n\n- this : 자기 자신의 참조 값 보유\n\n- super : 부모의 참조 값 보유\n\n생성자 호출이 궁금하다면? [클래스와 객체 (2)](brain/Book/do-it-java/chap06) 생성자에서 다른 생성자를 호출하는 this 참고\n  \n\n\u003cbr\u003e\n\n**상위 클래스 생성자 호출** \n\n바로 위에 VIPCustomer() 생성자 호출한거 보면 Customer() 생성자도 같이 불러와졌는데, 이는 하위 클래스 생성자에서 `super();`가 디폴트로 설정되어 있어서 컴파일러에서 자동으로 불러온다.\n\n\u003cbr\u003e\n\n**super로 매개변수 있는 생성자 호출**\n\n- super는 상위 클래스의 **매개변수 없는 디폴트 생성자**를 받아온다.\n\n- 만약, 묵시적으로 호출될 디폴트 생성자가 상위 클래스에 정의되어있지 않다면, 오류가 발생한다.\n\n- 따라서, 반드시 명시적으로 다른 생성자를 호출해야한다.\n\n```java\npublic Customer() {\n\tcustomerGrade = \"SILVER\";\n\tbonusRatio = 0.01;\n\tSystem.out.println(\"Customer() 생성자 호출\");\n}\n```\n\nCustomer 클래스에 위와 같이 정의되어 있으면 VIPCustomer 클래스에서 super()가 디폴트 생성자를 묵시적으로 불러와줌. 그러나, 디폴트 생성자가 없다면?\n\n```java\npublic Customer(int customerID, String customerName) {\n\tthis.customerID = customerID;\n\tthis.customerName = customerName;\n\tcustomerGrade = \"SILVER\";\n\tbonusRatio = 0.01;\n\tSystem.out.println(\"Customer(int, String) 생성자 호출\");\n}\n```\n\n\u003cbr\u003e\n\n```java\npublic VIPCustomer(int customerID, String customerName, int agentID) {\n\tsuper(customerID, customerName);\n\tcustomerGrade = \"VIP\";\n\tbonusRatio = 0.05;\n\tsaleRatio = 0.1;\n\tSystem.out.println(\"VIPCustomer(int, String) 생성자 호출\");\n}\n```\n\n이런식으로 `super(매개변수)`라고 명시적으로 적어서 VIPCustomer 생성자를 실행하면, Customer 생성자를 실행하도록 해야 한다.\n\n\u003cbr\u003e\n\n**상위 클래스의 멤버 변수나 메서드를 참조하는 super**\n\n- VIPCustomer 클래스에서 상속받은 Customer 클래스의 showCustomerInfo() 메서드를 그냥 사용할 수 있지만, `showCustomerInfo() 메서드 기능 + 추가적인 기능`를 구현하고 싶다면?\n\n```java\n// VIPCustomer 클래스에 구현\npublic String showVIPInfo() {\n\treturn super.showCustomerInfo() + \" VIP전용 담당 상담원 아이디는 \" + agentID + \"입니다.\";\n}\n```\n\n\u003cbr\u003e\n\n```java\n// Customer 클래스 출력 비교\nSystem.out.println(customerLee.showCustomerInfo());\nSystem.out.println(customerKim.showVIPInfo());\n  \n// 이순신 님의 등급은 SILVER이며, 보너스 포인트는 1000입니다.\n// 김유신 님의 등급은 VIP이며, 보너스 포인트는 10000입니다. VIP전용 담당 상담원 아이디는 1입니다.\n```\n\n- 굳이 super를 쓰는건 여기서는 super를 안써도 상위 클래스의 메서드 호출이 잘 되지만, **하위 클래스가 상위 클래스와 동일한 이름의 메서드를 구현하는 경우**라면 어떤가? super가 무조건 필요하겠지\n\n- 이는 나중에 배울 \u003ca href='/brain/Book/do-it-java/chap08/#메서드-오버라이딩'\u003e메서드 오버라이딩\u003c/a\u003e관련된 내용!\n\n\u003cbr\u003e\n\n### 상위 클래스로 묵시적 클래스 형 변환 (업캐스팅)\n\n- 상속 공부할 때, 자료형 형 변환처럼 **클래스 간 형 변환 개념**이 매우 중요!\n\n- Customer는 일반적인 개념\n\n- VIPCustomer는 일반적인 개념 + 더 많은 기능\n\n- 따라서, VIPCustomer는 VIPCustomer형 이면서, 동시에 Customer형!\n\n- VIPCustomer 클래스로 인스턴스 생성할 때, 인스턴스의 자료형을 **Customer형으로 클래스 형 변환하여 선언 가능**\n\n```java\nCustomer vc = new VIPCustomer();\n```\n\n- `Customer` : 선언된 클래스형 (상위 클래스형)\n\n- `VIPCustomer()` : 생성된 인스턴스의 클래스형 (하위 클래스형)\n\n\u003cbr\u003e\n\n**최종 정리**\n\n- 하위 클래스 자료형 (더 많은 기능) -\u003e 상위 클래스 자료형 (일반적인 기능) O\n\n- 상위 클래스 자료형 (일반적인 기능) -\u003e 하위 클래스 자료형 (더 많은 기능) X\n\n\u003cbr\u003e\n\n![](brain/image/chap08-3.png)\n\n다시 이 그림을 보자. 위에서 `VIPCustomer()`로 VIPCustomer의 생성자를 이용하여 만들었다고 해도 `Customer`로 자료형을 선언했기에, 사용가능한 기능은 1번의 기능인 `Customer 클래스의 기능`만 사용 가능하다.\n\n이렇게 클래스 형 변환 사용하는 이유 -\u003e \u003ca href='/brain/Book/do-it-java/chap08/#메서드-오버라이딩'\u003e메서드 오버라이딩\u003c/a\u003e과  \u003ca href='/brain/Book/do-it-java/chap08/#다형성'\u003e다형성\u003c/a\u003e 때문 \u003cbr\u003e\n\nvc 참조 변수를 다시 VIPCustomer형으로 변환하는 것은  \u003ca href='/brain/Book/do-it-java/chap08/#다운-캐스팅과-instanceof'\u003e다운 캐스팅과 instanceof\u003c/a\u003e\n\n\u003chr\u003e\n\n## 메서드 오버라이딩\n\n### 상위 클래스 메서드 재정의\n\nVIPCustomer 클래스가 Customer 클래스 상속받을 시 언급했던 두 번째 문제점\n\n- VIP 고객에게 제공하는 혜택인 할인율과 세일 가격을 어떻게 적용할지?\n\n- 문제가 되는 이유 : 상속받은 메서드 calcPrice()가 일반 고객과 VIP 고객에게 다르게 적용되어야 함\n\n- 따로 vip를 위한 계산을 구현하기에는 리소스 낭비. 10% 할인만 적용하면 되니까\n\n- 따라서, 상위 클래스의 메서드를 하위 클래스 입맛에 맞게 메서드를 재정의해보자\n\n- 이를 **메서드 오버라이딩**이라고 함\n\n- **오버라이딩 조건 : 반환형/메서드 이름/매개변수 개수/매개변수 자료형 반드시 동일**\n\n```java\n// Customer 클래스의 calcPrice 메서드\npublic int calcPrice(int price) {\n\tbonusPoint += price * bonusRatio;\n\treturn price;\n}\n```\n\n\u003cbr\u003e\n\n```java\n// VIPCustomer 클래스의 calcPrice 메서드\n\n@Override\npublic int calcPrice(int price) {\n\tbonusPoint += price * bonusRatio;\n\n\t// 할인된 가격을 계산하여 반환\n\treturn price - (int)(price * saleRatio);\n}\n```\n\n`@Override 애노테이션`은 \"이 메서드는 재정의된 메서드입니다.\"라고 컴파일러에게 명확하게 알려주기 위함!\n\n\u003cbr\u003e\n\n\u003e [!note] 애노테이션(Annotation) ?\n\u003e\n\u003e 애노테이션은 해석해보면 \"주석\"이다. '@애노테이션 이름'으로 표현 자바의 애노테이션은 컴파일러에게 특정한 정보를 제공 미리 정의되어 있는 애노테이션을 표준 애니테이션이라고 함 \n\n\u003cbr\u003e\n\n|애노테이션|설명|\n|:--------|:----|\n|@Override|재정의된 메서드라는 정보 제공|\n|@FunctionalInterface|함수형 인터페이스라는 정보 제공|\n|@Deprecated|이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용됨|\n|@SuppressWarnings|특정 경고가 나타나지 않도록 함|\n\n\u003cbr\u003e\n\n### 묵시적 클래스 형 변환과 메서드 재정의\n\n\u003cbr\u003e\n\n```java\nCustomer vc = new VIPCustomer(10030, \"나몰라\", 2000);\nvc.calcPrice(10000);\n```\n  \n해당 코드는 묵시적 형 변환에 의해 VIPCustomer형이 Customer형으로 변환됨. 이 경우 calcPrice() 메서드는 오버라이딩 된 메서드인데, 어떤 클래스의 메서드를 호출하겠는가? Customer 클래스라면 지불해야하는 금액은 10000원, VIPCustomer 클래스라면 지불해야하는 금액은 9000원이다. 웃기게도.. VIPCustomer 결과가 나온다.\n\n```java\npackage Chapter08;\n\npublic class OverridingTest {\n\tpublic static void main(String[] args) {\n\t\tCustomer vc = new VIPCustomer(10030, \"나몰라\", 2000);\n\t\tvc.bonusPoint = 1000;\n\t\t\n\t\tSystem.out.println(vc.getCustomerName() + \" 님이 지불해야하는 금액은 \" + vc.calcPrice(10000) + \"원입니다.\");\n\t}\n} \n\n// 나몰라 님이 지불해야하는 금액은 9000원입니다.\n```\n\n- 멤버 변수와 메서드 : 선언한 클래스형에 따라 호출\n\n- 상속에서 상위와 하위에 같은 이름의 메서드가 존재할 때 : 인스턴스에 따라 결정\n\n메서드 오버라이딩을 한 경우에는 선언한 클래스 형이 아닌 **생성된 인스턴스의 메서드를 호출**한다. 이렇게 인스턴스의 메서드가 호출되는 기술을 **가상 메서드(virtual method)** 라고 한다.\n\n\u003cbr\u003e\n\n### 가상 메서드\n\n- 자바의 클래스는 멤버 변수와 메서드로 이루어짐\n\n- 인스턴스 변수는 힙 메모리에 위치하는거 이제 기억하지?\n\n- 변수는 인스턴스가 생성될 때마다 힙 메모리에 새로 생성\n\n- 메서드는 실행해야 할 명령 집합이라서 **인스턴스가 달라도 같은 로직 수행**\n\n- 즉, 인스턴스 여러 개 생성한다고 해도 메서드도 여러 개 생성되지는 않음. 또 애초에 메서드와 관련된 지역 변수와 매개 변수는 스택 메모리에 할당받고 메서드 끝나면 해제하잖아!\n\n- 메서드의 명령 집합은 **메서드 영역**에 위치함\n\n\u003cbr\u003e\n\n자바의 모든 메서드는 가상 메서드이다.\n\n\u003cbr\u003e\n\n```java\npackage Chapter08;\n\npublic class TestA {\n\tint num;\n\t  \n\tvoid aaa() {\n\t\tSystem.out.println(\"aaa() 출력\");\n\t}\n\t  \n\tpublic static void main(String[] args) {\n\t\tTestA a1 = new TestA();\n\t\ta1.aaa();\n\t\tTestA a2 = new TestA();\n\t\ta2.aaa();\n\t}\n}\n\n// aaa() 출력\n// aaa() 출력\n```\n\n\u003cbr\u003e\n\n![](brain/image/chap08-4.png)\n\n- main() 함수가 실행되면 지역 변수 스택에 위치\n\n- 참조 변수 a1, a2가 가리키는 인스턴스 힙 메모리에 생성\n\n- 메서드 aaa()의 명령 집합 메서드 영역에 생성\n\n- 메서드 호출하면 콜 스택에서 메서드 영역의 주소를 참조하여 명령 실행\n\n- **따라서, 인스턴스 달라도 동일한 메서드 호출**\n\n\u003cbr\u003e\n\n**가상 메서드의 원리**\n\n일반적으로 메서드를 호출한다는 것\n\n- 메서드를 호출 한다 = 메서드의 명령 집합이 있는 메모리 위치를 참조하여 명령 실행\n\n\u003cbr\u003e\n\n가상 메서드의 경우 (**자바의 모든 메서드는 가상 메서드**)\n\n- **가상 메서드 테이블**이 생성됨\n\n- 각 메서드 이름, 실제 메모리 주소가 짝을 이룸\n\n- 따라서, 어떤 메서드가 호출되면 가상 메서드 테이블에서 주소 값을 찾아서 해당 메서드의 명령을 수행\n\n\u003cbr\u003e\n\n![](brain/image/chap08-5.png)\n\n- calcPrice() 메서드와 같이 재정의 된 메소드\n\n- 실제 인스턴스에 해당하는 메서드가 호출\n\n- showCustomerInfo() 메서드와 같이 재정의 되지 않은 메소드\n\n- 메서드 주소가 같으며 상위 클래스의 메서드가 호출\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n```java\npackage Chapter08;\n  \npublic class OverridingTest2 {\n\tpublic static void main(String[] args) {\n\t\tint price = 10000;\n\t\t  \n\t\tCustomer customerLee = new Customer(10010, \"이순신\");\n\t\tSystem.out.println(customerLee.getCustomerName() + \" 님이 지불해야하는 금액은 \" + customerLee.calcPrice(price) + \"입니다.\");\n\t\t\n\t\tVIPCustomer customerKim = new VIPCustomer(10020, \"김유신\", 12345);\n\t\tSystem.out.println(customerKim.getCustomerName() + \" 님이 지불해야하는 금액은 \" + customerKim.calcPrice(price) + \"입니다.\");\n\t\t  \n\t\tCustomer vc = new VIPCustomer(10030, \"나몰라\", 2000);\n\t\tSystem.out.println(vc.getCustomerName() + \" 님이 지불해야하는 금액은 \" +\n\t\tvc.calcPrice(price) + \"입니다.\");\n\t}\n}\n  \n// 10000원\n// 9000원\n// 9000원\n```\n\n1. Customer 형으로 선언하고 Customer 인스턴스 생성 -\u003e Customer의 메서드 호출\n\n2. VIPCustomer 형으로 선언하고 VIPCustomer 인스턴스 생성 -\u003e VIPCustomer의 메서드 호출\n\n3. Customer 형으로 선언하고 VIPCustomer 인스턴스 생성 -\u003e 원래라면 Customer형 메서드가 호출되는 것이 맞지만, **가상 메서드 방식에 의해 VIPCustomer의 인스턴스의 메서드가 호출**\n\n![](brain/image/chap08-6.png)\n\n\u003chr\u003e\n\n## 다형성\n\n### 다형성이란?\n\n묵시적 클래스 형 변환 + 가상 메서드를 바탕으로 다형성을 이해해보자.\n\n\u003cbr\u003e\n\n\n다형성(polymorphism) : 하나의 코드가 여러 자료형으로 구현되어 실행되는 것\n\n- 쉽게 말해서, 같은 코드에서 여러 실행결과가 나옴\n\n\u003cbr\u003e\n\nAnimal 클래스를 상속받는 Human, Tiger, Eagle 클래스가 있다고 가정  \n\n```java\npackage Chapter08.polymorphism;\n  \nclass Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"동물이 움직입니다.\");\n\t}\n}\n  \nclass Human extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"사람이 두 발로 걷습니다.\");\n\t}\n}\n  \nclass Tiger extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"호랑이가 네 발로 뜁니다.\");\n\t}\n}\n  \nclass Eagle extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"독수리가 하늘을 납니다.\");\n\t}\n}\n  \npublic class AnimalTest1 {\n\tpublic static void main(String[] args) {\n\t\tAnimalTest aTest = new AnimalTest();\n\t\taTest.moveAnimal(new Human());\n\t\taTest.moveAnimal(new Tiger());\n\t\taTest.moveAnimal(new Eagle());\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage Chapter08.polymorphism;\n  \npublic class AnimalTest {\n\tpublic void moveAnimal(Animal animal) {\n\t\tanimal.move();\n\t}\n}\n```\n\n- AnimalTest 클래스의 moveAnimal() 메서드는 어떤 인스턴스가 매개변수로 넘어와도 모두 Animal 형으로 형 변환 됨 (디테일한 하위 클래스 -\u003e 일반적인 상위 클래스 이니까)\n\n- 예를 들어, 매개 변수가 전잘되는 부분에 Human 인스턴스가 전달되었다면, Animal 형으로 선언한 곳에 Human 인스턴스가 들어온 것이니까 아래와 같다.\n\n```java\nAnimal animal = new Human();\n```\n\n- 가상 메서드 원리에 따라, `animal.move()` 메서드가 호출하는 메서드는 매개변수로 넘어온 **실제 인스턴스의 메서드를 호출함**.\n\n- 그래서 Animal의 move가 아닌 Human, Tiger, Eagle의 move를 호출하는 것\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n1. Animal의 `move()` 메서드를 Human, Tiger, Eagle에서 메서드 오버라이딩 함\n\n2. AnimalTest 클래스의 `moveAnimal()` 메서드의 매개 변수를 Animal 형으로 선언\n\n3. 따라서, 매개변수로 들어오는 Human, Tiger, Eagle은 Anmial 형으로 묵시적 형 변환 일어남\n\n4. 묵시적 형 변환이 일어났지만, **가상 메서드의 원리**에 의하여 `animal.move()` 메서드가 호출하는 메서드는 실제 인스턴스의 메서드를 호출\n\n5. 결과적으로 `animal.move()` 코드는 변함이 없지만, **어떤 매개변수가 넘어왔느냐에 따라 결과가 달라짐**\n\n6. 하나의 코드가 여러 자료형으로 구현되어 실행됨. 이것이 다형성\n\n\u003cbr\u003e\n\n### 다형성의 장점\n\n다른 동물이 새로 추가되어도, Animal 클래스를 상속받아 구현하면, **모든 클래스를 Animal 자료형 하나로 쉽게 관리할 수 있을 것이다.** 어차피, AnimalTest 클래스를 인스턴스 생성하고 AnimalTest의 메서드를 실행하는데 그 메서드는 매개변수로 Animal 자료형을 받기 때문이다.\n\n각 자료형에 따라 코드를 다르게 구현한 것보다 코드가 훨씬 간단해지고 유지보수가 수월해진다. 자 그러면 느껴봐야지?\n\n\u003cbr\u003e\u003cbr\u003e\n\n**다형성을 활용해 VIP 고객 클래스 리팩토링**\n\n- Customer.java\n\n```java\npackage Chapter08.polymorphism;\n\npublic class Customer {\n\tprotected int customerID;\n\tprotected String customerName;\n\tprotected String customerGrade;\n\tint bonusPoint;\n\tdouble bonusRatio;\n\t  \n\tpublic Customer() {\n\t\tinitCustomer();\n}\n  \npublic Customer(int customerID, String customerName) {\n\t\tthis.customerID = customerID;\n\t\tthis.customerName = customerName;\n\t\tinitCustomer();\n\t}\n\t  \n\t// 생성자에서만 호출하는 메서드니까 private으로 선언\n\tprivate void initCustomer() {\n\t\tcustomerGrade = \"SILVER\";\n\t\tbonusRatio = 0.01;\n\t}\n\t\n\tpublic int calcPrice(int price) {\n\t\tbonusPoint += price * bonusRatio;\n\t\treturn price;\n\t}\n\t  \n\tpublic String showCustomerInfo() {\n\t\treturn customerName + \"님의 등급은 \" + customerGrade + \"이며, 보너스 포인트는 \" + bonusPoint + \"입니다.\";\n\t}\n\t\n\tpublic int getCustomerID() {\n\t\treturn customerID;\n\t}\n\t  \n\tpublic void setCustomerID(int customerID) {\n\t\tthis.customerID = customerID;\n\t}\n\t\n\tpublic String getCustomerName() {\n\t\treturn customerName;\n\t}\n\t  \n\tpublic void setCustomerName(String customerName) {\n\t\tthis.customerName = customerName;\n\t}\n\t\n\tpublic String getCustomerGrade() {\n\t\treturn customerGrade;\n\t}\n\t  \n\tpublic void setCustomerGrade(String customerGrade) {\n\t\tthis.customerGrade = customerGrade;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n- VIPCustomer.java\n\n```java\npackage Chapter08.polymorphism;\n\npublic class VIPCustomer extends Customer {\n\tprivate int agentID;\n\tdouble saleRatio;\n\t\n\tpublic VIPCustomer(int customerID, String customerName, int agentID) {\n\t\tsuper(customerID, customerName);\n\t\tcustomerGrade = \"VIP\";\n\t\tbonusRatio = 0.05;\n\t\tsaleRatio = 0.1;\n\t\tthis.agentID = agentID;\n\t}\n\t\n\tpublic int calcPrice(int price) {\n\t\tbonusPoint += price * bonusRatio;\n\t\treturn price - (int)(price * saleRatio);\n\t}\n\t\n\tpublic String showCustomerInfo() {\n\t\treturn super.showCustomerInfo() + \" 담당 상담원 번호는 \" + agentID + \"입니다.\";\n\t}\n\t\n\tpublic int getAgentID() {\n\t\treturn agentID;\n\t}\n}\n```\n\n\u003cbr\u003e\n  \n- CustomerTest.java\n\n```java\npackage Chapter08.polymorphism;\n\npublic class CustomerTest {\n\tpublic static void main(String[] args) {\n\t\tCustomer customerLee = new Customer(10010, \"이순신\");\n\t\tcustomerLee.bonusPoint = 1000;\n\t\tSystem.out.println(customerLee.showCustomerInfo());\n\t\t  \n\t\tCustomer customerKim = new VIPCustomer(10020, \"김유신\", 12345);\n\t\tcustomerKim.bonusPoint = 10000;\n\t\tSystem.out.println(customerKim.showCustomerInfo());\n\t\t\n\t\tSystem.out.println(\"----- 할인율과 보너스 포인트 계산 -----\");\n\t\t\n\t\tint price = 10000;\n\t\tint leePrice = customerLee.calcPrice(price);\n\t\tint kimPrice = customerKim.calcPrice(price);\n\t\t  \n\t\tSystem.out.println(customerLee.getCustomerName() + \"님이 \" + leePrice + \"원 지불하셨습니다.\");\n\t\tSystem.out.println(customerLee.showCustomerInfo());\n\t\tSystem.out.println(customerKim.getCustomerName() + \"님이 \" + kimPrice + \"원 지불하셨습니다.\");\n\t\tSystem.out.println(customerKim.showCustomerInfo());\n\t}\n}\n```\n\n핵심은 Customer 자료형 하나로 관리하는 모습이다. 자료형은 Customer 형으로 동일하지만, 할인율과 보너스 포인트는 각 인스턴스의 메서드에 맞게 계산했다. 재정의된 메서드는 각각 호출되고 서로 다른 역할을 구현하기 떄문이다. 다형성을 적절하게 이용했다.\n\n\u003chr\u003e\n\n## 다형성 활용하기\n\n### 새로운 상황 부여 ver 01\n\n\u003e [!note] 예제 시나리오\n\u003e\n\u003e 고객이 늘어 VIP 고객까진 아니고 GOLD 등급 하나 추가하려함 \n\u003e - 제품을 살 때는 항상 10% 할인 (VIP랑 동일)\n\u003e - 보너스 포인트를 2% 적립 (SILVER는 1%, VIP는 5%)\n\u003e - 담당 전문 상담원 없음\n\n![](brain/image/chap08-7.png)\n\n```java\npackage Chapter08.polymorphism;\n  \npublic class GoldCustomer extends Customer {\n\tdouble saleRatio;\n\t  \n\tpublic GoldCustomer(int customerID, String customerName) {\n\t\tsuper(customerID, customerName);\n\t\tcustomerGrade = \"GOLD\";\n\t\tbonusRatio = 0.02;\n\t\tsaleRatio = 0.1;\n\t}\n\t  \n\t@Override\n\tpublic int calcPrice(int price) {\n\t\tbonusPoint += price * bonusRatio;\n\t\treturn price - (int)(price * saleRatio);\n\t}\n}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**배열로 고객 5명 구현하기**\n\n```java\npackage Chapter08.polymorphism;\nimport java.util.ArrayList;\n\npublic class CustomerTest2 {\n\tpublic static void main(String[] args) {\n\t\tArrayList\u003cCustomer\u003e customerList = new ArrayList\u003cCustomer\u003e(); \n\t\t\n\t\tCustomer customerLee = new Customer(10010, \"이순신\");\n\t\tCustomer customerShin = new Customer(10020, \"신사임당\");\n\t\tCustomer customerHong = new GoldCustomer(10030, \"홍길동\");\n\t\tCustomer customerYoul = new GoldCustomer(10040, \"이율곡\");\n\t\tCustomer customerKim = new VIPCustomer(10050, \"김유신\", 12345);\n\t\t  \n\t\tcustomerList.add(customerLee);\n\t\tcustomerList.add(customerShin);\n\t\tcustomerList.add(customerHong);\n\t\tcustomerList.add(customerYoul);\n\t\tcustomerList.add(customerKim);\n\t\t\n\t\tSystem.out.println(\"----- 고객 정보 출력 -----\");\n\t\tfor (Customer customer : customerList) {\n\t\t\tSystem.out.println(customer.showCustomerInfo());\n\t\t}\n\t\t  \n\t\tSystem.out.println();\n\t\t\n\t\tSystem.out.println(\"----- 할인율과 보너스 포인트 계산 -----\");\n\t\tint price = 10000;\n\t\tfor(Customer customer : customerList) {\n\t\t\tint cost = customer.calcPrice(price);\n\t\t\tSystem.out.println(customer.getCustomerName() + \"님이 \" + cost + \"원 지불하셨습니다.\");\n\t\t\tSystem.out.println(customer.getCustomerName() + \"님의 현재 보너스 포인트는 \" + customer.bonusPoint + \"점 입니다.\");\n\t\t}\n\t}\n}\n```\n\n- **Customer 형**으로 객체 배열 ArrayList 선언\n\n- **Customer 형**으로 선언하고 Customer, GoldCustomer, VIPCustomer 인스턴스 생성해서, 각 인스턴스 (하위) -\u003e Custmer (상위)로 묵시적 형 변환\n\n- 가상 메서드 원리에 의하여 **Customer 형**임에도 calcPrice() 메서드 호출 시 각 인스턴스의 메서드 호출하여 실행\n\n- 배열의 요소를 **Customer 형** 변수에 넣음\n\n- 이것이 바로 다형성 ~\n\n만약, 재정의한 (오버라이딩한) 메서드가 가상 메서드 방식에 의해 자동으로 호출되지 않는다면? -\u003e if/else-if로 각 자료형에 적합한 코드를 하나하나 따로 구현해야함 -\u003e 코드 길어짐, 유지보수 힘듬\n\n\u003cbr\u003e\n\n### 상속은 언제 사용?\n\n상속을 사용하여 이미 Customer 클래스가 있는 상태에서 (기본 뼈대) 추가적인 내용만 따로 구현 가능했다. 만약 상속을 사용하지 않는다면? 아래처럼 답 없이 짜야함\n\n```java\nif (customerGrade == \"VIP\") {\n\t// 할인해주고, 적립도 많이해주고\n} else if (customerGrade == \"GOLD\") {\n\t// 할인해주고, 적립 적당히\n} else if (customerGrade == \"SILVER\") {\n\t// 할인 없음, 적립만\n}\n```\n\n\u003cbr\u003e\n\n**그렇다면, 상속을 항상 사용하는 것이 좋은가?**\n\n- 아니다. 상속은 ==IS-A 관계(is a relationship; inheritance)== 처럼 일반적인 개념과 구체적인 개념의 관계에서 사용하는 것이 가장 효율적이다.\n\n- 일반 클래스를 점차 구체화하는 상황에서 사용하는 것이지 상속을 사용하면 **하위 클래스가 상위 클래스형에 종속되기 때문에** 이질적인 클래스 간에는 상속을 사용하지 않는 것이 좋다.\n\n\u003cbr\u003e\n\n예를 들어, 과목을 나타내는 Subject 클래스와 학생을 나타내는 Student 클래스가 있다고 하자. 모든 학생은 전공 과목(Subject)을 가지고 있으니까 Subject 클래스에서 제공하는 여러 메서드를 활용하면 좋을 것 같아서 상속받으면 될까?\n\nSubject가 Student를 **포괄**하는 개념이 **아니기** 때문에 좋지 않다. 이런 경우에는 IS-A 관계가 아닌 ==HAS-A 관계(has a relationship; association)== 로 표현한다. HAS-A 관계는 **한 클래스가 다른 클래스를 소유한 관계**이다.\n\n- 학생이 과목을 가지고 있다. HAS-A 관계\n\n- Subject는 Student에 포함되어 Student의 멤버 변수로 사용하는 것이 적절\n\n```java\nclass Student {\n\tSubject majorSubject;\n}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n- 상속은 무조건적인 코드 재사용 개념이 아니다.\n\n- 상속을 사용하면 클래스 간의 결합도가 높아져서, 상위 클래스의 변화가 하위 클래스에 미치는 영향이 커진다.\n\n- 일반적인 클래스와 구체적인(확장되는) 클래스, IS-A 관계에서 구현하는 것이 맞다.\n\n\u003cbr\u003e\n\n### 자바에는 다중 상속이 없어요\n\n다중 상속 : 한 클래스가 여러 클래스를 상속 받는 것\n\n- 다중 상속에서 오는 장점이 있겠지만, 다중 상속으로 인한 모호성 때문에 자바에서는 다중 상속 지원 X\n\n- ex) 두 개 이상의 상위 클래스에 같은 이름의 메서드가 정의되어 있다면, 다중 상속을 받는 하위 클래스는 어떤 메서드를 상속받을지 모호해짐\n\n- 객체 지향에서 다중 상속의 모호성에 대한 문제가 **다이아몬드 문제(diamond problem)**\n\n- 따라서, extends 예약어 뒤에 오는 클래스는 무조건 한 개\n\n\u003chr\u003e\n\n## 다운 캐스팅과 instanceof\n\n### 하위 클래스로 형 변환, 다운 캐스팅\n\n상위 클래스(일반적인 개념) -\u003e 하위 클래스(구체적인 개념)으로 형 변환 되는 과정\n\n\u003cbr\u003e\n\n```java\nAnimal ani = new Human();\n```\n\n- 생성된 인스턴스 Human은 Anmial 자료형\n\n- 업 캐스팅(하위-\u003e상위) 된 경우에는 상위 클래스에서 선언한 메서드나 멤버 변수만 사용 가능\n\n- 다시 말해, Human 클래스에 더 많은 메서드, 다양한 멤버 변수가 있어도 Animal 클래스의 메서드와 멤버 변수만 사용 가능\n\n- 필요에 따라 원래 인스턴스의 자료형(여기서 Human형)으로 되돌아가야하는 경우가 있음\n\n- 이때 쓰는 것을 다운 캐스팅(down casting)\n\n\u003cbr\u003e\n\n### instanceof  \n\n예를 들어, 상속 관계에서 모든 인간은 동물이지만, 모든 동물은 인간이 아니다. 따라서, 변환에서 생기는 오류를 막기 위하여, 다운 캐스팅 전 하위 클래스 -\u003e 상위 클래스로 형 변환된 **인스턴스의 원래 자료형을 확인하는 예약어가 instanceof** 이다.\n\n```java\nAnimal hAnimal = new Human();\n\nif(hAnimal instanceof Human) {\n\tHuman human = (Human)hAnimal;\n}\n```\n\n- `hAnimal instanceof Human` : hAnimal 인스턴스의 원래 자료형이 Human 형 이라면\n\n- `Human human = (Human)hAnimal` : 인스턴스 hAnimal을 Human형으로 다운 캐스팅\n\n```java\nAnimal ani = new Tiger();\nHuman h = (Human)ani;\n```\n\n- 이렇게 코딩해도 컴파일 에러는 안남. 왜? Human형으로 자료형이 같으니까\n\n- 대신 실행오류가 발생함\n\n```java\npackage Chapter08.polymorphism;\nimport java.util.ArrayList;\n\nclass Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"동물이 움직입니다.\");\n\t}\n}\n\nclass Human extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"사람이 두 발로 걷습니다.\");\n\t}\n\n\tpublic void readBook() {\n\t\tSystem.out.println(\"사람이 책을 읽습니다.\");\n\t}\n}\n\nclass Tiger extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"호랑이가 네 발로 뜁니다.\");\n\t}\n\t\n\tpublic void hunting() {\n\t\tSystem.out.println(\"호랑이가 사냥을 합니다.\");\n\t}\n}\n\nclass Eagle extends Animal {\n\tpublic void move() {\n\t\tSystem.out.println(\"독수리가 하늘을 납니다.\");\n\t}\n\t  \n\tpublic void flying() {\n\t\tSystem.out.println(\"독수리가 날개를 쭉 펴고 멀리 날아갑니다.\");\n\t}\n}\n\npublic class AnimalTest {\n\tArrayList\u003cAnimal\u003e aniList = new ArrayList\u003cAnimal\u003e();\n\t  \n\tpublic static void main(String[] args) {\n\t\tAnimalTest aTest = new AnimalTest();\n\t\taTest.addAnimal();\n\t\tSystem.out.println(\"원래 형으로 다운 캐스팅\");\n\t\taTest.testCasting();\n\t}\n\n\tpublic void addAnimal() {\n\t\taniList.add(new Human());\n\t\taniList.add(new Tiger());\n\t\taniList.add(new Eagle());\n\t\t  \n\t\tfor (Animal ani : aniList) {\n\t\t\tani.move();\n\t\t}\n\t}\n\n\tpublic void testCasting() {\n\t\tfor (int i = 0; i \u003c aniList.size(); i++) {\n\t\t\tAnimal ani = aniList.get(i);\n\t\t\t  \n\t\t\tif (ani instanceof Human) {\n\t\t\t\tHuman h = (Human) ani;\n\t\t\t\th.readBook();\n\t\t\t} else if (ani instanceof Tiger) {\n\t\t\t\tTiger t = (Tiger) ani;\n\t\t\t\tt.hunting();\n\t\t\t} else if (ani instanceof Eagle) {\n\t\t\t\tEagle e = (Eagle) ani;\n\t\t\t\te.flying();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"지원되지 않는 형입니다.\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 사람이 두 발로 걷습니다.\n// 호랑이가 네 발로 뜁니다.\n// 독수리가 하늘을 납니다.\n// 원래 형으로 다운 캐스팅\n// 사람이 책을 읽습니다.\n// 호랑이가 사냥을 합니다.\n// 독수리가 날개를 쭉 펴고 멀리 날아갑니다.\n```\n\n- 배열 요소가 Animal 형이라서 각 인스턴스에서 제공하는 구체적인 메서드를 사용할 수 없음\n\n- 따라서, 사용하려면 원래 자료형으로 다운캐스팅 되어야 함","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/chap09":{"title":"09.추상 클래스","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 09 - 추상 클래스\n\n\u003cbr\u003e\n\n## 추상 클래스\n\n- 추상 클래스는 완전하지 않은 클래스\n\n- 부족하다는 뜻도 있지만,\n\n- 다른 한 편으로 **가능성이 남아 있다는 의미**, 즉, 확장이 가능하다\n\n\u003cbr\u003e\n\n### 추상 클래스란?\n\n- 추상적이다 = 구체적이지 않고 막연하다\n\n- 어떤 클래스가 추상적이다 = 구체적이지 않은 클래스\n\n- 추상 클래스 (abstract class)\n\n- 추상 클래스가 아닌 클래스 (concrete class), 지금까지 해온 모든 클래스가 이거\n\n**추상 클래스는 항상 추상 메서드를 포함한다.** 추상 메서드는 구현 코드가 없다. 즉, **함수 몸체가 없다**. 아래와 같이 `{}` 안의 내용이 함수 몸체이다.\n\n```java\nint add(int x, int y) {\n\treturn x + y;\n}\n```\n\n- 중괄호 `{}`로 감싼 부분 = 함수의 구현부(implementation)\n\n- 함수의 구현부가 없는 함수 = 추상 함수(abstract function)\n\n- 자바에서는 이를 **추상 메서드(abstract method)** 라고 한다.\n\n- 추상 메서드는 선언만 하며 abstract 예약어 사용  \n\n```java\nabstract int add(int x, int y);\n```\n\n아래는 중괄호 `{}`가 있으니까 추상 메서드 아님. `{}`안에 코드만 없을 뿐 `{}`를 구현은 한 것이다.\n\n```java\nint add(int x, int y) {}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**메서드 선언의 의미** \n\n변수를 선언하고 제어문을 사용하여 로직을 만들고 기능을 구현하는 것도 물론 중요하지만, 로직을 구현하는 것보다 중요한 것이 **어떻게 구현할지를 결정하는 것**이다.\n\n```java\nint add(int num1, int num2);\n```\n\n위 코드만 봐도 두 개의 정수를 입력받고 더해서 반환한다는 것을 유추할 수 있다.\n\n- **메서드의 선언부(declaration)만 봐도 어떤 일을 하는 메서드인지 유추할 수 있다.**\n\n- 선언부에 해당하는 반환 값(리턴), 함수 이름, 매개변수를 정의한다는 것이 **함수의 역할이 무엇인지, 어떻게 구현해야 하는지를 정의한다**는 의미다.\n\n- 어떤 의미로는, **함수 몸체를 구현하는 것보다 함수 선언부 작성이 더 중요하다는 말이다.**\n\n\u003cbr\u003e\n\n### 추상 클래스 구현\n\n- 클래스 다이어그램에서 일반 클래스는 똑바로 쓰는데 **추상 클래스는 기울임 꼴**로 작성\n\n![](brain/image/chap09-1.png)\n\n\u003cbr\u003e\n\n**Computer 클래스**\n\n```java\npackage chapter09.abstractex;\n  \npublic abstract class Computer {\n\tpublic abstract void display();\n\tpublic abstract void typing();\n\t\n\tpublic void turnOn() {\n\t\tSystem.out.println(\"전원을 켭니다.\");\n\t}\n\t\n\tpublic void turnOff() {\n\t\tSystem.out.println(\"전원을 끕니다.\");\n\t}\n}\n```\n\n- 추상화 하고자 하는 메서드(몸체, 구현부 `{}` 없는)에 abstract 안붙히면 오류\n\n- 추상 메서드가 들어있는 클래스에 abstract 안붙히면 오류\n\n- Computer 클래스를 상속받는 클래스 중 `turnOn()`과 `turnOff()` 구현 코드는 공통\n\n- 하지만, 추상 메서드인 `display()`와 `typing()`은 하위 클래스에 따라 달라질 수 있음\n\n- 추상 메서드는 **이 메서드는 Computer 클래스에서 구현하지 않고, 구현에 대한 책임을 상속 받는 클래스에 위임한다**라는 의미\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n- 상위 클래스에서 하위 클래스도 공통으로 사용할 메서드 구현\n\n- 하위 클래스마다 다르게 구현할 메서드는 추상 메서드로 선언\n\n\u003cbr\u003e\u003cbr\u003e\n\n**DeskTop 클래스**\n\n```java\npackage chapter09.abstractex;\n  \npublic class DeskTop extends Computer{\n  \n}\n```\n\n- 이렇게 하면 오류 발생\n\n- Computer 클래스가 추상 클래스니까, 추상 클래스를 상속받는 클래스는 **추상 메서드를 상속받음**\n\n- 해결방법 01. DeskTop도 추상 클래스로 만들기\n\n- 해결방법 02. DeskTop에서 Computer에서 구현되지 않았던 추상 메서드를 구현하기, 대신 모든 추상 메서드를 모두 구현해야함. 하나라도 추상 메서드 있으면 추상 클래스니까\n\n\u003cbr\u003e\u003cbr\u003e\n\n아래에서 해결방법 02를 사용했다.\n\n```java\npackage chapter09.abstractex;\n\npublic class DeskTop extends Computer{\n\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"DeskTop display()\");\n\t}\n\n\t@Override\n\tpublic void typing() {\n\t\tSystem.out.println(\"DeskTop typing()\");\n\t}\n}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**NoteBook 클래스**\n\n```java\npackage chapter09.abstractex;\n  \npublic abstract class NoteBook extends Computer{\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"NoteBook display()\");\n\t}\n}\n```\n\n- 추상 메서드 `display()`와 `typing()`중 `display()`만 구현했으니 추상 클래스라고 해주는 `abstract`를 붙혀야함\n\n\u003cbr\u003e\u003cbr\u003e\n\n**MyNoteBook 클래스**\n\n```java\npackage chapter09.abstractex;\n  \npublic class MyNoteBook extends NoteBook {\n\t@Override\n\tpublic void typing() {\n\t\tSystem.out.println(\"MyNoteBook typing()\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**모든 추상 메서드를 구현하고도 클래스에 abstract 사용하면?**\n\n```java\npublic abstract class AbstractTV {\n\tpublic void turnOn() {\n\t\tSystem.out.println(\"전원을 켭니다.\");\n\t}\n\t  \n\tpublic void turnOff() {\n\t\tSystem.out.println(\"전원을 끕니다.\");\n\t}\n}\n```\n\n- 모든 추상 메서드를 구현했어도, 완벽하게 TV의 기능이 구현된 것은 아니고 TV의 **공통 기능만 구현해놓은 것**이다.\n\n- 이 클래스는 사용할 목적이 아닌 **상속만을 위해 만든 추상 클래스**이다.\n\n- 이런 경우 **new 예약어로 인스턴스 생성 불가**\n\n추상 클래스 연습한거는 \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter09/abstractex/alone/Car.java' target='_blank'\u003eCar\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter09/abstractex/alone/Bus.java' target='_blank'\u003eBus\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter09/abstractex/alone/AutoCar.java' target='_blank'\u003eAutoCar\u003c/a\u003e, \u003ca href='https://github.com/Shin-Jae-Yoon/do-it-java/blob/master/src/chapter09/abstractex/alone/CarTest.java' target='_blank'\u003eCarTest\u003c/a\u003e\n\n\u003cbr\u003e\n\n### 추상 클래스를 만드는 이유\n\n\u003cbr\u003e\n\n**추상 클래스는 인스턴스로 생성할 수 없다.**\n\n- 추상 클래스는 모든 메서드가 구현된 것은 아니므로, 인스턴스로 생성 불가\n\n- 추상 메서드를 호출했을 때 구현된 코드가 없으므로 수행할 수 있는 내용 없으니까.\n\n\u003cbr\u003e\n\n**추상 클래스에서 구현하는 메서드**\n\n- 생성할 수 없는 추상 클래스를 어디에 씀? -\u003e 추상 클래스는 상속을 하기 위해 만든 클래스\n\n- 추상 클래스에서 구현하는 메서드 : 하위 클래스에서도 사용할, 하위 클래스에서도 구현 내용을 공유할 메서드를 구현\n\n- 하위 클래스에서 내용을 각각 다르게 구현해야 하면, 구현 내용을 추상 메서드로 남겨 두고 하위 클래스에 구현을 위임\n\n\u003cbr\u003e\n\n| 메서드        | 특징                                                                           |\n|:------------- |:------------------------------------------------------------------------------ |\n| 구현된 메서드 | 하위 클래스에서 공통으로 사용할 구현 코드. 하위 클래스에서 재정의 할 수도 있음 |\n| 추상 메서드 | 하위 클래스가 어떤 클래스냐에 따라 구현 코드가 달라짐  |\n\n\u003cbr\u003e\n\n예를 들어, `turnOn()`, `turnOff()`의 구현은 하위 클래스에서 공유할 수 있다. 하지만, `display()`와 `typing()`의 구현내용은 NoteBook인지 DeskTop인지에 따라 달라지니까 Computer 클래스에서 구현 안했던 것\n\n\u003cbr\u003e\u003cbr\u003e\n\n**추상 클래스와 프레임워크**\n\n- 추상 클래스는 많은 프레임워크에서 사용하고 있는 구현 방식\n\n- ex) 안드로이드 앱 만들 때 안드로이드 라이브러리에서 제공하는 많은 클래스 사용. 모두 구현된 클래스도 있지만, 일부만 구현되어 있어서 상속 받고 그 뒤에 구현하는 경우도 많음\n\n- 구현을 미루어 놓은 메서드(추상 메서드)는 앱을 어떻게 만드냐에 따라 다르게 구현해야할 내용으로 앱에서 구현하도록 **선언**만 해둔 것\n\n\u003chr\u003e\n\n## 템플릿 메서드\n\n### 추상 클래스와 템플릿 메서드\n\n- 템플릿 메서드는 추상 클래스를 활용한 예\n\n- 템플릿(template)는 사전적 의미로 틀이나 견본을 의미\n\n- 즉, 템플릿 메서드 = 틀이 있는 메서드\n\n- 싱글톤 패턴과 같은 디자인 패턴\n\n\u003cbr\u003e\n\n**Car 클래스**\n\n```java\npackage chapter09.template;\n  \npublic abstract class Car {\n\tpublic abstract void drive();\n\tpublic abstract void stop();\n\t\n\tpublic void startCar() {\n\t\tSystem.out.println(\"시동을 켭니다.\");\n\t} \n\t\n\tpublic void turnOff() {\n\t\tSystem.out.println(\"시동을 끕니다.\");\n\t}\n\t\n\tfinal public void run() {\n\t\tstartCar();\n\t\tdrive();\n\t\tstop();\n\t\tturnOff();\n\t}\n}\n```\n\n- `final`이 부분이 템플릿 메서드\n\n- 시동을 켜고 끄는 방법은 비슷비슷 하니까 `startCar()`, `turnOff()`는 미리 구현해놈\n\n- `drive()`, `stop()`은 차종에 따라 다를 수 있으니까 추상 메서드로 선언\n\n- `run()`은 템플릿 메서드인데, 자동차가 달리는 방법을 순서대로 구현해뒀음. 시동 키고 -\u003e 달리고 -\u003e 브레이크로 멈추고 -\u003e 시동 끔\n\n\u003cbr\u003e\n\n**AICar 클래스**\n\n```java\npackage chapter09.template;\n\npublic class AICar extends Car {\n\t@Override\n\tpublic void drive() {\n\t\tSystem.out.println(\"자율 주행합니다.\");\n\t\tSystem.out.println(\"자동차가 알아서 방향을 전환합니다.\");\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\tSystem.out.println(\"스스로 멈춥니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**ManualCar 클래스**\n\n```java\npackage chapter09.template;\n  \npublic class ManualCar extends Car {\n\t@Override\n\tpublic void drive() {\n\t\tSystem.out.println(\"사람이 운전합니다.\");\n\t\tSystem.out.println(\"사람이 핸들을 조작합니다.\");\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\tSystem.out.println(\"브레이크로 정지합니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**CarTest 클래스**\n\n```java\npackage chapter09.template;\n  \npublic class CarTest {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"--- 자율 주행하는 자동차 ---\");\n\t\tCar myCar = new AICar();\n\t\tmyCar.run();\n\t\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"--- 사람이 운전하는 자동차 ---\");\n\t\tCar hisCar = new ManualCar();\n\t\thisCar.run();\n\t}\n}\n\n// --- 자율 주행하는 자동차 ---\n// 시동을 켭니다.\n// 자율 주행합니다.\n// 자동차가 알아서 방향을 전환합니다.\n// 스스로 멈춥니다.\n// 시동을 끕니다.\n  \n// --- 사람이 운전하는 자동차 ---\n// 시동을 켭니다.\n// 사람이 운전합니다.\n// 사람이 핸들을 조작합니다.\n// 브레이크로 정지합니다.\n// 시동을 끕니다.\n```\n\n\u003cbr\u003e\n\n### 템플릿 메서드 역할\n\n- 템플릿 메서드는 **메서드 실행 순서와 시나리오를 정의**하는 것\n\n- 시나리오를 정의한 메서드라서 바꾸면 안됨\n\n- `final` 예약어를 사용하면 상속받은 하위 클래스가 메서드를 재정의 할 수 없음\n\n- 상수를 선언할 때 `final` 썼잖음 그거\n\n- 템플릿 메서드는 로직 흐름이 이미 정해져 있는 프레임워크에서 많이 사용하는 기본 구현 방법\n\n\u003chr\u003e\n\n## 템플릿 메서드 응용하기\n\n\u003e [!note] 예제 시나리오\n\u003e\n\u003e Player가 게임을 한다. 게임에서 Player가 가지는 레벨에 따라 할 수 있는 세 가지 기능이 있다. 이 기능은 run(), jump(), turn()이다.\n\u003e - 초보자 레벨 : 천천히 달릴(run) 수 있음\n\u003e - 중급자 레벨 : 빠르게 달리고(run) 점프(jump)할 수 있음\n\u003e - 고급자 레벨 : 엄청 빠르게 달리고(run) 점프하고(jump) 턴(turn)할 수 있음\n\u003e \u003cbr\u003e\n\u003e 모든 레벨에서 Player가 사용할 수 있는 필살기 go(int count) 메서드 제공 \u003cbr\u003e\n\u003e  go() 메서드는 한 번 run하고, 매개변수로 전달된 count만큼 jump하고, 한 번 turn 함 \u003cbr\u003e\n\u003e  그 레벨에서 불가능한 기능을 요청하면 할 수 없다는 메세지 출력\n  \n\u003cbr\u003e\n\n### 클래스 설계하기\n\n![](brain/image/chap09-2.png)\n\n- Player 클래스와 PlayerLevel 클래스는 포함(HAS-A) 관계\n\n- 게임에서 모든 플레이어는 레벨이 있으니까, 플레이어가 레벨을 멤버 변수로 갖는 것\n\n- 모든 레벨에서 공통으로 수행하는 기능은 구현\n\n- 레벨마다 달라지는 기능은 추상 메서드로 선언만\n\n다이아몬드 표시는 포함 관계를 나타내는 것\n\n\u003cbr\u003e\n\n**Player 클래스**\n\n```java\npackage chapter09.gameLevel;\n  \npublic class Player {\n\tprivate PlayerLevel level;\n\t  \n\tpublic Player() {\n\t\tlevel = new BeginnerLevel();\n\t\tlevel.showLevelMessage();\n\t}\n\t  \n\tpublic PlayerLevel getLevel() {\n\t\treturn level;\n\t}\n\t  \n\tpublic void upgradeLevel(PlayerLevel level) {\n\t\tthis.level = level;\n\t\tlevel.showLevelMessage();\n\t}\n\t  \n\tpublic void play(int count) {\n\t\tlevel.go(count);\n\t}\n}\n```\n\n- Player가 가지는 level 변수 선언\n\n- 디폴트 생성자로 처음 생성되었을 때 초보자 레벨로 시작하게\n\n- 레벨 변경 메서드는 현재 자신의 level을 매개변수로 받은 level로 변경\n\n- 이때, 매개변수 자료형을 모든 레벨로 변환 가능하게 PlayerLevel 형으로 선언\n\n- PlayerLevel의 템플릿 메서드 go 호출\n\n\u003cbr\u003e\n\n**PlayerLevel 클래스**\n\n```java\npackage chapter09.gameLevel;\n  \npublic abstract class PlayerLevel {\n\tpublic abstract void run();\n\tpublic abstract void jump();\n\tpublic abstract void turn();\n\tpublic abstract void showLevelMessage();\n\t  \n\tfinal public void go(int count) {\n\t\trun();\n\t\t\n\t\tfor(int i = 0; i \u003c count; i++) {\n\t\t\tjump();\n\t\t}\n\t\t\n\t\tturn();\n\t}\n}\n```\n\n- 레벨마다 다른 기능인 `run(), jump(), turn(), showLevelMessage()`는 추상 메서드로 선언만\n\n- 템플릿 메서드인 `go()`는 예약어 `final`써서 순서 마음대로 못바꾸게\n\n- count에 따라 점프 횟수 바뀌니까 반복문으로\n\n\u003cbr\u003e\n\n**BeginnerLevel 클래스**\n\n```java\npackage chapter09.gameLevel;\n  \npublic class BeginnerLevel extends PlayerLevel {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"천천히 달립니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void jump() {\n\t\tSystem.out.println(\"Jump 할 줄 모르지롱. 레벨 올려오셈\");\n\t}\n\t  \n\t@Override\n\tpublic void turn() {\n\t\tSystem.out.println(\"Turn 할 줄 모르지롱. 레벨 올려오셈\");\n\t} \n\t\n\t@Override\n\tpublic void showLevelMessage() {\n\t\tSystem.out.println(\"****** 초보자 레벨입니다. ******\");\n\t}\n}\n```\n\n\u003cbr\u003e  \n\n**AdvancedLevel 클래스**\n\n```java\npackage chapter09.gameLevel;\n  \npublic class AdvancedLevel extends PlayerLevel {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"빨리 달립니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void jump() {\n\t\tSystem.out.println(\"높이 점프합니다.\");\n\t}\n\t\n\t@Override\n\tpublic void turn() {\n\t\tSystem.out.println(\"Turn 할 줄 모르지롱. 레벨 올려오셈\");\n\t}\n\t\n\t@Override\n\tpublic void showLevelMessage() {\n\t\tSystem.out.println(\"****** 중급자 레벨입니다. ******\");\n\t}\n}\n```\n\n\u003cbr\u003e \n\n**SuperLevel 클래스**\n\n```java\npackage chapter09.gameLevel;\n\npublic class SuperLevel extends PlayerLevel {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"엄청 빨리 달립니다.\");\n\t}\n\t\n\t@Override\n\tpublic void jump() {\n\t\tSystem.out.println(\"아주 높이 점프합니다.\");\n\t}\n\t\n\t@Override\n\tpublic void turn() {\n\t\tSystem.out.println(\"한 바퀴 돕니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void showLevelMessage() {\n\t\tSystem.out.println(\"****** 고급자 레벨입니다. ******\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**MainBoard 클래스**\n\n```java\npackage chapter09.gameLevel;\n\npublic class MainBoard {\n\tpublic static void main(String[] args) {\n\t\tPlayer player = new Player();\n\t\tplayer.play(1);\n\t\n\t\tAdvancedLevel aLevel = new AdvancedLevel();\n\t\tplayer.upgradeLevel(aLevel);\n\t\tplayer.play(2);\n\t\n\t\tSuperLevel sLevel = new SuperLevel();\n\t\tplayer.upgradeLevel(sLevel);\n\t\tplayer.play(3);\n\t}\n} \n\n//****** 초보자 레벨입니다. ******\n//천천히 달립니다.\n//Jump 할 줄 모르지롱. 레벨 올려오셈\n//Turn 할 줄 모르지롱. 레벨 올려오셈\n\n//****** 중급자 레벨입니다. ******\n//빨리 달립니다.\n//높이 점프합니다.\n//높이 점프합니다.\n//Turn 할 줄 모르지롱. 레벨 올려오셈\n\n//****** 고급자 레벨입니다. ******\n//엄청 빨리 달립니다.\n//아주 높이 점프합니다.\n//아주 높이 점프합니다.\n//아주 높이 점프합니다.\n//한 바퀴 돕니다.\n```\n\n- 당연히, 이번 실습에서도 다형성이 사용됨을 확인 가능\n\n- Player가 가질 수 있는 여러 레벨을 **PlayerLevel**로 관리함\n\n- 레벨 변경하는 upgradeLevel() 메서드의 매개변수 자료형도 **PlayerLevel**\n\n- **하나의 코드가 다양한 자료형을 대상으로 동작하는 다형성을 활용한 것**\n\n\u003chr\u003e\n\n## final 예약어\n\n\u003cbr\u003e\n\n| 사용 위치 | 설명 |\n| :-------: | :----------------------------------------: |\n| 변수 | final 변수는 상수를 의미 |\n| 메서드 | final 메서드는 하위 클래스에서 재정의 불가 |\n| 클래스 | final 클래스는 상속할 수 없음 |\n  \n\u003cbr\u003e\n\n### final 변수\n\n\u003cbr\u003e\n\n```java\npackage chapter09.finalex;\n\npublic class Constant {\n\tint num = 10;\n\tfinal int NUM = 100;\n\t  \n\tpublic static void main(String[] args) {\n\t\tConstant cons = new Constant();\n\t\tcons.num = 50;\n\t\tcons.NUM = 200;\n\t\t  \n\t\tSystem.out.println(cons.num);\n\t\tSystem.out.println(cons.NUM);\n\t}\n}  \n\n// 오류\n```\n\n- 변수 이름은 소문자와 대문자 구분해서 `num`이랑 `NUM`은 다른거임\n\n- `final`로 선언한 `NUM`에 값을 넣으려고 하면 오류 발생\n\n\u003cbr\u003e\u003cbr\u003e\n\n**여러 자바 파일에서 공유하는 상수 값 정의**\n\n- 하나의 자바 파일에서만 사용하는 상수 값은 그냥 파일 안에서 final 정의하고 쓰면 됨\n\n- ex) 최솟값(MIN), 최댓값(MAX), 과목 코드 값 등 이런 값들은 여러 파일에서 공유하면서 써야하는 상수\n\n- 여러 파일에서 공유하는 상수 값은 **한 파일에 모아 `public static final`로 선언하여 사용하면 좋음**\n\n```java\npackage chapter09.finalex;\n  \npublic class Define {\n\tpublic static final int MIN = 1;\n\tpublic static final int MAX = 99999;\n\tpublic static final int ENG = 1001;\n\tpublic static final int MATH = 2001;\n\tpublic static final double PI = 3.14;\n\tpublic static final String GOOD_MORNING = \"Good Morning!\";\n}\n```\n\n- 상수를 모두 `public` 예약어로 선언해서 외부에서 사용 가능\n\n- 상수를 모두 `static` 예약어로 선언해서 인스턴스 안만들고 클래스 이름으로 참조해서 사용 가능\n\n```java\npackage chapter09.finalex; \n\npublic class UsingDefine {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(Define.GOOD_MORNING);\n\t\tSystem.out.println(\"최솟값은 \" + Define.MIN + \"입니다.\");\n\t\tSystem.out.println(\"최댓값은 \" + Define.MAX + \"입니다.\");\n\t\tSystem.out.println(\"수학 과목 코드 값은 \" + Define.MATH + \"입니다.\");\n\t\tSystem.out.println(\"영어 과목 코드 값은 \" + Define.ENG + \"입니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### final 메서드\n\nfinal 메서드는 위에서 배웠던 하위 클래스에서 재정의 불가능한 \u003ca href='/brain/Book/do-it-java/chap09/#템플릿-메서드'\u003e템플릿 메서드\u003c/a\u003e 참고\n\n\u003cbr\u003e\n\n### final 클래스\n\n클래스를 final로 선언하면 상속 불가능.\n\n- 상속하면 변수나 메서드 재정의할 수 있게되니까 그러면 클래스가 가지고 있는 기능에 오류 생길 수 있음\n\n- 보안과 관련, 기반 클래스가 변하면 안되는 경우 =\u003e final로 선언\n\n- 대표적으로 JDK에서 제공하는 클래스인 문자열을 나타내는 `String 클래스`, 정수 값을 나타내는 `Integer 클래스`가 final로 선언되었음.\n\n\u003cbr\u003e\n\n### 프로그램을 잘 구현하는 또 다른 방법\n\n- 테스트 코드(최종 실행 파일)부터 만들기\n\n위에서는 MainBoard 클래스 -\u003e 각 레벨 클래스 -\u003e PlayerLevel 클래스 -\u003e Player 클래스 순으로 개발했다. 이제는 반대로 MainBoard 클래스부터 구현해보자.\n\n```java\npackage chapter09.gameLevel; \n\npublic class MainBoard {\n\tpublic static void main(String[] args) {\n\t\tPlayer player = new Player(); // 오류 발생\n\t\tplayer.play(1); \n\t\t\n\t\tAdvancedLevel aLevel = new AdvancedLevel();\n\t\tplayer.upgradeLevel(aLevel); // 오류 발생\n\t\tplayer.play(2);\n\t\t\n\t\tSuperLevel sLevel = new SuperLevel();\n\t\tplayer.upgradeLevel(sLevel); // 오류 발생\n\t\tplayer.play(3);\n\t}\n}\n```\n\n- 정의되어있지 않은 클래스를 인스턴스로 생성하려니 많은 오류가 뜰 것\n\n- 이 오류들을 없애기 위하여 **MainBoard.java (테스트 코드)** 가 제대로 실행되게 하나씩 고쳐나가는 것\n\n\u003cbr\u003e\n\n이렇게 테스트 코드를 먼저 개발하는 방법론을 ==테스트 주도 개발(Test Driven Development; TDD)== 라고 한다. 테스트 코드를 만들 수 있다는 것은 이미 구현 코드가 머릿속에 있다는 의미이기도 하다.","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/chap10":{"title":"10.인터페이스","content":"\u003cbr\u003e\n\n\u003e 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.\n\n\u003chr\u003e\n\n# Chapter 10 - 인터페이스\n\n\u003cbr\u003e  \n\n## 인터페이스란?\n\n- 인터페이스(interface) : 모든 메서드가 추상 메서드로만 이루어져있음\n\n\u003cbr\u003e\n\n### 구현 코드가 없는 인터페이스\n\n- 인터페이스는 클래스 혹은 프로그램이 제공하는 기능을 **명시적으로 선언하는 역할**\n\n- 인터페이스는 **추상 메서드와 상수로만 이루어짐**\n\n\u003cbr\u003e\u003cbr\u003e\n\n**인터페이스 만들기**, 인텔리제이는 new - java class에서 interfaces 클릭하면 됨\n\n```java\npackage chapter10.interfaceex;\n  \npublic interface Calc {\n\tdouble PI = 3.14;\n\tint ERROR = -999999999;\n\t  \n\tint add(int num1, int num2);\n\tint substract(int num1, int num2);\n\tint times(int num1, int num2);\n\tint divide(int num1, int num2);\n}\n```\n\n- 파일 생성 시 인터페이스로 생성했기 때문에 `public abstract` 예약어를 명시적으로 쓰지 않아도 컴파일 과정에서 **자동으로 추상메서드로 변환**됨\n\n- 인터페이스에서 **선언한 변수**는 모두 컴파일 과정에서 값이 변하지 않는 **상수로 자동 변환됨**. `public static final` 예약어를 쓰지 않아도 무조건 상수로 인식!\n\n\u003cbr\u003e\n\n### 클래스에서 인터페이스 구현\n  \n클래스에서 인터페이스를 구현한다 (implements) = 인터페이스를 클래스가 사용하는 것\n\n![](brain/image/chap10-1.png)\n\n클래스 다이어그램\n- 점선 : 인터페이스 구현\n- 마름모 : 챕터9에서 했는데 복습하려고, 포함(HAS-A) 관계 의미\n\n\u003cbr\u003e\n\n```java\npackage chapter10.interfaceex;\n\npublic abstract class Calculator implements Calc {\n\t@Override\n\tpublic int add(int num1, int num2) {\n\t\treturn num1 + num2;\n\t}\n\t  \n\t@Override\n\tpublic int substract(int num1, int num2) {\n\t\treturn num1 - num2;\n\t}\n}\n```\n\n생각해보면, 인터페이스 자체가 추상 메서드만으로 이루어져있으니, 그걸 `implements`하면 클래스인 Calculator는 추상 메서드 4개를 포함하는 상태이니까 이걸 구현하지 않으면 Calculator 클래스도 추상 클래스가 되는 것. **추상 메서드 4개 다 구현하던가~** 혹은 **추상 클래스로 만들던가~**\n\n여기서는 add하고 substract만 구현했으니까 abstract class로 만든 것\n\n\u003cbr\u003e\n\n![](brain/image/chap10-2.png)\n\n\u003cbr\u003e\n\n```java\npackage chapter10.interfaceex;\n\npublic class CompleteCalc extends Calculator {\n\t@Override\n\tpublic int times(int num1, int num2) {\n\t\treturn num1 * num2;\n\t}\n\t\n\t@Override\n\tpublic int divide(int num1, int num2) {\n\t\tif (num2 != 0) {\n\t\t\treturn num1 / num2;\n\t\t} else {\n\t\t\treturn Calc.ERROR;\n\t\t}\n\t}\n\t\n\tpublic void showInfo() {\n\t\tSystem.out.println(\"Calc 인터페이스를 구현하였습니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e  \n\n```java\npackage chapter10.interfaceex;\n\npublic class CalculatorTest {\n\tpublic static void main(String[] args) {\n\t\tint num1 = 10;\n\t\tint num2 = 5;\n\t\t  \n\t\tCompleteCalc calc = new CompleteCalc();\n\t\tSystem.out.println(calc.add(num1, num2));\n\t\tSystem.out.println(calc.substract(num1, num2));\n\t\tSystem.out.println(calc.times(num1, num2));\n\t\tSystem.out.println(calc.divide(num1, num2));\n\t\tcalc.showInfo();\n\t}\n}\n```\n\n- Calculator 클래스는 추상 클래스 =\u003e 인스턴스 생성 불가\n\n- 그래서 CompleteCalc를 인스턴스 생성한거임\n\n\u003cbr\u003e\n\n### 인터페이스 구현과 형 변환\n\n\u003cbr\u003e\n\n```java\n// 이렇게 가능\nCalc calc = new CompleteCalc();\n```\n\n- 인터페이스도 마찬가지로 하위 클래스 =\u003e 상위 클래스로 묵시적 형 변환 가능\n\n- CompleteCalc 클래스는 상위 클래스인 Calculator형이면서 Calc형이기도 함\n\n- 이렇게하면, `showInfo()` 메서드는 CompleteCalc에서 선언한 메서드니까 `showInfo()`메서드 사용 불가능하겠군.\n\n\u003chr\u003e\n\n## 인터페이스와 다형성\n\n### 인터페이스의 역할\n\n자바 8에서 새롭게 추가된 \u003ca href='/brain/Book/do-it-java/chap10/#디폴트-메서드'\u003e디폴트 메서드\u003c/a\u003e, \u003ca href='/brain/Book/do-it-java/chap10/#정적-메서드'\u003e정적 메서드 구현부\u003c/a\u003e가 없다면, 인터페이스는 그야말로 껍데기이다. 메서드 구현부(implementation part)가 없고 메서드 선언부(declaration part)만 있는 인터페이스를 왜 사용할까?\n\n- 인터페이스는 클라이언트 프로그램에 어떤 메서드를 제공하는지 미리 알려주는 **명세(specification) 혹은 약속**의 역할\n\n\u003cbr\u003e\n\n예를 들어, Abc 인터페이스, 이를 구현한 A 클래스, 이 클래스를 사용하는 Z 프로그램이 있다고 하면, **Z 프로그램에서 A 클래스의 구현 코드 전체를 살펴보지 않고 Abc 인터페이스의 선언부만 봐도 이 A 클래스를 어떻게 사용할지 알 수 있는 것**이다.\n\n프로그램에서 클래스를 사용할 때 클래스에서 구현한 내용을 몰라도 **인터페이스에서 선언한 메서드의 매개변수 자료형과 반환 값만 알면** 인터페이스를 구현한 어떤 클래스든 사용할 수 있다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n- 인터페이스의 역할 : 인터페이스를 구현한 클래스가 어떤 기능의 메서드를 제공하는지 명시하는 것\n\n- 클라이언트 프로그램은 인터페이스에서 약속한 명세대로 구현한 클래스를 생성해서 사용하면 됨\n\n\u003cbr\u003e\n\n### 인터페이스와 다형성\n\n- 인터페이스 사용하면 다형성 구현해서 확장성 있는 프로그램 만들 수 있음\n\n- 이는 클라이언트 프로그램을 많이 수정하지 않고 **기능을 추가하거나 다른 기능을 사용할 수 있음**을 의미한다.\n\n\u003e [!note] 예제 시나리오\n\u003e\n\u003e 고객 센터에 전화 상담하는 상담원들이 있음. 센터로 전화가 오면 대기열에 저장됨. 상담원이 지정되기 전까지 대기 상태가 됨. 각 전화를 상담원에게 배분하는 정책은 여러 방식으로 구현 가능\n\u003e - 순서대로 배분\n\u003e - 짧은 대기열 찾아 배분\n\u003e - 우선순위에 따라 배분\n\u003e \u003cbr\u003e\n\u003e 1. 순서대로 배분하기 : 모든 상담원이 동일한 상담 건수를 처리하도록, 들어오는 전화 순서대로 상담원에게 하나씩 배분\n\u003e 2. 짧은 대기열 찾아 배분 : 고객 대기 시간을 줄이기 위해 상담을 하지 않는 상담원이나 가장 짧은 대기열을 보유한 상담원에게 배분\n\u003e 3. 우선순위에 따라 배분 : 고객 등급에 따라 등급이 높은 고객의 전화를 우선 가져와서 업무 능력이 좋은 상담원에게 우선 배분\n\n![](brain/image/chap10-3.png)\n\n\u003cbr\u003e\n\nScheduler 인터페이스를 구현하는 RoundRobin(순서대로), LeastJob(짧은 대기열 먼저), PriorityAllocation(우선순위에 따라) 클래스를 구현\n\n\u003cbr\u003e\n\n**Scheduler 인터페이스**\n\n```java\npackage chapter10.scheduler;\n\npublic interface Scheduler {\n\tpublic void getNextCall();\n\tpublic void sendCallToAgent();\n}\n```\n\n\u003cbr\u003e\n\n**RoundRobin 클래스**\n\n```java\npackage chapter10.scheduler;\n\npublic class RoundRobin implements Scheduler {\n\t@Override\n\tpublic void getNextCall() {\n\t\tSystem.out.println(\"상담 전화를 순서대로 대기열에서 가져옵니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void sendCallToAgent() {\n\t\tSystem.out.println(\"다음 순서 상담원에게 배분합니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**LeastJob 클래스**\n\n```java\npackage chapter10.scheduler;\n\npublic class LeastJob implements Scheduler {\n\t@Override\n\tpublic void getNextCall() {\n\t\tSystem.out.println(\"상담 전화를 순서대로 대기열에서 가져옵니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void sendCallToAgent() {\n\t\tSystem.out.println(\"현재 상담 업무가 없거나 대기가 가장 적은 상담원에게 할당합니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**PriorityAllocation 클래스**\n\n```java\npackage chapter10.scheduler;\n\npublic class PriorityAllocation implements Scheduler {\n\t@Override\n\tpublic void getNextCall() {\n\t\tSystem.out.println(\"고객 등급이 높은 고객의 전화를 먼저 가져옵니다.\");\n\t}\n\t  \n\t@Override\n\tpublic void sendCallToAgent() {\n\t\tSystem.out.println(\"업무 skill 값이 높은 상담원에게 우선적으로 배분합니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**SchedulerTest 클래스**\n\n```java\npackage chapter10.scheduler;\nimport java.io.IOException;\n\npublic class SchedulerTest {\n\tpublic static void main(String[] args) throws IOException {\n\t\tSystem.out.println(\"전화 상담 할당 방식을 선택하세요.\");\n\t\tSystem.out.println(\"R : 한명씩 차례로 할당 \");\n\t\tSystem.out.println(\"L : 쉬고 있거나 대기가 가장 적은 상담원에게 할당 \");\n\t\tSystem.out.println(\"P : 우선순위가 높은 고객 먼저 할당 \");\n\t\t  \n\t\tint ch = System.in.read();\n\t\tScheduler scheduler = null;\n\t\t\n\t\tif(ch == 'R' || ch == 'r') {\n\t\t\tscheduler = new RoundRobin();\n\t\t} else if(ch == 'L' || ch == 'l') {\n\t\t\tscheduler = new LeastJob();\n\t\t} else if(ch == 'P' || ch == 'p') {\n\t\t\tscheduler = new PriorityAllocation();\n\t\t} else {\n\t\t\tSystem.out.println(\"지원되지 않는 기능입니다.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tscheduler.getNextCall();\n\t\tscheduler.sendCallToAgent();\n\t}\n}\n```\n\n- 문자를 입력받는 `System.in.read()`를 사용하려면 IOException에서 오류를 처리해야 한다.\n\n- 마지막에 Scheduler 자료형으로 선언한 scheduler 참조변수를 이용하여, 어떤 클래스를 호출하든가와 상관없이 **인터페이스에 선언한 메서드 호출**\n\n\u003cbr\u003e\n\n### 클라이언트가 클래스를 사용하는 방법\n\n간단하다. 인터페이스를 통해 구현해야 할 메서드를 선언해놨으니까, 약속한 명세대로 클래스를 만들어서 사용하면 된다.\n\n\u003e 예를 들어, 상담 전화 할당 방식이 아닌 상담원이 본인이 필요할 때 가져오는 정책을 추가해보자. getNextCall() 호출되면 \"상담원이 다음 전화 요청\" 출력, sendCallToAgent() 호출되면 \"상담원이 전화를 가져갔습니다\" 출력, 추가된 정책은 A나 a 입력하면 선택되게\n\n\u003cbr\u003e\n\n```java\npackage chapter10.scheduler;\n\npublic class AgentGetCall implements Scheduler {\n\t@Override\n\tpublic void getNextCall() {\n\t\tSystem.out.println(\"상담원이 다음 전화 요청\");\n\t}\n\t\n\t@Override\n\tpublic void sendCallToAgent() {\n\t\tSystem.out.println(\"상담원이 전화 상담을 가져갔습니다.\");\n\t}\n}\n```\n\n\u003chr\u003e\n\n## 인터페이스 요소 살펴보기\n\n### 인터페이스 상수\n\n- 인터페이스는 추상 메서드로 이루어짐, 인스턴스 생성 불가, 멤버 변수 사용 불가\n\n- 하지만, 인터페이스에 아래와 같이 선언해도 오류 발생 X\n\n```java\npublic interface Calc {\n\tdouble PI = 3.14;\n\tint ERROR = -9999999;\n}\n```\n\n- 인터페이스에 선언한 변수를 컴파일하면 상수로 변환되기 때문 !\n\n- 인터페이스의 `PI`를 컴파일하면 `public static final double PI = 3.14` 즉, 상수 3.14로 변환된다. ERROR도 마찬가지로 `public static final`로 변환!\n\n\u003cbr\u003e\n\n### 디폴트 메서드와 정적 메서드\n\n- 자바 7까지는 인터페이스에서 추상 메서드, 상수만 선언 가능했음\n\n\t- 이렇게 하면 불편한 점이 인터페이스에서 코드를 구현할 수 없으므로, **여러 클래스에서 사용할 메서드가 클래스마다 같은 기능을 제공하는 경우, 클래스마다 반복해서 구현해야 했음**\n\n- 자바 8부터는 디폴트 메서드, 정적 메서드 기능 제공\n\n\t- 디폴트 메서드 : 인터페이스에서 구현 코드까지 작성한 메서드, 인터페이스를 구현한 클래스에 기본적으로 제공할 메서드\n\n\t- 정적 메서드 : 인스턴스 생성과 상관없이 사용할 수 있는 메서드\n\n- But, 디폴트 메서드나 정적 메서드가 추가되었다고 해도 인터페이스가 인스턴스를 생성할 수 있는 것은 아님  \n\n\u003cbr\u003e\n\n### 디폴트 메서드\n\n- 기본으로 제공되는 메서드\n\n- 인터페이스에서 디폴트 메서드 구현\n\n- 인터페이스를 구현한 클래스가 생성되면, 그 클래스에서 사용할 기본 기능\n\n- `default` 예악어 사용해서 디폴트 메서드 선언\n\n- 클래스 입장에서 구현이 강제되지 않는다 !\n\n\u003cbr\u003e\n\n**Calc 인터페이스에 코드 추가**\n\n```java\npackage chapter10.interfaceex;\n\npublic interface Calc {\n\tdefault void description() {\n\t\tSystem.out.println(\"정수 계산기를 구현합니다.\");\n\t}\n}\n```\n\n이후, Calculator 클래스, CompleteCalc 클래스에 별다른 코드를 추가 안해도 CalculatorTest 클래스에서 디폴트 메서드 그냥 호출하면 됨\n\n\u003cbr\u003e\n\n**CalculatorTest 클래스**\n\n```java\npackage chapter10.interfaceex;\n  \npublic class CalculatorTest {\n\tpublic static void main(String[] args) {\n\t\tCompleteCalc calc = new CompleteCalc();\n\t\tcalc.description();\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**디폴트 메서드 재정의하기**\n\n- 이미 인터페이스에서 구현된 디폴트 메서드가 **새로 생성한 클래스에서 원하는 기능이 아니라면, 하위 클래스에서 디폴트 메서드를 재정의 가능**\n\n```java\npackage chapter10.interfaceex;\n  \npublic interface Calc {\n\tdefault void description() {\n\t\tSystem.out.println(\"정수 계산기를 구현합니다.\");\n\t}\n}\n```\n\n\u003cbr\u003e  \n\n```java\npackage chapter10.interfaceex;\n\npublic class CompleteCalc extends Calculator {\n\t@Override\n\tpublic void description() {\n\t\tSystem.out.println(\"디폴트 메서드를 재정의\");\n\t}\n}\n```\n\n\u003cbr\u003e \n\n```java\npackage chapter10.interfaceex;\n\npublic class CalculatorTest {\n\tpublic static void main(String[] args) {\n\t\tCompleteCalc calc = new CompleteCalc();\n\t\tcalc.description();\n\t}\n}\n\n// 디폴트 메서드를 재정의\n```\n\n\u003cbr\u003e\n\n### 정적 메서드\n\n- 정적 메서드는 `static` 예약어를 사용하여 선언\n\n- 클래스 생성과 무관하게 사용 가능\n\n- 인터페이스 이름으로 직접 참조하여 사용\n\n- 클래스 입장에서 구현이 강제되지 않는다 !\n\n\u003cbr\u003e\n\n**Calc 인터페이스**\n\n- `total()` : 매개변수로 전달된 배열의 모든 요소 값을 더하는 정적 메서드\n\n```java\npackage chapter10.interfaceex;\n\npublic interface Calc {\n\tstatic int total(int[] arr) {\n\tint total = 0;\n\t\n\tfor (int i : arr) {\n\t\ttotal += i;\n\t}\n\t\n\treturn total;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chapter10.interfaceex;\n\npublic class CalculatorTest {\n\tpublic static void main(String[] args) {\n\t\tCompleteCalc calc = new CompleteCalc();\n\t\t  \n\t\tint[] arr = {1, 2, 3, 4, 5};\n\t\tSystem.out.println(Calc.total(arr));\n\t}\n}\n\n// 15\n```\n\n- CompleteCalc를 참조한 calc를 쓴 것이 아님\n\n- System.out.println을 보면 **Calc 인터페이스를 직접 참조**했음\n\n\u003cbr\u003e\n\n### private 메서드\n\n- 자바 9부터 인터페이스에 private 메서드 구현 가능\n\n- private 메서드는 인터페이스를 구현한 클래스에서 사용하거나 재정의 불가\n\n기존에 구현된 코드를 변경하지 않고, **인터페이스를 구현한 클래스에서 공통으로 사용하는 경우에 private 메서드로 구현하면 코드 재사용성을 높일 수 있다.**\n\n추가로, 클라이언트 프로그램에 제공할 기본 기능을 private 메서드로 구현하기도 한다.\n\n\u003cbr\u003e\n\n**private 메서드는 코드를 모두 구현**해야 하므로, **추상 메서드에 private 예약어를 사용할 수 없음**. 하지만, **static 예약어는 사용 가능**하다. **private static 메서드는 정적 메서드에서 호출하여 사용**한다.\n\n```java\npackage chapter10.interfaceex;\n\npublic interface Calc {\n\tdefault void description() {\n\t\tSystem.out.println(\"정수 계산기를 구현합니다.\");\n\t\tmyMethod();\n\t}\n\t\n\tstatic int total(int[] arr) {\n\t\tint total = 0;\n\t\t\n\t\tfor (int i : arr) {\n\t\t\ttotal += i;\n\t\t}\n\t\t\n\t\tmyStaticMethod();\n\t\treturn total;\n\t}\n\t\n\tprivate void myMethod() {\n\t\tSystem.out.println(\"private 메서드입니다.\");\n\t}\n\t\n\tprivate static void myStaticMethod() {\n\t\tSystem.out.println(\"private static 메서드입니다.\");\n\t}\n}\n```\n\n- 디폴트 메서드에서 private 메서드 호출\n\n- 정적 메서드에서 private static 메서드 호출\n\n\u003chr\u003e\n\n## 인터페이스 활용\n\n### 한 클래스가 여러 인터페이스를 구현하는 경우\n\n- 한 클래스가 여러 클래스를 상속받으면, 호출이 모호해져서 자바에서는 다중 상속을 막았었음\n\n- 하지만, 인터페이스는 한 클래스가 여러 인터페이스 구현 가능\n\n![](brain/image/chap10-4.png)\n\n**한 클래스에서 인터페이스 여러 개 구현 가능한 이유**\n\n- 인터페이스는 구현 코드나 멤버 변수를 가지지 않음\n\n- 따라서 여러 개 동시에 구현 가능\n\n- 두 인터페이스에 이름이 같은 메서드가 선언되었다고 해도 **구현은 클래스에서 이루어지니까, 어떤 메서드를 호출해야 하는지 모호하지 않은 것!**\n\n- Diamond problem(다이아몬드 문제) 발생 안함!\n\n\u003cbr\u003e\n\n**Buy 인터페이스**\n\n```java\npackage interfaceex;\n\npublic interface Buy {\n\tvoid buy();\n}\n```\n\n\u003cbr\u003e  \n\n**Sell 인터페이스**\n\n```java\npackage interfaceex;\n\npublic interface Sell {\n\tvoid sell();\n}\n```\n\n\u003cbr\u003e  \n\n**Customer 클래스**\n\n```java\npackage chapter10.interfaceex;\n\npublic class Customer implements Buy, Sell {\n\t@Override\n\tpublic void sell() {\n\t\tSystem.out.println(\"판매하기\");\n\t} \n\t\n\t@Override\n\tpublic void buy() {\n\t\tSystem.out.println(\"구매하기\");\n\t}\n}\n```\n\n\u003cbr\u003e  \n\n**CustomerTest 클래스**\n\n```java\npackage chapter10.interfaceex;\n\npublic class CustomerTest {\n\tpublic static void main(String[] args) {\n\t\tCustomer customer = new Customer();\n\t\t\n\t\tBuy buyer = customer;\n\t\tbuyer.buy();\n\t\t\n\t\tSell seller = customer;\n\t\tseller.sell();\n\t\t\n\t\tif (seller instanceof Customer) {\n\t\t\tCustomer customer2 = (Customer) seller;\n\t\t\tcustomer2.buy();\n\t\t\tcustomer2.sell();\n\t\t}\n\t}\n}\n\n// 구매하기\n// 판매하기\n// 구매하기\n// 판매하기\n```\n\n- 두 인터페이스를 구현한 Customer 클래스는 Buy형이자, Sell형\n\n- `Buy buyer = customer;`는 customer를 Buy 인터페이스형 변수에 대입하여 형 변환 일어남. 따라서, Buy 인터페이스에 선언한 메서드만 호출 가능\n\n- 상속에서처럼 원래의 인스턴스 자료형으로 다운 캐스팅 하려면 **instanceof** 사용\n\n\u003cbr\u003e\n\n### 두 인터페이스의 정적 메서드가 중복되는 경우\n\n- 정적 메서드는 인스턴스 생성과 상관없이 사용 가능\n\n- Buy 인터페이스, Sell 인터페이스 각각에 `pay()` 정적 메서드가 있다고 가정\n\n- 인스턴스 생성 없이 `Buy.pay()`, `Sell.pay()`와 같이 특정해서 호출하기 때문에 정적 메서드는 중복되어도 상관없음\n\n\u003cbr\u003e\n\n### 두 인터페이스의 디폴트 메서드가 중복되는 경우\n\n- 디폴트 메서드는 인스턴스를 생성해야 호출할 수 있는 메서드\n\n- 이름이 같은 디폴트 메서드가 두 인터페이스에 있으면 문제가 됨\n\n- Diamond problem(다이아몬드 문제) 발생!\n\n\u003cbr\u003e\n\n**Buy 인터페이스**\n\n```java\npackage interfaceex;\n\npublic interface Buy {\n\tvoid buy();\n\t\n\tdefault void order() {\n\t\tSystem.out.println(\"구매 주문\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**Sell 인터페이스**\n\n```java\npackage interfaceex;\n\npublic interface Sell {\n\tvoid sell();\n\t\n\tdefault void order() {\n\t\tSystem.out.println(\"판매 주문\");\n\t}\n}\n```\n\n- Buy, Sell 인터페이스 중 `어떤 디폴트 메서드 order()`를 불러올 지 모호해진다.\n\n- 따라서, 이를 구현한 Customer 클래스에서 `order()`를 재정의하면 재정의된 메서드가 호출되어서 문제가 해결된다.\n\n\u003cbr\u003e  \n\n```java\npackage interfaceex;\n\npublic class Customer implements Buy, Sell {\n\tpublic void order() {\n\t\tSystem.out.println(\"고객 판매 주문\");\n\t}\n}\n```\n\n\u003cbr\u003e  \n\n```java\npackage chapter10.interfaceex;\n\npublic class CustomerTest {\n\tpublic static void main(String[] args) {\n\t\tCustomer customer = new Customer();\n\t\t\n\t\tBuy buyer = customer;\n\t\tbuyer.buy();\n\t\tbuyer.order();\n\t\t\n\t\tSell seller = customer;\n\t\tseller.sell();\n\t\tseller.order();\n\t\t  \n\t\tif (seller instanceof Customer) {\n\t\t\tCustomer customer2 = (Customer) seller;\n\t\t\tcustomer2.buy();\n\t\t\tcustomer2.sell();\n\t\t}\n\t\tcustomer.order();\n\t}\n}\n\n// 구매하기\n// 고객 판매 주문\n// 판매하기\n// 고객 판매 주문\n// 구매하기\n// 판매하기\n// 고객 판매 주문\n```\n\n- `buyer.order()` 혹은 `seller.order()`를 해도 Customer 클래스에 재정의된 메서드가 호출된다. \u003ca href='/brain/Book/do-it-java/chap08/'\u003e상속과 다형성\u003c/a\u003e에서 배웠던 **가상 메서드** 원리 안까먹었지!?\n\n\u003cbr\u003e\n\n### 인터페이스 상속하기\n\n- 인터페이스 간에도 상속 가능\n\n- 인터페이스 간 상속은 구현 코드를 통해 **기능을 상속하는 것이 아니**므로, **형 상속(type inheritance)** 라고 부른다.\n\n- 클래스의 경우 - 하나의 클래스만 상속\n\n- 인터페이스의 경우 - 여러 인터페이스 동시에 상속 가능\n\n- **상속받은 인터페이스는 상위 인터페이스에 선언한 추상 메서드 모두 가지게 됨**\n\n\u003cbr\u003e\n\n![](brain/image/chap10-5.png)\n\n- Myinterface 인터페이스는 X, Y 인터페이스 상속 받음\n\n- MyClass는 MyInterface 인터페이스를 구현\n\n- MyClass가 구현애햐 하는 추상 메서드는 총 3개\n\n\u003cbr\u003e\n\n**X 인터페이스**\n\n```java\npackage chapter10.interfaceex;\n\npublic interface X {\n\tvoid x();\n}\n```\n\n\u003cbr\u003e\n\n**Y 인터페이스**\n\n```java\npackage chapter10.interfaceex;\n\npublic interface Y {\n\tvoid y();\n}\n```\n\n\u003cbr\u003e\n\n**MyInterface 인터페이스**\n\n```java\npackage chapter10.interfaceex;\n\npublic interface MyInterface extends X, Y {\n\tvoid myMethod();\n}\n```\n\n\u003cbr\u003e\n\n**MyClass 클래스**\n\n```java\npackage chapter10.interfaceex;\n\npublic class MyClass implements MyInterface {\n\t@Override\n\tpublic void x() {\n\t\tSystem.out.println(\"x()\");\n\t}\n\t\n\t@Override\n\tpublic void y() {\n\t\tSystem.out.println(\"y()\");\n\t}\n\t\n\t@Override\n\tpublic void myMethod() {\n\t\tSystem.out.println(\"myMethod()\");\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**MyClassTest 클래스**\n \n```java\npackage chapter10.interfaceex;\n\npublic class MyClassTest {\n\tpublic static void main(String[] args) {\n\t\tMyClass mClass = new MyClass();\n\t\t\n\t\tX xClass = mClass;\n\t\txClass.x();\n\t\t\n\t\tY yClass = mClass;\n\t\tyClass.y();\n\t\t\n\t\tMyInterface iClass = mClass;\n\t\tiClass.myMethod();\n\t\tiClass.x();\n\t\tiClass.y();\n\t}\n}\n\n// x()\n// y()\n// myMethod()\n// x()\n// y()\n```\n\n- 생성한 클래스는 상위 인터페이스형으로 변환 가능\n\n- 상위 인터페이스로 형 변환 하면 **상위 인터페이스에 선언한 메서드만 호출 가능**\n\n\u003cbr\u003e\u003cbr\u003e\n\n**최종 정리**\n\n- 인터페이스 간 상속은, **인터페이스를 정의할 때 기능상 계층 구조가 필요한 경우에 상속을 사용하기도 함**\n\n\u003cbr\u003e\n\n### 인터페이스 구현과 클래스 상속 함께 쓰기\n\n- 한 클래스에서 클래스 상속, 인터페이스 구현 모두 가능\n\n![](brain/image/chap10-6.png)\n\n\u003cbr\u003e\n\n**Shelf 클래스**\n\n```java\npackage chapter10.bookshelf;\nimport java.util.ArrayList;\n\npublic class Shelf {\n\tprotected ArrayList\u003cString\u003e shelf;\n\t\n\tpublic Shelf() {\n\t\tshelf = new ArrayList\u003cString\u003e();\n\t}\n\t\n\tpublic ArrayList\u003cString\u003e getShelf() {\n\t\treturn shelf;\n\t}\n\t\n\tpublic int getCount() {\n\t\treturn shelf.size();\n\t}\n}\n```\n\n- 자료를 순서대로 저장할 배열 객체 선언 (이름을 저장하게 자료형은 String)\n\n- 디폴트 생성자로 Shelf 클래스 생성 시 ArrayList 생성\n\n\u003cbr\u003e\n\n**Queue 인터페이스**\n\n```java\npackage chapter10.bookshelf;\n\npublic interface Queue {\n\tvoid enQueue(String title); // 배열의 맨 마지막에 추가\n\tString deQueue(); // 배열의 맨 처음 항목 반환\n\tint getSize(); // 현재 Queue에 있는 개수 반환\n}\n```\n\n![](brain/image/chap10-7.png)\n\n\u003cbr\u003e\n\n**BookShelf 클래스**\n\n```java\npackage chapter10.bookshelf;\n\npublic class BookShelf extends Shelf implements Queue {\n\t@Override\n\tpublic void enQueue(String title) {\n\t\tshelf.add(title);\n\t}\n\t\n\t@Override\n\tpublic String deQueue() {\n\t\treturn shelf.remove(0);\n\t}\n\t\n\t@Override\n\tpublic int getSize() {\n\t\treturn getCount();\n\t}\n}\n```\n\n- `enQueue()` : 배열에 요소 추가\n\n- `deQueue()` : 맨 처음 요소 배열에서 삭제하고 반환\n\n- `getSize()` : 배열 요소 개수 반환\n\n\u003cbr\u003e\n\n**BookShelfTest 클래스**\n\n```java\npackage chapter10.bookshelf;\n\npublic class BookShelfTest {\n\tpublic static void main(String[] args) {\n\t\tQueue shelfQueue = new BookShelf();\n\t\tshelfQueue.enQueue(\"태백산맥 1\");\n\t\tshelfQueue.enQueue(\"태백산맥 2\");\n\t\tshelfQueue.enQueue(\"태백산맥 3\");\n\t\t  \n\t\tSystem.out.println(shelfQueue.deQueue());\n\t\tSystem.out.println(shelfQueue.deQueue());\n\t\tSystem.out.println(shelfQueue.deQueue());\n\t}\n}\n\n// 태백산맥 1\n// 태백산맥 2\n// 태백산맥 3\n```\n\n\u003cbr\u003e\n\n### 실무에서 인터페이스를 사용하는 경우\n\n- 인터페이스는 클래스가 제공할 기능을 선언하고 설계하는 것\n\n- 여러 클래스가 같은 메서드를 서로 다르게 구현하는 경우\n\n- 우선, 인터페이스에 메서드 선언\n\n- 다음, 인터페이스를 구현한 각 클래스에서 같은 메서드에 대해 다양한 기능 구현\n\n- 이것이 인터페이스를 이용한 다형성의 구현\n\n\u003cbr\u003e\n\n예를 들어, SI 회사에서 시스템 개발했음. 이 시스템이 자료 저장할 때 DB 사용하는데 회사마다 MySQL, 오라클 DB, MS-SQL 이런식으로 DB가 제각각이라고 하자. 단, 웹 페이지나 모바일 페이지는 DB와 관계없이 수행 된다.\n\n이런 경우 **데이터베이스 기능을 수행할 인터페이스를 정의**. 그리고 인터페이스 정의에 맞게 여러 데이터베이스 관련 모듈을 개발하면 됨.\n\n\u003cbr\u003e\n\n![](brain/image/chap10-8.png)\n\n- 사용자 정보를 DB에 입력, 업데이트, 삭제하는 기능을 UserInfoDao 인터페이스에서 정의\n\n- 여러 DB에 맞게 구현하는 것은 각 클래스가 담당\n\n\u003cbr\u003e\n\n**JDBC와 인터페이스**\n\n- JDBC는 Java DataBase Connectivity\n\n- 자바와 데이터베이스를 연결해 주는 역할\n\n- 자바와 데이터베이스를 연결하려면 여러 기능 수행해야함. 그 중 대표적인 것이 **Connection을 생성하고 연결**하는 것\n\n- 자바에서 DB를 어떻게 사용할 것인지를 기술한 명세, 즉, 약속\n\n\u003cbr\u003e\n\n**Connection** : 자바와 DB를 연결하기 위해 사용하는 인터페이스\n\n- 여기에 여러 메서드들이 미리 구현되어 있음","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/do-it-java/do-it-java":{"title":"Do it! 자바 프로그래밍 입문","content":"\n\u003cbr\u003e\n\n\u003e [!note] Do it! 자바 프로그래밍 입문 필기노트\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2022.10.25 ~ 2022.11.03\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e Java에 대한 기초 지식 확보\n\n\u003cbr\u003e\n\n\u003cimg class=\"book\" src=\"http://image.yes24.com/goods/62281686/XL\"\u003e\n\n## 목차\n\n- [Chapter01 - 자바 프로그래밍](brain/Book/do-it-java/chap01)\n- [Chapter02 - 변수와 자료형](brain/Book/do-it-java/chap02)\n- [Chapter03 - 여러가지 연산자](brain/Book/do-it-java/chap03)\n- [Chapter04 - 제어문](brain/Book/do-it-java/chap04)\n- [Chapter05 - 클래스와 객체 (1)](brain/Book/do-it-java/chap05)\n- [Chapter06 - 클래스와 객체 (2)](brain/Book/do-it-java/chap06)\n- [Chapter07 - 배열과 ArrayList](brain/Book/do-it-java/chap07)\n- [Chapter08 - 상속과 다형성](brain/Book/do-it-java/chap08)\n- [Chapter09 - 추상클래스](brain/Book/do-it-java/chap09)\n- [Chapter10 - 인터페이스](brain/Book/do-it-java/chap10)\n\n\n","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/headfirst/":{"title":"헤드퍼스트 디자인패턴","content":"","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/headfirst/chap01":{"title":"01. 소개와 전략패턴","content":"","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/Book/headfirst/headfirst":{"title":"헤드퍼스트 디자인패턴","content":"\n\u003cbr\u003e\n\n\u003e [!note] 헤드퍼스트 디자인패턴 필기노트\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2023.06.05 ~ 진행중\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e 23가지 디자인패턴 파악하기\n\n\u003cbr\u003e\n\n\u003cimg class=\"book\" src=\"https://image.yes24.com/goods/108192370/XL\"\u003e\n\n\u003cbr\u003e\n\n## 목차\n\n- [Chapter01 - 디자인 패턴 소개와 전략 패턴](brain/Book/headfirst/chap01)","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/CS/":{"title":"Computer Science","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/":{"title":"Algorithm","content":"","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/CS/Algo/principle/":{"title":"Principle","content":"","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/CS/Algo/principle/binarySearch":{"title":"이진 탐색","content":"\n\u003chr\u003e\n\n### 이진탐색 개념\n\n==**이진 탐색 (이분 탐색, Binary Search) : 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 탐색 알고리즘**==\n- 배열 내부의 데이터가 정렬되어있어야 사용 가능\n- [분할 정복](brain/CS/Algo/principle/divideConquer) 알고리즘을 사용한 예시\n- ==**시간복잡도 : $O(\\log n)$**==\n\t- **최선** : $O(1)$ (찾고자 하는걸 바로 찾을 때), **평균** : $O(\\log n)$, **최악** : $O(\\log n)$\n\t- 이렇게 ==**1번 처리할 때마다 검색해야하는 데이터의 양이 절반씩 떨어지는 알고리즘을 $O(\\log n)$ 알고리즘이라고 함**==\n\t\t- $\\log n$은 굉장히 작아서 상수에 거의 근접하다고 보면됨\n\t\t- ex) N이 10,000,000이면 $\\log 10000000 = 23.253\\dots$\n\n![](brain/image/binarySearch-2.png)\n\n- 매번 실행할 때마다 $\\frac {1} {2}$씩 크기가 줄어든다. 몇 번 만에 크기가 1이 될까? 입력 크기가 N이라고 하자.\n\n$$\nN * \\left( \\frac{1}{2} \\right)^k = \\frac {N} {2^k} = 1\n$$\n\n$$\n2^k = N \\Rightarrow \\log_2 2^k = \\log_2 N\n$$\n\n$$\n\\therefore k = log N\n$$\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 이진탐색 - 단순 반복\n\n\u003cbr\u003e\n\n```java\npublic class BinarySearch {  \n    private static int binarySearch(int[] arr, int key, int start, int end) {  \n        int mid;  \n  \n        while (start \u003c= end) {  \n            mid = (start + end) / 2;  \n            // 탐색 성공  \n            if (key == arr[mid]) {  \n                return mid;  \n            }  \n            // key 보다 작은 부분 탐색 start ~ mid -1            \n            else if (key \u003c arr[mid]) {  \n                end = mid - 1;  \n            }  \n            // key 보다 큰 부분 탐색 mid + 1 ~ end            \n            else {  \n                start = mid + 1;  \n            }  \n        }  \n  \n        // 탐색 실패  \n        return -1;  \n    }  \n  \n    public static void main(String[] args) {  \n        int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  \n        System.out.println(binarySearch(arr, 3, 0, arr.length - 1));  \n    }  \n}\n\n// key가 위치한 인덱스 반환, 없으면 -1 반환\n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 이진탐색 - 재귀 구현\n\n\u003cbr\u003e\n\n```java {title=\"BinarySearch.java\"}\npublic class BinarySearch {  \n    private static int binarySearch(int[] arr, int key, int start, int end) {  \n        // 탐색 실패  \n        if (start \u003e end)  \n            return -1;  \n          \n        int mid = (start + end) / 2;  \n  \n        // 탐색 성공  \n        if (key == arr[mid]) {  \n            return mid;  \n        }  \n        // key 보다 작은 부분 탐색 start ~ mid -1        \n        else if (key \u003c arr[mid]) {  \n            return binarySearch(arr, key, start, mid - 1);  \n        }  \n        // key 보다 큰 부분 탐색 mid + 1 ~ end        \n        else  \n            return binarySearch(arr, key, mid + 1, end);  \n    }  \n  \n    public static void main(String[] args) {  \n        int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  \n        System.out.println(binarySearch(arr, 3, 0, arr.length - 1));  \n    }  \n}\n\n// key가 위치한 인덱스 반환, 없으면 -1 반환\n```\n\n\u003chr\u003e\n\n### 참고\n\n- \u003ca href='https://www.youtube.com/watch?v=tTFoClBZutw\u0026list=PLcXyemr8ZeoQGXwikaiVxhdYRpQU4ojCu' target='_blank'\u003e쉬운코드님의 시간복잡도 강의\u003c/a\u003e\n","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/CS/Algo/principle/divideConquer":{"title":"분할 정복","content":"\n\u003chr\u003e\n\n### 분할정복 개념\n\n![](brain/image/divideConquer-1.png)\n\n==**분할정복 (divide and conquer) : 여러 알고리즘의 기본이 되는 해결방법으로, 크고 방대한 문제를 조금씩 나눠가면서 풀기 쉬운 문제 단위로 만들어서 해결하고, 이후 다시 합쳐서 해결하는 개념**==\n- 문제 해결 전략 중 하나\n\t- 어떤 문제를 유사한 형태를 가지는 더 작은 크기의 서브 문제들로 나눈 후 이들을 **재귀적**으로 같은 방식으로 해결한 뒤, 각 서브 문제들을 해결한 결과를 활용하여 원래 문제를 해결하는 방식\n- 대표적인 예시 [합병정렬](brain/CS/Algo/sort/comparison/mergeSort), [퀵정렬](brain/CS/Algo/sort/comparison/quickSort), [이진탐색](brain/CS/Algo/principle/binarySearch)\n\t- 분할정복을 이해하기 좋은 예시는 합병정렬이다.\n\n\u003cbr\u003e\n\n| 개념               | divide and conquer                                                                       |\n| ------------------ | ---------------------------------------------------------------------------------------- |\n| **divide (분할)**  | 문제를 작은 크기의 서브 문제들로 나눔                                                    |\n| **conquer (정복)** | 서브 문제들을 동일하게 재귀적인 방식으로 해결 \u003cbr\u003e 만약 더 이상 나눌 수 없으면 직접 해결 |\n| **combine (조합)** | 서브 문제들의 솔루션을 합쳐서 원래(original) 문제의 답을 만듬                                                                                         |\n\n\u003cbr\u003e\n\n\n\n### 참고\n\n- \u003ca href='https://www.youtube.com/watch?v=aj3vw_KDmxc\u0026t=2s' target='_blank'\u003e쉬운코드님의 divide and conquer 강의\u003c/a\u003e","lastmodified":"2024-12-05T16:13:38.246758455Z","tags":null},"/brain/CS/Algo/sort/":{"title":"Sorting","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/comparison/":{"title":"Comparison","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/comparison/bubbleSort":{"title":"버블 정렬","content":"\n\u003chr\u003e\n\n### 버블정렬 개념\n\n==**버블정렬 (Bubble Sort) : 앞에서부터 2개씩 서로 인접한 원소와 비교하여, 조건에 맞지 않다면 자리를 교환하여 정렬하는 알고리즘**==\n- 오름차순을 예시로, 2개씩 비교하면서 앞에가 작으면 넘어가고 앞에가 뒤에보다 크면 자리교환\n- ==**시간복잡도 : $O(n^2)$**==\n\t- **최선** : $O(n)$ (이미 정렬된 경우 + 최적화), **평균** : $O(n^2)$, **최악** : $O(n^2)$\n\t- 외부 루프를 n-1번 도는 동안, n-1, n-2, ... , 1번 인접한 원소를 비교\n\t- $T(n) = (n-1) + (n-2) + ... + 1 = (n-1) * \\frac{n}{2}$\n- ==**공간복잡도 : $O(1)$**==\n\t- 교환(swap)을 통해 정렬이 수행되므로, 추가적인 배열 공간 필요없음\n- ==**안정성\u0026제자리성 : 안정정렬(Stable-sort), 제자리 정렬(In-place sort)**==\n\t- 동일한 값을 지니는 경우, 원소들의 본래 순서가 유지됨 → 안정\n\t- 기존 배열 이외의 추가적인 메모리를 거의 사용하지 않고 배열 안에서 교환 → 제자리\n\n\u003cbr\u003e\n\n![](brain/image/gif/bubbleSort.gif)\n\n\u003cbr\u003e\u003chr\u003e\n\n### 버블정렬 - 단순 반복\n\n\u003cbr\u003e\n\n```java {title=\"Bubble.java\"}\nimport java.util.Arrays;  \n  \npublic class Bubble {  \n    private static void bubbleSort(int[] arr) {  \n        for (int i = 0; i \u003c arr.length; i++) {  \n            for (int j = 1; j \u003c arr.length; j++) {\n                if (arr[j - 1] \u003e arr[j]) {  \n                    int temp = arr[j - 1];  \n                    arr[j - 1] = arr[j];  \n                    arr[j] = temp;  \n                }  \n            }  \n        }  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {3, 5, 4, 2, 1};  \n        System.out.println(\"Before Sorting: \" + Arrays.toString(arr));  \n        bubbleSort(arr);  \n        System.out.println(\"After Sorting: \" + Arrays.toString(arr));  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n**swap을 메서드로 추출한 방식**\n\n```java {title=\"Bubble.java\"}\nimport java.util.Arrays;  \n  \npublic class Bubble {  \n    private static void bubbleSort(int[] arr) {  \n        for (int i = 0; i \u003c arr.length; i++) {  \n            for (int j = 1; j \u003c arr.length; j++) {  \n                if (arr[j - 1] \u003e arr[j]) {  \n                    swap(arr, j - 1, j);  \n                }  \n            }  \n        }  \n    }  \n  \n    private static void swap(int[] arr, int preIndex, int currentIndex) {  \n        int temp = arr[preIndex];  \n        arr[preIndex] = arr[currentIndex];  \n        arr[currentIndex] = temp;  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {3, 5, 4, 2, 1};  \n        System.out.println(\"Before Sorting: \" + Arrays.toString(arr));  \n        bubbleSort(arr);  \n        System.out.println(\"After Sorting: \" + Arrays.toString(arr));  \n    }  \n}\n```\n\n\u003cbr\u003e\u003chr\u003e\n\n### 버블정렬 - 최적화 반복\n\n\u003cbr\u003e\n\n```java {title=\"Bubble.java\"}\nimport java.util.Arrays;  \n  \npublic class Bubble {  \n    private static void bubbleSort(int[] arr) {  \n        // 제외될 원소의 개수 의미, 맨 마지막은 정렬된 상태니까  \n        for (int i = 0; i \u003c arr.length; i++) {  \n            boolean swapped = false;  \n            // j는 현재 원소, j-1은 이전 원소  \n            for (int j = 1; j \u003c arr.length - i; j++) {  \n                if (arr[j - 1] \u003e arr[j]) {  \n                    swap(arr, j - 1, j);  \n                    swapped = true;  \n                }  \n            }  \n            if (!swapped)  \n                break;  \n        }  \n    }  \n  \n    private static void swap(int[] arr, int preIndex, int currentIndex) {  \n        int temp = arr[preIndex];  \n        arr[preIndex] = arr[currentIndex];  \n        arr[currentIndex] = temp;  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {3, 5, 4, 2, 1};  \n        System.out.println(Arrays.toString(arr));  \n        bubbleSort(arr);  \n        System.out.println(Arrays.toString(arr));  \n    }  \n}\n```\n\n- swap이 발생하여 정렬이 되었는지 확인하는 불리안 변수 추가\n\t- 앞에서 swap이 발생하지 않았다면 정렬되었다고 간주 가능하여, break 하면됨\n- 비교하는 인덱스 `j`를 `arr.length - i` 까지로 변경\n\t- 맨 마지막은 정렬 된거니까 빼주는거임\n\n\u003cbr\u003e\u003chr\u003e\n\n### 버블정렬 - 재귀 구현\n\n\u003cbr\u003e\n\n```java\nimport java.util.Arrays;  \n  \npublic class Bubble {  \n    private static void bubbleSort(int[] arr) {  \n        // 배열의 주소, 배열에서 정렬이 되지 않은 부분의 마지막 인덱스  \n        // 처음에는 모든 배열의 방이 정렬 안된 상태니까 마지막 인덱스 줬음  \n        bubbleSort(arr, arr.length - 1);  \n    }  \n  \n    private static void bubbleSort(int[] arr, int last) {  \n        // 마지막 인덱스가 0보다 클때까지 재귀호출  \n        if (last \u003e 0) {  \n            for (int i = 1; i \u003c= last; i++) {  \n                // 내 앞에 있는 애가 나보다 큰가?  \n                if (arr[i - 1] \u003e arr[i]) {  \n                    // 크면 자리 바꾸기  \n                    swap(arr, i - 1, i);  \n                }  \n            }  \n            // 맨 마지막은 정렬 됐으니까 빼고 다시 버블정렬  \n            bubbleSort(arr, last - 1);  \n        }  \n    }  \n  \n    private static void swap(int[] arr, int preIndex, int currentIndex) {  \n        int temp = arr[preIndex];  \n        arr[preIndex] = arr[currentIndex];  \n        arr[currentIndex] = temp;  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {3, 5, 4, 2, 1};  \n        System.out.println(\"Before Sorting: \" + Arrays.toString(arr));  \n        bubbleSort(arr);  \n        System.out.println(\"After Sorting: \" + Arrays.toString(arr));  \n    }  \n}\n```\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/comparison/heapSort":{"title":"힙 정렬","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/comparison/insertSort":{"title":"삽입 정렬","content":"\n\u003chr\u003e\n\n### 삽입정렬 개념\n\n==**삽입정렬 (Insertion Sort) : 새로운 원소를 이전까지 정렬된 원소 사이에 올바르게 삽입시키는 알고리즘**==\n- 0번째 인덱스는 앞에 숫자가 없어서 정렬의 시작은 1번째 인덱스임\n\t- 1번째 인덱스부터 시작해서 앞의 원소들과 비교하며 삽입할 위치를 지정하고, 원소를 한칸씩 뒤로 다 땡기고 지정된 자리에 삽입하는 알고리즘\n\t- 들어갈 위치가 있는 것으로 보아 선택정렬과 유사해보이지만, 더 효율적임\n\t- \u003ca href='https://www.acmicpc.net/problem/10431' target='_blank'\u003e백준 줄세우기\u003c/a\u003e 문제가 삽입정렬임\n- ==**시간복잡도 : $O(n^2)$**==\n\t- **최선** : $O(n)$ (이미 정렬된 경우 + 최적화), **평균** : $O(n^2)$, **최악** :  $O(n^2)$\n\t- 외부 루프를 n-1번 도는 동안, 각 자리에 와야하는 값을 구하기 위해 n-1, n-2, ... , 1번 비교\n\t- $T(n) = (n-1) + (n-2) + ... + 1 = (n-1) * \\frac{n}{2}$\n- ==**공간복잡도 : $O(1)$**==\n\t- 교환(swap)을 통해 정렬이 수행되므로, 추가적인 배열 공간 필요없음\n\t- 만약, 새로운 배열을 만들어서 거기 삽입하면, 그때는 공간복잡도 $O(n)$\n- ==**안정성\u0026제자리성 : 안정 정렬(Stable-sort), 제자리 정렬(In-place sort)**==\n\t- 비교대상의 원소가 새로운 원소보다 클 때만 한자리 뒤로 이동시키니까 당연히 처음 순서가 유지되니까 → 안정\n\t- 기존 배열 이외의 추가적인 메모리를 거의 사용하지 않고 배열 안에서 교환 → 제자리\n\n\u003cbr\u003e\n\n![](brain/image/gif/insertionSort.gif)\n\u003cbr\u003e\u003chr\u003e\n\n### 삽입정렬 - 단순 반복\n\n\u003cbr\u003e\n\n```java {title=\"Insertion.java\"}\nimport java.util.Arrays;  \n  \npublic class Insertion {  \n    private static void insertionSort(int[] arr) {  \n        // 0번 인덱스는 앞에 숫자가 없으니까 1번 인덱스부터 시작  \n        for (int i = 1; i \u003c arr.length; i++) {  \n            // 뒤에서부터 동작하는 이유는, 앞에서부터 값을 땡기면  \n            // 그 값만 뒤로 복사돼서 그럼  \n            for (int j = i - 1; j \u003e= 0; j--) {  \n                if (arr[j] \u003e arr[j + 1])  \n                    swap(arr, j, j + 1);  \n            }  \n        }  \n    }  \n  \n    private static void swap(int[] arr, int preIndex, int currentIndex) {  \n        int temp = arr[preIndex];  \n        arr[preIndex] = arr[currentIndex];  \n        arr[currentIndex] = temp;  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {3, 2, 1, 8, 4, 5, 7, 12, 3};  \n        System.out.println(\"Before Sorting: \" + Arrays.toString(arr));  \n        insertionSort(arr);  \n        System.out.println(\"After Sorting: \" + Arrays.toString(arr));  \n    }  \n}\n```\n\n\u003cbr\u003e\u003chr\u003e\n\n### 삽입정렬 - 최적화 반복1\n\n\u003cbr\u003e\n\n```java {title=\"Insertion.java\"}\nimport java.util.Arrays;  \n  \npublic class Insertion {  \n    private static void insertionSort(int[] arr) {  \n        for (int i = 1; i \u003c arr.length; i++) {  \n            int j = i - 1;  \n            // while 안에다가 비교 작업을 넣어버렸음  \n            while (j \u003e= 0 \u0026\u0026 arr[j] \u003e arr[j + 1]) {  \n                swap(arr, j, j + 1);  \n                j--;  \n            }  \n        }  \n    }  \n  \n    private static void swap(int[] arr, int preIndex, int currentIndex) {  \n        int temp = arr[preIndex];  \n        arr[preIndex] = arr[currentIndex];  \n        arr[currentIndex] = temp;  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {3, 2, 1, 8, 4, 5, 7, 12, 3};  \n        System.out.println(\"Before Sorting: \" + Arrays.toString(arr));  \n        insertionSort(arr);  \n        System.out.println(\"After Sorting: \" + Arrays.toString(arr));  \n    }  \n}\n```\n\n- while문을 만들면서 안에다가 비교작업을 넣은 이유\n\t- 삽입될 숫자보다 작은 숫자들은 이미 정렬 해놓았기 때문에 비교가 무의미해서\n\t- 예를 들어, `[1, 2, 3, 5]`가 있고 4를 추가하는 상황이면 3이 4보다 작다는 사실만 파악하면 됨. 이 이상의 대소 비교는 무의미\n\n\u003cbr\u003e\u003chr\u003e\n\n### 삽입정렬 - 최적화 반복2\n\n\u003cbr\u003e\n\n```java {title=\"Insertion.java\"}\nimport java.util.Arrays;  \n  \npublic class Insertion {  \n    private static void insertionSort(int[] arr) {  \n        for (int i = 1; i \u003c arr.length; i++) {  \n            int current = arr[i];  \n            int j = i - 1;  \n            while (j \u003e= 0 \u0026\u0026 arr[j] \u003e current) {  \n                arr[j + 1] = arr[j];  \n                j--;  \n            }  \n            arr[j + 1] = current;  \n        }  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {3, 2, 1, 8, 4, 5, 7, 12, 3};  \n        System.out.println(\"Before Sorting: \" + Arrays.toString(arr));  \n        insertionSort(arr);  \n        System.out.println(\"After Sorting: \" + Arrays.toString(arr));  \n    }  \n}\n```\n\n- 사실 swap 작업도 필요 없음\n- 앞의 값이 정렬 범위에 추가시킨 값보다 크면 앞의 값을 뒤로 밀고 제일 작은거 만나는 순간 그 뒤에 추가된 값을 꽂으면 됨\n\n\n\u003cbr\u003e\u003chr\u003e\n\n### 삽입정렬 - 재귀 구현\n\n\u003cbr\u003e\n\n```java {title=\"Insertion.java\"}\nimport java.util.Arrays;  \n  \npublic class Insertion {  \n    private static void insertionSort(int[] arr) {  \n        // 0번 인덱스는 앞에 숫자가 없으니까 1번 인덱스부터 시작  \n        insertionSort(arr, 1);  \n    }  \n  \n    private static void insertionSort(int[] arr, int start) {  \n        // 배열의 마지막 방까지 재귀호출  \n        if (start \u003c arr.length) {  \n            // 현재 숫자는 1부터 시작  \n            int currentNum = arr[start];  \n            // 삽입할 곳의 인덱스는 0부터 시작하니까 start - 1            \n            int targetIndex = start - 1;  \n  \n            // 현재 숫자를 비교 대상들과 비교하여 삽입할 위치 찾기  \n            // 뒤에서부터 동작하는 이유는, 앞에서부터 값을 땡기면 그 값만 뒤로 복사돼서 그럼  \n            while (targetIndex \u003e= 0 \u0026\u0026 currentNum \u003c arr[targetIndex]) {  \n                // 더 큰 값들을 오른쪽으로 이동  \n                arr[targetIndex + 1] = arr[targetIndex];  \n                targetIndex--;  \n            }  \n  \n            // 현재 숫자를 삽입할 위치에 삽입  \n            arr[targetIndex + 1] = currentNum;  \n            // 다음 원소에 대해 재귀적으로 정렬 수행  \n            insertionSort(arr, start + 1);  \n        }  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {3, 2, 1, 8, 4, 5, 7, 12, 3};  \n        System.out.println(\"Before Sorting: \" + Arrays.toString(arr));  \n        insertionSort(arr);  \n        System.out.println(\"After Sorting: \" + Arrays.toString(arr));  \n    }  \n}\n```","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/comparison/mergeSort":{"title":"합병 정렬","content":"\n\u003chr\u003e\n\n### 합병정렬 개념\n\n==**합병정렬 (Merge Sort) : 분할 정복의 일종으로, 하나의 배열을 두 개의 균등한 배열로 분할하고 재귀적인 방식으로 분할된 배열을 각각 정렬한 다음, 이를 다시 합해서 정렬을 완성하는 알고리즘**==\n- ==**시간복잡도 : $O(n \\log n)$**==\n\t- **최선** : $O(n \\log n)$, **평균** : $O(n \\log n)$, **최악** :  $O(n \\log n)$\n\t- 분할정복의 시간복잡도는 $O(\\log n)$이지만, n개의 서브 배열들로 나눠야 하니까 $O(n \\log n)$이 되는 것\n\t- 합병정렬은, pivot을 잘 선택하는 [퀵정렬](brain/CS/Algo/sort/comparison/quickSort)의 느낌이다. 최악의 경우 $O(n^2)$인 퀵정렬에 비해 합병정렬은 최악도 $O(n \\log n)$이니까.\n- ==**공간복잡도 : $O(n)$**==\n\t- 크기가 1인 n개의 서브 배열이 필요하니까\n\t- 따라서, 추가로 메모리 공간을 사용하기를 원치 않으면 **퀵정렬** 사용\n- ==**안정성\u0026제자리성 : 안정 정렬(Stable-sort), 제자리 정렬 ❌(Not-in-place sort)**==\n\t- 동일한 원소에 대하여 정렬 후 본래의 순서가 유지되니까 → 안정\n\t- 임시배열이라는 추가적인 메모리를 사용함 → 제자리 정렬 아님 ❌\n\u003cbr\u003e\n\n![](brain/image/gif/mergeSort.gif)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 합병정렬 원리\n\n\u003cbr\u003e\n\n![](brain/image/mergeSort-1.png)\n\n더 작은 크기의 서브 문제들로 나눈 후 이들을 **재귀적**으로 같은 방식으로 해결한다고 분할정복에서 언급했었다. pseudo-code를 살펴보면,\n\n```java\n// 어디부터 어디까지인지를 파라미터로 이해\nmerge_sort(nums, start_index, end_index) {\n\tif (start_index \u003c end_index) {\n\t\tmiddle_index = (start_index + end_index) / 2\n\n\t\t// 각각의 서브 문제들에 대하여 재귀 수행\n\t\tmerge_sort(nums, start_index, middle_index)\n\t\tmerge_sort(nums, middle_index + 1, end_index)\n\n\t\tmerge(nums, start_index, middle_index, end_index)\n\t}\n}\n```\n\n- 시작 인덱스와 끝 인덱스가 같은 순간은, 배열의 방이 1개이고 그 안에 값이 1개 있는 상황이니까 최대한 작은 서브 문제까지 나눈 상태 !\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 합병정렬 구현\n\n\u003cbr\u003e\n\n```java\nimport java.util.Arrays;  \n  \npublic class MergeSort {  \n    private static void mergeSort(int[] arr) {  \n        int[] temp = new int[arr.length];  \n        mergeSort(arr, temp, 0, arr.length - 1);  \n    }  \n  \n    private static void mergeSort(int[] arr, int[] temp, int start, int end) {  \n        if (start \u003c end) {  \n            int mid = (start + end) / 2;  \n            // 절반 쪼개고 배열의 앞부분  \n            mergeSort(arr, temp, start, mid);  \n            // 절반 쪼개고 배열의 뒷부분  \n            mergeSort(arr, temp, mid + 1, end);  \n            \n            // 가운데를 기준으로 왼쪽, 오른쪽이 정렬된 상태일 것이니까 이걸 합치기  \n            merge(arr, temp, start, mid, end);  \n        }  \n    }  \n  \n    private static void merge(int[] arr, int[] temp, int start, int mid, int end) {  \n        // 임시 배열에 복사해놓기  \n        for (int i = start; i \u003c= end; i++) {  \n            temp[i] = arr[i];  \n        }  \n  \n        // 2개의 배열은 mid 를 기준으로 하나로 붙어있음  \n        // 첫 번째 배열의 첫 번째 방 - part1        \n        int part1 = start;  \n        \n        // 두 번째 배열의 첫 번째 방 - part2        \n        int part2 = mid + 1;  \n        \n        // 양쪽에서 작은값을 하나씩 복사할 때마다  \n        // 결과 배열 방의 어디에 저장할 지 알아야 하니까  \n        int index = start;  \n  \n        while (part1 \u003c= mid \u0026\u0026 part2 \u003c= end) {  \n            if (temp[part1] \u003c= temp[part2]) {  \n                arr[index] = temp[part1];  \n                part1++;  \n            }  \n            else {  \n                arr[index] = temp[part2];  \n                part2++;  \n            }  \n            index++;  \n        }  \n  \n        // 앞의 배열은 남아있고, 뒤의 배열은 빈 상황  \n        for (int i = 0; i \u003c= mid - part1; i++) {  \n            arr[index + i] = temp[part1 + i];  \n        }  \n  \n        // 앞의 배열은 비었고, 뒤의 배열은 남아있을 때는 상관 안해도됨  \n        // 이미 최종 배열의 뒤쪽에 정렬된 상태로 자리잡고 있기 때문임  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {2, 13, 4, 11, 9, 8, 1, 1, 10, 5};  \n        System.out.println(\"Before Sorting : \" + Arrays.toString(arr));  \n        mergeSort(arr);  \n        System.out.println(\"After Sorting : \" + Arrays.toString(arr));  \n    }  \n}\n```","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/comparison/quickSort":{"title":"퀵 정렬","content":"\n\u003chr\u003e\n\n### 퀵정렬 개념\n\n==**퀵정렬 (Quick Sort) : 분할 정복의 일종으로, pivot(기준)을 설정하여 이를 올바른 위치로 이동시키고 나머지 원소들을 두 개의 배열로 분할하여 재귀적으로 정렬시키는 알고리즘**==\n- ==**pivot 앞에는 pivot보다 값이 작은 것, 뒤에는 pivot보다 값이 큰 것이 오도록 함**==\n\t- pivot을 선정하는 방식에 따라 속도 차이가 발생함. pivot을 선정하는 방식은 아직도 논문으로 나올만큼 정답이 없음\n\t- 그래서 보통 물리적으로 중간에 위치한 값을 pivot으로 많이 설정함\n\t- 합병정렬과 달리 배열이 불균등하게 분할된다. 운 좋으면 균등하게 될 수도 있음\n\t- `Arrays.sort()`가 내부적으로 **듀얼-피봇 퀵소트**를 사용함\n- ==**시간복잡도 : $O(n \\log n)$**==\n\t- **최선** : $O(n \\log n)$, **평균** : $O(n \\log n)$, **최악** :  $O(n^2)$\n\t- 최악때문에 오해하기 쉬운데, 퀵소트가 합병정렬보다 평균적으로 빠름\n\t- 실전에서 평균적으로 $O(n \\log n)$보다 빠름\n- ==**공간복잡도 : $O(\\log n)$**==\n\t- 재귀호출을 위한 스택프레임 공간\n\t- 최악의 경우 $O(n)$까지 갈 수도 있음. 그러나 보통은 $O(\\log n)$\n- ==**안정성\u0026제자리성 : 불안정 정렬(Unstable-sort), 제자리 정렬 (In-place sort)**==\n\t- 동일한 원소에 대하여 정렬 후 본래의 순서가 유지안됨 → 불안정\n\t- 기존 배열 이외의 추가적인 메모리를 거의 사용하지 않음 - 제자리\n\n\u003cbr\u003e\n\n**첫 번째 원소를 무조건 pivot으로 선정하는 경우**\n\n![](brain/image/gif/quickSort.gif)\n\n\u003cbr\u003e\n\n**pivot을 랜덤하게 선정하는 경우**\n\n![](brain/image/gif/randomQuickSort.gif)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 퀵정렬 시간복잡도\n\n**희망편, 평균**\n\n![](brain/image/quickSort-1.png)\n\n\u003cbr\u003e\n\n**절망편 : 하필이면 고른 pivot이 계속 최솟값이나 최댓값인 경우**\n- 확률적으로 희박함\n\n![](brain/image/quickSort-2.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 퀵정렬 파티셔닝\n\n선정한 pivot을 기준으로 작은 값을 왼쪽, 큰 값을 오른쪽으로 이동시키는 방법을 생각해보자.\n\n**퀵소트의 재귀적인 그림**\n\n![](brain/image/quickSort-4.png)\n\n1. start 인덱스는 pivot보다 작은 값을 무시하면서 +1씩\n\t- pivot보다 큰거 만나면 일단 대기\n2. end 인덱스는 pivot보다 큰 값을 무시하면서 -1씩\n\t- pivot보다 작은거 만나면 일단 대기\n3. start와 end를 서로 swap\n4. 그리고 다시 1,2,3 반복\n5. start와 end가 정한 범위를 넘어서면 루프 종료\n\n\u003cbr\u003e\n\n![](brain/image/quickSort-3.png)\n\n- 이렇게 pivot을 기준으로 작은 값, 큰 값으로 파티셔닝을 나눔\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 퀵정렬 구현\n\n\u003cbr\u003e\n\n```java\nimport java.util.Arrays;  \n  \npublic class QuickSort {  \n    private static void quickSort(int[] arr) {  \n        quickSort(arr, 0, arr.length - 1);  \n    }  \n  \n    // 파티션을 나눌 범위를 start, end 를 파라미터로 받음  \n    private static void quickSort(int[] arr, int start, int end) {  \n        // 해당 배열 방의 start ~ end 영역 안에서 파티션을 나누고  \n        // 나눈 파티션의 오른쪽 방 첫번째 값을 part2가 받아옴  \n        int part2 = partition(arr, start, end);  \n        \n        // 만약 오른쪽 파티션 part2가 시작점 start 의 바로 오른쪽에서 시작한다면  \n        // 왼쪽 파티션의 데이터가 1개인거니까 그쪽은 정렬할 필요가 없음  \n        // 그래서 오른쪽 파티션과 시작점이 1개 이상 차이가 날 때만 재귀호출 실행  \n        if (start \u003c part2 - 1) {  \n            // 왼쪽 파티션이니까 시작점 ~ 오른쪽 파티션의 시작점 바로 이전  \n            quickSort(arr, start, part2 - 1);  \n        }  \n  \n        // 오른쪽 파티션의 배열 방이 1개 이상일 때만 재귀호출 해야함  \n        // 오른쪽 파티션의 시작점인 part2가 end 보다 작을때만  \n        if (part2 \u003c end) {  \n            quickSort(arr, part2, end);  \n        }  \n    }  \n  \n    private static int partition(int[] arr, int start, int end) {  \n        int pivot = arr[(start + end) / 2];  \n        while (start \u003c= end) {  \n            // start 인덱스의 값이 pivot 보다 작으면 무시하고 1 증가, 크면 일단 대기  \n            while (arr[start] \u003c pivot) start++;  \n            // end 인덱스의 값이 pivot 보다 크면 무시하고 1 감소, 작으면 일단 대기  \n            while (arr[end] \u003e pivot) end--;  \n            if (start \u003c= end) {  \n                swap(arr, start, end);  \n                start++;  \n                end--;  \n            }  \n        }  \n        return start;  \n    }  \n  \n    private static void swap(int[] arr, int start, int end) {  \n        int temp = arr[start];  \n        arr[start] = arr[end];  \n        arr[end] = temp;  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {2, 13, 4, 11, 9, 8, 1, 1, 10, 5};  \n        System.out.println(\"Before Sorting : \" + Arrays.toString(arr));  \n        quickSort(arr);  \n        System.out.println(\"After Sorting : \" + Arrays.toString(arr));  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 참고\n\n- \u003ca href='https://www.youtube.com/watch?v=7BDzle2n47c' target='_blank'\u003e엔지니어 대한민국 퀵소트\u003c/a\u003e","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/comparison/selectSort":{"title":"선택 정렬","content":"\n\u003chr\u003e\n\n### 선택정렬 개념\n\n==**선택정렬 (Selection Sort) : 해당 순서에 원소를 넣을 위치는 이미 정해져있고, 어떤 원소를 넣을 지 선택하는 알고리즘**==\n- 오름차순을 예시로, 배열을 돌면서 작은 값 부터 차근차근 앞으로 옮기는 정렬\n\t- 따라서 배열을 돌면서 찾은 가장 작은 값을 저장할 변수를 선언해야함\n\t- 해당 자리를 선택하고 그 자리에 오는 값을 찾는 과정\n- ==**시간복잡도 : $O(n^2)$**==\n\t- **최선** : $O(n^2)$, **평균** : $O(n^2)$, **최악** :  $O(n^2)$\n\t- 외부 루프를 n-1번 도는 동안, 각 자리에 와야하는 값을 구하기 위해 n-1, n-2, ... , 1번 비교\n\t- $T(n) = (n-1) + (n-2) + ... + 1 = (n-1) * \\frac{n}{2}$\n- ==**공간복잡도 : $O(1)$**==\n\t- 교환(swap)을 통해 정렬이 수행되므로, 추가적인 배열 공간 필요없음\n- ==**안정성\u0026제자리성 : 불안정 정렬(Unstable-sort), 제자리 정렬(In-place sort)**==\n\t- 동일한 값을 지니는 경우, 원소들의 본래 순서가 무작위 → 불안정\n\t- 기존 배열 이외의 추가적인 메모리를 거의 사용하지 않고 배열 안에서 교환 → 제자리\n\n\u003cbr\u003e\n\n![](brain/image/gif/selectionSort.gif)\n\n\u003cbr\u003e\u003chr\u003e\n\n### 선택정렬 - 반복 구현\n\n\u003cbr\u003e\n\n```java {title=\"Selection.java\"}\nimport java.util.Arrays;  \n  \npublic class Selection {  \n    private static void selectionSort(int[] arr) {\n\t    // 원소를 넣은 위치를 i로 선택  \n        for (int i = 0; i \u003c arr.length - 1; i++) {  \n            int min_index = i;  \n            // i + 1부터 선택한 위치 i의 값과 비교\n            for (int j = i + 1; j \u003c arr.length; j++) {\n\t            // min으로 큰 것보다 정하면 j로 초기화  \n                if (arr[j] \u003c arr[min_index]) {  \n                    min_index = j;  \n                }  \n            }  \n            // 배열, 원소 넣을 위치, 값 제일 작은 위치\n            swap(arr, i, min_index);  \n        }  \n    }  \n  \n    private static void swap(int[] arr, int preIndex, int postIndex) {  \n        int temp = arr[preIndex];  \n        arr[preIndex] = arr[postIndex];  \n        arr[postIndex] = temp;  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {3, 2, 1, 8, 4, 5, 7};  \n        System.out.println(Arrays.toString(arr));  \n        selectionSort(arr);  \n        System.out.println(Arrays.toString(arr));  \n    }  \n}\n```\n\n\u003cbr\u003e\u003chr\u003e\n\n### 선택정렬 - 재귀 구현\n\n\u003cbr\u003e\n\n```java {title=\"Selection.java\"}\nimport java.util.Arrays;  \n  \npublic class Selection {  \n    private static void selectionSort(int[] arr) {  \n        // 배열의 주소, 배열에서 정렬이 되지 않은 부분의 시작 위치  \n        // 처음에는 모든 배열의 방이 정렬 안된 상태니까 첫번째 인덱스 줬음  \n        selectionSort(arr, 0);  \n    }  \n  \n    private static void selectionSort(int[] arr, int start) {  \n        // 시작점이 배열의 마지막 인덱스보다 작을 때 재귀호출  \n        if (start \u003c arr.length - 1) {  \n            // 가장 작은 방의 인덱스를 저장할 변수  \n            // 시작 인덱스로 초기화  \n            int min_index = start;  \n            // 시작점부터 배열의 마지막 방까지 루프  \n            for (int i = start; i \u003c arr.length; i++) {  \n                // 배열의 인덱스를 돌면서 찾은 가장 작은 값의 인덱스를 저장  \n                if (arr[i] \u003c arr[min_index]) min_index = i;  \n            }  \n  \n            // 가장 작은 값의 인덱스를 맨 앞의 것과 swap            \n            swap(arr, start, min_index);  \n            selectionSort(arr, start + 1);  \n        }  \n    }  \n  \n    private static void swap(int[] arr, int preIndex, int postIndex) {  \n        int temp = arr[preIndex];  \n        arr[preIndex] = arr[postIndex];  \n        arr[postIndex] = temp;  \n    }  \n  \n    public static void main(String[] args) {  \n        int[] arr = {3, 2, 1, 8, 4, 5, 7};  \n        System.out.println(\"Before Sorting: \" + Arrays.toString(arr));  \n        selectionSort(arr);  \n        System.out.println(\"After Sorting: \" + Arrays.toString(arr));  \n    }  \n}\n```\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/etcsort/":{"title":"분류 방법","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/etcsort/comparisonSort":{"title":"비교정렬","content":"\n\u003chr\u003e\n\n### 비교정렬 개념\n\n==**비교정렬 (Comparison sort) : 정렬 알고리즘의 일종으로 두 값을 비교하는 것에 기반하는 알고리즘**==\n- 데이터 간 **상대적 크기 관계**만을 이용해서 정렬하는 알고리즘\n- 대표적으로 [버블정렬](brain/CS/Algo/sort/comparison/bubbleSort), [선택정렬](brain/CS/Algo/sort/comparison/selectSort), [삽입정렬](brain/CS/Algo/sort/comparison/insertSort), [합병정렬](brain/CS/Algo/sort/comparison/mergeSort), [퀵정렬](brain/CS/Algo/sort/comparison/quickSort), [힙 정렬](brain/CS/Algo/sort/comparison/heapSort)\n- 메모리를 어떻게 쓰냐에 따라 **내부 정렬**, **외부 정렬**, [제자리 정렬](brain/CS/Algo/sort/etcsort/inplaceSort)로 나뉨\n- 두 값이 같을 때, 값이 어떤 순서로 정렬되는지에 따라 [안정 정렬](brain/CS/Algo/sort/etcsort/stableSort), [불안정 정렬](brain/CS/Algo/sort/etcsort/unstableSort)로 나뉨\n\n\u003cbr\u003e\n\n기본적으로 비교 정렬을 구현하는 방법에 있어서, 기본 정렬 알고리즘과 고급 정렬 알고리즘이 있다.\n- ==**기본 정렬 알고리즘**==\n\t- 시간 복잡도가 ==$O(n^2)$==인 정렬 알고리즘\n\t- 버블 정렬, 선택 정렬, 삽입 정렬\n- ==**고급 정렬 알고리즘**==\n\t- 시간 복잡도가 ==$O(n \\log n)$==인 정렬 알고리즘\n\t- 합병 정렬, 퀵 정렬, 힙 정렬\n\n\u003cbr\u003e\u003chr\u003e\n\n### 비교정렬 한계\n\n==**비교 정렬 알고리즘은 최악의 경우에 $O(n \\log n)$보다 더 나은 성능을 낼 수 없다. 왜 이런 한계를 가지고 있을까?**==\n\n비교 정렬 알고리즘은 추상적인 관점에서 모두 **의사 결정 트리(Decision Tree)** 로 볼 수 있다. 크냐, 작냐와 같은 특정한 기준(질문)에 따라 비교하여 원소를 구분하기 때문이다. a, b, c를 비교하는 것을 의사 결정 트리로 표현한 예시를 살펴보자.\n\n\u003cbr\u003e\n\n![](brain/image/comparisonSort-1.png)\n\n\u003cbr\u003e\n\n정렬 알고리즘의 실행은 ==**루트에서부터 트리의 말단 노드(더이상 자식이 없는 트리, 리프 노트라고도 함)까지 경로를 따라가는 것에 대응**==한다. 즉, 루트 노드로부터 가장 먼 말단 노드까지 가는 경로의 길이가 ==**최악의 경우의 비교 횟수**==를 나타내는 것이다. 이는 ==**트리의 높이**==를 의미한다.\n\n\u003cbr\u003e\n\n- n개를 비교하는 의사 결정 트리의 **가능한 모든 리프 노드의 개수는 $n!$개**\n\t- n개에 대한 모든 순열이 존재하기 때문\n\n- 트리의 높이를 h라고 하면, **최대 리프의 개수는 이진 트리이므로 $2^h$개**\n\n- 도달 가능한 리프가 L개라고 하면 아래의 식이 성립\n\n$$\nn! \u003c= L \u003c= 2^h\n$$\n\n- 양변에 로그($\\log_2$)를 취하면\n\n$$\n\\log 2^h \u003c= \\log L \u003c= \\log n!\n$$\n\n$$\nh \u003c= \\log(n!)\n$$\n\n- $n!$을 \u003ca href='https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%84%B8%EB%A7%81_%EA%B7%BC%EC%82%AC' target='_blank'\u003e스털링 근사\u003c/a\u003e하여 스털링 급수로 바꾸면 $n! \\sim \\sqrt{2\\pi n} (\\frac{n}{e})^n$\n\n$$\nn \\log n \u003c= h\n$$\n\n\u003cbr\u003e\n\n따라서, 최악의 경우의 비교 횟수( = 트리의 높이, h)는 $O(n \\log n)$보다 반드시 커야 한다. 이로 인하여, ==**비교 정렬 알고리즘은 최악의 경우 $O(n \\log n)$보다 나은 성능을 낼 수 없다.**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 비교정렬 개선\n\n그렇다면, 어떻게 더 최적으로 정렬할 수 있을까? ==**비교를 안하면 된다.**== 이에 해당하는 정렬은 [Non-Comparison Sort (비교하지 않는 정렬)](brain/CS/Algo/sort/etcsort/noncomparisonSort)이다.\n\n\u003cbr\u003e \u003chr\u003e\n\n### 참고\n\n- \u003ca href='https://medium.com/@igniter.yoo/algorithms-%EB%B9%84%EA%B5%90-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%95%98%ED%95%9C%EA%B3%BC-%EC%9D%98%EC%82%AC-%EA%B2%B0%EC%A0%95-%ED%8A%B8%EB%A6%AC-4cdd993bf370' target='_blank'\u003emedium - Paul, Jongmin Yoo님의 정리 게시글\u003c/a\u003e\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/etcsort/externalSort":{"title":"외부 정렬","content":"\n\u003chr\u003e\n\n### 외부정렬 개념\n\n==**외부 정렬 (External Sort) : 메모리에 관련된 정렬로, 대용량의 데이터를 몇 개의 서브 파일로 나누어 각각 내부 정렬하고 이후 각 서브 파일을 합병하는 방법**==\n- 정렬하고자 하는 데이터가 너무 크기 때문에 일부만 올려놓은 상태에서 정렬한 것을 다시 합하는 방식\n- 속도는 느리지만만, 자료의 많은 경우 효과적","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/etcsort/inplaceSort":{"title":"제자리 정렬","content":"\n\u003chr\u003e\n\n### 제자리 정렬 개념\n\n==**제자리 정렬(in-place sort) : 메모리 공간과 관련된 것으로, 원소들의 개수에 비해 충분히 무시할만한 저장 공간만을 더 사용하는 정렬 알고리즘을 의미**==\n- 주어진 공간 외에 자료구조를 이용하는 것과 같이 추가적인 공간을 사용하지 않는 정렬 알고리즘\n- 약간의 추가 공간 정도는 허용한다\n- 대표적인 제자리 정렬은 **삽입 정렬**, **선택 정렬**, **버블 정렬**, **힙 정렬**, **퀵 정렬** \n- **합병 정렬**은 별도의 추가적인 메모리(임시 배열)을 사용하므로 **제자리 정렬** ❌\n- 추가적인 메모리가 필요하다면 고려할 수 있는 것은 [내부정렬](brain/CS/Algo/sort/etcsort/internalSort), [외부정렬](brain/CS/Algo/sort/etcsort/externalSort)\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/etcsort/internalSort":{"title":"내부 정렬","content":"\n\u003chr\u003e\n\n### 내부정렬 개념\n\n==**내부 정렬 (Internal Sort) : 메모리에 관련된 정렬로, 데이터량이 적은 경우에 주 기억장치(메모리) 내에서 정렬하는 방법**==\n- 정렬하고자 하는 모든 데이터가 메모리에 올라와 정렬이 수행되는 방식\n- 속도는 빠르지만, 정렬할 자료의 양이 많을 경우 부적합","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/etcsort/noncomparisonSort":{"title":"비교하지 않는 정렬","content":"\n\u003chr\u003e\n\n### 비교하지 않는 정렬 개념\n\n==**비교하지 않는 정렬 (Non-Comparison sort) : 비교 정렬 알고리즘을 개선하는 것으로 말 그대로 비교를 하지 않는 알고리즘**==\n- 정렬한 데이터에 대한 **특수한 성질**을 이용하며 적용에 제한이 있음\n- 대표적으로 [기수정렬](brain/CS/Algo/sort/noncomparison/radixSort), [계수정렬](brain/CS/Algo/sort/noncomparison/countingSort)\n- 메모리를 어떻게 쓰냐에 따라 **내부 정렬**, **외부 정렬**, [제자리 정렬](brain/CS/Algo/sort/etcsort/inplaceSort)로 나뉨\n- 중복된 값이 같을 때, 값이 어떤 순서로 정렬되는지에 따라 [안정 정렬](brain/CS/Algo/sort/etcsort/stableSort), [불안정 정렬](brain/CS/Algo/sort/etcsort/unstableSort)로 나뉨\n\n\u003cbr\u003e\n\n기본적으로 비교하지 않는 정렬을 구현하는 방법에 있어서, 특수 정렬 알고리즘을 사용한 방법이 있다.\n\n- ==**특수 정렬 알고리즘**==\n\t- 시간 복잡도가 ==$O(n)$==인 정렬 알고리즘\n\t- 기수 정렬, 계수 정렬\n\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/etcsort/stableSort":{"title":"안정정렬","content":"\n\u003chr\u003e\n\n### 안정정렬 개념\n\n==**안정 정렬 (Stable Sort) : 중복된 값이 있는 경우, 입력 순서와 동일하게 유지하여 정렬하는 알고리즘**==\n- 두 값이 같을 때, 이 때 값이 입력된 순서대로 정렬된다면 안정 정렬이다.\n- 대표적으로 **버블정렬**, **삽입정렬**, **합병정렬**\n\nex) $(k_i,e_i), (k_j, e_j)$에 대하여 $k_i = k_j$이며 $i \u003c j$였을 때, **정렬 이후에도 $i \u003c j$라면 안정 정렬 알고리즘**\n\n\u003cbr\u003e\u003chr\u003e\n\n### 안정정렬 예시\n\n![](brain/image/stableSort-1.png)\n\n- 하트 5와 스페이드 5를 보면 중복된 숫자이다.\n- 정렬 전, 하트 5가 스페이드 5보다 앞에 위치\n- 정렬 후, 하트 5가 스페이드 5보다 앞에 위치\n- **즉, 안정정렬이 되려면 정렬이 되고 나서도 하트 5가 스페이드 5보다 앞에 있음을 보장해야하는 것이다.**\n\n\u003cbr\u003e\u003cbr\u003e\n\n![](brain/image/stableSort-2.png)\n\n- 초기에 입력값은 시간 순으로 정렬된 상태\n- 입력 값을 지역별로 정렬하려는 상태\n- 초기 입력된 순서가 시간 순으로 정렬되어 있다는 의미\n\t- 안정 정렬은 정렬 이후에도 입력 받은 순서를 보장해줌\n\t\t- 같은 지역을 보면 여전히 시간 순서로 정렬되어있음\n\t- 불안정 정렬은 무작위로 섞이기 때문에 입력받은 순서를 보장하지 못함\n\t\t- 같은 지역을 보면 시간 순서로 정렬이 되어있을수도, 아닐수도 있음","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/etcsort/unstableSort":{"title":"불안정정렬","content":"\n\u003chr\u003e\n\n### 불안정정렬 개념\n\n==**불안정 정렬 (Unstable Sort) : 중복된 값이 있는 경우, 입력 순서와 상관없이 무작위로 뒤섞인 상태에서 정렬하는 알고리즘**==\n- 두 값이 같을 때, 이 때 값이 입력된 순서와 관계없이 무작위로 정렬된다면 불안정 정렬이다.\n- 대표적으로 **선택 정렬**, **퀵 정렬**, **힙 정렬**\n\nex) $(k_i,e_i), (k_j, e_j)$에 대하여 $k_i = k_j$이며 $i \u003c j$였을 때, **정렬 이후에 $i \u003c j$을 보장할 수 없으면 불안정 정렬 알고리즘**\n\n\u003cbr\u003e\u003chr\u003e\n\n### 불안정정렬 예시\n\u0003\n![](brain/image/unstableSort-1.png)\n\n- 하트 5와 스페이드 5를 보면 중복된 숫자이다.\n- 정렬 전, 하트 5가 스페이드 5보다 앞에 위치\n- 정렬 후, 스페이드 5가 하트 5보다 앞에 위치\n- **즉, 정렬이 되고 나서 입력 순서와 상관 없이 무작위로 뒤섞인 상태에서 정렬된 것을 볼 수 있음. 이는 하트 5가 스페이드 5보다 앞에 있음을 보장하지 못한 것이다.**\n\n\u003cbr\u003e\u003cbr\u003e\n\n![](brain/image/stableSort-2.png)\n\n- 초기에 입력값은 시간 순으로 정렬된 상태\n- 입력 값을 지역별로 정렬하려는 상태\n- 초기 입력된 순서가 시간 순으로 정렬되어 있다는 의미\n\t- 안정 정렬은 정렬 이후에도 입력 받은 순서를 보장해줌\n\t\t- 같은 지역을 보면 여전히 시간 순서로 정렬되어있음\n\t- 불안정 정렬은 무작위로 섞이기 때문에 입력받은 순서를 보장하지 못함\n\t\t- 같은 지역을 보면 시간 순서로 정렬이 되어있을수도, 아닐수도 있음","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/noncomparison/":{"title":"Non-Comparison","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/noncomparison/countingSort":{"title":"계수 정렬","content":"\n![](brain/image/gif/countingSort.gif)","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Algo/sort/noncomparison/radixSort":{"title":"기수 정렬","content":"\n![](brain/image/gif/radixSort.gif)","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/CA/":{"title":"Computer Architecture","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/CA/ComputerArchitecture":{"title":"컴퓨터구조","content":"\n==**컴퓨터구조(Computer Architecture)는 하드웨어를 구성하는 각 장치의 특성과 동작 원리를 다루는 학문이다.**==\n\n- **Computer architecture = Instruction set architecture ([ISA](brain/CS/CA/ISA) ) + Machine organization**\n\t- ISA는 machine이 사용하는 언어이다. 굉장히 low-level language이며, 하드웨어를 제어하기 위한 언어이다.\n\t- 즉, 컴퓨터 구조는 실제 하드웨어와 그것을 제어하기 위한 언어\n\n![](brain/image/ComputerArchitecture-1.png)\n\n\u003cbr\u003e\n\n예전에는 규모가 큰 컴퓨터에서 보드 형태였다면, 지금은 **One-Chip 형태로 바뀌어가고 있다.** \n\n![](brain/image/ComputerArchitecture-2.png)\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/CA/CpuArchitecture":{"title":"CPU 아키텍처","content":"\n==**CPU architecture(또는 Micro architecture)는 CPU나 GPU 같은 하드웨어가 작동하는 방식을 서술한 일종의 컴퓨터 설계도이다.**== \n\n사실, 마이크로아키텍처라는 용어가 더 자주 사용되며, 대표적으로 **CISC(Complex Instruction Set Computer) 방식과 RISC(Reduced Instruction Set Computer) 방식이 존재한다.**","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/CA/ISA":{"title":"ISA","content":"\n==**ISA(Instruction Set Architecture, 명령어 집합 구조)는 마이크로프로세서가 인식해서 기능을 이해하고 실행할 수 있는 기계어 명령어를 의미한다.**== 즉, 이는 하드웨어와 소프트웨어 사이의 **Interface를 정의**하는 것이다.\n- ISA는 소프트웨어 관점에서 굉장히 중요한 하드웨어 추상화를 진행한다.\n- ISA는 하드웨어를 프로그래밍한다. 가장 밑단에 있는 언어이다.\n- 장점 : HW가 바뀌더라도 architecture가 동일하면, ISA는 변하지 않는다.\n\t- ( ISA가 변하지 않는다 = SW가 변할 필요 없다. )\n- 단점 : ISA는 SW/HW 양쪽 모두 영향을 받아서 쉽게 바꾸지 못한다.\n- 예시 : IA-32, PowerPC, MIPS, SPARC, ARM 등\n\u003cbr\u003e\n\n![](brain/image/ISA-1.png)\n\n\u003cbr\u003e\n\nISA를 설계하는 것은 아주 중요하다. 왜냐하면, **ISA에 따라 마이크로프로세서의 성능이 정해지기 때문이다.** 하드웨어가 얼마나 잘 설계되었는지 보다는 ISA가 얼마나 잘 설계되었는지가 훨씬 중요하다. 하드웨어는 마음대로 바꿀 수 있지만, ISA는 한번 정해지면 쉽게 바꾸지 못하기 때문이다. 이것이 바로 ISA를 잘 설계해야하는 궁극적인 목표이다.\n\nISA는 굉장히 다양한데, 예를 들어, Intel, AMD 프로세서를 사용하는 아키텍처는 **x86 ISA를 가지고 있다**라고 한다. 스마트폰에 쓰이는 것으로 **ARM ISA**가 있다. x86과 ARM은 서로 다른 ISA이다. 그래서 데스크탑의 application이 있고 모바일 전용 application이 있는데 호환이 안되는 것은 **애초에 Interface가 다르니 말이 통하지 않는 것**이다.\n\nISA를 ==**물리적으로 구현하는 방법을 마이크로 아키텍쳐**==라고 하는데, 같은 ISA를 서로 다른 마이크로 아키텍쳐로 구현하기도 한다. 그래서 Intel과 AMD가 x86 ISA를 사용함에도 다른 성능을 내는 이유는 **ISA를 구현하는 방법이 다르기 때문**이다.\n\n마이크로 아키텍처는 마이크로 프로세서가 사용하는 명령어 처리 방식인데, 마이크로 프로세서를 우리가 흔히 아는 CPU라고 이해하면 된다. 과거와 비교하였을 때, 상대적으로 작아져서 micro가 붙은 것이다. 따라서, micro architecture 역시 [CPU architecture](brain/CS/CA/CpuArchitecture)의 맥락으로 이해하면 편하다. 미리 말하자면, 대표적으로 CISC(Complex Instruction Set Computer)와 RISC(Reduced Instruction Set Computer) 방식이 있다.","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/DS/":{"title":"Data Structure","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/DS/bst":{"title":"Binary Search Tree","content":"\n\u003chr\u003e\n\n### 이진탐색트리 기본\n\n==**이진탐색트리 (Binary Search Tree)**==\n- [이진탐색(Binary Search)](brain/CS/Algo/principle/binarySearch)과 연결리스트(Linked list)를 결합한 자료구조\n\n![](brain/image/lecture08-26.png)\n\n- 모든 노드의 왼쪽 서브 트리는 해당 노드의 값보다 작은 값들만 가짐\n- 모든 노드의 오른쪽 서브 트리는 해당 노드의 값보다 큰 값들만 가짐\n- **이진 탐색 트리의 최소값** : 트리의 가장 왼쪽에 존재\n\t- 왼쪽 → 왼쪽 하니까 최소값 3\n- **이진 탐색 트리의 최대값** : 트리의 가장 오른쪽에 존재\n\t- 오른쪽 1번밖에 안됨. 최대값 50\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**이진탐색트리 장점**==\n- 삽입 / 삭제가 유연 (레퍼런스만 재조정하면 되니까)\n- 값의 크기에 따라 좌우 서브트리가 나눠지기 때문에 삽입/삭제/검색이 (보통은) 빠르다\n- 값의 순서대로 순회 가능 (정렬된 형태로 접근 가능하다는 말)\n\n\u003cbr\u003e\n\n==**이진탐색트리 단점**==\n- 트리가 구조적으로 한쪽으로 편향되면 삽입/삭제/검색 등등 수행시간이 악화됨\n- 이 문제를 해결하기 위해 스스로 균형을 잡는 이진탐색트리가 사용됨\n\t- ex) AVL 트리, Red-Black 트리\n\t- 얘네는 worst case 에서도 $O(\\log N)$으로 처리됨\n\n\u003cbr\u003e\n\n==**이진탐색트리 시간복잡도**==\n\n|            |     best     |   average   |    worst     |\n|:----------:|:------------:|:-----------:|:------------:|\n| **insert** | $\\theta (1)$ | $O(\\log N)$ | $\\theta (N)$ |\n| **delete** | $\\theta (1)$ | $O(\\log N)$ | $\\theta (N)$ |\n| **search** | $\\theta (1)$ | $O(\\log N)$ | $\\theta (N)$ |\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**이진탐색트리 순회방법**==\n- **전위순회 (preorder traversal)**\n\t1. 현재 노드 방문 (ex. 값 출력)\n\t2. 재귀적으로 왼쪽 서브 트리 순회\n\t3. 재귀적으로 오른쪽 서브 트리 순회\n- ==**중위순회 (inorder traversal)**==\n\t1. 재귀적으로 왼쪽 서브 트리 순회\n\t2. 현재 노드 방문 (ex. 값 출력)\n\t3. 재귀적으로 오른쪽 서브 트리 순회\n- **후위순회 (postorder traversal)**\n\t1. 재귀적으로 왼쪽 서브 트리 순회\n\t2. 재귀적으로 오른쪽 서브 트리 순회\n\t3. 현재 노드 방문 (ex. 값 출력)\n\n\u003cbr\u003e\u003chr\u003e\n\n### 이진탐색트리 연산\n\n**삽입**\n- 그냥 값이 크면 오른쪽, 작으면 왼쪽 이거만 기억하고 넣으면 됨\n\n![](brain/image/lecture08-37.png)\n\n\u003cbr\u003e\n\n**삭제**\n- 삭제하려는 노드가 있는지 먼저 검색\n- 있으면 삭제\n- 즉, 삭제는 검색이라는 작업이 동반됨\n\n**자녀가 없는 노드 삭제**\n- 삭제될 노드를 가리키던 레퍼런스를 가리키는 것이 없도록 처리\n\n**자녀가 하나인 노드 삭제**\n- 삭제될 노드를 가리키던 레퍼런스를 삭제될 노드의 자녀를 가리키게 변경\n\n**자녀가 둘인 노드 삭제**\n- 삭제될 노드의 오른쪽 서브트리에서 제일 값이 작은 노드가 삭제될 노드를 대체\n- 만약, 왼쪽 서브트리로 정했다면 제일 값이 큰 노드가 삭제될 노드를 대체하면 됨\n\n\n\u003cbr\u003e\u003chr\u003e\n\n### 이진탐색트리 구현\n\n\u003cbr\u003e\n\n```java\nclass BinarySearchTree {  \n    class Node {  \n        int data;  \n        Node left;  \n        Node right;  \n  \n        public Node(int data) {  \n            this.data = data;  \n        }  \n    }  \n  \n    Node root;  \n  \n    public Node search(Node root, int key) {  \n        // leaf 노드 도착, 찾는 노드 만남  \n        if (root == null || root.data == key)  \n            return root;  \n        // 찾는 값이 작으면 왼쪽  \n        if (root.data \u003e key)  \n            return search(root.left, key);  \n        // 찾는 값이 크면 오른쪽  \n        return search(root.right, key);  \n    }  \n  \n    public void insert(int data) {  \n        root = insert(root, data);  \n    }  \n  \n    public Node insert(Node root, int data) {  \n        // 맨 처음 혹은 리프노드일 때도 해당됨  \n        if (root == null) {  \n            root = new Node(data);  \n            return root;  \n        }  \n  \n        // 루트가 null 도 아니고 리프노드에도 도착안했으면  \n        if (data \u003c root.data)  \n            root.left = insert(root.left, data);  \n        else if (data \u003e root.data)  \n            root.right = insert(root.right, data);  \n  \n        return root;  \n    }  \n  \n    public void delete(int data) {  \n        root = delete(root, data);  \n    }  \n  \n    public Node delete(Node root, int data) {  \n        if (root == null)  \n            return root;  \n  \n        if (data \u003c root.data)  \n            root.left = delete(root.left, data);  \n        else if (data \u003e root.data)  \n            root.right = delete(root.right, data);  \n        // 삭제할 데이터를 찾은 경우  \n        else {  \n            // 자녀가 없는 경우  \n            // 부모에게 그냥 null 을 반환해서 링크 끊고 그냥 삭제  \n            if (root.left == null \u0026\u0026 root.right == null)  \n                return null;  \n            // 자녀가 하나인 경우  \n            // 자녀를 그냥 위로 올려버리면 됨  \n            else if (root.left == null)  \n                return root.right;  \n            else if (root.right == null)  \n                return root.left;  \n  \n            // 자녀가 둘인 경우  \n            // 루트의 데이터를 대체, 오른쪽 서브트리에서 제일 값이 작은 노드  \n            root.data = findMin(root.right);  \n            root.right = delete(root.right, root.data);  \n        }  \n        return root;  \n    }  \n  \n    // 루트 노드를 받아서 계속 왼쪽으로 null 을 만날때까지 감  \n    // 왼쪽 자식이 null 인 노드는 해당 트리에서 가장 작은 값이니까  \n    int findMin(Node root) {  \n        int min = root.data;  \n        while (root.left != null) {  \n            min = root.left.data;  \n            root = root.left;  \n        }  \n        return min;  \n    }  \n  \n    // 전위순회  \n    public void preorder() {  \n        System.out.println(\"---전위순회---\");  \n        preorder(root);  \n        System.out.println();  \n    }  \n  \n    private void preorder(Node root) {  \n        if (root != null) {  \n            System.out.print(root.data + \" \");  \n            preorder(root.left);  \n            preorder(root.right);  \n        }  \n    }  \n  \n    // 중위순회  \n    public void inorder() {  \n        System.out.println(\"---중위순회---\");  \n        inorder(root);  \n        System.out.println();  \n    }  \n  \n    private void inorder(Node root) {  \n        if (root != null) {  \n            inorder(root.left);  \n            System.out.print(root.data + \" \");  \n            inorder(root.right);  \n        }  \n    }  \n  \n    // 후위순회  \n    public void postorder() {  \n        System.out.println(\"---후위순회---\");  \n        postorder(root);  \n    }  \n  \n    private void postorder(Node root) {  \n        if (root != null) {  \n            postorder(root.left);  \n            postorder(root.right);  \n            System.out.print(root.data + \" \");  \n        }  \n    }  \n}  \n  \npublic class BinarySearchTreeTest {  \n    public static void main(String[] args) {  \n        BinarySearchTree bst = new BinarySearchTree();  \n\n        bst.insert(4);  \n        bst.insert(2);  \n        bst.insert(1);  \n        bst.insert(3);  \n        bst.insert(6);  \n        bst.insert(5);  \n        bst.insert(7);  \n  \n        bst.preorder();  \n        bst.inorder();  \n        bst.postorder();  \n    }  \n}\n\n// ---전위순회---\n// 4 1 2 3 5 6 7 \n// ---중위순회---\n// 1 2 3 4 5 6 7 \n// ---후위순회---\n// 1 2 3 5 6 7 4\n\n// ---전위순회---\n// 4 2 1 3 6 5 7 \n// ---중위순회---\n// 1 2 3 4 5 6 7 \n// ---후위순회---\n// 1 3 2 5 7 6 4 \n```","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/DS/queue":{"title":"Queue","content":"\n\u003chr\u003e\n\n### 큐 기본개념\n\n==**큐 (Queue) : 삽입과 삭제 연산이 FIFO로 이뤄지는 자료구조**==\n\n![](brain/image/queue-1.png)\n\n- FIFO (First-In-First-Out, 선입선출) : 가장 처음에 들어온 것이 가장 먼저 나감\n\t- 입력을 rear, 출력을 front로 제한\n\t\t- 큐의 가장 첫 원소가 front, 끝 원소가 rear\u001e\n\t\t- 들어오는건 rear로 들어오고, 나가는건 front부터 빠지는거임\n- 버퍼, 대기 큐, BFS 등 다양한 곳에서 사용됨\n\n\u003cbr\u003e\n\n==**큐를 구성하는 4가지 기능**==\n\n- **`add()`** : 맨 끝 (rear)에 데이터 추가\n- **`remove()`** : 맨 앞 (front)에서 데이터 꺼내기\n- **`peek()`** : 맨 앞 (front)에 데이터 보는거\n- **`isEmpty()`** : 큐가 비었는지 확인\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 큐 자바로 구현해보기\n\n\u003cbr\u003e\n\n```java\nimport java.util.NoSuchElementException;  \n  \nclass Queue\u003cT\u003e {  \n    class Node\u003cT\u003e {  \n        // 제네릭 타입인 T로 data 받음  \n        private T data;  \n        // 다음 노드 next        private Node\u003cT\u003e next;  \n  \n        public Node(T data) {  \n            this.data = data;  \n        }  \n    }  \n  \n    // 큐는 앞, 뒤의 주소 알아야하니까  \n    private Node\u003cT\u003e first;  \n    private Node\u003cT\u003e last;  \n  \n    public void add(T item) {  \n        // add 할 아이템을 가지고 Node 를 하나 생성  \n        Node\u003cT\u003e t = new Node\u003cT\u003e(item);  \n  \n        // 마지막 Node 가 있다면 거기에 item 붙이기  \n        if (last != null) {  \n            last.next = t;  \n        }  \n  \n        // 이제 t가 마지막 노드가 됨  \n        last = t;  \n  \n        // 데이터가 없을 때  \n        if (first == null) {  \n            first = last;  \n        }  \n    }  \n  \n    public T remove() {  \n        // 큐가 비어있으면  \n        if (first == null) {  \n            throw new NoSuchElementException();  \n        }  \n  \n        // 맨 앞에 있는 데이터를 반환하기 전에  \n        // 그 다음에 있는 녀석을 first 으로 만들어줘야함  \n        // 그래서 데이터 백업해놓는거  \n        T data = first.data;  \n        first = first.next;  \n  \n        if (first == null) {  \n            last = null;  \n        }  \n  \n        return data;  \n    }  \n  \n    public T peek() {  \n        if (first == null) {  \n            throw new NoSuchElementException();  \n        }  \n        return first.data;  \n    }  \n  \n    public boolean isEmpty() {  \n        return first == null;  \n    }  \n}  \n  \npublic class QueueTest {  \n    public static void main(String[] args) {  \n        Queue\u003cInteger\u003e queue = new Queue\u003cInteger\u003e();  \n        queue.add(1);  \n        queue.add(2);  \n        queue.add(3);  \n        queue.add(4);  \n        System.out.println(queue.remove());  \n        System.out.println(queue.remove());  \n        System.out.println(queue.peek());  \n        System.out.println(queue.remove());  \n        System.out.println(queue.isEmpty());  \n        System.out.println(queue.remove());  \n        System.out.println(queue.isEmpty());  \n    }  \n}\n\n// 1\n// 2\n// 3\n// 3\n// false\n// 4\n// true\n```","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/DS/stack":{"title":"Stack","content":"\n\u003chr\u003e\n\n### 스택 기본개념\n\n==**스택 (Stack) : 삽입과 삭제 연산이 LIFO로 이뤄지는 자료구조**==\n\n![](brain/image/stack-2.png)\n\n- LIFO (Last-In-First-Out, 후입선출) : 가장 나중에 들어온 것이 가장 먼저 나감\n\t- 입력과 출력이 하나의 방향으로 제한\n- 바로 넣었다가 거꾸로 정렬된 데이터를 꺼내고 싶을 때 유용\n\t- 함수의 콜스택, 문자열 역순 출력, 연산자 후위표기법 등등\n\t- DFS에서도 쓰긴 하는데.. 사실 DFS는 그냥 재귀로 하는게 ...\n\n\u003cbr\u003e\n\n==**스택을 구성하는 4가지 기능**==\n\n- **`push()`** : 맨 위에 데이터를 하나 쌓아올리기\n- **`pop()`** : 맨 위에 데이터를 가져오면서 **삭제**\n- **`peek()`** : 맨 위에 데이터가 뭔지 보는거\n- **`isEmpty()`** : 스택이 비었는지 확인\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 스택 자바로 구현해보기\n\n\u003cbr\u003e\n\n```java\nimport java.util.EmptyStackException;  \n  \nclass Stack\u003cT\u003e {  \n    class Node\u003cT\u003e {  \n        // 제네릭 타입인 T로 data 받음  \n        private T data;  \n        // 다음 노드 next        \n        private Node\u003cT\u003e next;  \n  \n        public Node(T data) {  \n            this.data = data;  \n        }  \n    }  \n  \n    // 스택은 맨 위의 주소만 알고 있으면 되니까  \n    private Node\u003cT\u003e top;  \n  \n    public void push(T item) {  \n        // push 할 아이템을 가지고 Node 를 하나 생성  \n        Node\u003cT\u003e t = new Node\u003cT\u003e(item);  \n        // top 앞에 생성한 Node 를 위치시킴  \n        t.next = top;  \n        // 이제 이 push 된 Node 가 top        \n        top = t;  \n    }  \n  \n    public T pop() {  \n        if (top == null) {  \n            throw new EmptyStackException();  \n        }  \n  \n        // 맨 위에 있는 데이터를 반환하기 전에  \n        // 그 아래에 있는 녀석을 top 으로 만들어줘야함\n        // 그래서 데이터 백업해놓는거  \n        T item = top.data;  \n        top = top.next;  \n        return item;  \n    }  \n  \n    public T peek() {  \n        if (top == null) {  \n            throw new EmptyStackException();  \n        }  \n        return top.data;  \n    }  \n  \n    public boolean isEmpty() {  \n        return top == null;  \n    }  \n}  \n  \npublic class StackTest {  \n    public static void main(String[] args) {  \n        Stack\u003cInteger\u003e stack = new Stack\u003cInteger\u003e();  \n        stack.push(1);  \n        stack.push(2);  \n        stack.push(3);  \n        stack.push(4);  \n        System.out.println(stack.pop());  \n        System.out.println(stack.pop());  \n        System.out.println(stack.peek());  \n        System.out.println(stack.pop());  \n        System.out.println(stack.isEmpty());  \n        System.out.println(stack.pop());  \n        System.out.println(stack.isEmpty());  \n    }  \n}\n\n// 4\n// 3\n// 2\n// 2\n// false\n// 1\n// true\n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 스택 2개로 큐 1개 구현\n\n- 스택의 특성을 이용하면 [큐](brain/CS/DS/queue)를 구현할 수 있다.\n\n![](brain/image/stack-3.png)\n\n- **Enqueue** : 큐가 `add()` 할 때 새로운 데이터를 stack1에다가 `push()`\n- **Dequeue** : 큐가 `peek()`, `remove()` 호출 했을 때 stack2가 비어있으면\n\t1. stack1에서 `pop()`\n\t2. stack2에다가 `push()`\n\t3. stack2에서 `pop()` 해서 확인\n\n\u003cbr\u003e\n\n```java\nimport java.util.Stack;  \n  \nclass MyQueue\u003cT\u003e {  \n    Stack\u003cT\u003e stackNew, stackOld;  \n  \n    MyQueue() {  \n        stackNew = new Stack\u003cT\u003e();  \n        stackOld = new Stack\u003cT\u003e();  \n    }  \n  \n    public int size() {  \n        return stackNew.size() + stackOld.size();  \n    }  \n  \n    public void add(T item) {  \n        stackNew.push(item);  \n    }  \n  \n    private void shiftStack() {  \n        // stackOld 가 비어있는 상태가 아닌 경우에는  \n        // 데이터가 mass up 될 수도 있음  \n        if (stackOld.isEmpty()) {  \n            while (!stackNew.isEmpty()) {  \n                stackOld.push(stackNew.pop());  \n            }  \n        }  \n    }  \n  \n    public T peek() {  \n        shiftStack();  \n        return stackOld.peek();  \n    }  \n  \n    public T remove() {  \n        shiftStack();  \n        return stackOld.pop();  \n    }  \n}  \n  \npublic class StackQueueTest {  \n    public static void main(String[] args) {  \n        MyQueue\u003cInteger\u003e myQueue = new MyQueue\u003cInteger\u003e();  \n        myQueue.add(1);  \n        myQueue.add(2);  \n        myQueue.add(3);  \n        System.out.println(myQueue.remove());  \n        System.out.println(myQueue.remove());  \n        System.out.println(myQueue.remove());  \n    }  \n}\n\n// 1\n// 2\n// 3\n```","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/":{"title":"Language Theory","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/BNF":{"title":"BNF","content":"\n\u003cbr\u003e\n\n==**BNF(Backus-Naur Form)는 프로그래밍 언어 Algol(알골)의 구문을 정의하기 위해 배커스와 나우어가 사용한 표현법이다.**== 구문(syntax) 형식을 정의하는 가장 보편적인 표기법이다.\n\n\u003cbr\u003e\n\n| **메타기호** |      **의미**       |\n|:------------:|:-------------------:|\n|    `::==`    |        정의         |\n|     `\\|`      |      택일(OR)       |\n|    `\u003c \u003e`     | 비단말(nonterminal) | \n\n\u003cbr\u003e\n\nBNF에서 규칙은 메타 기호(`::==`)를 이용하여 표현한다.\n\n- 생성 규칙\n\t- 생성 규칙의 왼쪽 : 정의될 대상\n\t- 생성 규칙의 오른쪽 : 그 대상에 대한 정의\n\n메타 기호의 왼쪽에는 하나의 비단말 기호가, 오른쪽에는 기호들을 활용하여 정의하는 내용이 나오는 것이다. 참고로, 꺽쇠가 없는 것은 단말(terminal)이다.\n\n\u003cbr\u003e\n\n|  **기호**   |              **의미**               |                  **예시**                   |\n|:-----------:|:-----------------------------------:|:-------------------------------------------:|\n|  단말 기호  | 비단말 기호 및 메타기호가 아닌 기호 |   A, B, a, b, 0, 1, if, then, +, -, 등등    |\n| 비단말 기호 |     메타 기호 `\u003c \u003e`로 묶인 기호     | `\u003cidentifier\u003e`, `\u003cletter\u003e`, `\u003cdigit\u003e`, 등등 | \n\n\u003cbr\u003e\n\n- 사용 예시\n```\n\u003cif문\u003e ::= if \u003c논리식\u003e then \u003c문장\u003e else \u003c문장\u003e | if \u003c논리식\u003e then \u003c문장\u003e\n```\n\u003cbr\u003e\n\n```\n\u003cidentifier\u003e ::= \u003cletter\u003e | \u003cidentifier\u003e\u003cletter\u003e | \u003cidentifier\u003e\u003cdigit\u003e  \n\u003cletter\u003e ::= A | B | C | ... | X | Y | Z | a | b | ... | z |  \n\u003cdigit\u003e ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n```\n\n\u003cbr\u003e\n\n한 표현이 BNF에 의해 작성될 수 있는지 여부를 나타내는 것이 [파스 트리 (parse tree)](brain/CS/LT/ParseTree)이다. 참고로 BNF를 확장한 것은 [EBNF](brain/CS/LT/EBNF)이다.","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/Compile":{"title":"컴파일","content":"\n\u003cbr\u003e\n\n==**컴파일(Compile)**==은 인간이 이해할 수 있는 언어로 작성된 소스코드를 컴퓨터가 이해할 수 있는 기계어로 번역(변환)하는 작업을 의미한다. C, Java 등으로 작성된 소스코드를 전기 신호인 0, 1로 바꿔주는 과정이라고 이해하자. [컴파일러(Compiler)](brain/CS/LT/Compiler)는 컴파일 과정을 수행하는 프로그램이다. \n\n![](brain/image/Compile-1.png)\n\n컴파일 과정은 왜 반드시 필요할까?\n\n간단히 말하면, 인간이 작성한 언어를 컴퓨터가 이해하도록 변환해주는 것이지만, 상세하게 보면 컴퓨터를 이용하는 사용자들의 컴퓨터는 동일하지 않다. 프로그래밍 언어의 고급 언어는 약속된 문법을 사용하기 때문에 맥북인 내 컴퓨터로 C언어를 작성하든, 윈도우인 다른 사람의 컴퓨터로 C언어를 작성하든 C언어의 문법을 사용해서 application을 작성할 것이다.\n\n**그러나, 운영체제가 다르면[ ISA(Instruction Set Architecture)](brain/CS/CA/ISA)도 다르고 컴퓨터가 작동하는 원리에 차이가 있을 수 밖에 없다.** 같은 윈도우라도 window 7, window 10과 같이 사용자의 컴퓨터들은 차이점이 반드시 존재한다. 컴퓨터 내부의 CPU, RAM 등 모든 부품에도 차이가 있기 때문에 **사용자의 환경에 맞는 적절한 전기 신호를 보내야 하는데 인간이 작성한 고급 언어만 보고는 그런 작업을 할 수 없다.** 컴파일 과정을 통해 각자의 환경에 맞는 어셈블리어로 변환하고 기계어로 변환해야 하는 것이다.\n\n\u003cbr\u003e\n\n대략적인 컴파일 과정은 아래와 같다.\n\n1. High Level Language로 프로그램을 만듦\n\t- source code (소스코드) 생성\n2. High Level Language -\u003e Assembly Language로 컴파일\n\t- 어셈블리 언어는 하드웨어가 어떤 ISA를 사용하느냐에 따라 다름\n3. Assembler를 이용하여 Assembly Language -\u003e Machine language\n\t- object code (목적코드) 생성\n4. Linker object 관계 연결\n\t- out (리눅스), exe (윈도우) 같은 실행파일 생성\n5. Loader에 올라가고 메모리에 들어간 이후 코드를 읽어 실행\n\n\u003cbr\u003e\n\n\u003e [!note] 그렇다면, 인터프리터는? \u003cbr\u003e\n\u003e Python 같은 [인터프리터](brain/CS/LT/Interpreter)는 2, 3, 4, 5의 과정을 **프로그램을 실행시키면서 진행하기 때문에, 느리지만 호환성 걱정이 없다.**\n\n\n\u003cbr\u003e\n\n아래의 그림은 C언어에서의 컴파일 과정이다.\n\n![](brain/image/Compile-2.png)\n\nC에서의 컴파일 과정은 **4가지 단계(전처리 과정 - 컴파일 과정 - 어셈블리 과정 - 링킹 과정)** 로 나누어 진다. 이 4가지 단계를 묶어서 컴파일 과정, 빌드 과정이라고 부르기도 하고 컴파일 과정과 링킹 과정을 따로 나눠서 부르기도 한다. 보통 빌드 과정은 컴파일 과정보다 넓은 의미(`빌드=컴파일+링킹`)로 사용되는데 상황에 맞게 이해하면 될 거 같다.\n\n- 전처리기(preprocessor) : 원시 프로그램을 번역하기 전에 프로그램 내에 포함되어 있는 특별한 지시어를 먼저 해독해주는 번역 프로그램, 전처리기로 처리된 **소스 프로그램**은 컴파일러에 의해 **목적 프로그램**으로 변환됨\n\n- 링커 : 목적 프로그램에 라이브러리로부터 꺼낸 표준함수와 사용자 함수를 연결해서 실행 가능한 프로그램을 생성한다.\n\n- test라는 소스 코드를 C언어로 작성했다고 하면, `test.c`, `test.obj`, `test.exe` 총 3개의 파일이 만들어진다.\n\nC언어에서 컴파일에 관한 자세한 내용은 \u003ca href='https://bradbury.tistory.com/226' target='_blank'\u003e링크\u003c/a\u003e를 참고하자.","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/Compiler":{"title":"컴파일러","content":"\u003cbr\u003e\n\n==**컴파일러(Compiler)는 컴파일 과정을 수행하는 프로그램이다.**==\n- 소스 코드 전체를 목적 코드로 번역하고 그 결과를 한 번에 실행\n- 번역과 실행 작업이 따로 진행된다. 번역의 과정은 오래 걸리지만, 실행의 과정은 빠르다.\n- 실행 프로그램이 따로 생성된다.\n\n\u003cbr\u003e\n\n|           | **컴파일러(Compiler)** | **인터프리터(Interpreter)**          |\n| :---------: | :----------------------: | :------------------------------------: |\n| 번역 단위 | 전체                   | 한 줄 마다                           |\n| 실행 속도 | 빠름                   | 느림                                 |\n| 번역 속도 | 느림                   | 빠름                                 |\n| 목적 코드 | 생성 O                 | 생성 X                               |\n| 예시      | C, C++, Java Compiler  | Python, JavaScript, Java Interpreter | \n\n\u003cbr\u003e\n\n자바에서의 컴파일러에 관한 이야기는 [여기](brain/Java/JavaExecute)를 참고하자.\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Compiler Structure\n\n![](brain/image/Compiler-1.png)\n\n- Front-End : 언어에 의존하고 기계에 독립적인 부분\n- Back-End : 언어에 독립적이고 기계에 의존하는 부분\n\n\u003cbr\u003e\n\n![](brain/image/Compiler-2.png)\n\n1. ==**Lexical Analyzer (Scanner)**==\n\t- 컴파일러 내부에서 효율적이며 다루기 쉬운 정수로 바꿔 줌\n\t- source programs -\u003e **Lexical Analyzer** -\u003e A sequence of tokens\n\t- 대표적인 토큰 분석기로 [Lex](brain/CS/LT/Lex)가 있음\n\t- 예를 들어, `if (a \u003e 10)`이 있다고 하면, `if`, `(`, `a`, `\u003e`, `10`, `)` 6개의 토큰이 생성되는 것\n\n2. ==**Syntax Analyzer (Parser)**==\n\t- 구문(Syntax) 체크, 트리 생성\n\t- A sequence of tokens -\u003e **Syntax Analyzer** -\u003e Error message of syntactic structure\n\t- 대표적인 구문 분석기로[Yacc](brain/CS/LT/Yacc)가 있음\n\t- 출력\n\t\t- incorrect : error message 출력\n\t\t- correct : program structure (tree 형태) 출력\n\n![](brain/image/Compiler-3.png)\n\n3. ==**Intermidate Code Generator**==\n\t- 의미(Semantic) 체킹\n\t- ex) `if (a \u003e 10) a = 1.0` =\u003e a가 정수일 때 semantic error\n\t- ex) `a = b + 1;`\n\n![](brain/image/Compiler-4.png)\n\n4. ==**Code Optimizer**==\n\t- optional phase (선택적 단계)\n\t- 비효율적인 code를 구분해내서 더 효율적인 code로 바꿔준다.\n\t- Meaning of optimization (최적화)\n\t\t- major part : improve running time\n\t\t- minor part : reduce code size\n\t\t- ex) `LDC R1, 1`,  `LDC R1, 1` load가 중복되니까 하나 없애기\n\t- Criteria for optimization (최적화의 기준)\n\t\t- 프로그램 의미 보존\n\t\t- 평균 속도 상승\n\t\t- 노력할 가치가 있는 경우\n\t- Local optimization : local inspection을 통하여 비효율적인 code들을 구분해 내서 더 효율적인 code로 바꾸는 방법\n\t\t1. Constant folding (컴파일 시간 상수 연산)\n\t\t2. Eliminating redundant load, store instructions\n\t\t3. Algebraic simplification\n\t\t4. Strength reduction\n\t- Global optimization : flow analysis technique 이용\n\t\t1. Common subexpression (공통 부분식)\n\t\t2. Moving loop invariants\n\t\t3. Removing unreachable codes\n\n5. ==**Target Code Generator**==\n\t- 중간 코드로부터 machine instruction을 생성\n\t- Intermediate Code -\u003e **Target Code Generator** -\u003e Target Code\n\t- Code generator tasks\n\t\t1. instruction selection \u0026 generation\n\t\t2. register management\n\t\t3. storage allocation\n\t\t4. code optimization (Machine-dependent optimization)\n\n6. ==**Error Recovery**==\n\t- Error recovery : error가 다른 문장에 영향을 미치지 않도록 수정하는 것\n\t- Error repair : error가 발생하며 복구해 주는 것\n\t- Error Handling\n\t\t- Error detection\n\t\t- Error recovery\n\t\t- Error reporting\n\t\t- Error repair\n\t- Error\n\t\t- Syntax Error\n\t\t- Semantic Error\n\t\t- Run-time Error\n\n\u003cbr\u003e\n\n**추가사항**\n\n- Single Pass Compiler\n\t- 초창기의 컴파일러\n\t- 컴파일 속도 빠름\n- Multi-pass Compiler\n\t- 부분적인 기능개선 가능\n\t- 다른 기종으로 이전 편리\n\t- 작은 기억 공간 요구\n\t- 컴파일 속도 느림","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/EBNF":{"title":"EBNF","content":"\n\u003cbr\u003e\n\n==**EBNF(Extended Backus-Naur Form) 표기법은 BNF에 메타 기호를 추가하여 규칙을 더 간결하게 표현할 수 있도록 확장된 BNF이다.**== 총 4가지 메타기호가 추가되었다.\n\n\u003cbr\u003e\n\n| **구분** | **메타 기호** |               **의미**               |\n|:--------:|:-------------:|:------------------------------------:|\n|   BNF    |    `::==`     |                 정의                 |\n|   BNF    |     `\\|`      |               택일(OR)               |\n|   BNF    |     `\u003c \u003e`     |         비단말(nonterminal)          |\n|   EBNF   |     `[]`      |              생략 가능               |\n|   EBNF   |     `{}`      |            0번 이상 반복             |\n|   EBNF   |     `()`      | 한정된 범위의 택일, `\\|`와 함께 사용 |\n|   EBNF   |     `''`      |  메타 기호 자체를 단말 기호로 사용   | \n\n\u003cbr\u003e\n\n- 메타 기호 `[]`의 예시\n\t- 의미 : 생략 가능\n\n```\nBNF\n\u003cif문\u003e ::= if \u003c논리식\u003e then \u003c문장\u003e else \u003c문장\u003e | if \u003c논리식\u003e then \u003c문장\u003e  \nEBNF\n\u003cif문\u003e ::= if \u003c논리식\u003e then \u003c문장\u003e [ else \u003c문장\u003e ]\n```\n\n\u003cbr\u003e\n\n- 메타 기호 `{}`의 예시\n\t- 의미 : 0번 이상 반복\n\t- `\u003cunsigned integer\u003e ::= \u003cdigit\u003e`\n\t- `\u003cunsigned integer\u003e ::= \u003cdigit\u003e\u003cdigit\u003e`\n\t- `\u003cunsigned integer\u003e ::= \u003cdigit\u003e\u003cdigit\u003e\u003cdigit\u003e ...`\n\t- 이런식으로 재귀적인 표현 방법 사용했음\n\n```\nBNF\n\u003cunsigned integer\u003e ::= \u003cdigit\u003e | \u003cunsigned integer\u003e\u003cdigit\u003e  \nEBNF\n\u003cunsigned integer\u003e ::= \u003cdigit\u003e { \u003cdigit\u003e }\n```\n\n\u003cbr\u003e\n\n- 메타 기호 `()`의 예시\n\t- 의미 : 범위 중 택일\n\n```\nBNF\n\u003c수식\u003e ::= \u003c수식\u003e + \u003c수식\u003e | \u003c수식\u003e - \u003c수식\u003e | \u003c수식\u003e * \u003c수식\u003e | \u003c수식\u003e / \u003c수식\u003e\nEBNF\n\u003c수식\u003e ::= \u003c수식\u003e ( + | - | * | / ) \u003c수식\u003e]\n```\n\n\u003cbr\u003e\n\n- 메타 기호 `''`의 예시\n\t- 의미 : 메타 기호 자체를 단말 기호로 사용\n\n```\n\u003cBNF 규칙\u003e ::= \u003c왼쪽 부분\u003e '::=' \u003c오른쪽 부분\u003e\n```","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/Interpreter":{"title":"인터프리터","content":"\n\u003cbr\u003e\n\n[컴파일(Compile)](brain/CS/LT/Compile)은 인간이 이해할 수 있는 언어로 작성된 소스코드를 컴퓨터가 이해할 수 있는 기계어로 번역(변환)하는 작업을 의미한다고 했다. 이 과정에서 [컴파일러](brain/CS/LT/Compiler)는 **소스 코드 전체를 목적 코드로 바꿔주고 컴퓨터에서 실행 가능하도록**하는 원리였다. 그렇다면 인터프리터는 어떠한가?\n\n==**인터프리터는 소스 코드를 한 줄씩 읽어들여서 즉시 실행한다.**==\n1. 소스 코드 한 줄 마다 번역과 실행이 동시에 이루어진다.\n2. 줄 단위로 진행되어 시분할 시스템에 유용하다.\n3. CPU 사용 시간의 낭비가 크다.\n\n[컴파일러](brain/CS/LT/Compiler)는 사람이 하는 말을 처음부터 끝까지 들은 이후 작업 수행, 인터프리터는 소스 코드 한 줄 마다 번역함과 동시에 실행하는 작업을 수행한다. 쉽게 말해서, ==인터프리터는 사람의 말을 동시통역하는 개념==으로 이해하면 된다. **인터프리터는 줄 단위로 바로바로 프로그램이 실행 되기에 목적 프로그램이 따로 생성되지는 않는다.**\n\n\u003cbr\u003e\u003cbr\u003e\n\n|           | **컴파일러(Compiler)** | **인터프리터(Interpreter)**          |\n| :---------: | :----------------------: | :------------------------------------: |\n| 번역 단위 | 전체                   | 한 줄 마다                           |\n| 실행 속도 | 빠름                   | 느림                                 |\n| 번역 속도 | 느림                   | 빠름                                 |\n| 목적 코드 | 생성 O                 | 생성 X                               |\n| 예시      | C, C++, Java Compiler  | Python, JavaScript, Java Interpreter | \n\n\u003cbr\u003e\n\n위의 표를 보면 실행 속도와 번역 속도에 차이가 있음을 볼 수 있다. 인터프리터는 한 줄, 행마다 번역을 하기 때문에 번역 자체는 빠르지만, **프로그램 전체적으로 봤을 때, 번역 -\u003e 실행, 번역 -\u003e 실행의 과정을 반복하기 때문에 실행 속도는 컴파일러보다 느리게 되는 것이다.**\n\n따라서, 컴파일과 인터프리터는 각각 장단점이 있어서, 사용하는 상황과 용도에 따라서 선택하게 된다. 컴파일러는 실행 파일이 빠르고 안정적이지만, 번역하는데 시간이 걸리며, 수정이 어렵다. 인터프리터는 실행 파일이 빠르지 않고, 수정이 쉽지만, 오류를 찾는데 시간이 걸리고, 실행 중에 성능에 영향을 줄 수 있다.\n\n번역 기법의 장단점\n- 장점 : 실행 시간 효율성 제공 (한번 디코딩으로 반복 실행)\n- 단점 : 번역된 프로그램이 큰 기억 장치 요구 (I/O routine 등)\n\n인터프리터 기법의 장단점\n- 장점 : 줄마다 실행하므로 큰 기억 장치 요구하지 않음, 사용자 적응성(flexibility) 제공\n- 단점 : 실행 시간 효율성 떨어짐\n\n\u003cbr\u003e\n\n\u003e 컴파일러와 인터프리터는 다르지만, 확실하게 다르다고 경계선을 그을 수는 없다. 최근에는 컴파일러 방식, 인터프리터 방식을 섞어서 사용하기 때문이다.\n\n\u003cbr\u003e\n\n자바에서의 인터프리터에 관한 이야기는 [여기](brain/Java/JavaExecute)를 참고하자.","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/LanguageTheory":{"title":"프로그래밍 언어론","content":"\n\u003cbr\u003e\n\n프로그래밍 언어론은 ==**컴퓨터 프로그래밍 언어를 이론적인 측면에서 탐구하는 학문**==이다. 언어의 구문(Syntax), 의미(Semantics), 구조(Structure) 등을 분석하고 구셩 요소들이 언어의 특징과 동작을 어떻게 결정하는 지 연구한다. 대표적인 언어의 구문 표기법에는 [BNF](brain/CS/LT/BNF), [EBNF](brain/CS/LT/EBNF), [구문 도표](brain/CS/LT/SyntaxTable)가 있다.\n\n프로그래밍 언어 구현 기법에는 [컴파일러](brain/CS/LT/Compiler)를 이용한 [번역 기법 Compile](brain/CS/LT/Compile), [인터프리터 기법](brain/CS/LT/Interpreter), 하이브리드 기법이 있다. Java가 하이브리드 기법에 해당하므로, 이는 [Java의 실행원리](brain/Java/JavaExecute)를 참고하도록 하자.","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/Lex":{"title":"Lex","content":"\n\u003cbr\u003e\n\n==**Lex(A Lexical Analyzer Generator)는 입력 스트립에서 정규 표현식(regular expression)으로 기술된 토큰들을 찾아내는 프로그램을 작성하는데 유용한 도구이다.**== Lex 소스는 정규 표현식 및 해당하는 프로그램의 조각의 테이블이다. 그 테이블은 입력 스트림을 읽어서 출력 스트림으로 복사하고, 입력을 주어진 표현식에 매칭되는 문자열로 분할하는 프로그램으로 변환된다.\n\n![](brain/image/Lex-1.png)\n\n보통 Lex scanner와 Yacc parse는 같이 구현하는 경우가 대부분이다. [Yacc](brain/CS/LT/Yacc)가 Lex의 상위에서 구현된다. Lex는 입력문자열에 대한 일차적인 검색을 하고 실제적인 분석은 Yacc가 하는 것이다. ","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/ParseTree":{"title":"파스 트리","content":"\n==**파스트리(Parse Tree)란 BNF 문법을 이해하기 쉬운 구조로 나타낸 것으로, 원시 프로그램의 문법을 검사하는 과정에서 내부적으로 생성되는 트리 형태의 자료구조이다.**== \n\n![](brain/image/ParseTree-1.png)\n\n\u003cbr\u003e\n\n파스트리는 **모호성, 결합성의 우선순위**에 따라 서로 다른 유도과정을 거쳐 트리를 생성해낸다. 예를 들어, `B33`이라는 letter, digit, digit을 유도한다면\n\n1. `\u003cidentifier\u003e` → `\u003cidentifier\u003e \u003cdigit\u003e` → `\u003cidentifier\u003e 3` → `\u003cidentifier\u003e \u003cdigit\u003e 3` → `\u003cidentifier\u003e 3 3` → `\u003cletter\u003e 3 3` → B33\n\n2. `\u003cidentifier\u003e` → `\u003cidentifier\u003e \u003cdigit\u003e` → `\u003cidentifier\u003e \u003cdigit\u003e \u003cdigit\u003e` → `\u003cletter\u003e \u003cdigit\u003e \u003cdigit\u003e` → `B \u003cdigit\u003e \u003cdigit\u003e` → `B 3 \u003cdigit\u003e` → B33\n\n![](brain/image/ParseTree-2.png)\n\n\u003cbr\u003e\n\n그런데, 만약 뺼셈과 곱셈이 있는데 모호성이 발생한다면 어떻게 될까? 곱셈이 먼저 되어야 하는데 뺄셈이 먼저 될 수도 있으므로, 우선순위를 명확하게 하여 모호성을 제거하고 파스 트리를 만들어야 한다.\n\n\u003cbr\u003e\n\n추가적으로, `\u003cidentifier\u003e \u003cdigit\u003e`는 가능하지만 `\u003cdigit\u003e \u003cidentifier\u003e`는 안된다. 이는 변수명에 `sum5`는 되지만, `5sum`은 안되는 것을 의미한다.","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/SyntaxTable":{"title":"구문도표","content":"\n\u003cbr\u003e\n\n==**구문 도표(Syntax diagram)는 형태가 순서도와 유사하다. 그림(도표)으로 구문을 표현하는 것이다.**== 구문 도표는 EBNF와 일대일 대응되며, 초기 프로그래밍 언어 Pascal(파스칼)의 사용자 설명서에 사용되었다.\n\n- 다시 정의될 대상은 네모칸, 단말 기호는 원이나 타원형으로 표시, 이들 사이는 지시선으로 연결\n\n\u003cbr\u003e\n\n|  **도형**  |  **의미**   |\n|:----------:|:-----------:|\n| □ (사각형) | 비단말 기호 |\n|   ○ (원)   |  단말 기호  |\n| → (화살표) |  기호 연결  | \n\n\u003cbr\u003e\n\n![](brain/image/SyntaxTable-1.png)\n\n-   **BNF** : **\u003cif문\u003e ::=** **if \u003c논리식\u003e then \u003c문장\u003e | if \u003c논리식\u003e then \u003c문장\u003e else \u003c문장\u003e**\n-   **EBNF** : **\u003cif문\u003e ::= if \u003c논리식\u003e then \u003c문장\u003e [ else \u003c문장\u003e ]**","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/LT/Yacc":{"title":"Yacc","content":"\n\u003cbr\u003e\n\n==**Yacc(Yet Another Compiler-Compiler)는 컴퓨터 소프트웨어로 유닉스 시스템의 표준 Parser Generator이다.**== Yacc에서 Parse Tree를 생성할 때 Bottom-up (LR)을 채택하고, 그중에서도 LALR(Look-Ahead LR) parser 방식을 채택한다. 단순 LR 방식에서 선행예측을 하는 것이다.\n\n![](brain/image/Yacc-1.png)\n\n![](brain/image/Yacc-2.png)\n\n![](brain/image/Yacc-3.png)\n\n\u003cbr\u003e\n\nYacc는 입력에 대한 토큰(token)이 필요하면, [Lex](brain/CS/LT/Lex)에서 제공하는 `yylex()`함수를 호출하여, 입력된 토큰들의 배열이 주어진 문법에 맞는지를 체크하면서 그 조건에 맞는 실행을 하게 된다. 다르게 표현하면, Lex와 Yacc을 사용 동시에 사용할 시에는 yacc 기술파일의 main()함수에서 yyparse()함수라는 yacc에 의해 만들어지는 구문분석기를 부르고, yyparse()함수는 yylex()라는 lex가 만들어 주는 해석기(lexer)를 이용해서 입력열에서 처리단위의 토큰을 뽑아오게 된다.","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Network/":{"title":"Network","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/Network/Socket":{"title":"소켓","content":"\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/OS/":{"title":"Operating System","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/OS/Scheduling":{"title":"스케줄링","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CS/OS/SystemCall":{"title":"시스템콜","content":"\n\u003cbr\u003e\n\n==**시스템 콜(System Call)이란, 응용 프로그램과 하드웨어 사이에서 운영체제(OS)에 동작을 요청하는 함수 또는 동작들에 대한 인터페이스이다. 하드웨어를 간접제어하고 OS가 관리하는 정보에 접근하도록 요청하는 규약을 정의한 것을 의미한다.**==\n\nOS는 다양한 서비스 들을 수행하기 위해 하드웨어를 **직접적**으로 관리한다. 반면, 응용 프로그램은 OS가 제공하는 인터페이스를 통해서만 자원을 사용할 수 있다. **OS가 제공하는 이러한 인터페이스를 '시스템 콜 (system call)' 이라고 한다.**\n\n운영체제 커널이 제공하는 함수를 호출하여 운영체제 서비스를 이용하는데, 이러한 운영체제 서비스는 일반적으로 하드웨어와 직접적인 상호작용을 필요로 하는 기능들이며, 프로그램에서 직접 접근할 수 없는 보호된 자원에 대한 접근을 허용한다.\n\n- 사용자가 하드웨어를 직접 제어할 수 없음\n- 사용자와 하드웨어의 중간의 운영체제(OS)가 하드웨어 제어를 대신 해줌\n- 시스템 콜(System Call)은 운영체제의 기능을 호출하는 인터페이스로서, API의 일종이다. ==다만, 시스템 콜은 **운영체제의 기능을 호출하는 데에만 사용**되며, 운영체제의 다른 기능들을 호출하는 API와는 구분된다.==\n\n\u003cbr\u003e\n\n![](brain/image/SystemCall-1.png)\n\n위 그림처럼 운영체제(OS)는 메모리에 프로그램 적재, I/O처리, 파일시스템 처리 등 여러 서비스들을 제공하는데 **사용자 프로세스는 이에 직접적인 접근이 아닌 시스템 콜 호출을 통해 서비스를 제공받을 수 있다.** 이때, 직접적으로 System Call을 사용하기보다는 [API](brain/Common/API) (라이브러리 함수)를 통해 사용하게 된다.\n\n![](brain/image/SystemCall-2.png)\n\n\u003cbr\u003e\n\n시스템 콜은 크게 6가지로 분류할 수 있다.\n\n1. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e프로세스 제어 (Process Control)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- 끝내기(exit), 중지(abort)\n\t- 적재(load), 실행(excute)\n\t- 프로세스 생성(CreateProcess) - fork()\n\t- 프로세스 속성 획득과 속성 설정\n\t- 시간 대기 (wait time)\n\t- 사건 대기 (wait event)\n\t- 사건을 알림 (signal event)\n\t- 메모리 할당 및 해제 (malloc, free)\n\t\n\t\u003c/details\u003e\n\n2. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e파일 조작 (File Manipulation)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- 파일 생성(create), 삭제(delete)\n\t- 열기 / 닫기 / 읽기 / 쓰기 (open, close, read, write)\n\t- 위치 변경 (reposition)\n\t- 파일 속성 획득 및 설정 (get file attribute, set file attribute)\n\t\n\t\u003c/details\u003e\n\n3. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e장치 관리 (Device Manipulation)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- 하드웨어의 제어와 상태 정보를 얻음 (ioctl)\n\t- 장치를 요구(request device), 장치를 방출 (release device)\n\t- 읽기 / 쓰기 / 위치변경 (read, write, reposition)\n\t- 장치 속성 획득 및 설정\n\t- 장치의 논리적 부착 및 분리 (attach, detach)\n\t\n\t\u003c/details\u003e\n\n4. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e정보 유지 (Information Maintenance)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- getpid(), alarm(), sleep()\n\t- 시간과 날짜의 설정과 획득 (time)\n\t- 시스템 데이터의 설정과 획득 (date)\n\t- 프로세스 파일, 장치 속성의 획득 및 설정\n\t\n\t\u003c/details\u003e\n\n5. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e통신 (Communication)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- pipe(), shm_open(), mmap()\n\t- 통신 연결의 생성, 제거\n\t- 메시지의 송신, 수신\n\t- 상태 정보 전달\n\t- 원격 장치의 부착 및 분리\n\t\n\t\u003c/details\u003e\n\n6. \u003cdetails\u003e\n\t\u003csummary\u003e\u003cstrong\u003e보호 (Protection)\u003c/strong\u003e\u003c/summary\u003e\n\t\n\t- chmod()\n\t- umask()\n\t- chown()\n\t\n\t\u003c/details\u003e\n\n\u003cbr\u003e\n\n위 사진을 보면 Windows와 Unix에서 인터페이스를 구현한 함수의 모양이 다른 것을 알 수 있다. 당연하게도 **인터페이스는 사양만 정의해놓은 것이라 동일한 인터페이스에 대한 구현은 OS마다 차이가 있을 수 있는 것**이다.\n\n시스템 콜을","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CodeTree/":{"title":"코드트리","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CodeTree/basic":{"title":"개요","content":"\n코딩테스트를 진행함에 있어서, 잊어버리기 쉬운 기본 내용 정리\n\n- [입출력](brain/CodeTree/inputoutput.md)\n- [수학](brain/CodeTree/math.md)\n- [문자열](brain/CodeTree/string.md)\n- [자료구조](brain/CodeTree/dataStructure.md)\n- [DP](brain/CodeTree/dp.md)\n- [그래프 탐색](brain/CodeTree/graph.md)\n\n\u003chr\u003e\n\n\u003cbr\u003e\n\n## 시간복잡도\n\n\u003cbr\u003e\n\n![](brain/image/p1-ch02-1.png)\n\n\u003cp align=\"center\"\u003e\u003cstrong\u003eO(1) \u003c O(log\u003csub\u003e2\u003c/sub\u003en) \u003c O(n) \u003c O(n log\u003csub\u003e2\u003c/sub\u003en) \u003c O(n\u003csup\u003e2\u003c/sup\u003e) \u003c O(2\u003csup\u003en\u003c/sup\u003e)\u003c/strong\u003e\u003c/p\u003e\n\n\u003cbr\u003e\n\n참고로 $log N$은 상용로그가 아닌 밑이 2\n\n$N \u003c= 10$\n- 시간 복잡도 $O(N!)$, $O(2^N)$, $O(3^N)$\n\n$N \u003c= 20$\n- 시간 복잡도 $O(2^N)$\n\n$N \u003c= 100$\n- 시간 복잡도 $O(N^4)$\n\n$N \u003c= 500$\n- 시간 복잡도 $O(N^3)$\n\n$N \u003c= 1,000$\n- 시간 복잡도 $O(N^2)$, $O(N^2 logN)$\n\n==$N \u003c= 100,000$==\n- ==시간 복잡도 $O(N)$, $O(N log N)$, $O(log N)$, $O(1)$==\n\n\u003chr\u003e\n\n\u003cbr\u003e\n\n## 공간복잡도\n\n![](brain/image/basic-1.png)\n\n```\nint a[2천만] : 80MB\nint a[2백만] : 80 / 10 = 8MB\nchar a[2천만] : 80 / 4 = 20MB\ndouble a[2천만] : 80 * 2 = 160MB\n```","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CodeTree/binarySearch":{"title":"이진탐색","content":"\n코드트리(Codetree)의 \u003ca href='https://www.codetree.ai/curriculums/6' target='_blank'\u003eNovice High - 자료구조 알고리즘\u003c/a\u003e을 정리한 내용입니다.\n- 그림은 해당 내용을 참고하여 그렸습니다.\n\n\u003chr\u003e\n\n## Binary Search\n\n- 찾아야 하는 수의 범위 중 가운데 값과 찾고자 하는 값을 비교하여 대소 관계에 따라 특정 구간으로 이동 반복\n- left는 `mid + 1`이고, right는 `mid - 1`인 이유\n\t- mid는 target을 포함할 숫자 범위에서 명확히 제외해야하니까\n- 시간 복잡도\n\t- 정렬된 상태 : ==**$O(log N)$**==\n\t- 정렬되지 않은 상태 : ==**$O(N log N + log N)$**==\n\t- \n\n```python\nfunction binary_search(arr, target)\n\tset left = 0\n\tset right = arr.size - 1\n\twhile (left \u003c= right)\n\t\tset mid = (left + right) / 2\n\t\tif arr[mid] == target\n\t\t\treturn mid\n\n\t\tif arr[mid] \u003e target\n\t\t\tright = mid - 1\n\t\telse\n\t\t\tleft = mid + 1\n\n\treturn -1\n```\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CodeTree/dataStructure":{"title":"자료구조","content":"\n코드트리(Codetree)의 \u003ca href='https://www.codetree.ai/curriculums/6' target='_blank'\u003eNovice High - 자료구조 알고리즘\u003c/a\u003e을 정리한 내용입니다.\n- 그림은 해당 내용을 참고하여 그렸습니다.\n\n\u003chr\u003e\n\n## ArrayList\n\n\u003cbr\u003e\n\n```java\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tArrayList\u003cT\u003e list = new ArrayList\u003c\u003e();\n\t}\n}\n```\n\n- 정적 배열과는 다르게, 가변적인 배열인 ArrayList (동적 배열)\n- `add(E)` : 맨 뒤에 데이터 E를 추가\n- `remove(index)` : index 위치에 있는 원소 삭제\n- `size()` : ArrayList에 들어있는 데이터 수 반환\n- `get(index)` : index 위치에 있는 원소 반환\n- 삽입, 삭제, 탐색 시간 복잡도는 정적 배열과 동일\n\t- 삽입 : ==**$O(N)$**==\n\t- 삭제 : ==**$O(N)$**==\n\t- 탐색 : ==**$O(1)$**==\n\t\t- Index 기반 ==**$O(1)$** ==\n\t\t- Data 기반 ==**$O(N)$**==\n\n\u003e [!note] **정적 배열 시간복잡도 (동적 배열과 동일)** \u003cbr\u003e\n\u003e - 삽입 : ==**$O(N)$**==\n\u003e - 삭제 : ==**$O(N)$**==\n\u003e - 탐색 : ==**$O(1)$**==\n\u003e - Index 기반으로 접근할 시 원하는 원소에 바로 접근할 수 있기 때문에 ==**$O(1)$** ==\n\u003e - Data 기반으로 접근할 시 조건에 만족하는 Data를 찾지 못한다면 모든 원소를 한번씩 탐색해야 하기 때문에 ==**$O(N)$**==\n\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## LinkedList\n\n\u003cbr\u003e\n\n```java\nimport java.util.LinkedList;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedList\u003cT\u003e ll = new LinkedList\u003c\u003e();\n    }\n}\n```\n\n- `addFirst(E)` : 맨 앞에 데이터 E 추가\n- `addLast(E)` : 맨 뒤에 데이터 E 추가\n- `pollFirst()` : 맨 앞에 데이터 반환하면서 리스트에서 제거\n- `pollLast()` 맨 뒤에 데이터 반환하면서 리스트에서 제거\n- `size()` : 데이터 수 반환\n- `isEmpty()` : list 비어있으면 true, 아니면 false\n- `peekFirst()` : 맨 앞에 데이터 반환\n- `peekLast()` : 맨 뒤에 데이터 반환\n\n\u003cbr\u003e\n\n![](brain/image/dataStructure-35.png)\n\n- 하나의 Node는 Data와 다른 Node로 이동하는 경로를 가지고 있음\n- 배열과는 다르게 삽입과 삭제가 자주 일어나는 상황에 용이\n\t- 삽입 : ==**$O(1)$**==\n\t- 삭제 : ==**$O(1)$**==\n\t- 탐색 : ==**$O(N)$**==\n- \u003ca href='/brain/CodingTest/dataStructure/#single-linked-list'\u003e단일 연결리스트 (Single Linked List)\u003c/a\u003e\n- \u003ca href='/brain/CodingTest/dataStructure/#double-linked-list'\u003e이중 연결리스트 (Double Linked List)\u003c/a\u003e\n\n\u003cbr\u003e\n\n### Single Linked List\n\n![](brain/image/dataStructure-36.png)\n\n- 연결 방향이 단방향\n- next에 null이 있으면 연결이 끊어진 상태\n\t- 즉, 이는 노드를 삭제하는 과정에서 유용함\n- ==`head` : 리스트가 시작되는 지점==\n\t- ex) 리스트의 모든 값을 탐색해야 하는 상황에 시작점을 모르면 모든 값을 탐색했는지 판단할 수 없으니까 head가 필요한 것\n- ==`tail` : 리스트가 종료되는 지점==\n\t- ex) 종료 지점을 명시해놓으면 탐색할 때 추가적인 처리 없이 현재 방문한 노드가 종료 지점인지 판단하는 과정만 거치고 탐색을 종료할 수 있음\n- 단일 연결리스트는 head → tail 단방향으로, tail에 도달하면 다시 뒤로 돌아갈 수 없음\n- 시간 복잡도\n\t- 삽입 : ==**$O(1)$**==\n\t- 삭제 : ==**$O(1)$**==\n\t- 탐색 : ==**$O(N)$**==\n\t\t- 탐색은 Head부터 Tail까지 일일이 확인해야함\n\n\u003cbr\u003e\n\n==**단일 연결리스트 tail 뒤에 신규 노드 삽입**==\n\n![](brain/image/dataStructure-37.png)\n\n```\nfunction SLL.insert_end(num)\n  set new_node = node(num)       # Step 1. 노드 만들기\n  SLL.tail.next = new_node       # Step 2. 이어 붙이기\n  SLL.tail = new_node            # Step 3. Tail 변경하기\n```\n\n\u003cbr\u003e\n\n==**단일 연결리스트 head 앞에 신규 노드 삽입**==\n\n![](brain/image/dataStructure-38.png)\n\n```\nfunction SLL.insert_front(num)\n  set new_node = node(num)       # Step 1. 노드 만들기\n  new_node.next = SLL.head       # Step 2. 이어 붙이기\n  SLL.head = new_node            # Step 3. Head 변경하기\n```\n\n\u003cbr\u003e\n\n==**단일 연결리스트 head 뒤에 신규 노드 삽입**==\n- head 바로 뒤에 노드를 추가하는 것은 조금 복잡함 \n- 연결을 아무 생각 없이 끊어버리게 되면 예상치 못한 결과가 나올 수 있어서\n\n1. 새로운 노드 생성\n\n\t![](brain/image/dataStructure-34.png)\n\n\u003cbr\u003e\n\n2. 새로운 노드의 next 값을 head의 next 값으로 설정\n\n\t![](brain/image/dataStructure-33.png)\n\n\u003cbr\u003e\n\n3. head의 next 값을 새로운 노드로 변경\n\n\t![](brain/image/dataStructure-32.png)\n\n\u003cbr\u003e\n\n4. 최종\n\n\t![](brain/image/dataStructure-31.png)\n\n\u003cbr\u003e\n\n```\nfunction SLL.insert_after_head(num)\n  set new_node = node(num)            # Step 1. 노드 만들기\n  new_node.next = SLL.head.next       # Step 2. 새로운 노드의 next 값 변경\n  SLL.head.next = new_node            # Step 3. Head의 next 값 변경\n```\n\n\u003cbr\u003e\n\n==**단일 연결리스트 삭제**==\n- 삭제하게 되는 노드의 ==**바로 전 노드**==에서 그 다음 노드로 연결관계를 바꿔줘야 한다는 것\n- ex) tail을 삭제하는 과정\n\t- tail 바로 전 노드의 next 값을 null로 변경\n\t- tail을 그 전으로 옮기기\n\n\u003cbr\u003e\n\n==**단일 연결리스트 tail 삭제**==\n\n![](brain/image/dataStructure-30.png)\n\n- tail 바로 전 노드의 next 값 → null로 변경\n- tail 옮기기\n\n\u003cbr\u003e\n\n==**단일 연결리스트 head 삭제**==\n\n![](brain/image/dataStructure-29.png)\n\n- head의 값을 head.next로 지정\n- 실제로 값을 삭제하지는 않았지만, 노드가 정상적으로 삭제된 것처럼 보임\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Double Linked List\n\n![](brain/image/dataStructure-28.png)\n\n- 연결 방향이 양방향\n- 삽입/삭제 시 앞/뒤 연결 모두 변경해야함\n\n\u003cbr\u003e\n\n![](brain/image/dataStructure-27.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Iterator\n\n- Iterator(반복자)는 연결리스트 내의 노드를 가리키는 역할\n- Iterator를 이용해 prev, next 값을 활용하여 특정 위치를 지정할 수 있음\n- 최초에 k번째 위치 찾는건 ==**$O(N)$**== 이후 바로 옆에 삽입/삭제/탐색은 ==**$O(1)$**==\n\n\u003cbr\u003e\n\n1. ==`hasNext()` 순회==\n\n```java\nimport java.util.LinkedList;\nimport java.util.ListIterator;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedList\u003cCharacter\u003e l = new LinkedList\u003c\u003e(); \n        l.add('a');             // l : ['a']\n        l.add('b');             // l : ['a', 'b']\n        l.add('c');             // l : ['a', 'b', 'c']\n\n        // Iterator를 이용한 list 내의 원소들 순회 (맨 앞에서 시작)\n        ListIterator\u003cCharacter\u003e it = l.listIterator();\n\n        while(it.hasNext())               // 'a' 'b' 'c'\n            System.out.print(it.next());  // next는 뒤로 이동하면서 값을 반환\n    }\n}\n```\n\n\u003cbr\u003e\n\n2. ==`hasPrevious()` 순회==\n\n```java\nimport java.util.LinkedList;\nimport java.util.ListIterator;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedList\u003cCharacter\u003e l = new LinkedList\u003c\u003e();\n        l.add('a');             // l : ['a']\n        l.add('b');             // l : ['a', 'b']\n        l.add('c');             // l : ['a', 'b', 'c']\n\n        // Iterator를 이용한 list 내의 원소들 순회 (맨 뒤에서 시작)\n        ListIterator\u003cCharacter\u003e it = l.listIterator(l.size());\n\n        while(it.hasPrevious())               // 'c' 'b' 'a'\n            System.out.print(it.previous());  // previous는 앞으로 이동하면서 값을 반환\n    }\n}\n\n```\n\n\u003cbr\u003e\n\n==**Iterator 주요 메서드**==\n\n- `next()`, `previous()`\n\t- `next()`는 뒤에서 ==앞으로== 이동\n\t- `next()`는 `hasNext()`가 true인 경우에만 사용\n\t- `previous()`는 앞에서 ==뒤로== 이동\n\t- `previous()`는 `hasPrevious()`가 true인 경우에만 사용\n- `remove()`\n\t- `next()`를 진행했던 원소 제거\n\t- ==`remove()`전에 `next()`가 반드시 선행되어야 함==\n- `add()`\n\t- iterator 위치에 새로운 원소 E 추가\n\n\u003cbr\u003e\n\n```java\nimport java.util.LinkedList;\nimport java.util.ListIterator;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedList\u003cCharacter\u003e l = new LinkedList\u003c\u003e(); \n        l.add('a');\n        l.add('b');\n        l.add('c');\n\n        // iterator를 list의 맨 앞에 위치시킴\n        ListIterator\u003cCharacter\u003e it = l.listIterator();\n        System.out.println(it.next());      // 원소 값을 한 칸 뒤로 이동 ('a')\n        System.out.println(it.next());      // 원소 값을 한 칸 뒤로 이동 ('b')\n        System.out.println(it.previous());  // 원소 값을 한 칸 앞으로 이동 ('b')\n        System.out.println(it.previous());  // 원소 값을 한 칸 앞으로 이동 ('a')\n\n        it.next();                          // remove 전에 next 필요\n        it.remove();                        // 원소 'a'를 제거\n        it.add('d');                        // 원소 'd'를 추가\n        \n        // list에 들어있는 원소 값을 순서대로 출력합니다.\n        it = l.listIterator();\n        while(it.hasNext()) {               // 'd' 'b' 'c' q\n            System.out.print(it.next());    // 원소 값을 출력하며 한 칸 뒤로 이동합니다.\n        } \n    }\n}\n\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Circular Linked List\n\n- 원형 연결리스트는 연결리스트를 원 형태로 구현한 모습\n- 기존 연결리스트의 head와 tail만 연결하면 됨\n- `head.prev = tail`이 되기에 굳이 tail을 들고 있을 필요가 없음\n- 그래서 보통 head만 놔둠\n- head에서 next를 계속 반복하면 다시 head에 도달함\n\n![](brain/image/dataStructure-26.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Stack\n\n\u003cbr\u003e\n\n```java\nimport java.util.Stack;\n\nStack\u003cT\u003e stack = new Stack\u003c\u003e();\n\n// Stack은 class, 구현체 그 자체 (Vector 상속)\n```\n\n- LIFO (Last In First Out)\n- 위에서부터 쌓아가는 자료구조\n- `push(E)` : E를 스택 맨 위에 넣기\n- `size()` : 스택에 쌓인 블럭 개수 반환\n- `isEmpty()` : 스택 맨 위에 비어있으면 true, 아니면 false\n- `peek()` : 스택 맨 위에 값 반환\n- `pop()` : 스택 맨 위에 값 반환하면서 블럭 제거\n- 삽입 삭제 시간복잡도 ==**$O(1)$**==\n\n```python\nfunction push(arr, E)\n  if arr.size == maxsize          // 배열에 이미 원소들이 가득 채워져 있으면\n    throw exception()             // 예외처리\n  arr.append(E)                   // 정상적인 상황이라면, E를 \n                                  // 마지막 위치에 추가\n\n\nfunction pop(arr) \n  if arr.size == 0                // 배열에 아무런 원소도 없다면\n    throw exception()             // 예외처리\n  set last = arr[arr.size - 1]    // 정상적인 상황이라면, 마지막 값을 변수에 저장\n  delete arr[arr.size - 1]        // 맨 끝에 있는 값을 실제로 제거\n  return last                     // 마지막에 있었던 값을 반환\n```\n\n\u003cbr\u003e\n\n\u003e [!note] 배열을 스택처럼 쓸 수 있음 \u003cbr\u003e\n\u003e - 배열의 삽입 삭제 시간 복잡도는 ==**$O(N)$**==\n\u003e - 만약, 배열의 맨 뒤에다가 값을 넣고 빼면 스택처럼 사용할 수 있겠네\n\u003e - 다만 그 공간은 남아있어야겠네\n\u003e - 혹은, 연결리스트를 써서 스택처럼 쓸 수도 있음 !\n\u003e - 연결리스트는 모든 연산에 대해 시간복잡도 ==**$O(1)$**== 이니까\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Queue\n\n\u003cbr\u003e\n\n```java\nimport java.util.Queue;\nimport java.util.LinkedList;\n\n// Queue는 interface, LinkedList는 class (구현체)\nQueue\u003cT\u003e queue = new LinkedList\u003c\u003e();\n\n// Queue\u003cT\u003e queue = new Queue\u003c\u003e();\n// 이렇게 작성 시 당연히 오류나겠지 ?\n```\n\n- FIFO (First In First Out)\n- `add(E)` : E를 맨 뒤(rear)에 추가\n- `size()` : 큐에 들어있는 데이터 개수 반환\n- `isEmpty()` : 큐가 비어있으면 true, 아니면 false\n- `peek()` : 맨 앞(front)에 있는 값 반환\n- `poll()` : 맨 앞(front)에 있는 값 반환하면서 제거\n- 삽입 삭제 시간복잡도 ==**$O(1)$**==\n\n\u003e [!note] 배열을 큐처럼은? \u003cbr\u003e\n\u003e - 배열 맨 앞에 삽입 + 맨 뒤에 삭제하면 시간복잡도 ==**$O(N)$**==\n\u003e - 큐처럼 쓰기에는 무리가 있음\n\u003e - 근데 맨 앞이나 뒤에서 삽입 삭제가 일어날 때 ==**$O(1)$**==인거 있잖아\n\u003e - → 연결리스트 !\n\n\u003e [!note] 큐를 스택처럼 사용하려면? \u003cbr\u003e\n\u003e - 큐 2개를 이용해서 사용 가능\n\u003e - 15 35 20 순서로 데이터 삽입\n\u003e - 스택은 15 35 20 (아래에서 위)\n\u003e - 첫 번째 큐는 20 35 15 (왼쪽에서 오른쪽)\n\u003e - 스택의 pop을 구현하기 위해, 첫번째 큐에서 가장 마지막에 들어온 20을 제외한 나머지를 두번째 큐로 이동하고 빼면 됨\n\n```\nfunction Stack.push(q, val)\n  q.push(val)\n\nfunction Stack.pop(q)\n  set new_q = empty queue\n  while q.size() != 1\n    new_q.push(q.pop())\n  set top = q.pop()\n  q = new_q\n  return top\n```\n\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Deque\n\n\u003cbr\u003e\n\n```java\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\npublic class Main {\n    public static void main(String[] args) {\n        Deque\u003cInteger\u003e dq = new ArrayDeque\u003c\u003e();\n    }\n}\n\n// Deque는 interface, ArrayDeque는 class (구현체)\n```\n\n- 덱은 스택과 큐의 특성을 합친 자료구조\n- 덱은 스택처럼 큐처럼 둘다 사용 가능, 메서드가 지원됨 (\u003ca href='https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/ArrayDeque.html' target='_blank'\u003e오라클\u003c/a\u003e)\n- ==맨 앞, 맨 뒤에서 삽입/삭제 모두 가능==\n- 삽입/삭제 시간복잡도 ==**$O(1)$**==\n- `addFirst(E)` : 맨 앞에 데이터 E 추가\n- `addLast(E)` : 맨 뒤에 데이터 E 추가\n- `pollFirst()` : 맨 앞에 데이터 반환하면서 덱에서 제거\n- `pollLast()` : 맨 뒤에 데이터 반환하면서 덱에서 제거\n- `size()` : 덱에 있는 데이터 개수 반환\n- `isEmpty()` : 덱이 비어있다면 true, 아니면 false 반환\n- `peekFirst()` : 맨 앞에 데이터 반환\n- `peekLast()` : 맨 뒤에 데이터 반환\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Vector, Stack 권장하지 않는 이유\n\n\u003cbr\u003e\n\n출처 : \u003ca href='https://vanslog.io/posts/language/java/why-use-deque-instead-of-stack/' target='_blank'\u003e[Java] 왜 Stack 대신 Deque를 사용하는가?\u003c/a\u003e\n\n\u003cbr\u003e\n\n| **비교**    | **Vector**  | **ArrayList** |\n| ----------- | ----------- | ------------- |\n| 동기화 처리 | O           | X             |\n| 쓰레드 안전 | O           | X             |\n| 성능        | 비교적 느림 | 비교적 빠름   |\n| 용량 증가   | 2배         | 1.5배              |\n\n- Vector\n\t- 동기화한 메서드로 구성되어 멀티스레드 환경에서 안전\n\t- 단일스레드 환경에서는 동기화 처리에 대한 오버헤드로 성능 하락\n- ArrayList\n\t- 동기화처리 하지 않으니 단일스레드 환경에서 성능 좋음\n\t- 멀티스레드 환경에서는 동기화 처리를 위해 `Collections.synchronizedList` 이용\n\n\u003cbr\u003e\n\n| **비교**    | **Stack**   | **ArrayDeque** |\n| ----------- | ----------- | -------------- |\n| 동기화 처리 | O           | X              |\n| 쓰레드 안전 | O           | X              |\n| 성능        | 비교적 느림 | 비교적 빠름               |\n\n- Vector, ArrayList와 Stack, ArrayDeque는 유사한 관계\n- 다만, ArrayDeque는 ArrayLIst 처럼 동기화처리를 위한 메서드 존재 X\n\t- `Collections.synchronizedDeque` 이런건 없음\n\t- 그러나, 아래의 코드처럼 멀티스레드 환경에서 동기화처리 가능\n\n```java\nclass SyncStack\u003cE\u003e {\n    private final Deque\u003cE\u003e stack = new ArrayDeque\u003c\u003e();\n\n    public synchronized void push(E e) {\n        stack.push(e);\n    }\n}\n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Tree\n\n![](brain/image/dataStructure-14.png)\n\n- **노드** : 각 지점, **정점**이라고도 부름\n\t- 루트 노드 : 트리에서 부모가 없는 최상위 노드, 트리의 시작점\n\t- 부모 노드 : 루트 노드 방향으로 직접 연결된 노드\n\t- 자식 노드 : 루트 노드 반대방향으로 직접 연결된 노드\n\t- 형제 노드 : 같은 부모 노드를 갖는 노드들\n\t- 리프 노드 : 차수가 0인 노드, 자식이 없는 노드, 단말 노드라고도 부름\n- **간선** : 두 노드를 연결하는 선, **엣지**\n- **차수** : 각 노드의 자식 개수\n- **깊이** : 루트 노드와 얼마나 떨어져있는지\n- **높이** : 트리에서 깊이가 가장 깊은 노드의 깊이\n- 레벨은 논문에 따라 0부터 시작하거나 1부터 시작하거나 둘 중 하나\n\n\u003cbr\u003e\n\n![](brain/image/dataStructure-15.png)\n\n- **Unrooted Tree**\n\t- 이렇게 부모-자식 관계가 정의되어있지 않아도 트리라고 부름\n\t- 트리의 원래 정의는 ==노드끼리 전부 연결되어 있으면서 사이클이 존재하지 않는 **그래프**==\n\t- 위의 그림처럼 루트 노드가 설정되어 있는 트리는 **Rooted Tree**\n\n\u003cbr\u003e\n\n![](brain/image/dataStructure-25.png)\n\n- 노드끼리 전부 연결되어있지 않거나, 사이클이 존재하므로 위의 예시는 **트리가 아님**\n\n\u003cbr\u003e\u003chr\u003e\n\n### Binary Tree\n\n![](brain/image/dataStructure-19.png)\n\n- **이진트리** : 자식의 수가 최대 2인 트리\n- 이진트리는 배열로 구현 가능\n- ==특정 노드의 위치 `i`인 경우, 그 노드의 왼쪽 자식은 `i * 2`, 오른쪽 자식은 `i * 2 + 1`==\n\t- ==그럼 자식의 입장에서 부모는? `i / 2` 겠네==\n\n```\n// 1은 루트노드\n// 2는 왼쪽 자식\n// 3은 오른쪽 자식\n\nIndex 0  1  2  3  4  5  6  7\nArray -  5  3  3  4  7  8  9\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n![](brain/image/dataStructure-20.png)\n\n- 방문하는 순서에 따라 탐색을 구현할 수 있음 (전위, 중위, 후위)\n- **전위 탐색 (Preorder Traversal)** : 부모 → 왼쪽 → 오른쪽\n\t- 1 - 2 - 5 - 4 - 3 - 6 - 8 - 7\n- **중위 탐색 (Inorder Traversal)** : 왼쪽 → 부모 → 오른쪽\n\t- 2 - 4 - 5 - 1 - 3 - 6 - 8 - 7\n- **후위 탐색 (Postorder Traversal)** : 왼쪽 → 오른쪽 → 부모\n\t- 4 - 5 - 2 - 8 - 6 - 7 - 3 - 1\n\n```\nfunction Preorder(n)\n\tvisit(n)\n\tPreorder(n.left)\n\tPreorder(n.right)\n\nfunction Inorder(n)\n\tInorder(n.left)\n\tvisit(n)\n\tInorder(n.right)\n\nfunction Postorder(n)\n\tPostorder(n.left)\n\tPostorder(n.right)\n\tvisit(n)\n```\n\n\u003cbr\u003e\u003chr\u003e\n\n### Binary Search Tree\n\n![](brain/image/dataStructure-21.png)\n\n![](brain/image/dataStructure-22.png)\n\n- 이진 탐색 트리의 특성\n\t- 부모의 왼쪽 방향에 있는 노드들은 전부 부모보다 값이 작음\n\t- 부모의 오른쪽 방향에 있는 노드들은 전부 부모보다 값이 큼\n\t- 시간 복잡도 (삽입/삭제/탐색)\n\t\t- 균형 잡히지 않은 이진 탐색 트리의 경우 : ==**$O(N)$**==\n\t\t- 균형 잡힌 이진 탐색 트리의 경우 : ==**$O(log N)$**==\n\t\t\t- ex) Red Black Tree, AVL Tree\n\t\t\t- 노드를 회전과 같은 작업을 통해 트리의 높이를 ==**$log N$**==으로 유지할 수 있음\n\t- **이진 탐색 트리를 중위 탐색하면 정렬된 순서대로 값이 나옴**\n\n\u003cbr\u003e\n\n- ==**이진 탐색 트리 - 탐색**==\n\n```\nfunction bst.search(x)\n    set node = bst.root                     // root에서 시작\n    while node != null and node.value != x  // node의 값 == x까지 계속 반복\n        if node.value \u003e x                   // node의 값 \u003e x이면\n            node = node.left                // 왼쪽 자식으로 내려와 탐색진행 \n        else                                // node의 값 \u003c x이면\n            node = node.right               // 오른쪽 자식으로 내려와 탐색진행\n    \n    return node                             // 최종 위치를 반환\n```\n\n\u003cbr\u003e\n\n- ==**이진 탐색 트리 - 삽입**==\n\t- 데이터 삽입 과정은, 부모를 계속 업데이트하면서 내려가면 됨\n\t- Case 1. 부모가 비어있는(null) 인 경우 → root를 node(x)로 설정\n\t- Case 2. 부모의 값이 삽입하려는 값보다 큰 경우 → 부모의 왼쪽에 node(x) 삽입\n\t- Case 3. 부모의 값이 삽입하려는 값보다 작은 경우 → 부모의 오른쪽에 node(x) 삽입\n\n```\nfunction bst.insert(x)\n    set node = bst.root          // root에서 시작\n    set parent = bst.root        // parent도 root로 설정하고 시작\n\n    while node != null           // node가 null이 되기 전까지 반복\n        parent = node            // parent는 node가 움직이기 직전 위치로 갱신 \n        if node.value \u003e x        // node의 값 \u003e x이면\n            node = node.left     // 왼쪽 자식으로 이동 \n        else                     // node의 값 \u003c x이면\n            node = node.right    // 오른쪽 자식으로 이동\n    \n    if parent == null            // Case 1. 비어있는 tree이면\n        bst.root = node(x)       // root를 node(x)로 설정.\n    else if parent.value \u003c x     // Case 2. parent의 값 \u003c x이면\n        parent.left = node(x)    // parent의 왼쪽에 node(x) 삽입\n    else                         // Case 3. parent의 값 \u003e x\n        parent.right = node(x)   // parent의 오른쪽에 node(x) 삽입\n\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n- ==**이진 탐색 트리 - 삭제**==\n\t- Case 1. 삭제하려는 값 노드의 왼쪽 노드가 비어있음 → 오른쪽 노드 올려주기\n\t- Case 2. 삭제하려는 값 노드의 오른쪽 노드가 비어있음 → 왼쪽 노드 올려주기\n\t- Case 3. 삭제하려는 값 노드의 왼쪽 오른쪽 노드 전부 채워짐 → successor 찾기\n\t\t- successor(후임자) : 현재 노드 기준으로 더 크면서 가장 작은 값을 갖는 노드\n\t\t- 현재 노드보다 크니까, 오른쪽부터 시작해서 왼쪽으로 계속 내려가면 됨\n\t\t- successor의 값을 node로 옮겨주고 successor의 오른쪽 자식을 전부 올려\n\t\t- successor가 노드 바로 오른쪽에 있으면 node 지우고 그대로 오른쪽 노드 전체를 위로 올려\n\n```\nfunction bst.search(x)\n    set node = bst.root                     \n    while node != null and node.value != x \n        if node.value \u003e x                \n            node = node.left           \n        else                               \n            node = node.right           \n    \n    return node            \n\n\nfunction bst.minimum(node)             // node 하위 트리에서 최솟값 구해\n    while node.left != null            // node.left != null이면 내려가\n        node = node.left\n    return node                        // 최종 node의 위치를 반환합니다.\n\n\nfunction bst.delete(x)                 // x를 찾아 삭제하는 함수\n    set node = bst.search(x)                // x 값 찾기\n    \n    if node.left == null               // Case1. node의 왼쪽자식 비어있으면\n        move(node.right, node)         // 오른쪽 자식을 위로 올려\n    else if node.right == null         // Case2. node의 오른쪽자식 비어있으면\n        move(node.left, node)          // 왼쪽 자식을 위로 올려\n    else                               // Case3. 왼쪽 오른쪽 자식이 풀이면\n        set succ = bst.minimum(node.right)  // successor를 구해\n        \n        // successor는 현재 노드의 오른쪽 자식에서 시작하여 계속 왼쪽으로 내려가면 됨\n        if succ == node.right          // successor가 노드의 오른쪽 자식이면 \n            move(node.right, node)     // 오른쪽 자식을 위로 올려\n        else                           // 그렇지 않은 일반적인 경우라면\n            node.value = succ.value    // node의 값 successor 값으로 대체\n            move(succ.right, succ)     // successor의 오른쪽 자식을 위로 올려\n\n```\n\n\u003cbr\u003e\u003chr\u003e\n\n### Heap\n\n- 힙은 이진 트리의 특별한 형태\n\t- 완전 이진트리 모양\n\t- 트리의 높이 ==**$log N$**==\n- 최대 힙(max-heap), 최소 힙(min-heap) 둘 중 하나\n- 특정 수가 추가되거나 삭제될 때, heap 구조를 유지하려면 ==**$O(log N)$**== 만큼 소요됨\n\t- ==**최대 최소값을 찾는 시간복잡도 $O(1)$이 가능하게 함**==\n\n\u003cbr\u003e\n\n**완전 이진 트리**\n\n![](brain/image/dataStructure-23.png)\n\n- 트리의 모든 값이 비는 것 없이 왼쪽부터 순서대로 차 있는 형태\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**최대 힙(max-heap)**==\n\n![](brain/image/dataStructure-24.png)\n\n- 완전 이진 트리를 띄면서, 모든 노드에 대해 부모 노드가 자신의 자식 노드가 갖는 값보다 같거나 큰 경우를 만족하는 경우\n- 루트 노드에는 전체 숫자 중 최댓값이 들어있음\n- 시간 복잡도\n\t- 최대 힙 만드는 데에 ==**$O(N)$**==\n\t- 최댓값 탐색 ==**$O(1)$**==\n\t- 삽입/삭제 ==**$O(log N)$**==\n\t\t- 완전 이진 트리에서의 삽입/삭제니까\n- 최대 힙에서의 삭제는 **루트 노드**에서만 가능\n- k번째 최댓값을 구할 수  ❌\n\t- 루트 노드를 제외하고 다른 원소가 어느 위치에 있는 지 알 수 없음\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**힙 만들기**==\n\n- $n / 2$번째 원소부터 거꾸로 1번째 원소까지 **heapify** 진행\n-  heapify : 현재 노드를 기준으로 heap 특성에 맞을 때까지 계속 밑으로 내려주는 과정\n\t1. `현재 노드 위치 = i` , `왼쪽 자식 노드 = i * 2` , `오른쪽 자식 노드 = i * 2 + 1` 세 노드 중 가장 큰 노드를 largest 라고 한다.\n\t2. `largest 노드`가 `i`가 아니라 자식 노드라면, `현재 노드(i)`와 `자식 노드(largest)`의 값을 교환\n\t3. 만약 `largest 노드`가 `현재 노드(i)` 이면 종료\n- 힙은 트리의 높이가 $log N$ 이니까 heapify 과정은 1번 일어날 때, 최대 $log N$번까지 가능\n- 최대 힙(max-heap) 만들 때, $n / 2$ 개의 원소에 대해 heapify 과정을 거침\n- 각 노드별로 최대로 움직이게 되는 횟수를 합해보면 시간복잡도 ==**$O(N)$**== 소요\n- 예시\n\n\t![](brain/image/dataStructure-39.png)\n\n\t- `n = 7` 이므로, `n / 2 = 3`이니까 `heapify(3)`부터 진행\n\t- `heapify(3)` 진행\n\t\t- largest 노드는 7번 노드이므로, 3번 노드와 교환하고 `heapify(7)` 진행\n\t\t- 다만, 7번 노드는 자식이 없으므로 heapify 종료\n\t- `heapify(2)` 진행\n\t\t- largest 노드는 5번 노드이므로, 2번 노드와 교환하고 `heapify(5)` 진행\n\t\t- 다만, 5번  노드는 자식이 없으므로 heapify 종료\n\t- `heapify(1)` 진행\n\t\t- largest 노드는 3번 노드이므로, 1번 노드와 교체하고 `heapify(3)` 진행\n\t\t- `heapify(3)`에서 다시 largest 노드가 6번 노드이므로, 3번 노드와 교체하고 `heapify(6)` 진행\n\t\t- 다만, 6번 노드는 자식이 없으므로 heapfiy 종료\n- 최종 모습\n\n\t![](brain/image/dataStructure-40.png)\n\n\u003cbr\u003e\n\n```\nfunction heapify(arr[], n, i)\n  set largest = i                     // 최대 노드를 i번이라 가정\n  set l = i * 2                       // 왼쪽 자식 노드 번호\n  set r = i * 2 + 1                   // 오른쪽 자식 노드 번호\n\n  if l \u003c= n \u0026\u0026 arr[l] \u003e arr[largest]  // 왼쪽 자식이 크면, 최대 번호를 수정\n    largest = l\n\n  if r \u003c= n \u0026\u0026 arr[r] \u003e arr[largest] // 오른쪽 자식이 크면, 최대 번호를 수정\n    largest = r\n\n  if largest != i                   // 최대 노드가 자식 노드라면\n    swap(arr[i], arr[largest])      // 해당 자식과 현재 노드를 교환\n    heapify(arr, n, largest)        // 내려간 위치에서 다시 heapify 진행\n```\n\n\u003cbr\u003e\n\n```\nfunction build_heap(arr[], n)\n  for i = n / 2 ... i \u003e= 1      // n / 2번째 원소부터 1번째 원소까지 돌며\n    heapify(arr, n, i)         // heapify 과정을 진행하여 max-heap 만듦\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**최대 힙 - 삽입**==\n\n- 트리 맨 끝에 삽입하고, 현재 노드 기준 부모와 값을 계속 비교하며, 부모가 더 작으면 교환\n- 삽입의 시간 복잡도는 트리의 높이와 관련, 따라서 ==**$O(log N)$**==\n\n```\nfunction insert(arr[], n, x)\n  arr.append(x)                          // 가장 끝에 노드 x를 추가\n\n  set i = n + 1                          // 마지막 노드에서 시작\n  while i \u003e 1 and arr[i / 2] \u003c arr[i]    // 부모가 자식보다 값이 작은 경우라면\n                                         // max-heap 조건에 어긋나므로\n    swap(arr[i], arr[i / 2])             // 두 값을 교환하고\n    i = i / 2                            // 부모 위치로 올라감\n```\n\n\u003cbr\u003e\n\n==**최대 힙 - 삭제**==\n\n- 루트 노드 값 삭제하면, 빈 자리가 남을 것\n- 빈 자리에 트리의 끝 값을 넣고 난 이후에도 max-heap 특성 유지해야하니까 heapify 진행\n- n번 노드를 1번 노드로 바로 올린 것이니까 반드시 **`heapify(1)`** 진행\n- heapify 과정의 시간 복잡도가 ==**$O(log N)$**== 이므로, 삭제 또한 마찬가지\n\n```\nfunction heapify(arr[], n, i)\n  set largest = i                     // 최대 노드를 i번이라 가정\n  set l = i * 2                       // 왼쪽 자식 노드 번호\n  set r = i * 2 + 1                   // 오른쪽 자식 노드 번호\n\n  if l \u003c= n \u0026\u0026 arr[l] \u003e arr[largest]  // 왼쪽 자식이 크면, 최대 번호를 수정\n    largest = l\n\n  if r \u003c= n \u0026\u0026 arr[r] \u003e arr[largest] // 오른쪽 자식이 크면, 최대 번호를 수정\n    largest = r\n\n  if largest != i                   // 최대 노드가 자식 노드라면\n    swap(arr[i], arr[largest])      // 해당 자식과 현재 노드를 교환\n    heapify(arr, n, largest)        // 내려간 위치에서 다시 heapify 진행\n\n\nfunction remove(arr[], n)\n  arr[1] = arr[n]                   // 가장 끝 노드를 루트 노드로 이동\n  delete arr[n]                     // 가장 마지막 노드를 삭제\n  heapify(arr, n - 1, 1)            // 루트 노드 기준으로 heapify를 진행\n                                    // max-heap 상태 계속 유지됨 \n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Hasing\n\n![](brain/image/dataStructure-41.png)\n\n- 해싱, 해시 함수\n\t- ==**들어온 \u0008순서 상관 없이** 삽입/삭제/탐색 자주 발생할 때 사용하기 좋음==\n\t- 임의의 데이터를 받아, 해당 데이터를 고정된 길이의 특정 값으로 반환하는 함수\n\t- 어떤 값을 넣더라도 특정 범위에 해당하는 값 반환\n\t- ex) 해시 함수의 반환값을 0부터 시작하는 양의 정수로 설정한 상황\n\t\t- 특정 값 → 해시함수 → 해시함수의 반환 값에 해당하는 인덱스 → 배열의 인덱스에 해당하는 위치에 값 저장\n\t- 해시 충돌 자체를 줄이기 위해, 일반적으로 들어갈 최대 데이터의 3~4배 정도의 크기로 해시 테이블을 설정함\n\t- 시간 복잡도 : 해시 함수를 1번만 통과하여 나온 인덱스만 관리하면 됨\n\t\t- 탐색 : ==**$O(1)$**==\n\t\t- 삽입 : ==**$O(1)$**==\n\t\t- 삭제 : ==**$O(1)$**==\n\n```\nfunction append(key, value)\n  set index = hash_function(key)\n  hash[index] = value\n  \nfunction find(key)\n  set index = hash_function(key)\n  if hash[index] != null\n    return hash[index]\n    \nfunction remove(key)\n  set index = hash_function(key)\n  if hash[index] == null\n    return \n  hash[index] = null\n```\n\n\n\u003e [!note] 해싱이 만능은 아니다 \u003cbr\u003e\n\u003e - 문자열, 숫자 등 대응 가능한 타입이 많다\n\u003e - 다만, 배열의 경우 배열 내 값의 개수가 불분명해서 해시 함수에서 배열을 다루지 않음\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**대표적인 해시 함수**==\n\n- \u003ca href='https://dbehdrhs.tistory.com/70' target='_blank'\u003e고니님 블로그\u003c/a\u003e 참조\n- \u003ca href='https://ratsgo.github.io/data%20structure\u0026algorithm/2017/10/25/hash/' target='_blank'\u003eratsgo's blog\u003c/a\u003e 참조\n- \u003ca href='https://velog.io/@stresszero/hash-table#%EC%B6%A9%EB%8F%8C-%ED%95%B4%EA%B2%B0-%EA%B8%B0%EB%B2%95' target='_blank'\u003e개발자 강세영\u003c/a\u003e 참조\n- \u003ca href='https://dev-kani.tistory.com/2' target='_blank'\u003e개발자 카니\u003c/a\u003e 참조\n\n1. **Division Method (제산법)** : 나눗셈과 나머지 연산자 이용, 입력 값(key)을 테이블의 크기로 나눈 나머지를 반환\n\t- `hash_index = key % M`\n\t- M은 해시 테이블의 크기인데, 소수(prime number)로 설정 시 해시 주소가 좋은 효율을 가짐\n\t\t- M이 짝수라면 메모리 주소는 대부분 짝수이므로, 해시 함수값 또한 짝수가 나올 것\t\n\t\t- 소수로 하게 된다면, 0 ~ M - 1을 골고루 사용하는 값을 만들어냄\n\t\t- 특히 2의 제곱수와 거리가 먼 소수를 사용한 해시 함수가 좋은 성능을 냄\n\n2. **Digit Folding (폴딩법)** : 입력 값(key)을 몇 개의 부분으로 나누어 더하거나 비트별로 XOR 연산하여 해시 주소로 사용\n\t- `hash_index = (short)(key ^ key \u003e\u003e 16)` \n\t- key가 문자열일 경우 ASCII 코드로 바꿔서 연산\n\u001f\n3. **Multiplication Method (곱셈법)** : 숫자로 된 입력 값(key)이 k이고, A는 0~1 사이의 실수일 때, 보통 2의 제곱수인 m을 활용하여 계산하고 해시 주소로 사용\n\t- `h(k) = (kA % 1) * m`\n\n4. **Mid-Square (중간 제곱법)** : 키 값을 제곱한 후에 중간의 몇 자리를 선택하여 그 중간 값을 해시 주소로 사용\n\n5. **Radix Conversion (기수 변환법)** : 입력 값(key)을 다른 진법으로 변환하여 얻은 값을 해시 주소로 사용\n\n6. **Digit Analysis(숫자 분석법)** : 입력 값(key) 각각의 위치에 있는 숫자 중 편중되지 않은 수들을 해시 테이블의 크기에 적합한 만큼 조합해 해시 주소로 사용\n\n7. **Universal Hasing (무작위 해싱)** : 다수의 해시함수를 만들고 이 해시함수의 집합 H에서 무작위로 해시함수를 선택해 해시 주소로 사용\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**대표적인 해시 알고리즘**==\n\n- MD(메시지 출력) 시리즈, SHA 시리즈, RIPEMD, WhirlPool\n- MD4 : MD5의 초기 버전으로, 입력 데이터(길이에 상관없는 하나의 메시지)로부터 128비트 메시지 축약을 만듦으로써 데이터 무결성을 검증하는데 사용되는 알고리즘\n- MD5 : 널리 사용된 해시 알고리즘이지만, 충돌 회피성에서 문제점 이 있다는 분석이 있으므로 기존의 응용과의 호환으로만 사용하고 더 이상 사용하지 않도록 하고 있음\n- SHA : 가장 많이 사용되고 있는 방식이다. SHA1은 DSA에서 사용하도록 되어 있으며 많은 인터넷 응용에서 default 해시 알고리즘으로 사용된다. SHA256, SHA384, SHA512 는 AES의 키 길이인 128, 192, 256 비트에 대응하도록 출력 길이를 늘인 해시 알고리즘이다.\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### Hash collision\n\n- \u003ca href='https://dev-kani.tistory.com/1' target='_blank'\u003e개발자 카니\u003c/a\u003e 참조\n\n![](brain/image/dataStructure-42.png)\n\n- ==**해시 충돌**==\n\t- 해시 함수를 적용해 생성된 배열의 고유한 index가 동일해서 충돌이 발생하는 상황\n\t- 가장 쉬운 해결 방법으로는 인덱스에 **연결 리스트**를 적용\n\t\t- 다만, 충돌 횟수가 증가하면 연결리스트를 순회해야해서 삽입/삭제/탐색 시간복잡도가 $O(N)$이 됨\n\t\t- 이렇게 되면 해싱을 써야할 이유가 없어짐\n\t\t- 결국 충돌이 최대한 덜 일어나게 적절한 해시 함수 적용하는 것이 중요\n\n\u003cbr\u003e\n\n- ==**해시 충돌 해결방법**==\n\t- Separata chaining (분리 연결법, 체이닝)\n\t- Open Addressing (개방 주소법)\n\n\u003cbr\u003e\n\n- ==**Separata chaining (분리 연결법, 체이닝)**==\n\t![](brain/image/dataStructure-44.png)\n\t- 연결 리스트를 사용하여 관리\n\t- 즉, 추가적인 메모리를 이용하는 방식\n\t- 연결 리스트가 쌓이면 탐색에 $O(N)$ 소요\n\t- 데이터가 채워짐에 따라 성능 저하 발생\n\n\u003cbr\u003e\n\n- Separata chaining 상세한 내용\n\t- 연결리스트를 이용하여 관리\n\t\t- key에 매핑된 index가 가리키는 LinkedList에 Node를 추가하여 Value 추가\n\t- 데이터의 주소 값(index)이 변경되지 않음\n\t- 부하율이 100%에 가까울수록 삽입/삭제/탐색의 효율이 매우 낮아진다.\n\t\t- 부하율 (Load Factor) : 전체 버킷에서 사용 중인 버킷의 비율\n\t- 해시 함수를 선택하는 관점에서 클러스터링(Clustering)에 거의 영향을 받지 않기에 충돌의 최소화만 중점적으로 보면 됨\n\t- 해시 테이블의 버킷이 채워져도 성능 저하가 선형적으로 발생\n\n\u003cbr\u003e\n\n- ==**Open Addressing (개방 주소법)**==\n\t![](brain/image/dataStructure-45.png)\n\t- 추가적인 메모리를 사용하는 Chaining 방식과 다르게 **비어있는 해시 테이블의 공간을 활용하는 방법**\n\t- ==선형 탐사법 (Linear Probing)== : 해시충돌 시 다음 버킷 또는 비어 있지 않다면 몇 개 건너뛰어 데이터를 삽입\n\t- ==제곱 탐사법 (Quadratic Probing)== : 해시충돌 시 제곱만큼 건너뛴 버킷에 데이터를 삽입\n\t- ==이중 해시법 (Double Hasing)== : 해시충돌 시 한번 더 적용해서 나온 버킷에 데이터 삽입\n\t- n차 충돌 발생 가능, 메모리 효율 높음, 다른 자료구조가 필요 ❌, 데이터가 적을 때 유리\n\t- 데이터 삭제 시, 삭제된 공간은 Dummy Space로 활용되기에 Hash Table을 재정리 해주는 작업이 필요\n\n\u003cbr\u003e\n\n- Open Addressing 상세한 내용\n\t- 연결 리스트(Linked List)같은 추가적인 메모리를 사용하지 않고 해시 테이블(Hash Table)의 빈 버킷(Bucket)을 이용하는 방법\n\t- 데이터의 주소 값(index) 바뀜\n\t\t- 충돌 발생 시, 다른 버킷에 저장하니까\n\t- 특히, 선형 검색법에서 체이닝 방식보다 뛰어난 참조 지역성(Locality of reference)을 가짐\n\t\t- 이러한 특성으로 LoopUp 연산에서 특히 좋은 성능\n\t- 테이블에 모두 저장될 수 있고, 캐시 라인에 적합할 수 있을 정도로 데이터의 크기가 작을수록 성능이 좋아짐\n\t- 삭제의 경우 충돌에 의해 뒤에 저장된 데이터가 검색되지 않을 수 있음\n\t\t- 이를 방지하기 위해 삭제한 위치에 Dummy Node를 삽입\n\t\t- Dummy Node는 실제 값을 가지지는 않지만, 검색할 때 다음 위치(인덱스)까지 연결해주는 역할\n\t\t- 삭제가 빈번히 일어날 경우 Dummy Node 수가 많아져서, 검색할 경우에 많은 버킷(Bucket)을 연속적으로 검색해야 하기 때문에 이 Dummy Node의 개수가 일정 수 이상이 되었을 경우에 주기적으로 새로운 배열을 만들려고 재해시(Rehash)를 해줘야 성능을 유지할 수 있음\n\n- Linear Probing 상세한 내용\n\t- 충돌 발생시 새로운 키(Key)를 저장할 기억공간을 찾기 위해 충돌이 일어난 그 위치에서 선형적으로 검색하여 첫 번째 빈 영역에 키를 저장하는 방법\n\t- 현재의 버킷 index로부터 고정된 폭만큼 이동하여 차례대로 검색\n\t- 테이블의 끝에 도달하게 되면 처음으로 되돌아 감\n\t- 조사를 시작한 위치로 되돌아 오게 되면 테이블이 가득찬 것\n\t- 장점 : 구조가 간단하고 캐시의 효율이 높음\n\t- 단점 : 최악의 경우 해시 테이블(Hash Table) 전체를 검색해야 하는 상황이 발생할 수 있으므로 비효율적이고, 데이터의 클러스터링(Clustering)에 가장 취약\n\n- Quadratic Probing 상세한 내용\n\t- Linear Probing에서 발생하는 제1밀집(primary clustering) 문제를 제거하는 방법\n\t- 같은 해시 값을 갖는 키(Key)에 대해서는 제2밀집(secondary clustering) 발생\n\t- 해시의 저장순서 폭을 제곱으로 저장하는 방식\n\t- 원래 저장할 위치로부터 1, 4, 9, 16, ... 과 같이 떨어진 영역을 차례대로 검색하여 첫번째 빈 영역에 키를 저장하는 방법\n\t- 캐시 효율과 클러스터링(Clustering) 방지 측면에서 Linear Probing과 Double Hashing의 중간 정도의 성능\n\n- Double Hasing 상세한 내용\n\t- 하나의 해시 함수(Hash Function)에서 충돌이 발생하면 2차 해시 함수를 이용해 검색 이동 거리를 얻는 방법\n\t- 캐시 효율은 떨어지지만 클러스터링(Clustering)에 영향을 거의 받지 않음\n\t- 가장 많은 연산량을 요구\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### Java Hash collision\n\n\u003ca href='https://d2.naver.com/helloworld/831311' target='_blank'\u003eNaver D2의 Java HashMap은 어떻게 동작하는가?\u003c/a\u003e 필수로 보기\n\n![](brain/image/dataStructure-43.png)\n\n- 각각의 Key 값에 해시함수 적용 이후 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하는데, 이때 ==**내부적으로 저장되는 배열을 버킷**==이라고 함\n- 서로 다른 key 들이 같은 hash를 가지는 경우 충돌함\n\n\u003cbr\u003e\n\n**HashTable 에서의 충돌**\n- `hf(key1) != hf(key2)` 이지만, `hf(key1) % M == hf(key2) % M` 인 경우\n- 즉, 서로 다른 key에 대하여 제산법을 적용시킨 결과가 동일한 경우\n\n\u003cbr\u003e\n\n**Hash Collision 발생 이유**\n- 완벽한 해시 함수 구현의 어려움\n\t- Boolean같이 서로 구별되는 객체의 종류가 적거나, Integer, Long, Double 같은 Number 객체는 객체가 나타내려는 값 자체를 해시 값으로 사용할 수 있기 때문에 완전한 해시 함수 대상으로 삼을 수 있음\n\t- 하지만 String이나 POJO(plain old java object)에 대하여 완전한 해시 함수를 제작하는 것은 사실상 불가능\n\t- → 그래서, 보조 해시 함수를 사용하기도 함\n- key의 크기에 비해, hash table의 크기가 작기 때문\n\n\u003cbr\u003e\n\n==**Java에서의 Hash Collision 해결**==\n- JDK 7 이전 : LinkedList를 사용한 **Separata Chaining 활용**\n- JDK 8 이후 : LinkedList와 Red-Black Tree를 혼용한 **Separata Chaining 활용**\n\t- 충돌을 한 key-value 쌍이 적을 때 : LinkedList로 작동\n\t- 충돌을 한 key-value 쌍이 임계치에 도달 : Red-Black Tree로 작동\n- LinkedList의 최악은 $O(N)$ 이지만, RBT의 최악은 $O(log n)$ 이니까 성능적으로 개선됐다고 볼 수 있음\n\n![](brain/image/dataStructure-46.png)\n\n- JDK 8에서는 슬롯(Slot)의 갯수가 8개 이하일 경우 연결 리스트(Linked List)를 사용하며 그 이상의 경우는 레드 블랙 트리(RBT) 구조를 사용하여 검색의 효율을 높임\n-  **부하율(Load Factor, 전체 버킷에서 사용중인 버킷의 비율)이 100%에 가까울수록 삽입, 삭제, 검색의 효율이 비약적으로 낮아진다**는 설명을 위에서 했었는데, 보통 80%로 제한한다.\n\t- Java의 HashMap의 경우에는 75%로 제한한다.\n\n\u003chr\u003e\n\n### HashMap\n\n\u003cbr\u003e\n\n```java\nimport java.util.HashMap;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tHashMap\u003cK, V\u003e m = new HashMap\u003c\u003e();\n\t}\n}\n```\n\n- `m.put(K, V)` : HashMap에 쌍(Key, Value) 추가\n- `m.remove(K)` : key가 K인 쌍을 찾아서 제거\n- `m.get(K)` : key가 K인 쌍을 찾아서 value인 V를 반환\n\t- `m.containsKey(K)` 를 확인하여 true 인 경우에만 get을 사용\n\t- 해당하는 쌍이 없으면 에러가 발생하기 때문\n\t- `m.getOrDefault(K, D)` 쓰면 해당하는 쌍이 없으면 D를 기본으로 반환해줌","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CodeTree/dp":{"title":"DP","content":"\n\u003chr\u003e\n\n## DP\n\n**DP (동적 계획법, Dynamic Programming)**\n- 큰 문제에 대한 답을 얻기 위해, 동일한 문제이지만 크기가 더 작은 문제들을 해결한 뒤, 그 결과들을 이용해 큰 문제를 비교적 간단하게 해결하는 기법\n\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CodeTree/graph":{"title":"그래프 탐색","content":"\n코드트리(Codetree)의 \u003ca href='https://www.codetree.ai/curriculums/6' target='_blank'\u003eNovice High - 자료구조 알고리즘\u003c/a\u003e을 정리한 내용입니다.\n- 그림은 해당 내용을 참고하여 그렸습니다.\n\n\u003chr\u003e\n\n## 그래프\n\n\n![](brain/image/graph-1.png)\n\n- 그래프(Graph) : \u0008노드와 간선의 집합으로 구성된 자료구조\n- 노드(Node) : 정점(Vertex), 각각의 지점\n- 간선(Edge) : 정점과 정점을 잇는 선\n- 간선의 가중치 : 간선에 값이 적혀져 있는 경우\n- 차수(Degree) : 연결된 정점의 수\n\t- 방향그래프의 경우 들어올 수 있는 정점의 수, 나갈 수 있는 정점의 수가 다름\n\t- 위 그림에서 3번 노드를 기준으로 생각\n\t- 무방향 그래프의 3번 노드 차수 : 3\n\t- 진입차수(In-degree) : 0\n\t- 진출차수(Out-degree) : 3\n- 특정 지점에서 출발하여 다시 본래의 지점을 돌아올 수 있는 경우 = 사이클이 존재한다\n- 연결 그래프 : 모든 정점들에 대해서 갈 수 있는 경로가 존재하는 경우\n- 비연결 그래프 : 갈 수 있는 경로가 존재하지 않는 경우\n- 연결요소 : 간선으로 연결되어 있는 정점들을 묵었을 때 나오는 그룹\n\t- 위의 예시에서는 두 그래프 모두 연결 요소가 1\n\t- 만약 비연결 그래프 형태로 하나의 선을 끊었다고 치면 2가 될 것\n\n\u003cbr\u003e\n\n### 그래프 구현\n\n- 그래프는 보통 ==**인접 행렬, 인접 리스트**== 2가지 방식으로 구현\n\t- 일반적으로 인접 행렬이 메모리를 더 많이 차지함\n\t- 특정 정점과 연결된 정점의 수를 확인하는 연산은 인접 리스트가 더 빠름\n\t\t- 인접 행렬은 모든 정점의 연결관계 확인하니까 ==**$O(|V|)$**==\n\t\t- 인접 리스트는 리스트의 크기만 보면 되니까\n\t- 특정 두 정점이 연결되었는지 확인하는 연산은 인접 행렬이 더 빠름\n\t\t- 인접 행렬은 2차원배열의 1칸을 확인하면 되니까 ==**$O(1)$**==\n\t\t- 인접 리스트는 정점에 해당하는 연결된 정점을 찾기 위해 모든 정점을 순서대로 확인해야해서 ==**$O(|V|)$**==\n\n\u003cbr\u003e\n\n**인접 행렬**\n\n![](brain/image/graph-2.png)\n\n- 정점의 수 $|V|$, 간선의 수 $|E|$\n- 인접 행렬 : $|V| * |V|$ 크기의 2차원 배열 만들어서 연결관계 표현\n- 시간 복잡도\n\t- 특정 정점 $I$, $J$ 연결되어 있는지 확인 : ==**$O(1)$**==\n\t- 특정 정점과 연결된 모든 정점 확인 : ==**$O(|V|)$**==\n\t- 공간 복잡도 : ==**$O(|V| * |V|)$**==\n\n\u003cbr\u003e\n\n**인접 리스트**\n\n![](brain/image/graph-3.png)\n\n- 3번 노드의 연결 리스트 길이는 2\n- 시간 복잡도\n\t- 특정 정점 $I$, $J$ 연결되어 있는지 확인 : ==**$O(min(degree(I), degree(J)))$**==\n\t- 특정 정점과 연결된 모든 정점 확인 : ==**$O(degree(X))$**==\n\t\t- X라는 정점에 해당하는 리스트의 크기, 연결된 정점의 수\n\t- 공간 복잡도 : ==**$O(|V| + |E|)$**==\n\n\u003cbr\u003e\u003chr\u003e\n\n## DFS\n\n**DFS (Depth First Search) : 깊이 우선 탐색**\n- 최대한 깊게 탐색한 후, 더 이상 도달할 수 없는 상황이라면 다시 이전으로 돌아감\n- DFS는 ==**재귀(스택)**==를 활용해 구현하는 경우가 많음\n\t- 방문할 수 있는 지점이 있다면 그 지점을 방문하는 함수를 **재귀적으로 호출**하고, 더 이상 방문할 곳이 없다면 함수를 종료\n- 이미 방문했던 지점을 또 방문하면 효율이 떨어지기 때문에 이전에 방문했던 지점은 다시 방문하지 않아야 함\n\t- 이런 처리를 위해, **visited라는 배열을 하나 만들어서** 그 번호를 갖고 있는 지점을 방문한 적이 있는지 확인하며 진행\n- 시간 복잡도\n\t- ==**$O(∣V∣+∣E∣)$**==\n\t- 어차피 모든 노드와 엣지를 방문하니까\n\n\u003cbr\u003e\u003chr\u003e\n\n## BFS\n\n![](brain/image/graph-4.png)\n\n**BFS (Breadth First Search) : 너비 우선 탐색**\n- 시작점을 기준으로 가장 가까운 정점부터 방문\n- BFS는 ==**큐**==를 활용해 구현함\n\t- 하나의 노드에 방문하면, 해당하는 노드와 인접한 노드 중 방문한 적 없는 노드를 전부 큐에 넣음\n\t- 큐는 FIFO 이니까, 이후에 처음 넣었던 노드의 이웃 노드를 순차적으로 방문\n- 시간 복잡도\n\t- ==**$O(∣V∣+∣E∣)$**==\n\t- 어차피 모든 노드와 엣지를 방문하니까\n\n\u003cbr\u003e\n\n```python\nfunction bfs(position)\n\tset Q = Queue\n\tQ.push(position)\n\tvisit(position)\n\twhile Q is not empty\n\t\tset node = Q.pop\n\t\tfor children of node\n\t\t\tif visitied[child] == false\n\t\t\t\tvisit(child)\n\t\t\t\tQ.push(child)\n```\n\n\u003cbr\u003e\n\n\u003e [!note] DFS와 BFS의 성능 차이 \u003cbr\u003e\n\u003e - 어차피 모든 노드와 엣지를 방문하니까 시간 복잡도는 동일\n\u003e - 그러나, 실제로는 DFS가 미묘하게 느림\n\u003e - 재귀함수의 오버헤드 때문 ! 그래도 별 차이는 없습니다 ~!\n\n\u003cbr\u003e\u003chr\u003e\n\n## 최단거리\n\n**BFS를 이용한 최단거리 구하기**\n- BFS의 동작 과정을 생각해보자\n- A를 방문했고, A의 이웃한 정점을 큐에다가 넣으면, 큐에 있는 모든 것들은 A와 거리가 1임\n- 1의 이웃들이 큐에 들어가면, 거리가 1이니까 A와의 거리는 2가 됨\n- ==**가중치만 전부 동일하다면**==, 방향 그래프에서도 동일하게 적용됨\n\n\u003cbr\u003e\n\n![](brain/image/graph-5.png)\n\n- 간선에 적혀있는 ==**가중치가 전부 동일하지 않다면,**== 최단거리 구하는 것이 복잡해짐\n- 실제로 1에서 2로 가는 최단거리는 4이다\n\t- BFS를 그냥 이용하면, 가장 인접한 노드부터 순차적으로 보니까 최단거리를 100이라고 판단함\n\t- 이를 해결하는 다양한 알고리즘이 존재 → ex) 다익스트라, 플로이드-워셜\n\n\u003cbr\u003e\n\n### Dijkstra\n\n**다익스트라 알고리즘**\n- ==**특정 시작점**==에서 ==**다른 모든 정점**==으로 가는 최단거리를 각각 구해주는 알고리즘\n- `특정 지점까지 거리 = A까지 가는 거리 + A에서 특정 지점까지 소요되는 거리`\n- ex) 5개의 정점이 있고, 1번 정점에서 출발한다고 치면 1번에서 2번~5번으로 가는 최단거리 구함\n- 시간 복잡도\n\t- 그래프 내의 정점의 수 $|V|$\n\t- 그래프 내의 간선의 수 $|E|$\n\t- ==**$O(|E| log |V|)$**==\n\t- 다익스트라 알고리즘을 진행하면 각 간선을 한 번씩 보게 되는데, 이때 dist값이 변하면 우선순위 큐에서의 순서가 계속 바뀌게 될 수도 있으므로 ==**간선의 수 × 우선순위 큐 이용**== 이 된 것\n\t- 우선순위큐 안쓰고 for문 쓰면 $O(V^2)$\n- 음수 가중치가 있을 때의 최단거리는 다익스트라로 구할 수 ❌\n\t- 다익스트라 자체가 최솟값을 고르면서 가는건데, 음수 때문에 꼬임\n\t- 음수 가중치가 있는 그래프의 최단거리를 구하려면 플로이드 와샬이나 벨만포드(2차원 DP)로 가능\n\n\u003cbr\u003e\n\n```\nfunction dijkstra(graph, source)              // 그래프, 시작점 정보\n    set Q = Queue()                           // 우선순위 큐 생성\n\n    for each vertex in graph                  // 그래프에 있는 모든 노드들\n        set dist[v] = INF                     // 초기값을 아주 큰 값으로 설정\n        Q.push(v)                             // 우선순위큐에 모든 노드 넣기\n\n    set dist[source] = 0                      // 시작점 dist 값을 0으로\n    while Q is not empty                      // 우선순위큐 빌 때 까지\n        set u = vertex in Q with min dist     // 우선순위 큐에서 dist값이 가장 작은 노드를 선택\n        Q.remove(u)                           // 우선순위 큐에서 해당 노드를 제거\n\n        for each neighbor v of u              // u번 노드와 연결된 노드들을 전부 살펴보면서\n            set alt = dist[u] + length(u, v)  // 현재 dist값에 간선 가중치를 더한 값을 계산하여\n            if alt \u003c dist[v]                  // 기존 dist값보다 더 alt값이 작다면\n                set dist[v] = alt             // dist값을 갱신\n\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**문제 : 5번을 시작점으로 하여, 다른 모든 정점에 도달하기 위한 최단거리 구하기**==\n\n![](brain/image/graph-6.png)\n\n\u003cbr\u003e\n\n==**1. 거리 배열을 전부 아주 큰 값인 INF로 설정, 출발지만 0으로**==\n\n![](brain/image/graph-7.png)\n\n\u003cbr\u003e\n\n==**2. 거리 배열 내의 값들 중 최솟값 고르기**==\n- 최솟값 고르는 과정 여러번 반복\n- 효과적으로 최솟값을 계속 찾기 위해 **우선순위 큐(최소힙)** 이용\n- 1번 정점 ~ 5번 정점 전부 우선순위 큐에 넣어서 최솟값 찾기\n\n![](brain/image/graph-8.png)\n\n\u003cbr\u003e\n\n==**3. 최솟값을 골랐으면, 시작점 ~ 뽑힌 노드까지의 거리는 정해졌으니 우선순위 큐에서 빼기**==\n\n![](brain/image/graph-9.png)\n\n\u003cbr\u003e\n\n==**4. 우선순위 큐에서 뺀 노드로부터 연결된 노드들 확인, 값 비교 이후 갱신**==\n- 뽑힌 노드가 5번이니 **`dist[5] + 간선에 적혀있는 값`** 과 **`해당 노드에 적혀있는 dist 값`** 중에 더 작은 값으로 갱신\n- `dist[5] + 4 \u003c dist[2]` → 4로 갱신\n- `dist[5] + 2 \u003c dist[4]` → 2로 갱신\n\n![](brain/image/graph-10.png)\n\n\u003cbr\u003e\n\n==**5. 그 다음 우선순위 큐에 담겨있는 노드 중 최솟값 고르고 반복**==\u0004\n- `dist[4] + 1 \u003c dist[2]` → 3로 갱신\n- `dist[4] + 2 \u003c dist[3]` → 4로 갱신\n\n![](brain/image/graph-11.png)\n\n![](brain/image/graph-12.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### Floyd-Warshall\n\n**플로이드-와샬 알고리즘**\n- 모든 쌍에 대해 최단거리를 구하는 알고리즘\n- 다익스트라와는 다르게, ==**모든 지점의 거리**==를 구하는 것\n\t- 다익스트라로 모든 지점을 확인하려면 각각의 지점에 대해 다익스트라를 1번씩 돌려야 함\n\t- 시간 복잡도가 for문 쓰면 $O(V^2)$, 우선순위큐 쓰면 $O(E log V)$ 였는데, V번 해야하니까 $O(V^3)$ 혹은 $O(VE log V)$가 되어버림\n\t- 만약, 그래프에 간선이 굉장히 많다면 $E = V^2$이 되므로, $O(V^3)$가 더 효율적일 수 있음\n- A → B 경로보다, A → X → B가 더 짧으면 그것으로 갱신해주는 방식\n- 시간 복잡도\n\t- 삼중 반복문 돌리므로 ==**$O(V^3)$**==\n\t- 상당히 비효율적이라서, 정점의 수가 많지 않거나 모든 쌍의 최단거리를 꼭 구해야 할 때만 쓰고, 안그런 경우라면 다익스트라로 필요 지점만 보는게 효율적\n- ==for문 i, j, k가 아니라 k, i, j 인거 유의==\n\n\u003cbr\u003e\n\n```\nfunction floyd(graph)\n    set dist = |V| * |V| array initialized to INF  // dist INF로 초기화\n    for each edge(u, v)                            // 모든 간선에 대해\n        dist[u][v] = length(u, v)                  // 간선 가중치 배열에 작성\n    for k = 1 ... |V|                              // 확실하게 거쳐갈 정점을 1번부터 V번까지 순서대로 정의\n        for i = 1 ... |V|                          // 고정된 k에 대해 모든 쌍 (i, j)를 살펴보기\n            for j = 1 ... |V|\n                if dist[i][j] \u003e dist[i][k] + dist[k][j]     // i에서 j로 가는 거리가 k를 경유해 가는 것이 더 좋다면\n                    dist[i][j] = dist[i][k] + dist[k][j]    // dist[i][j]값을 갱신\n    return dist\n\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**1. $V^2$ 크기의 배열(dist) 내에 모든 값 INF로 채우기**==\n\n![](brain/image/graph-13.png)\n\n\u003cbr\u003e\n\n==**2. 간선에 적혀져 있는 숫자들을 배열(dist)에 적기**==\n\n![](brain/image/graph-14.png)\n\n\u003cbr\u003e\n\n==**3. 노드1 ~ 노드N 까지 순서대로 경유했을 때를 가정**==\n- 모든 쌍(i, j)에 대해 노드 1을 경유하는 것이 더 좋은 경우 그 값을 갱신\n- **`dist[i][j] \u003e dist[i][1] + dist[1][j]`** 를 만족하는 경우 \n\t- **`dist[i][j]`에 `dist[i][1] + dist[1][j]`** 값을 넣기\n\n![](brain/image/graph-15.png)\n\n\u003cbr\u003e\n\n==**4. 노드2, 노드3, . . . , 노드N까지 똑같이 진행**==\n\n![](brain/image/graph-16.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### MST\n\n**MST (Minimum Spanning Tree) : 최소 신장 트리**\n- ==가중치의 합을 최소로 하는 Spanning Tree==\n- 최소한의 간선을 사용하여 그래프 내 모든 정점을 이어준다면, 그것을 Spanning Tree라고 한다\n\t- N개의 정점에 N-1개의 간선이 존재하는 트리\n\t- 노드끼리 전부 연결되어 있으면서 ==**사이클이 존재하지 않는**== 그래프를 트리라고 하니까\n\t- 가중치가 있을때 최소한의 비용을 사용한 Spanning Tree가 Minimum Spanning Tree\n- MST를 구할 때, 모양이 다를 수는 있어도 크루스칼이든 프림이든 MST를 구하기만 하면, ==**항상 MST의 가중치의 합은 동일함**==\n- 프림은 MST에 포함되지 않은 정점에 대해서만 동작하므로 사이클 만들어질 걱정 ❌\n- 크루스칼은 최소비용 간선 확인하면서 가니까 사이클 만들어질 걱정 🟢 → 그래서 union-find 진행\n\n\u003cbr\u003e\u003chr\u003e\n\n### Union-Find\n\n**Union Find : 합집합 찾기**\n- 여러 개의 원소가 있고 여러 개의 집합이 있을 때, ==**특정 원소가 어떤 집합에 속해있는지 확인하고, 특정 집합을 합쳐야 할 때 유용**==\n- ==**여러 개의 노드가 존재할 때, 두 개의 노드를 선택해서, 이 노드들이 서로 같은 그래프에 속하는지 판별할 때 유용 → 사이클 존재여부 !!**== \n\n\u003cbr\u003e\n\n```\nfunction union(x, y)\n  set X = find(x), Y = find(y)\n  uf[X] = Y\n\nfunction find(x)\n  if uf[x] == x        // x가 루트 노드라면\n    return x           // x 값을 반환\n  return find(uf[x])   // x가 루트 노드가 아니라면, x의 부모인 uf[x]에서 더 탐색을 진행\n```\n\n\u003cbr\u003e\n\n![](brain/image/graph-17.png)\n\n- 모든 노드가 연결되어 있지 않은 상태에서 시작\n- uf 배열의 초기값은 자기 자신\n- 처음에는 모든 노드가 전부 다른 그룹에 있음\n\t- `uf[x]`는 부모 노드를 가리킨다고 보면 됨\n\t- 현재 초기화한게 `x == uf[x]` 이니가 모두가 본인이 루트노드라고 초기화한 것\n\n\u003e [!note] union(X, Y) \u003cbr\u003e\n\u003e X 부모에다가 Y 부모 넣는다고 생각하면 됨\n\n\n\u003cbr\u003e\n\n**1번 예시 - `union(1, 3)`**\n\n![](brain/image/graph-18.png)\n\n- `union()` 연산 사용 → 두 노드가 같은 그룹임을 표시할 수 있음\n- ex) 1번 노드와 3번 노드 연결 → `uf[1]`에 3을 적으면 됨\n- `union(1, 3) = find(1), find(3)`\n- `find(1) = 1`\n- `find(3) = 3`\n- `uf[1] = 3`\n\n\u003cbr\u003e\u003cbr\u003e\n\n**2번 예시 - `union(5, 6)`**\n\n![](brain/image/graph-19.png)\n\n- `union(5, 6)` → 5번 노드와 6번 노드 연결, `uf[5]`에 6을 적으면 됨\n- union을 이용해 두 노드를 합치게 되면 ==**uf 배열의 값은 그룹으로서의 의미 뿐만이 아니라, 실제 노드가 현재 가리키고 있는 부모 노드의 번호가 됨**==\n- `union(5, 6) = find(5), find(6)`\n- `find(5) = 5`\n- `find(6) = 6`\n- `uf[5] = 6`\n\n\u003cbr\u003e\u003cbr\u003e\n\n**3번 예시 - `union(5, 1)`**\n\n![](brain/image/graph-21.png)\n\n- `find()` 과정 수행 → 두 노드 모두 부모 노드를 따라 올라 갈 수 있는데 까지 계속 올라가기\n\t- `x`와 `uf[x]` 가 같아지기 전까지 올라가는 것\n\t\t- `x == uf[x]` 라는 말은 x가 루트 노드 라는 것\n\t- `find(5) = 6` → `find(6) = 6`\n\t- `find(1) = 3` → `find(3) = 3`\n\t- ==골라진 루트 노드가 `X`, `Y` 라면, `uf[X]`에 `Y`를 넣으면 됨==\n\t- `uf[6] = 3`\n\n\u003cbr\u003e\u003cbr\u003e\n\n**4번 예시 - `union(4, 1)`**\n\n![](brain/image/graph-22.png)\n\n- 왼쪽에다가 오른쪽 넣기\n- `union(4, 1) = find(4), find(1)`\n- `find(4) = 4`\n- `find(1) = 3`\n- `uf[4] == 3`\n\n\u003cbr\u003e\n\n==**Union Find 시간 개선**==\n\n![](brain/image/graph-23.png)\n\n![](brain/image/graph-24.png)\n\n- 모든 집합들이 합쳐져 있다고 가정하면, 부모를 찾다보면 결국 $O(N)$이 소요될 것\n- find를 호출할때 조상을 찾아내면, **현재 값의 부모값을 조상으로 바꿔버리는 방식으로 최적화**\n- `find()`가 호출될 때마다 탐색했던 모든 노드가 전부 root로 붙게 되어 깊이가 전부 1로 바뀌게 되므로, 이후 동일한 노드를 탐색하게 될 경우 시간이 거의 소요되지 않음\n\t- 이러한 방법을 ==**경로 압축(Path Compression)**== 이라고 함\n\t- 시간 복잡도 : ==**$O(log N)$**==\n\n\u003cbr\u003e\n\n**기존의 `find()`**\n\n```\nfunction find(x)\n  if uf[x] == x        // x가 루트 노드라면\n    return x           // x 값을 반환\n  return find(uf[x])   // x가 루트 노드가 아니라면, x의 부모인 uf[x]에서 더 탐색을 진행\n```\n\n\u003cbr\u003e\n\n**개선된 `find()`**\n\n```\nfunction find(x)\n  if uf[x] == x                 // x가 루트 노드라면\n    return x                    // x 값을 반환\n  set root_node = find(uf[x])   // x가 루트 노드가 아니라면, x의 부모인 uf[x]에서 더 탐색을 진행\n  uf[x] = root_node             // 노드 x의 부모를 루트 노드로 설정\n  return root_node              // 찾아낸 루트 노드를 반환\n```\n\n\u003cbr\u003e\u003chr\u003e\n\n### Kruskal\n\n**Kruskal : 크루스칼 알고리즘**\n- 크루스칼은 MST를 찾는 알고리즘\n\t- 그래프 내의 모든 정점들을 가장 적은 비용으로 연결하기 위해 사용\n- (1) 최소 비용인 간선부터 시작\n- (2) 특정 간선 선택 시, 두 노드에 union 연산 수행\n\t- 합쳤으니까, 같은 집합이 됨\n- (3) 사이클이 발생한다면, 같은 집합으로 합치지 않고 넘어가기\n- 즉, ==**간선의 가중치가 작은 것부터 순서대로 보면서 해당 간선 양 끝에 있는 두 노드 x, y에 대해 find(x), find(y)값을 비교하여 일치하지 않는 경우에만 간선을 선택해주고 union(x, y)를 진행**==\n- 시간 복잡도\n\t- 그래프 내의 간선의 수가 $E$ 라고 하자\n\t- 최소비용 간선부터 처리하니까 정렬해야겠지. $O(E log E)$\n\t- 각 간선에 대한 union-find 비용 $O(log N)$\n\t\t- E번 해야하니까 $O(E log N)$\n\t- $O(E log E) + O(E log N)$이니까\n\t- ==**최종 $O(E log E)$**==\n\n\u003e [!note] 팁 ! \u003cbr\u003e\n\u003e - 이미 MST에 포함된 노드끼리의 연결은 사이클 형성 🟢\n\u003e - MST에 새로운 노드가 추가되는 형태여야 사이클 형성 ❌\n\n\n\n\u003cbr\u003e\n\n```\nfunction kruskal()\n    mst = []                       // mst 담을 배열\n    sort edge[] by length          // 간선을 가중치 기준으로 오름차순 정렬\n    uf = uf_init(|V|)              // uf 배열을 노드의 수 |V|만큼 초기화\n\n    for E in edge[]                // 각각의 간선에 대해 \n        u, v = E                   // 간선을 이루고 있는 두 노드 u, v를 보며\n        if find(u) != find(v)      // u, v의 루트 노드가 다른 경우에만\n            mst.push(E)            // mst에 해당 간선을 넣어주고\n            union(u, v)            // u, v를 같은 루트 노드를 갖도록 만들어줌\n    \n    return mst\n```\n\n\u003cbr\u003e\n\n**(1) 최소 비용인 간선부터 시작, 비용 5정도 까지만 진행함**\n\n![](brain/image/graph-25.png)\n\n\u003cbr\u003e\n\n**(2) 비용 6인 간선 진행하려하니, 사이클 발생**\n- 노드 5, 노드 8의 루트 노드가 동일한지 판단해야함\n- `find(5) == find(8)` 이니까 간선 추가 ❌\n\n![](brain/image/graph-26.png)\n\n\u003cbr\u003e\n\n**(3) 비용 7인 간선의 노드들을 보면 `find(5) != find(7)` 이니까 간선 추가**\n\n![](brain/image/graph-27.png)\n\n\u003cbr\u003e\n\n**(4) 결과물**\n\n![](brain/image/graph-28.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### Prim\n\n**Prim : 프림 알고리즘**\n- Prim은 MST를 찾는 알고리즘\n- 전체에서 최소비용 간선을 선택하던 Kruskal과는 반대로, ==**한 지점에서 시작하여 점점 확장하는 방식**==\n- Prim 알고리즘은 Dijkstra 알고리즘과 2줄 빼고 전부 동일\n\t- 현재 노드를 u라고 하자\n\t- Dijkstra : `dist[v]`, `dist[u] + length(u, v)` 비교 후 작은 것으로 갱신\n\t- Prim : `dist[v]`, `length(u, v)` 비교 후 작은 것으로 갱신\n\t- Dijkstra의 `dist[x]` → 시작점부터 x까지의 거리\n\t- Prim의 ==`dist[x]` → 현재까지 만들어진 MST와 x를 연결하기 위해 필요한 최소비용==\n- 시간 복잡도\n\t- 그래프 내의 정점의 수를 $|V|$, 간선의 수를 $|E|$ 라고 하자\n\t- 프림 알고리즘을 진행하면 각 간선을 한 번씩 보게 되는데, 이때 dist값이 변하면 우선순위큐에서의 순서가 계속 바뀌게 될 수도 있으므로 `간선의 수 × 우선순위 큐 이용` 시간복잡도\n\t- 다익스트라와 마찬가지로 ==**$O(|E|log|V|)$**==\n\t- 우선순위큐 안쓰고 for문 쓰면 ==**$O(V^2)$**==\n\n```\nfunction prim(graph)                   // 그래프와 시작점 정보가 주어짐\n    set Q = PriorityQueue()            // 우선순위 큐 생성\n\n    for each vertex in graph           // 그래프에 있는 모든 노드들에 대해\n        set dist[v] = INF              // 초기값을 전부 아주 큰 값으로 설정 \n        Q.push(v)                      // 우선순위큐에 각 노드를 넣기\n    set source = |V|                   // 시작점을 임의로 마지막 노드로 설정\n    set dist[source] = 0               // 시작점 대해서만 dist 값을 0으로\n    while Q is not empty               // 우선순위 큐가 비어있지 않을 때까지 반복\n        set u = vertex in Q with min dist     // 우선순위 큐에서 dist값이 가장 작은 노드를 선택\n        Q.remove(u)                           // 우선순위 큐에서 해당 노드를 제거\n\n        for each neighbor v of u              // u번 노드와 연결된 노드들을 전부 살펴보면서\n            set alt = length(u, v)            // 간선 가중치를 살펴보기\n            if alt \u003c dist[v]                  // 기존 dist값보다 alt값이 작다면\n                set dist[v] = alt             // dist값을 갱신\n\n```\n\n\u003cbr\u003e\n\n**(1) 아무 정점이나 잡아도 되는데, 편의상 1번 잡음**\n\n![](brain/image/graph-30.png)\n\n\u003cbr\u003e\n\n**(2) 1에 연결된 간선 중 최소 비용인거 선택, MST에 간선 추가**\n\n![](brain/image/graph-31.png)\n\n\u003cbr\u003e\n\n**(3) 붙어있는 간선 중 최소 비용인거 선택**\n\n![](brain/image/graph-32.png)\n\n\u003cbr\u003e\n\n**(4) 최소 비용인 13은 사이클 만드니까 선택 ❌**\n- ==이미 MST에 포함된 노드끼리의 연결이고, MST에 새로운 노드가 추가되는 것이 아니니까==\n\n![](brain/image/graph-33.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**문제 : 5번을 시작점으로 하여, MST 구하기**==\n\n\u003cbr\u003e\n\n==**1. 프림 또한 최솟값을 고르는 과정을 여러번 반복하므로, 우선순위 큐 사용**==\n- 처음 거리가 최솟값인 노드를 선택하면 5번 노드 → 우선순위 큐에서 빼겠다는 말\n- 프림 알고리즘에서 최솟값이 골라졌다는 의미는 해당 노드를 MST에 추가하겠다는 것\n\n![](brain/image/graph-34.png)\n\n\u003cbr\u003e\n\n==**2. 5번 노드와 연결된 다른 노드들을 보며 간선에 적혀있는 값과 해당 노드에 적혀있는 dist값과 비교하여 더 작은 값으로 갱신**==\n- 현재 MST를 이루고 있는 노드가 5번 노드이므로 5번 노드에 추가적으로 연결할 수 있는 정점들에 대해 각 정점을 간선을 통해 추가했을 때 추가적으로 나가게 되는 비용을 갱신해주는 것\n\n![](brain/image/graph-36.png)\n\n\u003cbr\u003e\n\n==**3. dist(v)와 length(u, v) 비교 후 갱신**==\n- `dist[2] = INF`, `length(5, 2) = 4` → 4로 갱신\n- `dist[4] = INF`, `length(5, 4) = 2` → 2로 갱신\n\n![](brain/image/graph-37.png)\n\n\u003cbr\u003e\n\n==**4. 우선순위 큐에 담긴 노드 중 dist 최솟값 고르기**==\n- `dist[4] = 2` 이므로 4번 노드 선택\n- ==이는 현재 MST에 4번 노드를 추가하는게 가장 좋은 상황이었다는 뜻==\n- 4번 노드가 뽑힘과 동시에 MST에 4-5를 연결하는 간선이 추가\n\n![](brain/image/graph-38.png)\n\n\u003cbr\u003e\n\n==**5. 4번 노드에 대해서도 연결된 간선 들 최솟값으로 갱신해주는 작업 진행**==\n- `dist[1] = INF`, `length(4, 1) = 3` → 3로 갱신\n- `dist[2] = 4`, `length(4, 2) = 1` → 1로 갱신\n- `dist[3] = INF`, `length(4, 3) = 2` → 2로 갱신\n- MST가 현재 노드 4, 5로 구성되어져 있는데 이들과 연결되기 위해 1번 노드는 비용 3이 필요하고, 2번 노드는 비용 1이 필요하고, 3번 노드는 비용 2가 필요하다는 뜻\n\n![](brain/image/graph-40.png)\n\n\u003cbr\u003e\n\n==**6. 우선순위 큐에 담긴 노드 중 dist 최솟값 고르기**==\n- `dist[2] = 1` 이므로 2번 노드 선택\n- ==이는 현재 MST에 2번 노드를 추가하는게 가장 좋은 상황이었다는 뜻==\n- 2번 노드가 뽑힘과 동시에 MST에 2-4를 연결하는 간선이 추가\n\n![](brain/image/graph-42.png)\n\n\u003cbr\u003e\n\n==**7. 2번 노드에 대해서도 연결된 간선 들 최솟값으로 갱신해주는 작업 진행**==\n- `dist[1] = 3`, `length(2, 1) = 2` → 2로 갱신\n\n![](brain/image/graph-43.png)\n\n\u003cbr\u003e\n\n==**8. 우선순위 큐에 담긴 노드 중 dist 최솟값 고르기**==\n- `dist[1] = 2`, `dist[3] = 2`인데 그냥 인덱스 작은거 고름\n- ==이는 현재 MST에 1번 노드 or 3번 노드를 추가하는게 가장 좋은 상황이었다는 뜻==\n- 1번 노드가 뽑힘과 동시에 MST에 1-2를 연결하는 간선이 추가\n\n![](brain/image/graph-45.png)\n\n\u003cbr\u003e\n\n==**9. 3번 노드에 대해서도 연결된 간선 들 최솟값으로 갱신해주는 작업 진행**==\n- `dist[3] = 2`, `length(1, 3) = 6` → 갱신 ❌\n- 4번 노드랑은 이미 진행했음\n\n\u003cbr\u003e\n\n==**10. 우선순위 큐에 담긴 노드 중 dist 최솟값 고르기**==\n- `dist[3] = 2`이므로 3번 노드 선택\n- ==이는 현재 MST에 3번 노드를 추가하는게 가장 좋은 상황이었다는 뜻==\n- 3번 노드가 뽑힘과 동시에 MST에 3-4를 연결하는 간선이 추가\n\n![](brain/image/graph-46.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n## Topological Sort\n\n**Topological Sort (위상 정렬)**\n\n![](brain/image/graph-47.png)\n\n- 순서가 정해져있는 작업을 차례로 수행해야 할 때 그 순서를 결정해주기 위해 사용하는 알고리즘\n- 위 그래프에서 가능한 순서는 `1, 3, 4, 6, 2, 5, 7` or `1, 4, 3, 6, 2, 5, 7` 등등\n- ==**이렇게 가능한 순서들 중 하나를 뽑아주는 방법이 위상정렬**==\n\t- dfs를 이용한 방법\n\t- in-degree를 이용한 방법\n\n\u003cbr\u003e\u003chr\u003e\n\n### Method 01 - DFS\n\n- DFS로 탐색 진행하다가 더이상 진행 못할 때 역순으로 가면서 스택에 넣으면 됨\n- 1번 정점부터 n번 정점까지 순서대로 보면서 아직 방문한 적이 없는 정점에 대해서는 전부 해당 정점을 시작점으로 하여 dfs를 추가적으로 진행해줘야만 한다는 것\n- 시간 복잡도\n\t- 각 정점과 각 간선을 한 번씩 보게 되기에 ==**$O(V+E)$**==\n\n\u003cbr\u003e\n\n==**예시 1번**==\n\n![](brain/image/graph-48.png)\n\n![](brain/image/graph-49.png)\n\n![](brain/image/graph-50.png)\n\n![](brain/image/graph-51.png)\n\n\u003cbr\u003e\n\n==**예시 2번**==\n- 1번부터 시작한다 했다면, 탐색 종료 이후 다음으로 작은거 다시 하면됨\n\n![](brain/image/graph-52.png)\n\n![](brain/image/graph-53.png)\n\n![](brain/image/graph-54.png)\n\n![](brain/image/graph-55.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### Method 02 - In-degree\n\n![](brain/image/graph-56.png)\n\n- In-degree : 정점마다 해당 정점으로 들어오는 간선의 수\n- 위상정렬이라는 것은 앞에 처리해야 할 순서가 끝나고 난 뒤에 현재 일을 처리하면 되는 것\n\t- → ==**in-degree가 0인 지점이 항상 시작점**==\n- 위상정렬 적용 불가능\n\t- 무방향 그래프 : 순서가 정의되지 않아서 적용하기 어려움\n\t- 사이클 이루는 경우 : 순서를 정의할 수 없어서 적용하기 어려움\n- 시간 복잡도\n\t- 각 정점과 각 간선을 한 번씩 보게 되기에 ==**$O(V+E)$**==\n- 응용\n\t- Q. 위상정렬 순서 중 사전순으로 가장 앞선 순서로 구해보면? (앞 순서에 더 작은 숫자가 나와야 유리하다는 말)\n\t- A. In-degree sort를 큐 대신 우선순위 큐로 진행 !\n\t\t- 큐에서 방문할 지점을 뽑을 때, 가장 인덱스가 작은 지점이 나오므로 원하는 결과 나옴\n\n\n\u003cbr\u003e\n\n==**1. in-degree가 0인 지점을 전부 큐에 넣고 시작**==\n\n![](brain/image/graph-57.png)\n\n\u003cbr\u003e\n\n==**2. 큐에서 가장 앞에 있는 값을 뽑아, 해당 정점에 연결된 모든 간선을 보고, 간선이 가리키는 곳에 있는 정점의 in-degree 1 감소**==\n\n![](brain/image/graph-58.png)\n- 간선을 지우지는 않았지만, 사실상 1과 2를 잇는 간선은 사라진것과 동일함\n\n![](brain/image/graph-60.png)\n\n![](brain/image/graph-61.png)\n- 3의 in-degree가 0이 되었으니 3을 큐에 넣은 것\n\n![](brain/image/graph-62.png)\n- 4도 마찬가지로 진행 !\n\n\u003cbr\u003e\n\n==**3. 큐가 빌 때까지 반복하면 됨**==\n\n![](brain/image/graph-63.png)\n\n![](brain/image/graph-64.png)\n\n![](brain/image/graph-65.png)\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CodeTree/inputoutput":{"title":"입출력","content":"\n\u003chr\u003e\n\n## Scanner\n\nScanner가 느리기는 하지만, 시간 절약상 좋긴 함\n\n- 공백, 줄바꿈 (`\\n`)을 단위로 끊어짐\n- `import java.util.Scanner;`\n- `Scanner sc = new Scanner(System.in);`\n- `sc.메서드` 방식으로 사용\n\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### 정수, 실수\n\n- `sc.nextInt()` : 정수\n- `sc.nextDouble()` : 실수\n- 소숫점 출력할 때 printf 말고 `String.format(\"%.2f\", ㅁ);` 형태도 가능\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tdouble c = sc.nextDouble();\n\n\t\tSystem.out.printf(\"%d %d %.2f\", a, b, c);\n\t\tSystem.out.print(String.format(\"%d %d %.2f\", a, b, c));\n\t}\n}\n\n// 입력\n// 1 2\n// 3.4772\n\n// 출력\n// 1 2 3.48\n```\n\n\u003cbr\u003e\n\n### 문자열, 문자\n\n- `sc.next()` : space나 new line으로 문자열 구분\n- `sc.nextLine()` : new line으로만 문자열 구분 (공백 포함하여 길이 계산됨)\n- `sc.next().charAt(0)` : 한 줄 전체 문자열에서 첫 번째 문자\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tString s = sc.next();\n\t\tchar c = sc.next().charAt(0);\n\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(c);\n\t}\n}\n\n// 입력\n// hello\n// jaeyoon\n\n// 출력\n// hello\n// j\n```\n\n\u003cbr\u003e\n\n### 구분자\n\n- `sc.useDelimiter(특정문자)` : 구분자로 잘라서 받기\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\":\");\n\n\t\tint hour = sc.nextInt();\n\t\tint minutes = sc.nextInt();\n\n\t\tSystem.out.println(\"현재 시각은 \" + hour + \"시 \" + minutes + \"분\");\n\t}\n}\n\n// 입력\n// 15:47\n\n// 출력\n// 현재 시각은 15시 47분\n```\n\n\u003cbr\u003e\n\n- useDelimiter 안의 값은 ==**정규 표현식**==을 이용\n- 따라서, `.`, `$` 등과 같은 특수 기호는 의도했던 바와 다르게 작용\n- 예를 들어, 정규표현식에서 `.`은 모든 문자를 의미하기에, 점을 나타내고 싶으면 `\\.`이라고 써야한다.\n\t- 자바에서는 역슬래쉬를 나타내기 위해 `\\`를 써야하므로, 최종적으로 `\\\\.` 라고 작성해야함\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\".\");\n\t}\n}\n\n// 런타임 에러\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\"\\\\.\");\n\t}\n}\n\n// 정상 작동\n```\n\n\u003cbr\u003e\u003chr\u003e\n\n## BufferedReader\n\n백준은 입출력 관련해서 웬만하면 기본으로 깔고 할 것\n\n1. `import java.util.*;`\n\t- 컬렉션, StringTokenizer 등\n2. `import java.io.*;`, main 메서드 뒤에 `throws IOException`\n\t- 버퍼리더 입출력 때문에\n3. `Scanner`느리니까 쓰지말고 `BufferedReader` 사용\n\n```java {title=\"BaekJoon - 1000\"}\nimport java.io.*;  \nimport java.util.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        System.out.println(Integer.parseInt(st.nextToken()) + Integer.parseInt(st.nextToken()));  \n    }  \n}\n```\n\n\u003chr\u003e\n\n## StringBuilder\n\n```java\nimport java.lang.StringBuilder;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"hi\")\n\t\t\t.append(\"\\n\");\n\n\t\tSystem.out.print(sb.toString());\n\t}\n}\n```\n\n- append로 붙여 나가기\n- 새로운 StringBuilder 객체 생성 안하고 초기화 하고 싶으면 `sb.setLength(0)`로 문자열 비워주기","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CodeTree/math":{"title":"수학","content":"\n\u003chr\u003e\n\n## 유클리드 호제법\n\n- 최대공약수 (GCD, Greateast Common Division)\n- 최소공배수 (LCM, Least Common Multiple)\n\t- ![](brain/image/PS-22.png)\n\t- 두 수 A, B와 최대공약수 G, 최소공배수 L이라고 하면 **`AB = LG`** 식이 성립\n\n- ==유클리드 호제법== : 최대공약수 GCD 찾는 방법\n\t- A를 B로 나눈 몫을 Q라 하고, 나머지를 R이라고 하면 `GCD(A, B) = GCD(B, R)`\n\t- 자연수 A, B가 있을 때 A를 B로 나눈 나머지를 N이라고 하면 (`a % b == n`) N이 0일 때 B가 바로 최대공약수 GCD 임을 이용하는 원리\n\t\t- N이 0이 아니라면, a에 b값을 넣고 다시 n을 b에 대입하여 재귀\n\t\t- 기본적으로 a가 b보다 크다는 전제 !!!\n\n\u003cbr\u003e\n\n- 프로그래머스에서 풀었던 재귀\n- \u003ca href='https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95' target='_blank'\u003e유클리드 호제법 위키피디아\u003c/a\u003e에서도 이와 같이 품\n\n```java\n    int GCD(int a, int b) {\n         if (b == 0)\n             return a;\n         else\n             return GCD(b, a % b);\n```\n\n- 코드트리 단순 반복\n\n```java\n    int GCD(int a, int b) {\n        while (b != 0) {\n            int temp = a % b;\n            a = b;\n            b = temp;\n        }\n        \n        return a;\n    }\n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 콜라스 추측\n\n모든 자연수에 대하여, 짝수는 나누기 2, 홀수는 곱하기 3 + 1을 유한번 재귀하면 결국 최종적으로 1로 간다는 것. 아직까지 반례를 찾지 못했음\n\n![](brain/image/math-1.png)\n\n- \u003ca href='https://namu.wiki/w/%EC%BD%9C%EB%9D%BC%EC%B8%A0%20%EC%B6%94%EC%B8%A1' target='_blank'\u003e위키피디아 - 콜라스 추측\u003c/a\u003e\n- 3n + 1 수열이라는 키워드도 봤음\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 피보나치 수열\n\n첫 번째 원소 1, 두 번째 원소 1, 세 번째 원소 부터는 바로 직전 두 원소의 합인 수열\n\n![](brain/image/math-2.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 순열 조합\n\n![](brain/image/math-3.png)\n\n\n```java\n// Permutation / r!\n\n// i개 중에서 순서 있게 2개 뽑기 (순열)\n// i * (i - 1)\n\n// i개 중에서 순서 있게 3개 뽑기\n// i * (i - 1) * (i - 2)\n\n// 배열하는 경우의 수 r!\n\n// i개 중에서 순서 없이 2개 뽑기 (조합)\n// i * (i - 1) / 2\n```","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/CodeTree/string":{"title":"문자열","content":"\n\u003chr\u003e\n\n## 문자열 관련 메서드\n\n- `charAt(인덱스)` : 문자열에서 문자 뽑아내기\n- `length()` : 문자열 길이\n- `substring(시작 인덱스, 끝 인덱스)`  : 시작 인덱스부터 끝 인덱스 전까지 부분문자열 반환\n- `equals(문자열)` : 문자열 동등성 비교\n- `contains(문자열)` : 부분문자열 포함 여부 (true / false)\n- `indexOf(문자열)` : 부분문자열 없으면 -1, 있으면 부분문자열 포함하는 곳의 가장 첫번째 인덱스 반환\n- `toCharArray()` : 문자열을 문자의 배열로 반환\n- `String.valueOf(배열)` : 문자로 이루어진 배열을 문자로 반환\n- `compareTo()` : 사전순으로 어떤 문자가 더 앞서는지\n\t- `str1.compareTo(str2)`\n\t\t- 값이 0보다 작으면 : str1이 사전순으로 더 앞섬\n\t\t- 값이 0 : 두 값이 같음\n\t\t- 값이 0보다 크면 : str2가 사전순으로 더 앞섬\n\n\n## 배열 관련\n\n- 배열 또한 참조형이므로, 값을 바꾸면 바뀌어버림.\n\t- 그래서 `.clone()` 같은 걸로 아예 새로운 배열을 만들어서 메서드로 넘기면 좀 괜찮\n\n## 정렬 관련\n\n- `import java.util.Arrays;`\n\t- `Arrays.sort(arr)` : 배열 오름차순정렬\n\t- `Arrays.sort(arr, 시작 index, 끝 index + 1)` : 배열 구간 오름차순 정렬\n\t- 문자열 정렬할 때는 `char[]`로 바꿔서 해야함\n\t\t- `char[] arr = str.toCharArray()`\n\t\t- `Arrays.sort(arr)`\n\t\t- `String str = new String(arr)`\n\n\u003cbr\u003e\n\n- `import java.util.Collections;`\n\t- **Java에서는 int (primitive tytpe)으로 구성된 배열을 한번에 내림차순 정렬할 수 있는 방법이 없음** → Integer로 선언되어 있어있으면 Collections 활용해서 가능\n\t- `Arrays.sort(arr, Collections.reverseOrder());` : 내림차순 정렬\n\n\u003cbr\u003e\n\n- Stream 써서 int (기본형) → Integer (참조형) 타입 변환\n\t- `Arrays.stream(arr).boxed().toArray(Integer[]::new);`\n\n- `Arrays.sort()` vs `Collections.sort()`\n\t- `Arrays.sort()`는 배열을 정렬\n\t\t- 시간 복잡도 \n\t\t- `Arrays.sort(arr, Collections.reverseOrder()) : 내림차순`\n\t- `Collections.sort()`는 객체를 정렬\n\t\t- `Collections.reverse() : 내림차순`\n\t- https://stonage.tistory.com/230\n\t- https://velog.io/@minizero0/Arrays.sort%EC%99%80-Collections.sort\n\n\u003cbr\u003e\n\n## 객체 정렬\n\n\u003cbr\u003e\n\n- Comparable과 Comparator의 차이 (https://st-lab.tistory.com/243)\n\t- 둘 다 인터페이스\n\t- 인터페이스니까 구현해줘야 함\n\n\u003cbr\u003e\n\n- Comparable 인터페이스\n\t- `compareTo(T o1)`\n\t- ==자기 자신과 매개변수 객체를 비교==\n\t- java.lang에 있어서 import 할 필요 X\n\n\u003cbr\u003e\n\n- Comparator 인터페이스\n\t- `compare(T o1, T o2)`\n\t- ==두 매개변수 객체를 비교==\n\t- java.util.Comparator로 import 필요 O\n\n\u003cbr\u003e\n\n1. `Comparable\u003cclass\u003e + @Override compareTo() 조합`\n\n```java\nclass Student implements Comparable\u003cStudent\u003e {\n\tint test;\n\n\t// 오름차순\n\t@Override\n\tpublic int compareTo(Student student) {\n\t\treturn this.test - studnet.test;\n\t}\n\t\n\t// 내림차순\n\t@Override\n\tpublic int compareTo(Student student) {\n\t\treturn studnet.test - this.test;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n2. 람다\n\t- 결국 메서드 하나인 인터페이스니까 람다로 가능\n\n```java\n// 오름차순\nArrays.sort(students, (a, b) -\u003e a.test - b.test);\n\n// 내림차순\nArrays.sort(students, (a, b) -\u003e b.test - a.test);\n```\n\n\u003cbr\u003e\n\n3. 2번에 걸쳐 다른 기준으로 정렬\n\t- `Arrays.sort`로 정렬하는 순간에 `Comparator` 이용하여 `compare()`\n\t- `compare()`는 `compareTo()`와는 다르게 인자를 2개 받아서 기준을 설정해줘야 함\n\n```java\nArrays.sort(students, new Comparator\u003cStudent\u003e() {\n\t@Override\n\tpublic int compare(Student a, Student b) {\n\t\treturn a.height - b.height;\n\t}\n})\n```\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Common/":{"title":"Common","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Common/API":{"title":"API","content":"\n\u003cbr\u003e\n\n==**API(Application Programming Inteface)는 소프트웨어 컴포넌트(라이브러리, 프레임워크, 플랫폼 등)가 제공하는 인터페이스로, 다른 소프트웨어에서 해당 컴포넌트의 기능을 사용할 수 있게 해주는 것이다.**==\n\n- **응용 프로그램에서 운영체제나 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스**\n- 프로그램 사이를 연결해주는 \"다리\"라고 생각하자.\n- **구현과는 독립적으로** 어떤 하드웨어, 혹은 서로 다른 컴퓨터 프로그램 간 정보를 주고 받을 때 사용하는 **규약 혹은 사양**을 정의한 것\n\n\u003cbr\u003e\n\nApplication\n- 운영체제 위에서 실행되는 모든 소프트웨어를 의미 (운영체제가 아닌 모든 프로그램)\n\nProgramming\n- 메모리에 올라가서 실행될 수 있는 명령어들의 집합인 **프로그램을 작성하는 행위**\n\nInterface\n- 서로 다른 두 개가 서로 정보를 주고 받기 위해 약속된 **규약(규격)**\n\n즉, API는 응용 프로그램을 만들 때 사용하는 인터페이스라는 뜻이 되겠군 !\n\n\u003chr\u003e\n\n**API의 특징**\n\n- ==구현과 독립적으로 사양만 정의==되어 있다.\n- API에 따라 접근 권한이 필요할 수 있다.\n- Java API, 여러 기업들의 오픈 API 등이 있다.\n\n\u003cbr\u003e\n\n**API의 예시**\n\n1. [System Call](brain/CS/OS/SystemCall) \n2. [Socket](brain/CS/Network/Socket)\n3. [REST API](brain/Common/RESTAPI)\n4. [RESTful API](brain/Common/RESTfulAPI)","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Common/Framework":{"title":"프레임워크","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Common/Library":{"title":"라이브러리","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Common/RESTAPI":{"title":"REST API","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Common/RESTfulAPI":{"title":"RESTful API","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/DB/":{"title":"Database","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/DevCourse/":{"title":"데브코스","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/DevCourse/001":{"title":"[1주차] 2023-06-02","content":"\n\u003chr\u003e\n\n## 💻 1주차 DAY 02\n\n1주차 DAY 01인 06월 01일(목)에는 슬랙과 노션에 초대되었고, 간단한 OT를 진행하며 앞으로 데브코스 과정의 방향성에 대해 자세하게 알게 되었고, 2주간 진행될 Pre팀의 팀원들과 간단하게 인사하며 하루를 마무리 했었다. 오늘부터 본격적으로 프레임워크를 위한 JAVA 학습이 시작되었다. 기본적인 개념은 알고 있다는 전제하에 조금 더 심화적인 부분에 관하여 수업이 진행되었다. 기존에 알고 있던 내용들을 리마인드하는 시간이었다.\n\n\u003cbr\u003e\n\n### JAVA 개발환경\n\n- JDK, JRE에 관한 간단한 설명\n- \u003ca href='https://jae-yoon.tistory.com/15' target='_blank'\u003eDev Uni 기술블로그 - Java의 실행원리 1편\u003c/a\u003e에 포스팅 한 내용을 참조하면 더욱 좋다.\n\n\u003cbr\u003e\n\n### Build Tool\n\n평소 Spring Boot 환경에서 자연스레 사용하던 gradle을 homebrew로 직접 설치하여 CLI 환경에서 실행해보는 실습을 진행하여 원리를 더욱 파악할 수 있게 되었다.\n\n```shell\n# homebrew 이용 gradle 설치\nbrew install gradle\n\n# 프로젝트 폴더로 이동하여 gradle 프로젝트 생성\n# application -\u003e Java -\u003e Groovy -\u003e JUnit Jupyter\n# JUnit Jupyter가 JUnit5를 의미하는 것\n# 패키지는 com.programmers.java\ngradle init\n\n# 프로젝트 빌드\ngradle build\n\n# 프로젝트 실행\ngradle run\n\n# tasks 확인\ngradle tasks\n```\n\n- build script로 코틀린도 많이 사용하는 추세이지만, 아직까지는 익숙한 groovy로 진행하기로 했음\n- gradle이 수행되는 명령 단위를 **task**라고 한다.\n- `build.gradle`에 task가 기록되어 있는데, `run`과 `build`같이 자주 사용되는 task는 Java application에서 사용할 것을 미리 만들어놔서 application 플러그인에 Java 프로그램을 실행시키기 위한 task가 들어가있다.\n\n\u003cbr\u003e\n\n### IDE (IntelliJ)\n\nBuild Tool을 사용하여 일일히 프로젝트를 생성하고 빌드하고 extension을 설치해서 task 확인하고 실행하는건 너무 불편하다는 사실을 모르고 당연하게 쓰던 IDE... 소중함을 알게 되었다.\n\n\u003cbr\u003e\n\n### Java 심화\n\n1. Java는 기본형 타입인 boolean, byte, int, short, long, float, double, char를 제외한 모든 것이 **참조 값(Reference value)** 이다.\n\n\t- 추가로, call by value와 call by reference에 대해서 언급해주셨는데, 기존에 알고 있던 바로는 Java에서 call by reference는 없다고 알고 있었다.\n    - 관련 내용은 \u003ca href='https://1-7171771.tistory.com/128' target='_blank'\u003eCall by value와 Call by reference\u003c/a\u003e를 참고\n\n2. String Constant Pool에 관한 이야기\n\t- Constant Pool, Runtime Constant Pool, String Pool에 관한 이야기는 사실 미묘한 차이가 약간씩 있다.\n\t- \u003ca href='https://jae-yoon.tistory.com/17' target='_blank'\u003eDev Uni 기술블로그 - Java의 실행원리 3편\u003c/a\u003e에 포스팅 한 내용을 참조하면 더욱 좋다.\n    \n3. String, StringBuilder, StringBuffer\n\n\t- String : 문자열 연산 자체가 적고 멀티스레드의 경우  \n\t- StringBuffer : 문자열 연산이 많고 멀티스레드의 경우  \n\t- StringBuilder : 문자열 연산이 많고 단일스레드고 동기화를 고려하지 않아도 되는 경우  \n\n\u003e 보통 Java-Spring에서는 멀티스레드 환경을 지원하고 있기 때문에 보통은 String, StringBuffer를 사용하는 편이다.\n\n\u003cbr\u003e\n\n4. Object 객체\n\t- `toString()`\n\t- `equals()`\n\t- `hashCode()`\n    - 반드시 메서드 오버라이딩하여 사용하자. 자주 쓴다.\n\n\u003cbr\u003e\n\n\u003e `동일성(Identity)` vs `동등성(equality)`\n\u003e - 동일성은 `'=='` 사용 시 참조하는 객체가 동일한지, 같은 객체를 가르키는지 확인하는 것\n\u003e - 동등성은 객체가 같은 정보를 가지고 있는지 확인하는 것\n\n\u003cbr\u003e\n\n\u003e `hashCode()`와 `eqauls()` 관계 : 찹쌀떡\n\u003e - hash 값을 사용하는 컬렉션에서 논리적으로 같은지 비교\n\u003e - hash(true) → equals(false) **다른 객체**\n\u003e - hash(true) → equals(true) **동등 객체**\n\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/DevCourse/002":{"title":"[2주차] 2023-06-05","content":"\n## 💻 2주차 DAY 01\n\n2주차 DAY 01부터 본격적으로 과제가 나오며 바쁜 일상이 시작되겠다는 것이 느껴졌다. 아직 부산에 방이 빠지지 않고 서울에 방을 구하지 못한 상황이고, 개인사로 인하여 심리적으로 안정되지 못한 상태이기 때문에, 공부에 풀 집중이 안되는 것이 아쉽다. 하지만, 현재 상황에 맞춰서 최대한 집중해보려고 한다 :)\n\n\u003cbr\u003e\n\n### 객체지향 프로그래밍\n\n평소, JAVA를 사용해왔기에 나는 객체지향 프로그래밍을 한다고 생각했지만, 오늘 강의를 통해 스스로 의문을 가지게 되었다. 나는 과연 객체지향적인 특성을 잘 활용하며 코드를 짜고 있을까? 결국 **객체지향 프로그래밍을 한다는 것은 좋은 객체를 잘 만들고 있는가**를 의미한다고 생각했다. **프로그램이 거대화**하면서 등장하게 된 객체지향 프로그래밍이라는 패러다임에 따른다면, 좋은 객체와 나쁜 객체는 아래와 같다.\n\n- **좋은 객체 : 역할과 책임에 충실하면서 다른 객체와 잘 협력하여 동작하는 객체**\n- 나쁜 객체 : 여러가지 역할을 한 가지 객체에게 부여하거나, 이름과는 맞지 않는 속성과 기능을 가지도록 하거나, 제대로 동작하지 않는 객체. 또한 다른 객체와 동작이 매끄럽지 않는 것도 나쁜 객체\n\n\u003cbr\u003e\n\n### POJO와 PSA\n\n좋은 객체를 생각하며, 자연스럽게 POJO(Plain Old Java Object)가 떠올랐다. POJO에 관한 자세한 내용은 **\u003ca href='https://shin-jae-yoon.github.io/brain/Interview/dog-study/dog-week06/#pojo' target='_blank'\u003eDev Uni 기록용 블로그 - POJO\u003c/a\u003e** 을 참고하자.\n\nPOJO(Plain Old Java Object)는 직역하자면 오래된 방식의 간단한 자바 객체라는 의미이다. 이는 특정 기술에 종속되지 않는 순수한 자바 객체를 의미한다.\n\n**객체 지향적인 원리에 충실하면서 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 POJO**라 말하고 POJO에 애플리케이션의 핵심로직과 기능을 담아 설계하고 개발하는 방법을 POJO 프로그래밍이라고 할 수 있다.\n\n예를 들어, ORM(Object Relationship Mapping) 기술을 사용하려면 ORM을 지원하는 프레임워크를 사용해야한다. 만약에 Java 객체가 ORM 기술을 사용하기 위해 Hibernate 프레임워크를 직접 의존하는 순간 POJO라고 할 수 없다. “특정 기술에 종속되었기 때문\"이다.\n\n그런데 Java 객체가 ORM 기술을 사용하기 위해 Hibernate 프레임워크를 직접 의존하는 순간 POJO가 아니라고 했으면서, Spring은 어떻게 POJO를 유지하면서 Hibernate를 사용할까? 이는 Spring에서 정한 표준 인터페이스가 있기 때문이다.\n\nORM을 사용하기 위해 JPA(Java Persistence API)라는 표준 인터페이스를 정의해뒀고, ORM 프레임워크들은 JPA의 구현체가 되어 실행된다. 이것이 새**로운 엔터프라이즈 기술을 도입하면서도 POJO를 유지하는 방법이고 이런 방법을 PSA**라고 한다.\n\n**PSA(Portable Service Abstraction)란 환경과 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 해주는 것**을 의미한다. PSA가 적용된 대표적인 예시는 JDBC, JPA, Transaction Manager가 있다.\n\n다시 POJO로 돌아와서, 그렇다면 특정 기술규약과 환경에 종속되지 않으면 모두 POJO라고 말할 수 있을까? 그렇지 않다. **진정한 POJO는 위에서 말한것처럼 객체 지향적인 원리에 충실하면서 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 의미**한다.\n\n\u003e 정리하자면, 객체지향적인 원리에 충실하는 좋은 객체이면서 환경과 기술에 종속되지 않고 필요에 따라 재활용 될 수 있는 방식으로 설계된 오브젝트가 POJO이구나 !\n\n\u003cbr\u003e\n\n### 아키텍처 이야기\n\n거대한 프로그램에서 객체가 역할과 책임에 충실하도록 기능을 나눠서 좋은 객체로 만드는 것을 살펴보았다. 그렇다면 이것을 **아키텍처 자체의 관점에서 살펴보자.** 내가 지금까지 코드를 짜면서 해왔던 모든 방식은 모놀리식 아키텍처이다. 모놀리식 아키텍처는 전통의 아키텍처를 지칭하며, 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어 있는 형태이다.\n\n최선을 다하여 좋은 객체를 만들고 잘게 쪼갰음에도 애플리케이션의 한 프로세스에 대한 수요가 급증하면 아키텍처 전체를 확장해야하는 상황이 왔다고 하자. 모놀리식이니까 scale up 형식으로 서버 스펙을 향상 시키는 것도 극한에 이르렀다고 가정하자. 어떻게 더 쪼개야할까?\n\n\u003cbr\u003e\n\n1. MSA (Micro Service Architecture)\n\n아마 먼저 떠올린 생각이 아닐까싶다. 모놀리식 아키텍처에서 MSA 아키텍처로 변경하는 것을 생각할 수 있다. 그러나, MSA 아키텍처에 관하여 자세히는 모르지만, 현직에 계신 분들의 의견을 들었을 때 생각보다 MSA에 부정적이신 분들이 많았고 MSA로 쪼개는 것은 그렇게 어울리는 방법이 아닐 수도 있다. 대표적인 단점은 아래와 같다.\n\n- 서비스가 분산되어 있어 관리하기 어려움\n- 트랜잭션 관리, 장애 추적 및 테스트 등이 쉽지 않음\n- 서비스마다 DB가 분리되어 데이터의 조회가 어려움 (당연히 DB 샤딩의 난이도도 급증할 것) + 데이터의 중복 발생\n- 테스트가 불편\n- 서비스 간 호출 시 REST API 사용으로 인한 통신비용, Latency(지연시간) 증가\n- 전체 서비스가 커짐에 따라 복잡도가 기하급수적으로 높아질 수 있음.\n\n이 중 가장 큰 단점은 개인적인 생각으로 비용적인 측면에 있지 않나라고 생각한다. DAU가 높지 않은 상황에 무리하게 모놀리식에서 MSA로 전환한다면 비용적인 폭탄을 맞지 않을까... 현업에 발을 디뎌본 적도 없는 취준생이라 개인적인 추측이고 자세한 상황은 모르겠지만 MSA로 전환은 쉽지 않다고 생각한다.\n\n\u003cbr\u003e\n\n2. 모놀리식을 유지하면서 멀티모듈\n\n최초에 애플리케이션을 개발할 때 멀티모듈로 개발한다면, 추후 서비스가 커졌을 때 확장성도 좋고 **응집도는 커지되, 결합도는 낮아진다**라는 이야기를 들었다. 아직, 멀티 모듈에 관하여 지식이 부족한 상태라 장단점을 확실하게 언급할 수는 없지만, 내가 채택을 해야하는 상황이라면 MSA 보다는 이 방식을 채택할 것 같다. 멀티모듈에 관한 자세한 이야기는 **\u003ca href='https://techblog.woowahan.com/2637/' target='_blank'\u003e우아한 형제들 - 멀티모듈 설계 이야기\u003c/a\u003e** 를 참고하자.\n\n\u003cbr\u003e\n\n### 객체지향의 특성\n\n좋은 객체, POJO가 되기 위하여 객체지향적인 원리에 충실해보자. 그러기 위하여 객체지향의 특성을 알아보려고 한다. 사실 개발 공부를 하면서 이런식의 암기는 좋아하지 않는데, 저번에 인터넷에서 보고 바로 외워버려서 말해보려고 한다. 객체지향의 특성은 캡상추다! (캡슐화, 상속, 추상화, 다형성)으로 쉽게 외워보자 ㅋㅋ\n\n\u003cbr\u003e\n\n**1. 캡슐화**\n- 완성도가 있다.\n- 정보가 은닉되어있다.\n\n좋은 객체가 되려면 객체가 기능을 수행해야 하는 책임을 가진다고 했는데, 이러한 관점에서 완성도가 있다는 의미이다. 캡슐화를 진행하면서 **의존성을 낮추고 결합도를 낮추는 것**이 핵심이다.\n\n캡슐화 과정에서 접근지정자, 접근제한자를 통해 정보은닉이 자연스레 따라온다. 객체의 정보에 밖에서 접근하는 행위를 막는 것이다.\n\n\u003e 디자인패턴의 가장 중요한 원칙과도 일맥상통한다. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리하여 나머지 코드에 영향을 주지 않도록 캡슐화하는 점을 의미한다.\n\n\u003cbr\u003e\n\n**2. 상속**\n- 상위 = 부모 = super = **추상 객체**\n- 하위 = 자식 = (this) = **구체 객체**\n\n곰튀김님께서 상속에 관한 오해를 설명해주셨을 때 가슴이 뜨끔했다. 평소 내가 가지던 생각과 완벽하게 일치했기 때문이다. 맹목적으로 공통된 기능이 있다면 상속으로 빼려고 한 안일한 생각이었다.\n\n- 오해 : 공통된 기능을 여러 객체에게 전달하고 싶을 때 상속을 많이 사용\n- 진실 : **추상과 구체 관계에서 상속을 표현해야 한다.**\n\n\u003cbr\u003e\n\n**3. 추상화**\n- 상속에서의 진실은 자연스럽게 추상화의 개념으로 이어진다.\n- 상속관계는 상위로 갈수록 추상화, 하위로 갈수록 구체화 된 모습이다.\n- 추상체 : 추상화된 객체 / 구상체 : 구체적인 객체\n- **객체 간 관계에서 상위에 있는 것이 항상 하위보다 추상적이어야 한다.**\n\n추상체와 구상체를 만드는 기준에는 크게 3가지 정도가 있다.\n- 둘다 구체적인 기능을 가지고 있으며, **의미적으로만 묶은 상태**\n- 구현체를 가지지 않고 정의만 하여 **추상클래스 형태로 제공하는 상태**\n- 객체 자체가 추상적인 **인터페이스 상태**\n\n여기에서, 왜 추상체를 가져야할까?에 관한 이유는 자연스럽게 다형성과 연결된다.\n\n\u003cbr\u003e\n\n**4. 다형성**\n- type(형)을 여러 형태로 표현할 수 있다.\n- 즉, 구체 클래스가 아닌 추상 클래스로 표현할 수 있는 상태를 의미한다.\n- 누가 접근하느냐에 따라 필터링 된 기능만 제공하는 형식도 가능하다.\n\n```java\nList\u003cInteger\u003e list = new ArrayList\u003cInteger\u003e();\n```\n\n구체 클래스인 ArrayList를 추상 클래스인 List로 표현할 수 있는 상태이면서, List에 해당하는 기능만 필터링 된 형식으로 제공한다. 즉, ArrayList에만 있는 기능은 위와 같은 코드에서 사용할 수 없다.\n\n다른 예시로는 아래와 같은 로그인이 있다.\n\n\u003cimg src=\"https://velog.velcdn.com/images/jae_yoon/post/3afbd311-a21d-401a-962e-c19a9cd8621b/image.png\"\u003e\n\n구상체인 카카오 로그인이나 네이버 로그인으로 표현하지 않고 추상체인 로그인 인터페이스로 표현하면서, 접근하는 사람에 따라 필터링 된 기능만 제공하는 형식이 가능하다.\n\n\u003cbr\u003e\n\n### 객체지향 설계, SOLID\n\n캡슐, 상속, 추상화, 다형성 같은 객체지향의 특성을 잘 지키는 좋은 객체가 의미하는 바는 알았다. 그렇다면 **좋은 설계를 했는지는 어떻게 알아야할까?** 이에 대한 답은 아래 2가지이다.\n\n- 객체를 어떻게 구분했는지\n- 객체간의 연관관계가 어떠한지\n\n좋은 설계를 하기 위해 객체를 기능에 따라 어떻게 잘 나누고, 어떻게 잘 연관짓느냐에 관한 원칙이 **SOLID 원칙**이다.\n\n\u003cbr\u003e\n\n- **S : SRP (Single responsibility principle)**\n\t- 단일 책임 원칙\n\t- **수정이 필요할 경우, 수정되는 이유는 하나 때문이어야 한다.**\n\t- 객체를 하나 만들면, 그 객체에다가 책임을 하나만 줘라\n\t- 책임은 객체가 수행해야 하는 임무, 기능을 의미\n\t- 그 객체가 가진 기능은 하나만 있으면 된다.\n\t- 하나의 객체에 너무 많은 기능을 가지게 하지마라\n\n\u003cbr\u003e\n\n- **O : OCP (Open/Closed principle)**\n\t- 개방 폐쇄 원칙\n\t- **수정에는 닫히고, 확장에는 열어라**\n\t- 처음부터 객체를 만들 때, 수정할 수 있는 형태로 만드는 것이 아니라, 확장해서 기능을 변경할 수 있는 방식으로 만들어라.\n\t- 즉, 기존거 건들지마라\n\n\u003cbr\u003e\n\n- **L : LSP (Liskov substitution principle)**\n\t- 리스코프 치환 원칙\n\t- **추상객체로 사용되는 부분에 구상객체가 들어가도 아무 문제 없어야 한다.**\n\t- 추상체와 구상체의 관계가 명확하다면, LSP는 잘 지켜질 것 이지만, 추상화에서 언급한 상속관계에서 공통적인 기능은 부모에 두는 경우로써 상속을 사용했다면 LSP가 깨지기 쉽다.\n    \n\u003cbr\u003e\n\n- **I : ISP (Interface segregation principle)**\n\t- 인터페이스 분리 원칙\n\t- 로그인이라는 인터페이스가 있고 검색이라는 인터페이스로 나눠서 구성한다고 하자. 로그인 기능만 제공해주고 싶으면 로그인 인터페이스로 보낼 수 있고, 검색 기능만 제공해주고 싶으면 검색 인터페이스로 보낼 수 있는 것이니까 인터페이스를 분리하면 유리하다.\n    \n\u003cbr\u003e\n\n- **D : DIP (Dependency inversion principle)**\n\t- 의존관계 역전 원칙\n\t- 상위 레벨의 모듈은 절대 하위 레벨 모듈에 의존하지 않는다. ( = 둘 다 추상화에 의존해야 한다 )\n\t- 결국, 클래스 간 결합을 느슨히 하기 위함이다.  클래스의 변경에 따른 클래스들의 영향을 최소화하는 것이 목적\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/DevCourse/003":{"title":"[2주차] 2023-06-06","content":"\n## 💻 2주차 DAY 02\n\n2주차 DAY 02 ! 드디어 오늘 부산 방이 빠졌다. pre 팀 기간 동안은 계산기 과제도 있고 여러 집중이 필요해서 서울에 방 구하러 올라가는 것은 pre 팀 기간 이후이지 않을까싶다. 오늘부터는 본격적으로 객체지향적인 설계를 위해 Java를 학습하는 시간이었다.\n\n\u003cbr\u003e\n\n### Interface\n\n평소, 추상 클래스와 인터페이스에 관한 차이를 공부한 편이었는데 정작 인터페이스의 기능에 관하여 간략하게만 알고 있었어서, 오늘 강의를 통해 정리해보는 시간을 가지게 되었다.\n\n내가 기존에 일던 인터페이스는 **메뉴얼, 설명서**의 느낌이었다. 인터페이스에 정의해둔 메서드를 구현하는 쪽에서 반드시 구현하도록 강제하는 것이다. 즉, **추상체에 정의된 메서드를 구상체에서 반드시 이것만은 구현해야 한다는 의미이다.** 제작자가 인터페이스를 만들면서 제작자의 의도를 포함시켜 사용자에게 인지시켜준다는 의미로도 생각할 수 있다.\n\n\u003cbr\u003e\n\n**Interface 기능**\n\n1. 구현을 강제\n2. 다형성 제공\n3. 결합도 낮추는 효과\n\n\u003cbr\u003e\n\n### 예시를 통해 알아보자\n\n가장 많이 사용하는 \"로그인 기능\"에 관하여 이야기 해보자.\n예시 코드는 굉장히 간단한 수준이다.\n\n- 구상체에서 추상체인 인터페이스의 메서드를 구현해준 모습\n\n```java\n// 추상체 \npublic interface Login {\n\tvoid login();\n}\n\n// 구상체\npublic class KakaoLogin implements Login {\n\t@Override\n    public void login() {\n    \tSystem.out.println(\"카카오 로그인\");\n    }\n}\n\n// 구상체\npublic class NaverLogin implements Login {\n\t@Override\n    public void login() {\n    \tSystem.out.println(\"네이버 로그인\");\n    }\n}\n```\n\n\n\n\u003cbr\u003e\n\n그렇다면, 사용 쪽에서 고려할 것들을 생각해보자.\n\n1. 인스턴스 생성 시 구상체 타입이 아닌 **추상체 타입으로 선언**하자.\n\t- 카카오 로그인과 네이버 로그인에 강하게 결합된 것을 없애기 위해\n2. **팩토리 메서드 패턴**을 이용하자.\n\t- 사용하는 곳의 구현부를 바꾸지 않고, 팩토리에 정의된 메서드만 수정하기 위해\n3. **enum 타입**도 고려해보자.\n\t- enum으로 빼고 팩토리 메서드 패턴에 주입하는 식으로\n4. ⭐️ **결정을 호스트 코드로 미루자.** ( = 위임하자 )\n\t- 의존체를 외부로부터 주입받아서 최종적으로 동작을 결정하는 것\n\n\u003cbr\u003e\n\n고려한 내용의 핵심은 **인터페이스 타입(=추상체의 타입)을 사용하여, 인터페이스의 다형성을 이용하면 어떤 것이 들어오든 상관 없이 호스트 코드 쪽에서 로그인을 요청하게 만들 수 있다는 의미**이다.\n\n추상체인 Login 인터페이스를 KakaoLogin과 NaverLogin에서 이용하여 기능을 수행하고 있는 상태이기 때문에 Login에 의존하고 있는 상태이다. 여기에서 의존체를 외부로부터 주입받는다고 하였는데, 왜 주입 받는지 아래를 보자.\n\n```java\nprivate Login login = new KakaoLogin();\n```\n\n직접 생성하는 형태를 이용한다면, KakaoLogin이라는 특정 기능을 수행하는 로그인 밖에 하지 못한다. 즉, 의존성을 외부에 맡김으로 인하여, 여러 로그인을 수행할 수 있는 능력을 탑재하는 것이다. 이를 **의존도를 낮춘다**라고 표현한다. 의존성을 주입받는다고 하여 이것을 **의존성 주입, DI (Dependency Injection)**라 한다.\n\n\u003e 구상체에 의존 =\u003e 강한 결합\n\u003e 추상체에 의존 + 의존성 주입받음 =\u003e 결합도 낮아짐\n\n\u003cbr\u003e\n\n### DIP\n\n이 과정을 그림으로 살펴보자. 먼저, 의존성을 주입받지 않고 직접 의존하는 형태이다. 예를 들어, UserService에서 비즈니스 로직인 KakaoLogin, NaverLogin에 직접 의존하는 형태이다.\n\n![](https://velog.velcdn.com/images/jae_yoon/post/236b0c53-8720-4d7f-9164-f1877fdf23d7/image.png)\n\n특정 기능을 하는 로그인에 강하게 결합되어있다. 만약 구글 로그인이 추가된다면 따로 GoogleLogin 클래스를 만들고 UserService에서 관련 코드를 추가해야한다. 벌써 머리 아프다.\n\n**추상체에 의존하면서 외부로부터 의존성을 주입받아보자.**\n\n![](https://velog.velcdn.com/images/jae_yoon/post/288b4b80-9a48-4cb5-9a5d-64deaf31de72/image.png)\n\n인터페이스를 통하게 되면서, 특정 기능을 수행하는 로그인 측의 화살표 방향이 바뀌게 된 것을 볼 수 있다. 의존성을 외부로부터 주입받는 형태가 되어 이것이 **의존성의 역전, DIP (Dependency Inversion Principle)**이다.\n\n\u003cbr\u003e\n\n**DIP (Dependency Inversion Principle)**\n- 의존관계 역전 원칙\n- 상위 레벨의 모듈은 절대 하위 레벨 모듈에 의존 ❌\n\t- 둘다 **추상화에 의존해야 한다.**\n- 클래스 간 **결합을 느슨하게 하기 위함**\n- 클래스 **변경에 따른 클래스들의 영향을 최소화하기 위함**\n\n\u003cbr\u003e\n\n### default 메서드\n\n인터페이스에 정의된 추상 메서드는 반드시 구현해야 한다는 엄격함으로 인하여, Java 8 이후부터 default 메서드가 등장하게 되었다. 이는 간단하게 **인터페이스가 구현체를 가질 수 있게 된 것**이다.\n\ndefault 메서드가 없던 시절을 예시로 떠올려서 생각해보자. 인터페이스에 3가지 추상메서드가 정의되어 있지만, 나는 단 1가지만 사용하고 싶은 경우, 무조건 3가지를 반드시 구현해야한다.\n\n이러한 경우 **Adapter (어댑터)**를 이용하는 방식을 고려할 수 있다.\n\n```java\npublic class MyAdapter implements MyInterface {\n    @Override\n    public void method1() {}\n    \n    @Override\n    public void method2() {}\n    \n    @Override\n    public void method3() {}\n}\n\nclass HelloClass extends MyAdapter {\n    @Override\n    public void method1() {\n        System.out.println(\"Hello World!\");\n    }\n}\n```\n\n- 어댑터에서 인터페이스를 구현한 이후 사용처에서 어댑터를 상속받도록 !\n- 그러나, Java는 다중상속을 지원하지 않기 때문에 안되는 상황 발생\n\n\u003cbr\u003e\n\ndefault 메서드 등장으로 인하여 이러한 Adapter 역할을 하게 되었다. default 메서드에 구현하게 되면, **인터페이스 추가만으로 기능을 확장할 수 있다는 장점**도 가지게 되었다. 이러한 특징을 이용하면 인터페이스 분리 원칙인 **ISP (Interface segregation principle)**를 이용하여 객체지향적인 설계도 가능해진다.\n\n\u003cbr\u003e\n\n### 추상 클래스 vs 인터페이스\n\n그러면, default 메서드의 등장으로 추상 메서드를 **포함**하던 추상 클래스와 추상 메서드 **만으로** 이루어져 있던 인터페이스의 경계가 모호해진 것 같다. 하지만, Java에서 추상 클래스와 인터페이스를 구분하게 된 이유가 **사용 목적**에 있기 때문에, 이를 고려하면 좋다.\n\n맨 위에서 언급했듯이 **인터페이스는 메뉴얼, 설계도의 느낌**이다. 인터페이스를 구현하는 측에서 같은 동작을 한다는 것을 보장하기 위함이다. KakaoLogin 이든 NaverLogin이든 결국 \"로그인\"이라는 동작을 하는 것이 보장된다. DB에 접근하는 기술 관련 repository도 살펴보자. JDBC, MyBatis, JPA 무엇을 이용하든 결국 DB에 접근한다는 동작은 보장된다.\n\n그렇다면 추상 클래스는 어떠한가. **추상 클래스는 상속하여 공통된 기능을 만들고, 그를 기반으로 확장해 나가는 느낌**이다. 설계도를 통하여 공통된 동작을 보장하는 느낌과는 다르게 추상 클래스는 부모를 기반으로 자식을 복제하고 거기에서 확장해가는 것이다.\n\n\u003cbr\u003e\n\n### 함수형 인터페이스\n\n인터페이스에서 default 메서드가 추가되면서, 인터페이스는 **static 메서드**도 가질 수 있게 되었다. static 메서드는 JVM에 올라갈 때 맨 처음에 로드되므로, 객체 생성 없이 인터페이스의 static 메서드를 호출할 수 있게 되면서, **인터페이스 자체가 함수 제공자가 되었다**는 의미이다. 정의만이 아닌 구현을 통해 기능 자체를 제공할 수 있게된 것이다.\n\n\u003e **잠깐, 왜 메서드가 아니라 함수?**\n\u003e\n\u003e 클래스에 종속된 함수를 메서드라고 하는데, 인터페이스에서 static 메서드가 추가됨으로 종속되지 않은 상태에서 사용 가능하여 **함수**라고 불리게 되었다. 즉, 함수형 인터페이스 기능이 추가된 것이다.\n\n\u003cbr\u003e\n\n이러한 배경을 바탕으로, 모던 자바에는 함수형 인터페이스가 추가되었다. 함수형 인터페이스는 **추상 메서드가 단, 1개만 존재하는 인터페이스**이다. 편의를 위하여 추가된 함수형 인터페이스는 `java.util.function` 에 정의되어 있다. 오라클 공식 문서나 **[hudi blog - 함수형 인터페이스](https://hudi.blog/functional-interface-of-standard-api-java-8/)**를 참고하도록 하자.\n\n```java\n@FunctionalInterface\npublic interface MyRunnable {\n    void run();\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n    \t\n        // 오류 !\n    \tMyRunnable my = new MyRunnable();\n        my.run();\n    }\n}\n```\n\n- 그러나, 인터페이스는 인스턴스 생성해서 만들 수 없으니 위 코드는 오류 발생\n- 추상 메서드 1개만 있어서 동작이 예측 가능한데.. 방법이 없을까?해서 나온게 익명 클래스\n\n\u003cbr\u003e\n\n### 익명 클래스와 람다 표현식\n\n익명 클래스의 등장으로 인터페이스의 인스턴스를 생성하고 구현을 바로 정의하게 되었다. 위의 코드를 익명 클래스를 사용하여 수정하면 아래와 같다.\n\n```java\n@FunctionalInterface\npublic interface MyRunnable {\n    void run();\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n    \t\n\t\tMyRunnable my = new MyRunnable() {\n              @Override\n              public void run() {\n                  System.out.println(\"안뇽 난 익명클래스\");\n              }\n        };\n    }\n}\n```\n\n하지만, `new`를 사용하여 인스턴스를 생성, `@Override`를 이용한 메서드 오버라이딩 등 너무나 당연한 코드가 중복되는 것을 없애고자 **Lambda 표현식**이 나오게 되었다.\n\n```java\n// 익명 클래스\nMyRunnable my = new MyRunnable() {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"안뇽 난 익명클래스\");\n\t}\n};\n\n// 람다 표현식\nMyRunnable my = () -\u003e System.out.println(\"안뇽 난 익명클래스\");\n```\n\n\u003cbr\u003e\n\n### 메서드 레퍼런스\n\n람다식을 사용하다보면, 인텔리제이에서 노란색 줄이 그어지면서 \"제발 나 좀 바꿔줘!\"라고 소리쳤다. 그래서 바꿔보면 기괴한 형식이 나왔다.\n\n```java\n// 람다식\nMyMapper\u003cString, Integer\u003e m = (str) -\u003e str.length();\n// 메서드 레퍼런스\nMyMapper\u003cString, Integer\u003e m = String::length;\n\n// 람다식\nMyMapper\u003cInteger, String\u003e m3 = i -\u003e Integer.toHexString(i);\n// 메서드 레퍼런스\nMyMapper\u003cInteger, String\u003e m3 = Integer::toHexString;\n```\n\n이는, 람다식에서 입력되는 값을 변경없이 바로 사용하는 경우에는, 자명하기 때문에 더 간단한 형태로 바꿔주는 방식이다. 최종으로 적용될 메서드의 레퍼런스를 지정해주는 표현 방식으로써, **메서드 레퍼런스**라고 한다.\n\n메서드 레퍼런스 사용 시 장점이 있는데, **값의 변경이 확실하게 없다고 보장**할 수 있다는 의미이다. 좀 확대해서 표현하면 **입력 값을 변경하지 말라**라는 표현 방식이기도 하다. 코드를 유지보수 해야하는 상황에 메서드 레퍼런스로 작성된 것을 보고 결과값을 마음대로 바꾸지 못하게 하여 안정성을 얻을 수 있다는 장점이 있다.\n\n\u003cbr\u003e\n\n### 모던 자바 사용법\n\n`java.util.function`에서 제공해주는 함수형 인터페이스와 람다 표현식을 잘 이용하면 재밌게 코드를 작성할 수 있다.\n\n```java\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class Main {\n\t// 여기가 호스트 코드 !\n    public static void main(String[] args) {\n        new Main().filteredNumbers(\n        \t\t50,\n                i -\u003e i % 5 == 0,\n                System.out::println\n        );\n    }\n\n    void filteredNumbers(int max, Predicate\u003cInteger\u003e predicate, Consumer\u003cInteger\u003e consumer) {\n        for (int i = 0; i \u003c max; i++) {\n            if (predicate.test(i)) consumer.accept(i);\n        }\n    }\n\n    void loop(int n, MyConsumer\u003cInteger\u003e consumer) {\n        for (int i = 0; i \u003c n; i++) {\n            consumer.consume(i);\n        }\n    }\n}\n```\n\n- 함수형 인터페이스인 Consumer를 이용하여 입력은 있지만, 출력은 따로 없어도 되는 상태를 만들었다.\n- 수행해야 할 것을 만들어놓고 구체적인 상황을 직접 처리하는 것이 아닌 **호스트 코드로 미룬 상태**이다. 위에서 의존성을 주입받던 상황과 닮지 않았는가?\n- 결과적으로 실질적인 구현부는 하나도 바꾸지 않으면서 호출하는 쪽에서 기능을 수행하도록 만들 수 있는 것이다. 👍\n\n\u003cbr\u003e\n\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/DevCourse/004":{"title":"[2주차] 2023-06-07","content":"\n## 💻 2주차 DAY 03\n\n2주차 DAY 03 ~! 강의를 2일치 몰아들었다. 모던 자바의 컬렉션과 스트림에 관한 이야기와 본격적인 객체지향 설계를 학습했다. 특히, 함수형 인터페이스를 적용하는 부분에서 곰튀김님께서 설명을 너무너무 잘해주셔서 아하 모먼트가 많았고 수업을 재밌게 들었다. 마지막으로, 본격적인 계산기 과제를 위하여 간단하게 설계해보는 시간을 가졌다.\n\n\u003cbr\u003e\n\n### Collection\n\n사실 JAVA가 약한 나는 컬렉션이 친숙하지 않았다. 단순히 자료구조라고만 생각하고 있었는데, 조금 더 이해해보면 **여러 데이터의 묶음이 컬렉션**이라고 이해할 수 있다.\n\n- 데이터 덩어리를 **받아서**, 데이터 덩어리를 **내보내자**.\n- 컬렉션은 추상체-구상체의 구조를 띈다.\n  - Collection (추상체)\n    - List (Colleciton의 구상체)\n      - LinkedList (List의 구상체)\n      - ArrayList (List의 구상체)\n      - Vector (List의 구상체)\n      - Stack (List의 구상체)\n    - Set\n      - HashSet\n\n\u003cbr\u003e\n\n### 함수형 인터페이스 적용\n\n이전 시간에 JAVA API에서 제공해주는 함수형 인터페이스에 관하여 배우기는 하였지만, 어떤식으로 적용되는지 사실 와닿지 않았었다. 오늘 컬렉션에 적용하는 모습을 보면서 살~짝 느낌을 잡았다.\n\n- 함수형 인터페이스를 활용하여 고정된 형태의 기능을 가지는 것이 아니라, **사용하는 측에서 그 기능을 정의할 수 있는 범용적인 형태의 컬렉션을 만들어 냄**\n- 이렇게 여러 데이터를 묶어서 다루는 것을 **Collection**이라고 한다. Collection은 데이터의 묶음이다. filter를 하든 map을 하든 묶여있는 데이터 덩어리를 내보냄\n\n\u003cbr\u003e\n\n**예제 1. forEach 만들기 + consumer 적용**\n\n```java\npublic void foreach() {\n\tfor (int i = 0; i \u003c list.size(); i++) {\n    \tT data = list.get(i);\n    }\n}\n```\n\n- `foreach()` 메서드는 data에서 무언가를 하려고 하는데, return 없이 void인 상태이다. 함수형 인터페이스의 **consumer** !?\n\n\n```java\npublic void foreach(Consumer\u003cT\u003e consumer) {  \n\tfor (int i = 0; i \u003c list.size(); i++) {  \n\t\tT data = list.get(i);  \n\t\tconsumer.accept(data);  \n\t}  \n}\n```\n\n- consumer를 사용해서 accept로 받아주는 모습이다.\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t// 익명 클래스\n\t\tnew MyCollection\u003c\u003e(Arrays.asList(1, 2, 3, 4, 5))  \n\t\t\t.foreach(new Consumer\u003cInteger\u003e() {  \n\t\t\t\t@Override  \n\t\t\t\tpublic void accept(Integer integer) {  \n\t\t\t\t\tSystem.out.println(integer);  \n\t\t\t\t}  \n\t\t\t});\n\n\t\t// 람다식\n\t\tnew MyCollection\u003c\u003e(Arrays.asList(1, 2, 3, 4, 5, \"A\"))\n\t\t\t.foreach(System.out::println);\n\t}\n}\n```\n\n- 익명 클래스 사용과 람다식의 사용이 익숙하지 않아서 만들어본 `foreach()` 메서드를 사용하는 예제도 넣어봤다.\n\n\u003cbr\u003e\n\n**예제 2. 데이터 변형해보기 + function 적용**\n\n```java\npublic \u003cU\u003e MyCollection\u003cU\u003e map(Function\u003cT, U\u003e function) {  \n\tList\u003cU\u003e newList = new ArrayList\u003c\u003e();  \n\tforeach(data -\u003e newList.add(function.apply(data)));  \n\treturn new MyCollection\u003c\u003e(newList);  \n}\n```\n\n- 데이터를 변경하는 것을 매핑한다 혹은 map 과 같이 표현함\n- `public MyCollection\u003cU\u003e map(Function\u003cT, U\u003e function)` 이라고 하면 오류 발생\n  - 1번에서 정의한 `MyCollection`에는 `\u003cT\u003e`만 있음\n  - 이 map 메서드에서만 사용하는 `\u003cU\u003e` 타입에 대하여 추가해야함\n  - 그래서 `public \u003cU\u003e MyCollection\u003cU\u003e map(Function\u003cT, U\u003e function)` 형태가 만들어짐\n- newList에는 List에 들어있는 T 타입의 값이 **function이라는 함수형 인터페이스**에 의해 새로운 U 타입으로 바뀐 결과가 들어감\n\n\u003cbr\u003e\n\n**예제 3. 필터 만들기 + Predicate 적용**\n\n```java\npublic MyCollection\u003cT\u003e filter(Predicate\u003cT\u003e predicate) {  \n\tList\u003cT\u003e newList = new ArrayList\u003c\u003e();  \n\tforeach(data -\u003e {  \n\t\tif (predicate.test(data)) newList.add(data);  \n\t});  \n\treturn new MyCollection\u003c\u003e(newList);  \n}\n```\n- 파라미터가 있고 그에 대한 boolean 값을 반환해주는 **predicate** 사용\n- 결과가 참이면 newList에 추가되도록~\n\n\u003cbr\u003e\n\n### Iterator\n\nColleection은 데이터 덩어리를 받아서, 데이터 덩어리를 내보낸다고 하였다. 이러한 여러 데이터의 묶음을 풀어서 하나씩 처리하고 싶은 경우가 있는데, 이러한 수단을 제공하는 것이 Iterator이다. `next()`를 통해 순방향으로 데이터를 조회하는 것은 가능하지만, 역순으로 움직일 수는 없다.\n\n정리해보면 Iterator는 **데이터 덩어리인 Collection을 풀어서 하나씩 사용하는 형태**라는 것이다. 하지만, 이렇게 되면서 데이터 묶음으로 처리하는 Collection에서 사용하던 **편리한 기능인 고차함수 map, filter, reduce** 같은 기능을 사용하지 못하게 되었다.\n\n그러면, Iterator 같이 하나씩 풀어쓰는 형식에서는 함수형 인터페이스를 활용한 고차함수를 사용할 수 없을까?\n\n\u003cbr\u003e\n\n### Stream\n\n그래서 등장한 것이 Stream이다. Stream은 **데이터의 연속으로, 연속된 데이터 중 하나**를 의미한다. 내가 이야기할 것은 모던 자바의 Stream이다. IO 스트림도 있지만, 그것은 \u003ca href='https://shin-jae-yoon.github.io/brain/Lecture/fun-java/fun-java09#io-stream' target='_blank'\u003eDev Uni 기록용 블로그 - IO 스트림\u003c/a\u003e 을 참고하자.\n\n모던 자바에 추가된 스트림은 데이터 스트림으로, 제공되는 `Collections.stream()`을 의미한다. **컬렉션 안의 데이터를 연속적인 흐름으로 처리할 수 있게 되었다.** 추가로, 고차함수 `filter`, `map`, `forEach`가 제공되어 아주 편하다.\n\n\u003e ⭐️ Stream의 등장으로 인하여, 연속된 데이터에 대한 풍부한 고차함수들을 사용하여 강력한 기능을 간결하게 표현할 수 있게 되었다 !!\n\n\u003cbr\u003e\n\nStream을 생성하는 방식에는 **generate**와 **iterate**가 있다.\n\n- **`Stream.generate()`**\n  - `generate()`의 파라미터로 supplier가 들어감\n  - 함수형 인터페이스 supplier는 input 값은 없고 결과값이 무언가 나와야하는 것을 의미한다.\n  \n```java\nRandom r = new Random();  \nStream.generate(() -\u003e r.nextInt())  \n\t.limit(10)  \n\t.forEach(System.out::println);\n```\n\n\u003cbr\u003e\n\n- **`Stream.iterate()`**\n  - 초기 값인 시드값이 들어오고, 그 다음에 어떠한 결과를 전달하는 방식\n  - 파라미터 2개를 이용한다.\n  \n```java\nStream.iterate(0, (i) -\u003e i + 1)  \n\t.limit(20)  \n\t.forEach(System.out::println);\n```\n\n\u003cbr\u003e\n\n### Optional\n\n개발자로 살아가며 가장 많이 마주할 문제가 바로 NPE (Null Pointer Exception)이다. Java는 거의 모든 것이 reference value라서 null이 될 가능성을 항상 가지고있다. 그래서 매번 null 체크를 확인해야할 필요가 있었고, 이러한 Optional이 등장하게 되었다.\n\n\u003e 여담이지만, 예전에 공부했던 바로는 사실 Optional을 사용하지 않는 상황이 제일 좋다고 한다. 즉, null이 나올 것 같다고 무조건 Optional을 때려버리는 것이 아니라 최대한 방어적으로 코딩하는 것이 좋다고 한다.\n\n\u003cbr\u003e\n\n**Optional은 null이 될 수 있는 값들을 운반해주는 일종의 캐리어**이다. 즉, Optional이 비어있는지 아닌지를 체크하여 NPE를 피하면서 null인지 아닌지를 알 수 있는 것이다.\n\n- `isEmpty()` -\u003e 값이 없으면 true ( = null이면 true )\n- `isPresent()` -\u003e 값이 있으면 true\n\n\u003cbr\u003e\n\n### 숫자야구 프로젝트\n\n실습 프로젝트 수업에서는 숫자야구를 구현해보는 방식이었다. 내가 봐왔던 숫자야구 구현과는 다르게 곰튀김님께서는 함수형 인터페이스를 자유자재로 다루셨고, IDE의 기능을 최대한 활용하여 상황에 맞게 코드를 짜시는 것을 보고 감탄했다.\n\n코드를 이해하기는 했는데, 생각의 흐름이 너무 좋았어서, 이는 강의와 코드를 여러 번 반복해서 보려고 한다. 완벽하게 내 것으로 만들고 나중에 따로 포스팅하는 것을 추가하도록 하겠다.\n\n\u003cbr\u003e\n\n### 계산기 프로젝트 preview\n\n\u003cbr\u003e\n\n**프로젝트 세팅 과정**\n\n오늘은 프로젝트 세팅과 간단한 설계에서 끝났다. 프로젝트 세팅에 관해서 조금 애먹었는데, 먼저 fork 뜨고 clone 이후 작업 branch를 하나 만들고 `.gitignore` 추가까지는 평탄했다. \n\n그러나, 프로젝트를 생성하려고 보니 클론한 프로젝트에는 README.md 파일 밖에 없어서 gradle을 추가로 설정해야하는 상태였다. New Project를 하려고 하니 새로운 폴더가 계속 형성되었고 `java-calculator/java-calculator` 이런식으로 되니까 보기가 불편했다.\n\n그래서, 1주차에 학습했던 것을 토대로 터미널로 프로젝트 폴더에 들어가서 `gradle init`으로 환경을 구성했다. 기존에 인텔리제이로 new project 하던 것보다 더 많은 파일이 나왔고, `build.gradle`에도 하나하나 주석이 달려있어서 사실 보기 좀 불편했다.\n\n그러던 와중 데브코스 팀원께서 방법을 찾으셔서 그 방법으로 시도했다.\n\n1. 클론한 프로젝트 폴더에서 new project로 내부에 프로젝트 그대로 생성\n2. 생성한 프로젝트 파일을 그대로 밖으로 가져와서 복사 붙혀넣기\n3. 인텔리제이 껐다가 키고 gradle 싱크 맞추기\n\n이렇게하니 기존에 인텔리제이로 만들던 것과 동일하여서 드디어 기쁘게 시작할 수 있었다...!! 아래는 gitignore 세팅과 추가적인 IDE 세팅들이다.\n\n\u003cbr\u003e\n\n- gitignore\n\n```bash\nHELP.md\n.gradle\nbuild/\n!gradle/wrapper/gradle-wrapper.jar\n!**/src/main/**\n!**/src/test/**\n\n### macOS ###\n.DS_Store\n\n### STS ###\n.apt_generated\n.classpath\n.factorypath\n.project\n.settings\n.springBeans\n.sts4-cache\n\n### IntelliJ IDEA ###\n.idea\n*.iws\n*.iml\n*.ipr\nout/\n\n### NetBeans ###\n/nbproject/private/\n/nbbuild/\n/dist/\n/nbdist/\n/.nb-gradle/\n\n### VS Code ###\n.vscode/\n# Ignore Gradle build output directory\nbuild\n\n# Ignore Gradle GUI config\ngradle-app.setting\n\n# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)\n!gradle-wrapper.jar\n\n# Avoid ignore Gradle wrappper properties\n!gradle-wrapper.properties\n\n# Cache of project\n.gradletasknamecache\n\n### Gradle Patch ###\n# Java heap dump\n*.hprof\n```\n\n- 인텔리제이 세팅\n1. File → Project Structures → SDK 자바 버전 11 확인\n2. Settings → Build → Build Tools → Gradle → 둘다 IntelliJ Idea로 수정\n3. Settings → Tools → Actions on Save → Optimize imports 체크\n4. Settings → Editor → General → Auto Import → 가운데 2개 import fly 체크\n5. Settings → Editor → Code Style → Java → 숫자 2개 999로 수정\n\n\u003cbr\u003e\n\n**계산기 설계**\n\n아직 디테일하게 설계는 못했지만, 최대한 SOLID 원칙을 신경쓰며 객체지향적으로 구성하려고 노력해보고 있는 상태이다. 지금까지 생각해본 구조는 대략 아래와 같다.\n\n- View\n  - Console\n- Model\n  - Calculation (인터페이스, 추상체)\n    - Plus (구상체)\n    - Minus (구상체)\n    - Divide (구상체)\n    - Multiple (구상체)\n  - Priority\n- Repository\n  - InMemoryRepository (인터페이스, 추상체)\n    - MapMemory (구상체)\n- Controller\n\n음~! 근데 각각 계산 방식에 대하여 저렇게 동사는 메서드니까 저걸 구현하는 것으로 가는게 아니라 연산자와 피연산자 객체를 설정하고 그에 해당하는 계산을 따로 빼야하나 싶기도 하고 ,, 컨트롤러는 어떻게 모델과 뷰를 연결시킬지에 대한 고민도 해봐야 할 것 같다.","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/DevCourse/005":{"title":"[2주차] 2023-06-08","content":"\n## 💻 2주차 DAY 04\n\n2주차 DAY 04.. 본격적인 계산기 과제를 시작했다. 계속 설계에만 몰두하다보니 정작 코드는 많이 짜지 못하였고, 금일 RBF나 잡혀있어서 생각보다 이래저래 시간을 많이 썼다.\n\n\u003cbr\u003e\n\n### 공유받은 꿀팁\n\nRBF (Random Bit Filp) 시간 때 팀원분께서 인텔리제이 플러그인인 Translation을 알려주셨다. 평소 변수명을 짓기 위하여 구글 번역기를 전전하던 나로써는 너무나 큰 꿀팁이었다.\n\n![](https://velog.velcdn.com/images/jae_yoon/post/3113f1de-7b15-4b7f-91ec-b5f5b4dc4eeb/image.gif)\n\n\n플러그인 설치 이후 명령어는 아래와 같다.\n- `ctrl + cmd + i` : 번역기 팝업 띄우기\n- `ctrl + cmd + u` : 영어 → 한글 번역 (docs 볼 때 유리)\n- `ctrl + cmd + o` : 한글 → 영어 번역 (변수명 짓기 개꿀)\n\n\u003cbr\u003e\n\n### 계산기 설계 고민\n\n설계에 관한 고민만 하다가, 본격적으로 코드를 많이 짜지는 못한 상황이다.\n\n- Operator 인터페이스를 구현하는 Addition, Substraction, Multiplication, Division은 너무 과한 것 아닐까? 세부적으로 구현되는 코드도 별로 없을 것이고.. 책임을 \"연산\"으로만 나누고 \"덧셈\"과 같이 구체적으로 나눠야하나?\n  - enum으로 따로 빼서 함수형 인터페이스를 사용하면 어떨까\n- Integer 사용 시, 계산 결과가 21억까지 밖에 나오지 않을텐데, 예외 처리를 하는 것보다 더 큰 수를 다룰 수 있도록 하는 것이 낫지 않을까\n  - BigDecimal을 사용하면 어떨까\n- 메뉴 번호를 입력 받을 때 1번과 2번만 받아야하는데, 이를 따로 뺴야하나?\n  - 이것 역시 enum으로 빼고 이외의 숫자나 문자가 들어오게 된다면 예외를 던져볼까\n- 예외처리하는 클래스를 따로 만들어서 처리하는 것이 나을까\n- Console을 통하여 입출력을 받는 상황인데, 나는 Input 인터페이스와 Output 인터페이스를 만들었고 이를 구현하는 InputView 클래스와 OutputView 클래스를 만든 상황. 이걸로 충분할까?\n\n\u003cbr\u003e\n\n### 팀 미팅 시간\n\n위와 같은 고민만 하다가 정작 코드는 많이 못 짠 상황인데, 팀 미팅 시간에 다른 팀원분은 진행이 어느정도 된 상태라 흑구 멘토님이 간단하게 리뷰해주셨다. 그 과정에서 자연스레 나의 고민도 약간이나마 해결되었다.\n\n1. 연산이라는 책임만 지게 하는 것이 괜찮다. 객체지향적으로 설계하다보면, 파일이 너무 많아지는 것도 있고, 사칙연산 하나하나를 클래스로 빼게 되는 것은 좋지 않아 보인다. enum으로 빼보자. (내가 고민하던 방향으로 해결 🟢)\n2. `calculate(int, int)` 같은 경우 테스트 코드를 짰을 때 문제가 생길 것 같지 않을까? 역시 내가 고민하던 방향이 맞았다. BigDecimal을 사용해보자.\n3. 메뉴 번호 처리 역시 enum으로 빼는 방향이 맞았다.\n4. 예외 처리하는 클래스를 따로 만드는 것 까지는 해결되지 않았지만, 최대한 **자바스럽게** 코드를 짜보자. try-catch나 throw와 같이 예외처리를 반드시 해보는 쪽으로! 코드가 더러워지는건 같이 고민해주겠다.\n5. `if - else if` 에 관하여 생각해본적이 있는가. if는 분기처리를 하여 쭈루룩 다 돌아야하기도 하고 가독성도 그렇게 좋지는 않다. `switch` 문을 고려하자.  \u003ca href='https://sas-study.tistory.com/475' target='_blank'\u003e흑구님의 Java Switch문 정리하기\u003c/a\u003e 게시글을 참고하자.\n6. Input, InputImpl, Output, OutputImpl, Console이 있고 상속의 형태가 아닌 컴포지션을 이용해보는 것은 어떠한가 (디자인 패턴의 컴포지트 패턴 ❌)\n7. Calculator에서 repository를 다룰 필요가 있나? 또, Calculator가 맡는 역할이 너무 많지 않은가?\n   - 계산기의 책임이 연산의 책임이라고 생각할 필요가 없을 것 같다.\n   - 계산기, 연산, 표현식과 같이 3가지 책임으로 생각해보는 것은 어떨까\n8. 시스템이 거대해졌을 경우도 생각해보자.\n   - Main 메서드에서 ManagementSystem과 같이 시스템을 만들고 의존성을 주입해보는 방식\n   \n우선, 기억 나는대로 다른 팀원분이 받은 피드백을 정리해봤는데, 사실 이해가 가지 않는 부분도 많았다. 이 부분은 내일 추가로 질문드릴 예정이다.\n\n\u003cbr\u003e\n\n### 내가 받은 피드백\n\npre 팀 첫 미팅 때 나왔던 피드백과 사실 결이 비슷했다. 받은 피드백을 토대로, 앞으로 어떤식으로 바꿔가야할 지 목록은 아래와 같다.\n\n- 하나를 깊게 파는 것이 너무 중요하지만, 사실 데브코스 기간 동안은 잠시 내려 놓자. 가성비가 굉장히 떨어지는 방식이다. 결국 목적은 취업이니까.\n- 설계라던가 꼼꼼함이라던가는 조금 내려놓자. 특히, TIL 작성, 수업 필기 등 코드 짜는 것이나 외적인 요소에 너무 신경쓴다. **제발 설계는 간단히, 필기는 간단히하고 코드부터 짜기, 머리로 이해하며 기억하기를 추구하자**\n- 데브코스 과정은 생각보다 어렵고 빡센 과정이다. 올빼미형으로 살다가는 버티기 힘들 수 있다. 생활 패턴을 아침형으로 바꿔보자.","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Infra/":{"title":"Infra","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Interview/":{"title":"Interview","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Interview/dog-study/":{"title":"개발바닥 면접스터디","content":"","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Interview/dog-study/dog-study":{"title":"개발바닥 면접스터디","content":"\n\u003cbr\u003e\n\n# Tech Interview\n\n\u003cbr\u003e\n\n\u003e 꼬리에 꼬리를 무는 면접 대비\n\n개발바닥 2사로에서 진행되는 \u003ca href='https://github.com/DevInterviewStudy/Backend-6' target='_blank'\u003e면접스터디\u003c/a\u003e 입니다. 주제를 선정하고 공격 2명, 수비 2명을 랜덤으로 당일에 선정하고 멘토님 참관하에 스터디가 진행됩니다. \n\n\u003chr\u003e\n\n## 목차\n\n- [1주차 스터디 - 불변객체, Exception](brain/Interview/dog-study/dog-week01)\n- [2주차 스터디 - Exception Handling](brain/Interview/dog-study/dog-week02)\n- [3주차 스터디 - Spring Basic](brain/Interview/dog-study/dog-week03)\n- [4주차 스터디 - Spring Web](brain/Interview/dog-study/dog-week04)\n- [5주차 스터디 - Spring 응용](brain/Interview/dog-study/dog-week05)\n- [6주차 스터디 - Spring Data](brain/Interview/dog-study/dog-week06)\n- [7주차 스터디 - Spring Transaction](brain/Interview/dog-study/dog-week07)\n- [8주차 스터디 - Spring JPA](brain/Interview/dog-study/dog-week08)\n- [9주차 스터디 - Spring 심화](brain/Interview/dog-study/dog-week09)\n","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Interview/dog-study/dog-week01":{"title":"1주차 - 불변객체, Exception","content":"\n\u003ca href='https://github.com/dingding-21/Rebellion-Of-Interviewees/issues/1' target='_blank'\u003e1주차 스터디 Issue 바로가기\u003c/a\u003e \n\n\u003chr\u003e\n\n\u003e[!note] 1주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC - 01** \u003cbr\u003e\n\u003e \u0026nbsp;\u0026nbsp;\u0026nbsp;불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요.\n\u003e \u003cbr\u003e\u003cbr\u003e\n\u003e **TOPIC - 02** \u003cbr\u003e\n\u003e \u0026nbsp;\u0026nbsp;\u0026nbsp;Checked Exception과 Unchecked Exception은 어떤 차이가 있는지 설명해주세요.\n\n\n\n## TOPIC 01 - 불변객체\n\n\u003cbr\u003e\n\n### 복사 시리즈\n\n1. 얕은 복사\n\t- 값을 복사하는 것이 아닌, 주소값을 복사\n\t- 따라서, 원본이 바뀌면 원본을 얕은 복사한 객체들도 같이 변경됨 (참조하고 있으니까)\n\n2. 깊은 복사\n\t- 내부 요소들 전부 복사하여 새로운 객체 생성\n\t- 객체가 가리키는 주소값이 원본과 모두 다름\n\t- 원본이든 내부 요소이든 바뀌어도 영향 없음\n\n3. 방어적 복사\n\t- 생성자에서 사용 시 입력받은 인자를 내부 필드로 초기화\n\t\t- 하지만, 인자의 내부 요소들은 그대로 원본 내부요소를 가리킴\n\t- `getter` 메서드에서 내부의 객체를 반환할 때, 객체의 복사본을 만들어 반환하는 것\n\t- ==객체의 내부 필드 값을 외부로부터 보호하는 것이 목적==\n\n4. Unmodifiable Collection\n\t- 원본 컬렉션으로의 수정 메서드를 할 수 없는 Read Only\n\t- `unmodifiableList()` 메서드를 통해 리턴되는 리스트는 읽기 용도로만 사용 가능\n\t- 하지만, `unmodifiable`과 `immutable`은 다르다. \n\t\t- `unmodifiable`이 불변성을 보장해주지는 않음\n\t\t- 원본 자체에 대한 수정이 일어나면 `unmodifiableList()` 메서드를 통해 반환되었던 리스트 또한 변경이 일어남\n\n\n\u003e 즉, 원본과의 주소 공유를 끊으려면 깊은 복사 or 방어적 복사를 해야함 \n\n\n\u003cbr\u003e\n\n**1. 생성자의 인자로 객체를 받았을 때**\n\n- 외부에서 넘겨줬던 객체를 변경해도 내부 객체는 변하지 않아야 하므로 ==방어적 복사==가 적절\n\n**2. getter 를 통해 객체를 리턴할 때**\n\n- 이러한 상황에선 ==방어적 복사==와 ==Unmodifiable Collection== 중 하나를 사용하여 값을 리턴하는것이 적절하다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 불변객체란?\n\n\u003cbr\u003e\n\n불변객체(immutable object)는 말 그대로 변하지않는 객체로 객체가 생성된 후 내부 상태가 변하지 않는 객체를 의미한다. 객체가 변하지 않는다는 것은 신뢰도가 높아진다는 의미이다.\n\n- 반대 개념은 가변객체(mutable object)로  객체 생성 이후에도 상태를 변경할 수 있음\n\n- 객체 생성 이후 내부 상태가 변하지 않으니, 불변객체는 Setter 메서드를 제공하지 않는다.\n\n- 혹은 방어적 복사(defensive-copy)를 통해 제공한다.\n\n\u003cbr\u003e\n\n\u003e [!note] final을 붙이면 불변객체가 되는 것인가?\n\u003e\n\u003e final 예약어 사용시\n\u003e - 변수 : 값을 수정할 수 없는 상수로 만듦\n\u003e - 메서드 : 오버라이딩을 할 수 없게 만듦\n\u003e - 클래스 : 상속이 불가능하게 만듦\n\u003e \u003cbr\u003e\n\u003e 즉, 객체 선언 시 final을 사용해도 **객체 내부 상태는 변경할 수 있다**\n\n\u003cbr\u003e\n\n### 불변객체 장점\n\n1. 쓰레드에 안전하여 멀티-쓰레드 환경에서 동기화를 고려하지 않아도 된다. (thread-safety)\n\n2. 불변객체를 필드로 사용할 때 방어적 복사가 필요없다.\n\n3. 불변객체는 내부상태가 변경되지 않으므로, Map Key와 Set 요소로 사용하기에 적합하다.\n\n4. 불변객체를 한 번 메모리에 할당하면 같은 객체를 계속 호출하여도 새롭게 할당하지 않아도 되므로 Garbage Collector의 성능을 높힐 수 있다.\n\n\u003cbr\u003e\n\n### 불변객체 단점\n\n1.  모든 객체의 불변성을 보장하게 된다면, 상태 변화가 필요한 경우 새로운 객체를 생성해야 한다는 단점이 있고, 새로운 객체를 많이 생성하는 경우 성능 문제가 발생할 수 있다.\n\n2.  하지만 Oracle에 의하면, 객체 생성 비용에 대한 영향은 종종 과대평가되며, 불변 객체를 활용할 때의 이점들이 이런 단점을 상쇄시킨다고 한다.\n\n\u003cbr\u003e\n\n### 불변객체 생성방법\n\n1. **`setter` 메서드 제공 X**\n\t- 내부 상태값을 변경하지 않기 위하여 `setter` 메서드를 제공하지 않는다.\n\n2. **클래스를 `final`로 선언**\n\t- 클래스를 `final`로 선언하면 해당 클래스를 다른 클래스에서 상속받는게 불가능, 따라서 부모 클래스에 선언되어 있는 메서드 Overriding 불가능\n\t- `final`을 선언했다고 객체가 immutable 한 것을 보장할 수 있지는 않음. 위에서 설명한 이유처럼 객체 내부상태는 여전히 바뀔 수 있음\n\t- 즉, 1번 방법이랑 같이 써야하는 것\n\n3. **모든 필드를 final과 private을 사용해서 선언**\n\t- 변수에 final을 붙이면 재할당이 불가능하게 상수 취급됨\n\t- 인스턴스 변수\n\t\t- ==Primitive type, 원시타입== : final로 선언하여 불변성 유지 가능\n\t\t- ==Reference type, 참조타입== : final로 선언하면 참조 대상이 바뀔 수 없다는 의미일 뿐 불변성을 보장할 수는 없다. 객체 내부 상태가 바뀔 수 있기 때문이다.\n\t- 따라서, 접근 제어자를 private으로 선언하여 해당 클래스만 해당 필드에 대한 접근 권한을 가지게 변경, setter 메서드를 제공하지 않으니 외부 클래스로부터 접근 차단하니까\n\n4. **객체를 생성하기 위한 생성자 or 정적 팩토리 메서드 추가**\n\t- 생성자를 통해 초기화되는 필드들은 깊은 복사를 통한 참조 대상 재할당\n\t\t- 생성자를 통해 초기화되는 인스턴스 변수들이 Reference Type이면 깊은 복사를 통해 참조하는 객체 내부의 값이 변경되는 것을 방지할 수 있음\n\t- getter 메서드를 객체의 깊은 복사본을 반환하도록 함\n\t\t- getter 메서드가 실제 객체에 대한 reference를 반환하는 대신 깊은 복사를 통해 ==생성한 객체에 대한 reference를 반환==하여, 반환받은 객체를 사용할 때 실수로라도 기존 객체를 건드릴 수 없게\n\n5. **인스턴스 필드에 가변객체가 포함된다면 방어적 복사를 이용하여 전달**\n\n\u003cdetails\u003e\n\u003csummary\u003e ==\u003cstrong\u003e코드 예시보기\u003c/strong\u003e== \u003c/summary\u003e\n\n\u003ca href='https://dev-cool.tistory.com/23' target='_blank'\u003e코드 출처\u003c/a\u003e\n\n```java \npublic final class ImmutableClass {  \n    /*  \n     * Integer 와 String 은 immutable 객체로  \n     * 값을 변경하는 Setter 가 없어서 값이 변하지 않는다.  \n     * */    \n    private final Integer immutableField1;  \n    private final String immutableField2;  \n    private final Date mutableField;  \n  \n    private ImmutableClass(Integer immutableField1, String immutableField2, Date mutableField) {  \n        this.immutableField1 = immutableField1;  \n        this.immutableField2 = immutableField2;  \n        this.mutableField = new Date(mutableField.getTime());  \n    }  \n  \n    public static ImmutableClass createImmutableClass(Integer immutableField1, String immutableField2, Date mutableField){  \n        return new ImmutableClass(immutableField1,immutableField2,mutableField);  \n    }  \n  \n    public Integer getImmutableField1() {  \n        return immutableField1;  \n    }  \n  \n    public String getImmutableField2() {  \n        return immutableField2;  \n    }  \n  \n    /*  \n     * Date 는 가변 객체로 인스턴스 변수의 참조를 return 하지 않는다.  \n     * 대신에 new 예약어를 사용해서 방어적복사를 수행한다.  \n     * */    \n     public Date getMutableField() {  \n        return new Date(mutableField.getTime());  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return \"immutableField1 = \" + immutableField1 + \", immutableField2 = \" + immutableField2 + \", mutableField = \" + mutableField;  \n    }  \n}\n\n\npublic class Main {  \n    public static void main(String[] args) {  \n        ImmutableClass immutableClass = ImmutableClass.createImmutableClass(1,\"cool\",new Date());  \n        System.out.println(immutableClass);  \n  \n        modiftyField(immutableClass.getImmutableField1(),immutableClass.getImmutableField2(),immutableClass.getMutableField());  \n        System.out.println(immutableClass);  \n    }  \n  \n    private static void modifyField(Integer immutableField1, String immutableField2, Date mutableField){  \n        immutableField1 = 2;  \n        immutableField2 = \"kim\";  \n        //가변객체 Date 의 setter 메소드  \n        mutableField.setTime(2);  \n    }  \n}\n\n// immutableField1 = 1, immutableField2 = cool, mutableField = Tue Feb 08 09:57:02 KST 2002\n// immutableField1 = 1, immutableField2 = cool, mutableField = Tue Feb 08 09:57:02 KST 2002\n```\n\n- 불변객체 생성 방법에 따라 생성 이후 객체의 상태를 바꾸는 메서드를 실힝해도 내부 상태가 변경되지 않은 결과를 확인하였음.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### String\n\n- String은 대표적인 불변객체의 예시이다.\n\t- 변수에 할당되면 참조를 업데이트하거나 내부 상태를 어떤 방법으로도 변경할 수 없기 때문\n\n- String 객체를 생성하는 방법 2가지\n\t- String literal `\"\"` 사용\n\t- new 연산자 사용\n\n```java\nString s1 = \"Cat\";\nString s2 = \"Cat\";\nString s3 = new String(\"Cat\");\n\ns1 == s2; // true\ns1 == s3; // false\n```\n\n\u003cbr\u003e\n\n![](brain/image/dog-week01-1.png)\n\n- literal로 생성한 객체는 String pool에 들어간다.\n\t- 생성한 객체의 값이 이미 존재한다면, String pool의 reference를 참조한다.\n\t- 문자열 리터럴을 캐싱하고 재사용하기 때문에 Heap 공간을 많이 절약할 수 있음\n\n- new 연산자로 생성하면 상수 풀에 있어도 Heap 영역에 새로운 객체를 생성한다.\n\t- 이는 불변객체인 String의 장점을 누리지 못한다는 의미\n\n- `intern()` 메서드\n\t- String pool에 String 객체 존재 -\u003e 그 객체를 그대로 return\n\t- String pool에 String 객체 존재 X (new 연산자로 생성한 경우)\n\t\t- 호출된 String 객체를 String pool에 추가하고 객체의 reference를 return\n\n\u003e String pool, Constant String pool 은 같은 의미\n\u003e Constant Pool, Runtime Constant Pool 등을 이해하려면 \u003ca href='https://jae-yoon.tistory.com/17' target='_blank'\u003e블로그 게시글\u003c/a\u003e 참고\n\n\u003cbr\u003e\n\n### String이 불변인 이유\n\n\u003cbr\u003e\n\n1. **성능 (Performance)**\n\t- 상수 풀을 이용하여 캐싱하고 재사용하기 때문에 Heap 공간을 절약하여 성능 높힘\n\n\u003cbr\u003e\u003cbr\u003e\n\n2. **동기화 (Synchronization)**\n\t- 불변 객체는 값이 바뀔 일이 없어서 멀티스레드 환경에서 `Thread-safe`\n\t- 동시에 실행되는 여러 스레드에서 공유할 수 있다. 스레드가 값을 변경하면 동일한 문자열을 수정하는 대신, String pool에 새로운 문자열이 생성되기 때문에 스레드가 안전함\n\n```java\nString s1 = \"Hello\";\nString s2 = \"Java\";\nString s3 = s1 + s2;\n\n// String pool에 \"Hello\", \"Java\", \"HelloJava\"가 있는 상태\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n3. **해시코드 캐싱 (Hashcode Caching)**\n\t- String은 데이터 구조로도 많이 사용 (HashMap, HashTable, HashSet)\n\t- String의 `hashCode()` 메서드 구현을 보면 ==아직 hash 값을 계산한 적이 없을 때 최초 1번만 실제 계산 로직을 수행==하고, 이후부터는 해당 값을 그냥 반환만 하도록 overriding 되어 있다. (계산해놓았던 해시코드를 재사용하는 것)\n\t- String이 불변이기 때문에 이렇게 caching이 가능하다는 이점을 활용할 수 있는 것 (값이 변하지 않기 때문에 위와 같이 캐싱해서 사용할 수 있는 것)\n\n\u003e [!note] HashMap, HashSet 등 키를 불변형으로 많이 쓰는데, 이걸 가변형이라고 가정하면 어떤 문제가 있을까? \u003cbr\u003e\n\u003e  만약에 문자열이 가변이라고 하면 매번 해쉬값이 변하니까 이 데이터가 과연 맞는 값일까? 의문점을 가질 것이다. 키가 바뀌다보면 이게 A로, B로 확확 바뀌면 내가 찾고자 하는 값을 찾기 위하여 원하지 않게 두 번,세 번,네 번 계산을 해야하니까 **무조건 key 값은 불변자료로 넣어서 캐싱을 하기 쉽게, 혹은 재사용하기 쉽게 HashSet이나 HashMap에서의 key는 불변성을 유지하고 있다.**\u003cbr\u003e\u003cbr\u003e\n\u003e  간단하게 말해서 캐싱처리를 해서 재사용하기 쉽게, 메모리 공간처럼 자원을 아껴서 조금 더 빠르게 구동할 수 있게 하기 위함이다. Hash 함수를 쓰면 보통 O(1) 만큼의 값을 쳐줄 수 있는 성능상으로도 되게 유리해지고 멀티스레드나 동기성을 쉽게 다룰 수도 있는데 가변상태로 하게 되면, 디버깅을 할 수는 있겠지만 딥하게 파고드는 디버깅을 할 수도 없는 특징이 있다.\n\n\u003cbr\u003e\n\n4. **보안 (Security)**\n\t- 문자열은 Java 애플리케이션에서 사용자 이름, 암호, 연결 URL, 네트워크 연결 등과 같은 중요한 정보를 저장하는 데 널리 사용됨. 클래스를 로드하는 동안 JVM 클래스 로더에서도 광범위하게 사용.\n\t- String이 불변 객체가 아니라면 메서드를 호출했던 클라이언트는 String에 대한 참조가 메서드를 호출 이후에도 남아있다. 따라서 보안 검사를 실시한 이후에도 이 문자열이 안전하다고 보장할 수 없다. ==메서드를 호출했던 클라이언트가 String에 대한 참조를 계속 가지고 있기 때문에 문자열을 변경할 수 있다는 가능성이 남아있다.==\n\t\t- 이러한 보안 이슈 때문에 String을 불변객체로 만들었음\n\n\u003cbr\u003e\n\n### StringBuilder, StringBuffer\n\n- String을 단순 문자열로 활용하고 싶을 때는 불변객체가 적절하지 않을 수 있음\n\t- `문자열 연산 +`이 많은 경우\n- 문자열 연산 등으로 ==기존 객체의 공간이 부족해지는 경우, 기존의 버퍼 크기를 늘려 유연하게 동작하는 가변객체==\n- **StringBuffer**는 각 메서드별로 Synchronized Keyword가 존재하여, 멀티스레드 환경에서도 동기화를 지원.  \n- **StringBuilder**는 동기화를 보장하지 않음.\n\n\u003e [!note] 정리 \u003cbr\u003e\n\u003e **String** : 문자열 연산 자체가 적고 멀티스레드의 경우 \u003cbr\u003e \n\u003e **StringBuffer** : 문자열 연산이 많고 멀티스레드의 경우 \u003cbr\u003e \n\u003e **StringBuilder** : 문자열 연산이 많고 단일스레드고 동기화를 고려하지 않아도 되는 경우 \u003cbr\u003e\u003cbr\u003e\n\u003e 보통 Java-Spring에서는 멀티스레드 환경을 지원하고 있기 때문에 보통은 String, StringBuffer를 사용하는 편이다.\n\n\n\u003cbr\u003e\n\n### (심화) 객체 생성비용 최소화\n\n**생성비용이 많이 드는 객체가 반복해서 필요하다면 어떻게 해야할까?**\n\n- 정답 후보 3가지가 있고, 결론적인 방법은 필드캐싱이다.\n\t1. `static final`을 클래스 내부 필드에 해놓는 ==필드 캐싱== 방법\n\t2.  불변객체 시작하는 것을 클래스를 사용할 때만 맞춰서 하는 ==lazy initialization(지연 초기화) 방법==\n\t3.  인스턴스가 생성이 되는지 존재하지 않는지에 대해서 2번씩 체크하는 ==Double-checked Locking Pattern==\n\n\u003cbr\u003e\n\n상황마다 다르겠지만, 보통 지연 초기화는 코드를 더 복잡하게 만들어서 성능 개선이 크게 되지 않아서 잘 사용하지 않는다고 한다. ==실무에서는 필드 캐싱을 많이 사용==한다.\n\n보통 사람들은 Double-checked Locking을 생각할 수 있는데, 그러면 체크를 하면서 확인을 해야하고 이거에 따라 절차를 밟아가는 것이라서 보통은 캐싱처리를 하고 바로바로 사용하려고 한다. 실무에서는 메모리를 쪼~끔 더 쓰고 그냥 빠르게 쓰자는 의미로 캐싱해서 쓴다. 아니면, 메모리를 대체해줄 수 있는 Redis, NoSQL 같은 것으로 좀 빠르게 쓰자!라고 생각한다.\n\n\u003cbr\u003e\n\n### (심화) DCLP 지양에 관한 이야기\n\n**사실 DCLP는 Java와는 맞지 않는 패턴이다.**\n\n1.  DCLP는 멀티스레드 환경에서 안전하지 않다.\n    -   그 이유는 jvm이 out of order writes를 지원하기 때문인데,\n    -   멀티스레드 환경에서 그에따라 입력되는 순서가 보장되지 못한다.\n2.  순서 입력을 보장받기위해 volatile 키워드를 가용할 수 있습니다.\n    -   volatile 키워드의 기능은따라 cpu caching이 아니라 메인메모리에 직접 작성하는데,\n    -   jvm의 최적화를 끈다는 단점이 있고,\n    -   입력한 순서를 복사하여 jvm에 재입력 한다는 단점이 있다.\n3.  더불어 volatile 키워드가 멀티스레드 자체에서 race condition과 상기했듯이 memory visibility에 취약점을 가지고 있으므로, 결론적으로 보면 지양해야한다.\n\n\u003cbr\u003e\n\n싱글톤 패턴은 생성자가 여러 차례 호출 되어도 실제로 생성되는 인스턴스는 단 1개이고, 최초 생성 이후 호출된 생성자는 최초에 생성한 객체를 리턴하는 형태이다. 그러나, 멀티스레드 환경이라면 어떻게 될까? 인스턴스를 차지하기 위하여 스레드 간 경쟁이 일어나게 된다. 이 문제를 해결하기 위하여, 여러 가지 해결방법을 생각했는데 그중 DCLP는 자바와는 사실 잘 맞지 않는 방법이다. \n\n\u003cbr\u003e\n\n```java\npublic ResLock getInstance() {  \n  if(singletonResource == null) { // 1)  \n   mutex.lock();  \n   if(singletonResource == null) { // 2)  \n    singletonResource = new SingletonResource(); // 3)  \n   }  \n  }  \n  return singletonResource;  \n }\n```\n\n\u003cbr\u003e\n\n흐름을 살펴보면  \n\n1.  스레드1이 null이니까 (1)을 통과하고 뮤텍스의 제어권을 획득함.\n2.  스레드2도 null이지만 스레드1이 뮤텍스의 제어권을 가지고 있으니 여기에서 블락됨\n3.  스레드1은 (2) -\u003e (3)을 거쳐 싱글톤 자원을 만들고 인스턴스에 할당. 끝나면서 리턴\n4.  스레드2가 뮤텍스의 제어권 획득하고 null인지 확인하고 (2) -\u003e (3) 진행\n\n이렇게 흐름상 이론은 완벽해보이지만, DCLP는 자바 플랫폼 메모리 모델과는 맞지 않는 방법이다. \n\n- 조건이 두 개라서 mutex로 (2) 이전까지는 흐름을 제어할 수 있다. \n- mutex 자체가 key를 기반으로 한 상호배제 기법이니까 객체를 소유한 스레드만이 (2)에 접근할 수 있다. \n- 그러나, 자바의 메모리 모델은 “out-of-order-write”를 지원하기 때문에 메모리에 작성되는 순서를 보장하지 않는다. 하나의 스레드가 다른 스레드에 의해 인터럽트 된다면 생성자를 완료하기 이전에 이미 double-checking locking이 실패하는 것이다. \n\n정리하자면, 스레드1이 작업을 끝내고 뮤텍스 제어권을 획득한 스레드2가 (2)에 진입했을 때 초기화 작업을 끝냈을 것이라는 보장이 없다는 의미이다.\n\n그렇다면 volatile 키워드를 붙여서 “메인 메모리에 저장할 것”이라고 명시한다면 괜찮지 않을까? 멀티스레드 환경에서 volatile 변수의 초기값을 필요로 하고 새로운 값이 이 초기값을 근거로 한다면, volatile을 붙여도 더이상 정확한 가시성을 보장하지 못한다. 변수를 읽고 새 값을 쓰는 이 사이의 짧은 차이가 경합을 일으킨다. 또, 많은 JVM이 volataile의 순차적 영속성 기능을 구현하지 않기 때문에 결과적으로 volatile을 써도 보장할 수 없다는 의미이다.\n\n==따라서, DCLP는 지양되어야 한다.==\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## TOPIC 02 - Exception\n\n\u003cbr\u003e\n\n### Error, Exception\n\n- 컴파일 에러 : 컴파일 시에 발생하는 에러\n- 런타임 에러 : 실행 시에 발생하는 에러\n- 논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것\n\nJava에서는 실행 시(runtime) 발생할 수 있는 프로그램 오류를 ==에러(Error)==와 ==예외(Exception)==로 구분하였다.\n\n- Error : 메모리 부족(OutOfMemory), 스택오버플로우(StackOverFlowError)와 같이 일단 발생하면 복구할 수 없는 심각한 오류라서 개발자가 예측해서 프로그램 코드에 어떠한 대비는 불가능\n- Exception : Exception handling과 같이 예외 처리하는 방법을 통해 개발자가 예측하여 프로그램 코드에 대비 가능\n\n![](brain/image/dog-week01-2.png)\n\n\u003cbr\u003e\n\n### Checked vs Unchecked\n\n- Checked Exception : Runtime Exception을 ==상속하지 않는== Exception\n\t- ex) FileNotFoundException, ClassNotFoundException, IOException, SQLException\n- Unchecked Exception : Runtime Exception을 ==상속하는== Exception\n\t- ex) NullpointerException, IndexOutOfBoundException,  ArithmeticException\n\n\u003cbr\u003e\n\n|                   | Checked Exception       | Unchecked Exception     |\n| ----------------- | ----------------------- | ----------------------- |\n| **확인 시점**     | 컴파일 시점             | 런타임 시점             |\n| **처리 여부**     | 반드시 예외처리 O       | 예외처리 안해줘도 됨    |\n| **스프링에서 DB\u003cbr\u003e트랜잭션 처리\u003cbr\u003e기본 설정값** | 예외 발생 시 Rollback X | 예외 발생 시 Rollback O | \n\n\u003cbr\u003e\n\nException Handling에 관해서는 [2주차 스터디 참고](brain/Interview/dog-study/dog-week02)\n\n\u003cbr\u003e\n\n\u003e [!note] Spring에서의 DB 트랜잭션 처리 \u003cbr\u003e\n\u003e @Transactional 애노테이션에서는 의도해서 **모든** 경우의 수를 처리하지 않는 이상 롤백이 되지 않는다. 결국, Runtime Error를 발생시키지 않는다는 뜻이다. 정리하자면, 모든 경우의 수를 따져 try catch 해서 throw 하지 않으면 롤백이 되지 않아서, Runtime Error가 발생하지 않아 예외처리가 힘들다는 특징이 있다. (스터디 내용) \u003cbr\u003e\u003cbr\u003e\n\u003e Spring은 디폴트로 **UnCheckedException** 과 **Error**에 대해서 롤백 정책을 설정한다. 물론, 기본 설정값이 그렇다는 것이지 옵션을 설정하여 원하는대로 변경할 수 있다. \u003cbr\u003e\u003cbr\u003e\n\u003e \u003ca href='https://pjh3749.tistory.com/269' target='_blank'\u003e참고링크1\u003c/a\u003e, \u003ca href='https://kdhyo.kr/31' target='_blank'\u003e참고링크2\u003c/a\u003e\n\u003e 이 파트는 @Transactional 공부하고 다시 돌아오기\n\n\u003cbr\u003e\n\n(추가)\n\n- Checked Exception이 뜬다는거 자체가 컴파일 시점에 오류가 발생되는건데 @Transactional 애노테이션 붙인 트랜잭션 안에서 예외가 처리돼도 롤백되지 않는다. 왜냐하면, 스프링 기본 설정이 Unchecked와 Error에 관해서 롤백 정책을 결정하기 때문이다.\n\n- 결과적으로 체크드든 언체크든 throw 무조건 해주자 !\n\n\n## 참고\n\n- \u003ca href='https://velog.io/@kbsat/%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC-%EB%B0%A9%EC%96%B4%EC%A0%81-%EB%B3%B5%EC%82%AC%EA%B0%80-%EB%AD%90%EC%95%BC#%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC' target='_blank'\u003e얕은 복사 / 깊은 복사 / 방어적 복사\u003c/a\u003e\n- \u003ca href='https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/' target='_blank'\u003e방어적 복사 vs Unmodifiable Collection\u003c/a\u003e\n- \u003ca href='https://soft.plusblog.co.kr/71' target='_blank'\u003eUnmodifiable Collection 예시\u003c/a\u003e\n- https://dev-cool.tistory.com/23\n- \u003ca href='https://parkcheolu.tistory.com/16' target='_blank'\u003evolatile 키워드\u003c/a\u003e\n- \u003ca href='https://jungwoon.github.io/java/2019/08/11/Singleton-Pattern-with-Multi-Thread.html' target='_blank'\u003e멀티스레드 환경에서의 싱글톤\u003c/a\u003e\n- \u003ca href='https://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS6818849791\u0026cate_cd=' target='_blank'\u003eC#의 DCLP\u003c/a\u003e\n- \u003ca href='https://web.archive.org/web/20171027162134/https://www.ibm.com/developerworks/java/library/j-dcl/index.html' target='_blank'\u003e(원본) Java와 DCLP는 맞지 않다\u003c/a\u003e\n- \u003ca href='https://gampol.tistory.com/entry/Double-checked-locking%EA%B3%BC-Singleton-%ED%8C%A8%ED%84%B4' target='_blank'\u003e(번역본) Java와 DCLP는 맞지 않다\u003c/a\u003e","lastmodified":"2024-12-05T16:13:38.250758424Z","tags":null},"/brain/Interview/dog-study/dog-week02":{"title":"2주차 - Exception Handling","content":"\n\u003ca href='https://github.com/dingding-21/Rebellion-Of-Interviewees/issues/4' target='_blank'\u003e2주차 스터디 Issue 바로가기\u003c/a\u003e \n\n\u003chr\u003e\n\n\u003e[!note] 2주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC - 01** \u003cbr\u003e\n\u003e \u0026nbsp;\u0026nbsp;\u0026nbsp;Java의 Exception Handling 방법에 대하여 설명해주세요.\n\u003e \u003cbr\u003e\u003cbr\u003e\n\u003e **TOPIC - 02** \u003cbr\u003e\n\u003e \u0026nbsp;\u0026nbsp;\u0026nbsp;Spring에서의 예외 처리 방법과 흐름에 관하여 설명해주세요.\n\n\n\n## TOPIC 01 - 예외 핸들링\n\n제공하고 있는 서비스가 **프로그램 실행 중** 어떤 원인에 의하여 비정상적으로 종료가 되었다고 하자. 이러한 경우 대처를 어떻게 해야할까?\n\n- **실행 중을 뜻하는 것이라서 Runtime Exception을 의미**하는 것이다.\n\t- Error : 오류는 메모리 부족, 스택오버플로우와 같이 일단 발생하면 복구할 수 없는 심각한 오류이기 때문에 개발자가 예측이 불가능하다. 따라서 프로그램 코드에 어떠한 대비는 불가능\n\t- Exception : Exception Handling을 통하여 개발자가 예측해서 프로그램 코드에 대비가 가능하다.\n\t\t- Checked Exception : Runtime 시점이기 때문에 고려하지 않는다. 애초에 Checked Exception이면 컴파일 자체가 안되고 빨간줄이 뜰 것\n\t\t- **Unchecked Exception : 바로 이 부분에 관하여 핸들링하는 것이다.**\n\n\u003cbr\u003e\n\n### 예외복구\n\n- Exception이 발생하여도 Application은 정상적으로 동작\n- Exception 발생 시 이를 예측하여 다른 비즈니스 로직 흐름으로 유도\n- Exception이 발생하지 않는 상황으로 복구를 시도하는 로직을 추가\n- `try-catch-finally` 블록을 이용하여 예외상황을 파악하고 정상상태로 되돌려 놓는 것\n\n예를 들어, 네트워크의 환경이 좋지 않아서 서버에 접속이 안되는 상황의 시스템에 적용하면 효율적일 것이다. \n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e==코드 예시보기==\u003c/strong\u003e\u003c/summary\u003e\n\n```java\nprivate void NetworkThrowException() {\n    int maxTry = 5;\n    while(maxTry --\u003e 0) {\n    \ttry {\n    \t\t// RandomException 이 Throw 될 수 가능성이 있는 로직\n        \t// 성공 시 return, 해당 메소드 종료\n        \treturn ;\n    \t} catch(RandomException re) {\n    \t\t// Error 로그 출력\n            // 실패 로직 존재 시 원상 복구\n        \t// 일정 시간 동안 대기\n    \t} finally {\n    \t\t// 작업에 사용한 Resource 반환 및 정리\n    \t}\n    }\n    // 최대 횟수 실패시 예외 Throw\n    throw new MaxTryFailedException();\n\n\t// 혹은 네트워크 연결 실패 페이지로 이동시켜 흐름을 전환할 수도 있음\n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### 예외회피\n\n- 메서드에 `throws`를 붙여서 예외처리를 직접 담당하지 않고 호출한 쪽으로 던져서 회피\n- 예외를 회피하고 던지는 것이 정말 최선일 경우에만 던지기\n- 긴밀하게 역할을 분담하고 있는 경우가 아니라면, 굉장히 무책임한 행동\n- 프로그래머가 예외처리를 각자 프로그램에 맞기 처리하도록 유도하는 경\u001f우에는 괜찮을 수도 있음\n\n\u003e [!note] 잠깐! throw와 throws의 차이는? \u003cbr\u003e\n\u003e - **throw**는 예외를 던져주는 코드, 특정 조건에서 예외를 던지는 것, 사용자가 직접 예외를 만들어서 일부로 발생시킬 때 사용하는 것\n\u003e - **throws**는 throw 값을 받는 곳에서 예외를 처리하도록 하여, 예외처리의 주체를 바꿔주는 것\n\u003e - 메서드 옆에 붙이는 건 **throws**, new 연산자 옆에 붙이는게 **throw**\n\n\u003cbr\u003e\n\n### 예외전환\n\n- 특정 Exception 발생 시 명확한 의미의 새로운 Exception으로 전환하고 호출한 쪽으로 던짐\n- 호출 부분에서 Exception Handling 할 때, 어떤 Exception인지 분명하게 하여 해당하는 Exception에 대한 Handling이 수월하게 해주는 것\n- `Checked Exception`처럼 복구 불가능한 Exception을 **catch**하여 `Unchecked Exception`으로 전환하여 Handling 하면 다른 계층에서 일일이 Checked Exception을 선언하지 않도록 한다\n\n예를 들어, 클라이언트 단에서는 SQLException에 대하여 어떻게 처리해야할 지 모를 것이다. 이러한 Checked Exception에 관하여 **서버 단에서 클라이언트 단에게 에러 메세지를 정확하게 알려주고 싶은 경우**에 사용하면 유용한 방법이다.\n\n대표적인 예시로, Spring에서 로그인 5회이상 실패 혹은 잘못된 이미지 파일 확장자 검사 등 예외상황에 Unchecked Exception으로 처리하는 것이 일반적이다.\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e==코드 예시보기==\u003c/strong\u003e\u003c/summary\u003e\n\n\u003ca href='https://dev-cool.tistory.com/24' target='_blank'\u003e코드출처\u003c/a\u003e\n\n```java\npublic class ExceptionTest {\n\tpublic static void main(String[] args) throws CustomException {\n\t\tString test = \"test\";\n\n\t\ttry {\n\t\t\tSystem.out.write(test.getBytes());\n\t\t} catch (IOException e) {\n\t\t\tthrow new CustomException(\"list 못 읽음\");\n\t\t}\n\t}\n}\n\npublic class UncheckedExceptionTest {\n\tstatic String test;\n\tpublic static void main(String[] args) throws NullPointerException {\n\t\tString test2 = test.toLowerCase();\n\t\tSystem.out.println(test2);\n\t}\n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 다중 catch\n\ntry 블록 내부는 다양한 종류의 예외가 발생할 수 있다. 이를 해결하는 방법이 여러 개의 catch문을 사용하는 것이다.\n\n**하지만 catch 블록이 여러 개라 할지라도 단 하나의 catch 블록만 실행된다.** 그 이유는 try 블록에서 동시 다발적으로 예외가 발생하지 않고, 하나의 예외가 발생하면 즉시 실행을 멈추고 해당 catch\n블록으로 이동하기 때문이다.\n\n**그렇기 때문에 상위 예외 클래스가 하위 예외 클래스(더 상세한)보다 아래쪽에 위치해야 한다.** try블록에서 예외가 발생했을 때, 예외를 처리해줄 catch블록은 위에서부터 차례대로 검색된다. 만약, 상위 예외 클래스의 catch블록이 위에 있다면, 하위 예외 클래스의 catch 블록은 실행되지 않는다.\n\n왜냐하면 ==하위 예외는 상위 예외를 상속했기 때문에 상위 예외 타입도 되기 때문==이다. 아래 코드 예시처럼 상위 예외 클래스인 Exception이 ArrayIndexOutOfBoundsException보다 위에 있으면 에러가 난다.\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e==코드 예시보기==\u003c/strong\u003e\u003c/summary\u003e\n\n```java\n// Exception이 더 상위니까 에러남\npublic class CatchExceptionTest {  \n    public static void main(String[] args) {  \n        try {\n\t\t    // 블라블라~ \n        } catch (Exception e) {  \n    \n        } catch (ArrayIndexOutOfBoundsException e) {  \n        \n        }\n    }  \n}\n\n// 상위 예외 클래스가 아래로 가야 에러가 안남\npublic class CatchExceptionTest {  \n    public static void main(String[] args) {  \n        try {\n\t\t    // 블라블라~ \n        } catch (ArrayIndexOutOfBoundsException e) {  \n        \n        } catch (Exception e) {  \n        \n        }\n    }  \n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 멀티 catch\n\n\u003ca href='https://dololak.tistory.com/61' target='_blank'\u003e[관련 출처]\u003c/a\u003e 하나의 catch 블록에서 여러 개의 예외를 처리하는 것이다. `|`로 예외 연결한다. 그러나, 다중 catch처럼 멀티 catch도 사용 시 주의사항이 있다. \n\n1. **Multi Catch문에 사용된 예외들은 예외의 상속관계에서 부모와 자식관계에 있으면 안된다.**\n\n```java\ntry {\n} catch (ArithmeticException | RuntimeException e) {\n}\n\n// Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: \n// The exception ArithmeticException is already caught by the alternative RuntimeException\n```\n\n`ArithmeticException`은 `RuntimeException`의 자손 클래스이기 때문에 ==RuntimeException 하나만으로 처리가 가능하기 때문==에 예외가 발생한다. 즉, **다형성에 의해 RuntimeException 하나로 자손 예외들을 모두 처리 가능**하다는 의미이다.\n\n```java\n// 이렇게 수정하면 정상작동\ntry {\n} catch (RuntimeException e) {\n    RuntimeException 하나로 하위 예외들을 모두 처리           \n}\n```\n\n\u003cbr\u003e\n\n2. **Multi Catch문에 사용된 예외들의 공통된 조상의 멤버만 사용할 수 있다.**\n\n```java\ncatch (ExceptionA | ExceptionB | ExceptionC e\u001e) {\n\te.methodA();\n\t// e라는 참조변수 하나로 여러 가지 예외를 처리하기 때문에\n\t// e가 A, B, C 어느 예외인지 몰라서 처리할 수 없다.\n}\n```\n\nMulti Catch문에서는 ==공통된 조상의 메서드만 호출하거나 정확히 어느 예외의 인스턴스인지 판단하여 캐스팅(형변환) 후 해당 메서드를 사용==해야 한다.\n\n![](brain/image/dog-week02-1.png)\n\n```java\ntry {\n} catch(ChildExA | ChildExB | ChildExC e){\n   e.parentsMethod(); //공통조상인 parentsMethod()만 호출 가능\n}\n```\n\n\u003cbr\u003e\n\n```java\ntry {\n} catch(ChildExA | ChildExB | ChildExC e){\n   if (e instanceof ChildExA) {\n       ChildExA a = (ChildExA)e; //캐스팅\n       a.childMethodA();\n   } else if (e instanceof ChildExB) {\n       ChildExB b = (ChildExB)e; //캐스팅                     \n       b.childMethodB();\n   } else{ ... }\n}\n```\n\n그런데, 코드를 보면 이렇게 캐스팅해서 if문 쓸바에 평소대로 여러 개의 캐치문을 쓰는게 낫다\n\n\u003cbr\u003e\n\n### 에러 출력 메서드\n\n- `e.getMessage()` : 에러의 원인을 간단하게 출력\n- `e.toString()` : 에러의 Exception 내용과 원인을 출력\n- `e.printStackTrace()` : 에러의 발생 근원지를 찾아서 단계별로 에러를 출력\n\t- getMesage()와 toString()과는 다르게 printStackTrace는 리턴 값이 없다. 이 메소드를 호출하게 되면 예외 발생 당시의 호출 스택(Call stack)에 있던 메서드의 정보와 예외 결과를 화면에 출력한다. \n\n![](brain/image/dog-week02-2.png)\n\n\u003cbr\u003e\n\n### 진짜 Handling\n\n1. **catch**만 하지마라.\n\n```java\ntry {\n\t// Exception 발생 가능 로직\n} catch(???Exception e) {\n\n}\n```\n\n예외를 잡기만 하지말고, 로깅 / 복구 등 Exception에 대한 처리를 해라\n\n\u003cbr\u003e\n\n2. **catch**하고 바로 **throw** 하지마라.\n\n```java\ntry {\n\t// Exception 발생 가능 로직\n} catch(???Exception e) {\n\tthrow e;\n}\n```\n\n예외를 잡자마자 던질 것이면 왜 잡냐? 역시 로깅 / 복구 등 Exception에 대한 처리를 해라\n\n\u003cbr\u003e\n\n3. `e.printStackTrace()`는 지양하라\n\n```java\ntry {\n    // Exception 발생 가능 로직\n} catch (IOException e) {\n    e.printStackTrace()\n}\n```\n\n단순하게만 보면, Spring 서버의 콘솔에 얼마나 많은 내용이 찍히겠는가? 그 사이에서 `e.printStackTrace()` 내용을 찾기는 하늘에 별따기 일 것이다. 또, 따로 로깅을 통해서 파일에 정리해놔야 할 정도로 중요한 내용인데 단순히 출력만 했다고 에러 처리를 끝마쳤다고 볼 수는 없다.\n\n추가로, `printStackTrace()`를 지양해야하는 이유는 아래와 같다.\n\n- printStackTrace()를 call 할 경우, System.err로 쓰여져서 제어하기가 힘듦\n- printStackTrace()는 java 리플렉션을 사용하여 추적하는 것이라서 많은 오버헤드가 발생할 수 있음\n- printStackTrace()는 서버에서 스택정보를 취합하기 때문에 서버에 부하가 발생할 수 있음\n- printStackTrace()는 출력이 어디로 가는지 파악하기가 어려움. 톰캣의 경우 `catalina.out`에 남음\n- printStackTrace()는 관리가 힘듦\n\n로깅 라이브러리는 **log4j**, **logback**, **slf4j**, **commons logging** 등이 있다. 로그 패턴 및 로그 메세지를 지정 및 콘솔로그 / 파일로그 형태로 관리할 수 있다. 이런식으로 printStackTrace가 아닌 로깅을 하도록 하자. 여담으로 2021년에 log4j에서 엄청난 보안 취약점이 발견되어 세상이 뒤집어진 사건이 있었다. 대표적인 취약점 역직렬화, SQL 인젝션, 역직렬화 코드실행이 있는데 자세한건 검색해보길 바란다.\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e==코드 예시보기==\u003c/strong\u003e\u003c/summary\u003e\n\n```java\nprivate final Logger logger = LoggerFactory.getLogger(this.getClass());  \n  {  \n    try{  \n        //블라블라....  \n    } catch (FileNotFoundException e) {  \n        logger.error(\"FileNotFoundException\", e);  \n    } catch (IOException e) {  \n        logger.error(\"IOException\", e);  \n    }}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n\u003e [!note] Reflection 이란? \u003cbr\u003e\n\u003e 리플렉션은 간단하게 말하면 **구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API**이다. \u003cbr\u003e\u003cbr\u003e\n\u003e 힙 영역에 로드된 Class 타입의 객체를 통해, 원하는 클래스의 인스턴스를 생성할 수 있도록 지원하고, 인스턴스의 필드와 메소드를 접근 제어자와 상관 없이 사용할 수 있도록 지원하는 API이다. \u003cbr\u003e\u003cbr\u003e\n\u003e 여기서 로드된 클래스라고 함은, JVM의 클래스 로더에서 클래스 파일에 대한 로딩을 완료한 후, 해당 클래스의 정보를 담은 **Class 타입의 객체**를 생성하여 메모리의 힙 영역에 저장해 둔 것을 의미한다. new 키워드를 통해 만드는 객체와는 다른 것임을 유의하자.\n\n\u003cbr\u003e\n\n### printStackTrace 취약점\n\nCWE (Common Weakness Enumeration) 취약점이라는 다양한 소프트웨어 언어 및 아키텍처, 디자인 패턴, 설계 단계에 발생 가능한 취약점이라는 것이 있다. printStackTrace는 **CWE-497**에 등록된 취약점으로 매우 주의하여야 한다.\n\n**CWE-497 : Exposure of Sensitive System Information tp an authorized Control Sphere**\n\nException이 발생할 경우 콘솔에 발생지 근원부터 파일 경로 및 각종 정보들이 찍히는데, 이는 내가 아닌 외부인에게도 제공될 수 있다는 것이 큰 취약점이다. 이는 **자바 레벨의 순수 메서드까지 호출 경로가 노출이 된다**는 의미이다.\n\n따라서, printStackTrace를 사용한 경우에는 디버깅 중에 넣었던 시스템 정보 출력 코드를 반드시 **모두 삭제**하여야 한다. \n\n\u003cbr\u003e\n\n### try-with-resources\n\n자세한 내용은 \u003ca href='https://mangkyu.tistory.com/217' target='_blank'\u003e링크\u003c/a\u003e를 참고하자. 설명이 너무 잘되어있다.\n\n- `try-catch-finally`문에서 resources를 사용 후 반납하는 과정에서 여러 문제점이 있다.\n\t- 자원 반납에 의해 코드가 복잡해짐\n\t\t- Null 검사 귀찮게 해야해서\n\t- 실수로 자원을 반납 못함\n\t- 에러로 반납 못함\n\t- 에러 스택 트레이스가 누락되어 디버깅 어려움\n\n- `try-with-resources`를 이용하여 문제점을 해결하자.\n\t- 코드를 간결하게 만들 수 있음\n\t- 번거로운 자원 반납 안해도 됨\n\t- 실수로 자원 반납 못하는 경우 방지\n\t- 에러로 자원 반납 못하는 경우 방지\n\t- 모든 에러에 대한 스택 트레이스 남길 수 있음\n\n그냥 `try ( 여기에서 resources 생성 )`하면 바로 try-with-resources를 사용하는 것이다. 이는 Java에서 ==AutoCloseable 인터페이스를 구현==하고 있는 자원에 대하여 지원한다. 재미있는 점은, AutoCloseable 인터페이스는 Java 7 이전에 있던 기존의 Closeable 인터페이스에 **부모 인터페이스로 추가된 것**이라서 하위 호환성을 100% 달성했다.\n\n```java\npublic interface Closeable extends AutoCloseable {  \n    public void close() throws IOException;  \n}  \n  \npublic interface AutoCloseable {  \n    void close() throws Exception;  \n}\n```\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e==코드 예시보기==\u003c/strong\u003e\u003c/summary\u003e\n\n- `try-catch-finally`\n\n```java\npublic static void main(String args[]) throws IOException {  \n    FileInputStream is = null;  \n    BufferedInputStream bis = null;  \n    \n    try {  \n        is = new FileInputStream(\"file.txt\");  \n        bis = new BufferedInputStream(is);  \n        int data = -1;  \n        while((data = bis.read()) != -1){  \n            System.out.print((char) data);  \n        }    \n    } finally {  \n        // close resources  \n        if (is != null) is.close();  \n        if (bis != null) bis.close();  \n    }\n}\n```\n\n- `try-with-resources`\n\n```java\npublic static void main(String args[]) throws IOException {  \n    try (FileInputStream is = new FileInputStream(\"file.txt\"); BufferedInputStream bis = new BufferedInputStream(is)) {  \n        int data;  \n        while ((data = bis.read()) != -1) {  \n            System.out.print((char) data);  \n        }    \n    }\n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n### try-catch 성능\n\ntry-catch문을 많이 사용한다면 성능이 어떻게 될 지 의문점을 가졌었다.\n\n-   \u003ca href='https://stackoverflow.com/questions/16451777/is-it-expensive-to-use-try-catch-blocks-even-if-an-exception-is-never-throw' target='_blank'\u003e스택오버플로 게시글\u003c/a\u003e에서도  `try-catch는 성능에 별 영향을 끼치지 않는다 vs JVM이 일부 최적화를 수행하지 못하도록 하기 때문에 영향이 있을 수 있다`로 의견이 좀 갈리는 듯 하였다.\n- \u003ca href='https://january-diary.tistory.com/entry/JAVA-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC%EC%9D%98-%EB%B9%84%EC%9A%A9' target='_blank'\u003e다른 게시글\u003c/a\u003e에서는 예외를 만들어내는 비용이 크기 때문에 무분별한 남용을 지양하자고 하였다.\n-   try문 자체는 성능에 영향을 끼치지 않고 exception thread stack을 채우는데 걸리는 시간을 영향에 끼친다고 하는건가? e.printStackTrace 할 때 그것\n\n\u003e [!note] 결론부터 말하겠다 \u003cbr\u003e\n\u003e try-catch 성능저하에 대한 의문점에 답은 예외처리를 했을때와 안했을때 실행시간 차이가 있기는 하지만, 예외처리가 필수로 해야하는 부분은 어쩔수 없고 그렇다고해서 예외처리를 안 할 수 없어서 어느정도는 감안하고 사용한다. \u003cbr\u003e\u003cbr\u003e\n\u003e 그리고, **생각보다 실행시간 차이가 크지 않아서, 성능 이슈는 사실 상관없다. 불필요한 예외처리는 비용이 발생하므로, 적절하게 사용하되 방어코드를 사용하는 것이 비용이 덜 소모된다.** \u003cbr\u003e\u003cbr\u003e\n\u003e \u003ca href='https://jojoldu.tistory.com/58' target='_blank'\u003e향로님의 성능 비교 링크\u003c/a\u003e\n\n\u003cbr\u003e\n\n여기서부터는 고민의 과정일 뿐, 참고만 하자\n\n**Q. try-catch 성능에 관하여**\n\n-   Java에서 try-catch 블록을 사용하면 특히 코드의 중요한 섹션에서 try-catch 블록을 사용하는 경우 성능에 영향을 줄 수 있다고 한다.\n-   try-catch 블록이 발생하면 Java는 예외가 발생했는지 여부와 예외를 잡아서 처리해야 하는지 여부를 결정하기 위해 추가 검사를 수행해야 하는데, 이 추가 오버헤드로 인해 코드 실행 속도가 느려질 수 있다.\n-   **그러나 try-catch 블록이 초당 수백만 번 실행되지 않는 한 일반적으로 try-catch 블록의 성능 영향은 최소로 간주된다. 대부분의 경우 예외를 처리하기 위해 try-catch 블록을 사용하는 이점이 약간의 성능 저하보다 크다.**\n-   또한 try-catch 블록의 기본 목적은 예외 상황을 처리하고 예기치 않은 오류가 발생해도 프로그램이 계속 실행되도록 하는 것임을 기억하는 것이 중요하다. 따라서 일반적으로 try-catch 블록을 피함으로써 발생할 수 있는 작은 성능 향상보다 코드 명확성과 정확성을 우선시하는 것이 좋다.\n-   요약하면 try-catch 블록을 많이 사용하면 성능에 약간의 영향을 줄 수 있지만 일반적으로 최소한의 것으로 간주되며 대부분의 응용 프로그램에서 중요한 문제가 아니다.\n\n\u003cbr\u003e\n\n**Q. Java에서 try-catch 문의 성능 부하를 줄이는 방법에 관하여**\n\nJava에서 try-catch 블록의 성능 영향은 일반적으로 최소로 간주되지만 성능 오버헤드를 추가로 줄이는 데 사용할 수 있는 몇 가지 전략이 있다.\n\n1.  필요한 경우에만 try-catch 블록 사용 : 예외가 발생할 가능성이 있는 경우에만 try-catch 블록을 사용하는 것이 좋다. 예외가 발생할 가능성이 없는 상황과 같이 불필요하게 사용하지 마라.\n2.  try-catch 블록의 범위 제한 : try-catch 블록의 범위를 가능한 가장 작은 코드 블록으로 제한하라. 이렇게 하면 try-catch 블록 내에서 실행해야 하는 코드의 양을 줄이는 데 도움이 되어 성능 오버헤드를 줄일 수 있습니다.\n3.  조건문 사용: 경우에 따라 try-catch 블록이 필요하지 않도록 조건문을 사용할 수 있다. 예를 들어 예외를 발생시키는 조건을 확인하고 try-catch 블록 내에서 잠재적으로 예외를 발생시킬 수 있는 코드만 실행할 수 있다.\n4.  올바른 예외 처리 메커니즘 사용: Java에는 Checked Exception, Unchecked Exception 및 error와 같은 몇 가지 예외 처리 메커니즘이 있는데, 상황에 맞는 메커니즘을 사용하면 try-catch 블록의 성능 오버헤드를 줄이는 데 도움이 될 수 있다.\n5.  로깅 프레임워크 사용: 예외를 발생시키는 대신 로깅 프레임워크를 사용하여 오류를 기록하고 실행을 계속할 수 있다. 이것은 프로그램이 예외를 처리하기 위해 호출 스택을 중지하고 해제할 필요가 없기 때문에 try-catch 블록의 성능 오버헤드를 줄이는 데 도움이 될 수 있다.\n\n전반적으로 try-catch 블록의 성능 오버헤드를 줄일 수 있지만 이를 사용하는 주요 목표는 프로그램이 예외 상황을 처리하고 계속 실행되도록 하는 것임을 기억하는 것이 중요하다. 따라서 정확하고 신뢰할 수 있는 소프트웨어의 필요성과 성능 고려 사항의 균형을 맞추는 것이 중요하다.\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## TOPIC 02 - Spring에서는?\n\n몇몇 자바 파일에서 예외 처리하는 것을 넘어, 서버 규모로 넘어가면 어떻게 될까?\n- 예외처리 해야하는 부분이 매우 많아진다. =\u003e `try-catch`문 남용\n\t- 가독성 저하 : 일반 코드를 예외 처리 코드로 만들면, 코드 본래 목적 혼란스러움\n\t- 부작용 발생 : 예외가 발생해도 무시될 수 있어서 개발자가 모르는 부작용 발생, 디버깅 어려워짐\n\n그렇다면, Spring에서는 어떻게 try-catch문을 줄이면서 Exception Handling을 할 수 있을까?\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 스프링 예외처리\n\n스프링의 처리과정을 보면 예외처리가 발생하는 부분은 크게 2가지로 나눌 수 있다.\n1. Dispatcher Servlet 내에서 발생하는 예외 (Controller, Service, Repository 등)\n2. Dispatcher Servlet 전의 Filter에서 발생하는 예외\n\nDispatcher Servlet은 ==클라이언트에게 요청을 받아  MVC 처리과정을 통제하는== 것이다. Dispatcher Servlet 내에서라는 의미는 Spring 영역에서의 예외처리를 뜻하는 것이고, Disaptcher Servlet 전은 Spring 영역의 바깥에서 예외처리를 뜻하는 것이다. \n\n\u003cbr\u003e\u003cbr\u003e\n\n### Dispatcher Servlet 내에서\n\nDispatcher Servlet 내의 Spring에서 예외처리는 ==HandlerExceptionResolver==가 담당한다.\n\n![](brain/image/dog-week02-3.png)\n\n1. 메서드 단위에서 Handling\n2. Controller Level에서 Handling\n3. Global Level에서 Handling\n\n\u003cbr\u003e\n\n==**메서드 단위 : try-catch**==\n\n메서드 단위는 기존 하던 방법에서 `try-catch`를 이용하여 Exception Handling하는 과정이다. 그러나, 프로그램의 규모가 커지고 try-catch가 많아져서 가독성 저하, 부작용 발생 등의 단점이 생겨난다면 어떻게 해야할까 ?\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**Controller Level에서 Handling : @ExceptionHandler**==\n\n메서드 하나하나의 예외처리가 아닌, 컨트롤러 레벨에서 예외 처리를 진행한다. 즉, 컨트롤러에서 발생하는 예외를 공통적으로 처리해주는 기능을 이용한 것이다. 이때 `@ExceptionHandler` 애노테이션을 사용하여 **Controller의 메서드에서 throw된 Exception에 대한 공통적인 처리**를 할 수 있다.\n\n-   Controller 메서드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메서드 상위까지 예외를 throw 시키면 `@ExceptionHandler` 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.\n-   Controller 메서드 내의 하위 서비스에서 Unchecked Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다\n\n여기에서 나아가, 여러 Controller에서 같은 Exception이 발생하는 경우에, 전체적으로 처리하려면 어떻게 해야할까?\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**Global Level에서 Handling : @ControllerAdvice**==\n\n여러 Controller에서 발생하는 예외를 전역적으로 처리할 수 있다.\n\n- @ControllerAdvice\n\t- 모든 Controller에서 발생하는 예외를 처리하는 애노테이션\n\t- DispatcherServlet에서 발생하는 예외를 전역적으로 처리\n\t- Exception 처리 이후 Error Page 등을 통해 처리가 가능\n- @RestControllerAdvice\n\t- REST API에 대한 Exception 처리 용이\n\t- @ControllerAdvice + @ResponseBody\n\n\u003cbr\u003e\n\n\u003e [!note] 어떤 @ExceptionHandler가 먼저 실행? \u003cbr\u003e\n\u003e Controller 클래스 내의 @ExceptionHandler \u003cbr\u003e\n\u003e @ControllerAdvice 클래스 내의 @ExceptionHandler \u003cbr\u003e\n\u003e 둘 중 어떤 것이 먼저 실행될까? \u003cbr\u003e\u003cbr\u003e\n\u003e =\u003e  **Controller 내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.**  더 상위로 Exception을 throw하더라도 **@ControllerAdvice의 @ExceptionHandler에서 예외처리를 하지 않는다.**\n\n\u003cbr\u003e\n\n### HandlerExceptionResolver\n\nDispatcher Servlet 내에서 예외가 발생했을 때 HandlerExceptionResolver이 처리한다고 했다. 이를 자세히 들여다겠다.\n\n- HandlerExceptionResolver는 Controller의 작업 중 발생한 예외를 어떻게 처리할 지에 대한 전략이다.\n- Controller에서 Exception이 발생하면 Controller 밖으로 던져짐\n- 예외가 발생하면 ExceptionResolver가 발동\n- Dispatcher Servlet 내부에 등록된 3가지가 순서대로 실행\n\t1. ExceptionHandlerExceptionResolver\n\t2. ResponseStatusExceptionResolver\n\t3. DefaultHandlerExceptionResolver\n\n\u003cbr\u003e\n\n==**ExceptionHandlerExceptionResolver**==\n\nSpring 3.2의 AnnotationMethodExceptionResolver가 deprecated 처리되었고 Spring 4.0부터 사용하고 있는 ExceptionHandlerExceptionResolver이다. `@ExceptionHandler` 애노테이션에 관한 Resolver 클래스이다.\n\n1. 예외가 발생한 Controller 안에 적합한 @ExceptionHandler가 있는지 검사\n2. Controller의 @ExceptionHandler에서 처리가 가능하다면 처리하고, 그렇지 않으면 @ControllerAdvice로 넘어감\n3. @ControllerAdvice에 적합한 @ExceptionHandler가 있는지 검사하고 없으면 다음 Resolver로 넘어감\n\n\u003cbr\u003e\n\n==**ResponseStatusExceptionResolver**==\n\nException에 대한 HTTP 응답을 설정해줄 수 있다. 단순히 internal-server-error인 500 에러 대신 더 구체적인 응답 상태값을 전달해줄 수 있다.\n\n1. @ResponseStatus가 있는지 혹은 ResponseStatusException인지 검사\n2. 있다면 ServletResponse의 sendError()로 예외를 Servlet까지 전달하고 Servlet이 BasicErrorController로 요청을 전달\n\n\u003cbr\u003e\n\n\u003e [!note] ResponseStatusException?  \u003cbr\u003e\n\u003e 외부 라이브러리를 사용하는 경우, @ResponseStatus 애노테이션으로 직접적으로 수정할 수 없는 상황이 있다. 이때, 상태값에 관하여 직접 핸들링하고 싶은 경우에는 ResponseStatusException을 사용하여 처리한다.\n\n\n\u003cbr\u003e\n\n==**DefaultHandlerExceptionResolver**==\n\n위의 두 Resolver로도 처리가 안된다면 DefaultHandlerExceptionResolver를 사용하여 내부적으로 Spring 표준 예외처리를 해준다. 각 상황에 맞는 응답 코드를 반환하는 역할이다.\n\n- Request URL에 맞는 Controller를 찾지 못한 경우 - **404 Not Found**\n- Controller 메서드 실행 중 예외가 발생하는 경우 - **500 Internal Server Error**\n- Controller의 파라미터 형식이 잘못된 경우 - **400 Bad Request**\n\n1. Spring의 내부 예외인지 검사하여 맞으면 Exception을 처리하고 아니면 넘어감\n2. 적합한 ExceptionResolver가 없으므로 예외가 Servlet까지 전달되고, Servlet은 SpringBoot가 진행한 자동 설정에 맞게 BasicErrorController로 요청을 다시 전달\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Dispatcher Servlet 외부에서\n\n스프링 영역이 아닌 외부에서 발생하는 Exception은 어떻게 처리해야할까? 이를 말하기에 앞서서 스프링 영역의 컨트롤러 단에서 예외가 발생한 경우, 전체적인 흐름을 먼저 살펴보자.\n\n![](brain/image/dog-week02-4.png)\n\nSpring MVC request life cycle을 보면, 아래와 같이 흐름이 생긴다.\n- ==WAS -\u003e 필터 -\u003e 서블릿 -\u003e 인터셉터 -\u003e 컨트롤러(예외발생)==\n- ==WAS \u003c- 필터 \u003c- 서블릿 \u003c- 인터셉터 \u003c- 컨트롤러==\n\n그렇다면, Dispatcher Servlet 내부인 Spring 영역에서는 HandlerExceptionResolver를 이용하여 다양한 예외 처리를 하는데, **외부인 Filter 단에서 예외가 발생하면 어떻게 처리해야할까?**\n\n\u003cbr\u003e\n\n![](brain/image/dog-week02-5.png)\n\n이 그림을 봤을 때, Filter 단에서 예외가 발생하면 애초에 ==스프링 영역으로 들어가지 못하고, 튕겨져 나온다.== 하지만, `@HandlerException`, `@ControllerAdvice`와 같은 예외 처리는 Spring에서 제공하는 애노테이션이라서 스프링 영역이 아닌 필터에서는 사용할 수 없다.\n\n\u003cbr\u003e\n\n![](brain/image/dog-week02-6.png)\n\n이러한 경우에는 ==Filter에서 try-catch 문으로 예외를 잡아서 처리한다.== 위 그림의 예시로는 `doFilter()` 메서드를 try-catch로 잡아서 그 시점에 발생한 예외를 곧바로 handling 하는 것이다.\n\n\u003cbr\u003e\n\n### Filter에서 처리하는 예외\n\n1. **(가장중요) 모든 요청에 대한 로깅**\n2. 보안 관련 공통 작업 (JWT)\n3. ServletRequest 커스터마이징\n4. 이미지/데이터 압축 및 문자열 인코딩\n\n이중, 모든 요청에 대한 로깅은 특히 중요한데, 말 그대로 request, response 등 모든 처리에 관하여 로깅할 수 있다.\n\n\u003cbr\u003e\n\n## 참고자료\n\n- \u003ca href='https://cheese10yun.github.io/spring-guide-exception/#null' target='_blank'\u003e(가장 쓸만할 듯)프로젝트에 적용하면 좋을 실제 Spring 예외\u003c/a\u003e\n- \u003ca href='https://www.nextree.co.kr/p3239/' target='_blank'\u003e자바에서의 Exception Handling 3가지 방법\u003c/a\u003e\n- \u003ca href='https://catsbi.oopy.io/92cfa202-b357-4d47-8de2-b9b3968dfb2e' target='_blank'\u003e종합적인 예외처리 설명\u003c/a\u003e\n- \u003ca href='https://jaehun2841.github.io/2018/08/30/2018-08-25-spring-mvc-handle-exception/#ResponseStatusExceptionResolver' target='_blank'\u003eSpring Handler Exception\u003c/a\u003e\n- \u003ca href='https://github.com/binghe819/TIL/blob/master/Spring/%EA%B8%B0%ED%83%80/%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC%20%EA%B0%9C%EB%85%90%20%EB%B0%8F%20%EC%A0%84%EB%9E%B5.md' target='_blank'\u003e스프링 예외처리 개념 전략\u003c/a\u003e\n- \u003ca href='https://velog.io/@backtony/면접-시리즈2-Spring-JPA' target='_blank'\u003eSpring-JPA 면접시리즈\u003c/a\u003e\n- \u003ca href='https://terasolunaorg.github.io/guideline/5.3.0.RELEASE/en/ArchitectureInDetail/WebApplicationDetail/ExceptionHandling.html#exception-handling-basic-flow-label' target='_blank'\u003e(원본)Exception Handling Guideline\u003c/a\u003e\n- \u003ca href='https://steady-coding.tistory.com/601' target='_blank'\u003eFilter vs Interceptor\u003c/a\u003e\n- \u003ca href='https://velog.io/@wonizizi99/SpringSpring%EC%9D%98-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-%ED%9D%90%EB%A6%84' target='_blank'\u003eSpring에서의 예외 처리 흐름도\u003c/a\u003e\n- \u003ca href='https://jhkimmm.tistory.com/29' target='_blank'\u003eFilter 내에서 발생한 예외 처리하기\u003c/a\u003e\n- \u003ca href='https://beemiel.tistory.com/11' target='_blank'\u003eSpring Security JWT 토큰 검증시 Exception 처리\u003c/a\u003e","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/dog-study/dog-week03":{"title":"3주차 - Spring 기본","content":"\n\u003ca href='https://github.com/DevInterviewStudy/Backend-6/issues' target='_blank'\u003e3주차 스터디 Issue 바로가기\u003c/a\u003e \n\n\u003chr\u003e\n\n\u003e[!note] 3주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC** \u003cbr\u003e\n\u003e - 프레임워크란?\n\u003e - Spring 프레임워크의 정의 및 장점\n\u003e - DI (Dependency Injection)\n\u003e \t- 주입 방식\n\u003e - IoC\n\u003e - 스프링 컨테이너\n\n\u003cbr\u003e\n\n## 프레임워크란?\n\nFrame(틀, 뼈대) + work(일하다)로, 의미 그대로 해석하면 ==응용 프로그램이나 소프트웨어의 솔루션 개발을 수월하게 하기 위해 제공된 소프트웨어 환경==이다. 개발할 때, 자주 사용되는 범용적인 기능을 한꺼번에 제공하여 개발 효율의 향상을 목표하는 소프트웨어 환경이다.\n\n\u003cbr\u003e\n\n### Framework 특징\n\n-   공통적인 개발 환경을 제공한다. (개발 편의성)\n-   개발할 수 있는 범위가 정해져있다.\n-   상호협력하는 클래스와 인터페이스의 집합\n-   응용 프로그램이 **수동적**으로 프레임워크에 의해 사용된다. ( = 제어의 역전이 발생한다)\n\n\u003cbr\u003e\n\n### Library\n\nLibray는 ==응용 프로그램 개발을 위해 필요한 기능(함수)을 모아 놓은 소프트웨어==이다. \n\n- 개발하는데 필요한 것들을 모아둔 일종의 저장소\n- 필요할 때, 호출해서 사용한다.\n- 독립성을 가진다.\n- 응용 프로그램이 **능동적**으로 라이브러리를 사용한다. ( = 흐름을 제어한다. )\n\n\u003cbr\u003e\n\n### Framework vs Library\n\n둘을 바라봤을 때, 개발할 때 중복된 코드가 발생하지 않도록 필요한 것들을 모아놓았다는 측면에서 비슷해보인다. 그렇다면 둘의 차이는 어떠한가?\n\n- ==흐름을 제어하는 쪽이 어떤 쪽인지가 가장 큰 차이==\n- Framework : 내가 작성한 응용 프로그램이 프레임워크에 의해 **수동적**으로 사용된다. 제어의 흐름이 역전된 형태\n- Library : 내가 작성한 응용프로그램이 **능동적**으로 라이브러리를 사용한다. 제어의 흐름이 개발자에게 있는 형태\n\n\u003cbr\u003e\n\n## Spring 정의 및 장점\n\nSpring은 ==자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크==이다.\n\n- 경량 컨테이너로서 자바 객체를 직접 관리\n\t- 각각의 객체 생성, 소멸과 같은 Life cycle을 관리하며 Spring으로부터 필요한 객체를 얻어올 수 있다.\n- IoC(제어의 역전) 기술을 통한 애플리케이션의 **느슨한 결합** 추구\n- DI(의존성 주입)을 통한 객체 관계 구성을 지원\n- AOP(횡단 관심사 분리)를 이용하여 OOP를 보완\n- MVC 패턴로 계층을 분리하여 유지보수에 수월\n\n\u003cbr\u003e\n\n### Spring Boot\n\n이미, Spring의 장점으로도 충분해보이는데 Spring Boot 기술은 왜 나왔을까?\n\n1.  dependency\n\n\t-   Spring은 모든 dependency를 버전까지 한땀한땀 구성해야해서 매~우 길다. 하지만 Spring Boot는 매우 짧아졌고 버전 관리도 권장 버전으로 자동 설정해준다.\n\n2.  configuration\n\n\t-   Spring은 config가 매~우 길도 bean도 등록해주고 해야하는데 Spring Boot는 따로 config 파일을 작성해주지 않아도 되고 application.properties만 적용하면 된다. 최근에는 application.yml을 많이 사용한다고 한다. depth로 표현하기 때문에 훨씬 인간이 읽기 좋게 만들 수 있는 파일 형식이라고 한다.\n\n3.  embedded server\n\n\t-  서버 구동 시간이 절반 가까이 단축.\n\t-  대표적인 예시로 tomcat이 있는데, tomcat이 싫으면 jetty 써도 된다.\n\t-   `java -jar $REPOSITORY/$JAR_NAME \u0026` - 내장 서블릿 컨테이너 덕분에 jar 파일로 간단하게 배포!\n\t- 즉, Spring은 WAS가 내장되어있지 않아서, 외장 WAS를 따로 `.war`를 이용하여 함께 빌드하여야 했지만, Spring Boot에는 WAS가 내장되어 있기에 `.jar`를 이용하여 보다 빠른 빌드가 가능\n\n\u003cbr\u003e\n\n정리하자면, ==Spring Boot의 장점은 개발자들이 개발에만 더욱 집중==할 수 있도록!\n\n1.  간편한 설정 (configuration)\n2.  편리한 의존성 관리 \u0026 자동 권장 버전 관리 (dependency)\n3.  내장 서버로 인한 간단한 배포 서버 구축 (embedded server)\n4.  스프링 Security, Data JPA 등의 다른 스프링 프레임워크 요소를 쉽게 사용\n\n\u003cbr\u003e\n\n## IoC\n\nIoC(Inversion of Control)은 제어의 역전이라는 의미로 ==프로그램의 제어 흐름을 직접 제어하는 것이 아니라 프레임워크 같이 외부에서 관리하는 것==을 의미한다.\n\nIoC는 제어의 역전이라는 **원칙 그 자체**이므로, 이를 구현해줄 구현체가 필요하다. 이 중 대표적인 디자인 패턴이 아래에서 설명할 \u003ca href='/brain/Interview/dog-study/dog-week03/#DI'\u003eDI\u003c/a\u003e이다.\n\n-   IoC : 치즈떡볶이가 스스로의 재료를 결정하지 못한다는 ==**추상적인 개념**==\n-   DI : 치즈떡볶이의 재료를 외부에서 정해준다는 ==**구체적인 행위**==\n\n\u003cbr\u003e\n\n-  기존에 생성자로 생성하여 객체 생명주기나 메서드의 호출을 직접 **제어(관리)** 하는 방식\n\n```java\npublic class A { \n\tprivate B b; \n\tpublic A() { \n\t\tthis.b = new B(); \n\t} \n}\n```\n\n\u003cbr\u003e\n\n- 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 **외부에서 관리**하는 방식\n\n```java\npublic class A { \n\tprivate B b; \n\tpublic A(B b) { \n\t\tthis.b = b;\n\t} \n}\n```\n\n\u003cbr\u003e\n\n### IoC의 필요성\n\n- 객체 내부에서 제어했을 때, 변경에 자유롭지 못하던 코드가 외부의 제어를 받으면서 ==변경에 자유로운 장점==이 있다.\n- 객체지향 원칙을 잘 지키기 위해서!\n\t- 역할과 관심을 분리하여 ==객체 간 응집도를 높이고 결합도는 낮춘다.==\n\t- 이에 따라 변경에 유연한 코드를 작성할 수 있는 구조가 된다.\n\n\u003cbr\u003e\n\n예를 들어, 떡볶이를 만드는 클래스가 있다고 하자.  하지만, 아래와 같이 **객채 내에서 재료를 제어하는 경우**, 쌀떡을 밀떡으로 바꾸려고 한다면? 큰 변화가 생기는 것이다. **변경에 자유롭지 못하여 유지보수가 어려운 것**이다.\n\n- 즉, 현재는 치즈떡볶이가 스스로 자신의 상태를 결정짓는 상태!\n\n```java\npublic class Cheesetteokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic Cheesetteokbokki() {\n\t\tthis.riceTTok = new RiceTTok();\n\t\tthis.bigPa = new BigPa();\n\t\tthis.sliceOnion = new SliceOnion();\n\t\tthis.mozzarellaCheese = new MozzarellaCheese();\n\t}\n}\n```\n\n\u003cbr\u003e\n\n그럼 아래와 같이 **재료에 대한 제어를 외부로 바꾸면** 어떠한가? 쌀떡이든 밀떡이든 무엇이 들어와도 괜찮도록 변경에 자유롭게 되는 것이다.\n\n- 외부의 존재가 치즈떡볶이의 상태를 결정짓는 상태!\n\n```java\npublic class Cheesetteokbokki {\n\tTTok ttok;\n\tPa pa;\n\tOnion onion;\n\tCheese cheese;\n\n\tpublic Cheesetteokbokki(TTok ttok, Pa pa, Onion onion, Cheese cheese) {\n\t\tthis.ttok = ttok;\n\t\tthis.pa = pa;\n\t\tthis.onion = onion;\n\t\tthis.cheese = cheese;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### DIP\n\nIoC를 검색했을 때, 자주 나오는 DIP란 무엇인가? \n\n**DIP(Dependency Inversion Principle) - 의존 역전 원칙**\n- SOLID 원칙 중 D에 해당하는 부분\n- 상위 레벨의 모듈은 절대 하위 레벨 모듈에 의존하지 않는다. ( **= 둘 다 추상화에 의존해야 한다** )\n\n\u003cbr\u003e\n\n떡볶이의 예시로, 치즈 떡볶이와 일반 떡볶이가 있다고 하면, 조금 더 구체적이고 상세한 치즈 떡볶이가 고수준 모듈이고 일반 떡볶이가 저수준 모델이다.\n\n- 치즈 떡볶이(고수준 모듈) -\u003e 일반 떡볶이(저수준 모듈)\n\t- 필드가 이미 구체 클래스로 작성되어 있으면, 변경에 자유롭지 못하다.\n\t- 즉, 상위 레벨의 모듈이 하위 레벨의 모듈에 의존하면, 변경에 자유롭지 못하다는 의미이다.\n- 치즈 떡볶이 -\u003e 떡(Interface) \u003c- 일반 떡볶이\n\t- 이렇게 어떤 떡볶이든 떡이라는 추상화에 의존한다면, 쌀떡이든 밀떡이든 변경이 일어나도 자유롭게 수정할 수 있다.\n\n\u003cbr\u003e\n\n### IoC와 DIP\n\nIoC와 DIP의 목적\n- 클래스 간 결합을 느슨히 하기 위함\n\t- 한 클래스의 변경에 따른 클래스들의 영향을 최소화\n- 이로 인하여, 애플리케이션을 지속가능하고 확장성 있게 만듬.\n\nIoC와 DIP는 모두 **principle(원칙)**이다.\n- IoC는 ==제어의 역전==\n- DIP는 ==의존 방향의 역전==\n\n\u003cbr\u003e\n\n1. 객채 내에서 제어권을 가진 경우 (개발자가 제어권 가짐)\n\n```java\npublic class Cheesetteokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic Cheesetteokbokki() {\n\t\tthis.riceTTok = new RiceTTok();\n\t\tthis.bigPa = new BigPa();\n\t\tthis.sliceOnion = new SliceOnion();\n\t\tthis.mozzarellaCheese = new MozzarellaCheese();\n\t}\n}\n```\n\n2. 제어권이 외부로 넘어감 (제어의 역전, IoC 적용)\n\n```java\npublic class Cheeseeokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic void inject(RiceTTok riceTTok, BigPa bigPa, SliceOnion sliceOnion, MozzarallaCheese mozzarellaCheese) {\n\t\tthis.riceTTok = riceTTok;\n\t\tthis.bigPa = bigPa;\n\t\tthis.sliceOnion = sliceOnion;\n\t\tthis.mozzarellaCheese = mozzarellaCheese;\n\t}\n}\n```\n\n3. 단, 외부에서 주입한다고 해도 쌀떡, 밀떡 종류마다 넣어야하는 고수준 모듈이 저수준 모듈에 의존하는 상태이기 때문에, 이를 추상화에 의존하도록 바꾼다. (의존 방향의 역전, DIP 적용)\n\n```java\npublic class Cheesetteokbokki {\n\tTTok ttok;\n\tPa pa;\n\tOnion onion;\n\tCheese cheese;\n\n\tpublic Cheesetteokbokki(TTok ttok, Pa pa, Onion onion, Cheese cheese) {\n\t\tthis.ttok = ttok;\n\t\tthis.pa = pa;\n\t\tthis.onion = onion;\n\t\tthis.cheese = cheese;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n## DI\n\nDI(Dependency Injection)\n- 원칙일 뿐인 IoC를 구현하기 위한 구현체 중 대표적인 디자인 패턴이 DI\n- 클래스 간에 의존 관계가 있다는 것\n- 한 클래스가 바뀔 때 다른 클래스가 영향을 받는다는 것\n\n==변경에 의해 영향을 받는 \"의존성\"을 외부에서 주입해주는 것==이 바로 DI이다.\n\n\u003cbr\u003e\n\n### 생성자 주입\n\n- 생성자 호출 시 외부로부터 의존성을 주입받는 방법\n- 필요한 의존성을 모두 포함하는 생성자를 만들고, 그 생성자를 통해서 의존성을 주입한다.\n\n```java\npublic class Cheeseeokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic void inject(RiceTTok riceTTok, BigPa bigPa, SliceOnion sliceOnion, MozzarallaCheese mozzarellaCheese) {\n\t\tthis.riceTTok = riceTTok;\n\t\tthis.bigPa = bigPa;\n\t\tthis.sliceOnion = sliceOnion;\n\t\tthis.mozzarellaCheese = mozzarellaCheese;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### Setter 주입\n\n- 의존성을 주입받는 setter 메서드를 만들고 이 메서드들을 호출해서 의존성을 주입한다.\n\n```java\npublic class Cheeseeokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic void setRiceTTok(RiceTTok riceTTok) {\n\t\tthis.riceTTok = riceTTok;\n\t}\n\t\n\tpublic void setBigPa(BigPa bigPa) {\n\t\tthis.bigPa = bigPa;\n\t}\n\t\n\tpublic void setSliceOnion(SliceOnion sliceOnion) {\n\t\tthis.sliceOnion = sliceOnion;\n\t}\n\t\n\tpublic void setMozzarallaChees(MozzarallaCheese mozzarellaCheese) {\n\t\tthis.mozzarellaCheese= mozzarellaCheese;\n\t}\n\n}\n```\n\n\u003cbr\u003e\n\n### Interface 주입\n\n-   의존성을 주입하는 메서드를 포함한 인터페이스를 작성하고, 이 인터페이스를 구현하도록 함으로써 실행 시 이를 통해서 의존성을 주입\n-   Setter 주입처럼 메서드를 외부에서 호출해줘야 하는 것은 비슷하지만, 의존성 주입을 빠뜨릴 수 있는 Setter 주입과는 다르게 Override를 통해 메서드 구현을 강제할 수 있다는 차이가 있다.\n\n```java\npublic class Cheeseeokbokki {\n\tRiceTTok riceTTok;\n\tBigPa bigPa;\n\tSliceOnion sliceOnion;\n\tMozzarallaCheese mozzarellaCheese;\n\n\tpublic void inject(RiceTTok riceTTok, BigPa bigPa, SliceOnion sliceOnion, MozzarallaCheese mozzarellaCheese) {\n\t\tthis.riceTTok = riceTTok;\n\t\tthis.bigPa = bigPa;\n\t\tthis.sliceOnion = sliceOnion;\n\t\tthis.mozzarellaCheese = mozzarellaCheese;\n\t}\n\n\tinterface RecipeInjection {\n\t\tvoid inject(RiceTTok riceTTok, BigPa bigPa, SliceOnion sliceOnion, MozzarallaCheese mozzarellaCheese);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n여기까지 하면 의존성이 주입되기는 한 상태이다. 하지만 여전히 구체적인 Cheeseeokbokki 클래스를 구현하고 있는 것으로 보아 변경에 자유롭지 못해보인다. 지금까지는 “의존성을 주입”하는 방법만 생각했다면, 이제 **의존성 분리**를 생각해보자.\n\n의존성 분리 : DIP를 이용해 의존 관계를 분리시킨다.\n-   상위 계층이 하위 계층에 의존하는 상황을 Interface를 이용해 반전시켜 하위계층의 구현으로부터 독립시킨다.\n\n```java\npublic class Cheesetteokbokki {\n\tTTok ttok;\n\tPa pa;\n\tOnion onion;\n\tCheese cheese;\n\n\tpublic Cheesetteokbokki(TTok ttok, Pa pa, Onion onion, Cheese cheese) {\n\t\tthis.ttok = ttok;\n\t\tthis.pa = pa;\n\t\tthis.onion = onion;\n\t\tthis.cheese = cheese;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n## Spring DI\n\n-   MemberService라는 의존성을 주입받는 MemberController\n    -   생성자를 통해 의존성 주입받는 중\n    -   특정한 MemberService를 받는 생성자가 어딘가에서 호출되어야 하겠네\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class MemberController {\n\tprivate final MemberService memberService;\n\n\tpublic MemberController(MemberService memberService) {\n\t\tthis.memberService = memberService;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n하지만, MemberController보다 상위의 어떤 코드를 살펴봐도 MemberController 생성시 MemberService 인스턴스를 주입하는 코드가 없는 것을 확인할 수 있다. 그러면 우리가 어떻게 사용할까?\n\n\u003cbr\u003e\n\n```java\n@SpringBootApplication\npublic class DiApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DiApplication.class, args);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n스프링이 자동으로 의존성을 주입해주기 때문이다. ==**스프링 Bean으로 등록되면 스프링이 자동으로 생성해주는데 이때 필요한 의존성도 주입해준다.**== 그렇다면, 어떻게 해야 스프링이 자동으로 의존성을 주입할 수 있게 해줄까?\n\n\u003cbr\u003e\n\n\u003e **@Autowired 애노테이션**\n\u003e -   여기에 의존성을 주입해달라는 뜻\n\u003e -   스프링이 자동으로 적절한 의존성을 주입해줌\n\n\u003cbr\u003e\n\n### (Spring) 필드 주입\n\n-   스프링을 적용하지 않은 DI의 방법에는 없던 방법\n-   원래는 불가능한 주입을 프레임워크의 힘을 빌려 주입하는 방법\n-   하지만, 필드 주입은 추천되는 방법이 아님 (인텔리제이도 경고함)\n    -   필드주입을 사용하면 테스트 등의 이유로 자동이 아닌 수동 의존성 주입하고 싶어도 ==**생성자도, setter도 없으므로 개발자가 직접 의존성을 넣어줄 수 없다.**==\n    -   이는 ==**의존성이 프레임워크에 강하게 종속된다는 문제점**==이 있다는 것\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class MemberController {\n\t@Autowired\n\tprivate MemberService memberService;\n}\n```\n\n\u003cbr\u003e\n\n### (Spring) Setter 주입\n\n-   setter 메서드에 @Autowired를 붙이면 스프링이 setter를 사용해서 자동으로 의존성을 주입해줌\n-   이때, Bean 객체를 만들고 setter로 의존성을 주입해주기 때문에 Bean 생성자 혹은 Bean 정적 팩토리 메서드가 필요하다.\n    -   ==이때문에 final 필드를 만들 수 없고 의존성의 불변을 보장할 수 없다는 특징이 있다.==\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class MemberController {\n\tprivate MemberService memberService;\n\n\t@Autowired\n\tpublic void setMemberService(MemberService memberService) {\n\t\tthis.memberService = memberService;\n\t}\n}\n```\n\n\u003cbr\u003e\n\nsetter 주입은 왜 존재할까?\n- 런타임에 setter를 다시 호출하면 주입해줬던 의존성을 다시 변경할 수 있을 것이다. \n- 그래서, 주로 런타임에 의존성을 수정해야 하거나 의존성을 선택적으로 주입할 때 사용한다.\n\n\u003cbr\u003e\n\n### (Spring) 생성자 주입\n\n-   생성자 주입을 사용하면 객체의 최초 생성 시점에 스프링이 의존성을 주입해준다.\n-   스프링에서 공식적으로 추천하는 방법. Spring 4.3 버전 이후 ==**생성자가 1개밖에 없을 경우 해당 생성자에 스프링이 자동으로 @Autowired를 붙여주기 때문에 애노테이션 생략이 가능**==하다.\n-   스프링 공식문서에서는 생성자 주입 + Setter 주입을 혼용할 수 있지만 생성자 주입을 추천한다고 한다.\n-   setter 주입은 선택적 의존성에 사용하라고 한다.\n    -   생성자 주입된 컴포넌트들이 완전히 초기화된 상태로 클라이언트에 반환되기 때문이라고 함.\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class MemberController {\n\tprivate final MemberService memberService;\n\n\tpublic MemberController(MemberService memberService) {\n\t\tthis.memberService = memberService;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### 생성자 주입 장점\n\n1.  **생성자 주입을 사용하면 필드를 final로 만들어줄 수 있고 의존성 주입이 생성자 호출 시 최초 1회만 이루어지기 때문에 의존 관계를 불변으로 만들어줄 수 있는 장점이 있다.**\n    \n2.  final이 가능하기 때문에 `NullPointerException` 을 방지할 수 있다.\n    -   필드 주입, setter 주입의 경우 스프링의 빈 관리 기능을 빌리지 않고 new 키워드로 직접 객체를 생성할 경우 NullPointerException이 발생할 수 있다.\n        -   왜냐하면, 이들은 빈 생성자를 사용해서 기본적으로 의존성이 없는 상태니까\n    -   하지만, 생성자 주입은 객체 생성 시점에 모든 의존성을 주입해주므로 Null을 의도적으로 넣지 않는 한 NullPointerException을 방지할 수 있다.\n\n3.  순환참조 문제 방지 가능\n    -   필드 주입, setter 주입의 경우 A객체 → B 객체 의존하는데 B객체 또한 A객체를 의존하는 순환참조 문제가 발생할 수 있다.\n    -   생성자 주입을 사용하는 객체들끼리 의존성이 순환되면, 스프링은 에러메세지와 함께 프로그램을 종료한다.\n\n\u003cbr\u003e\n\n```java\n@Component\npublic class A {\n\t@Autowired\n\tprivate B b;\n\n\tpublic void doSomething() {\n\t\tb.doSomething();\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\n@Component\npublic class B {\n\t@Autowired\n\tprivate A a;\n\n\tpublic void doSomething() {\n\t\ta.doSomething();\n\t}\n}\n```\n\n- 순환호출이 반복되다가 스택오버플로우 에러가 발생해서 프로그램이 멈출 것\n\t- 생성자 주입을 이용하면 애플리케이션 시작 타이밍에 에러를 통해 방지!\n\t- 근데, 스프링부트 2.6 버전부터는 필드 주입이나 setter 주입도 기본 설정으로 순환참조 방지됨\n\n\u003cbr\u003e\n\n### 생성자가 여러 개\n\n**생성자가 여러 개인 경우 어떻게 해야할까?**\n-   의존성을 자동으로 주입하는데 사용할 생성자에 @Autowired 붙이기\n-   @Autowired가 여러 개 있을 경우, 스프링은 가장 많은 의존성을 주입할 수 있는 생성자를 사용해서 의존성을 주입한다.\n-   @Autowired가 붙은 모든 생성자가 사용 불가능하거나 어떤 생성자에도 @Autowired가 없을 경우에는 기본 생성자를 호출한다.\n-   기본 생성자조차 없으면 컴파일 에러 발생\n\n**의존성 주입 순서**\n\n생성자 → 필드 → setter\n\n\u003cbr\u003e\n\n### 주입하고자 하는 의존성이 여러 개\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class PayController {\n\tprivate final PayService payService;\n\n\tpublic PayController(PayService naverPayService) {\n\t\tthis.payService = naverPayService;\n\t}\n}\n```\n\n-   결제를 담당하는 payService 인터페이스가 있다고 하자.\n    -   구현체인 네이버 페이 서비스와, 카카오 페이 서비스가 있음\n    -   모두 Bean으로 등록되어있음\n-   payController에서는 어떤 거를 주입받아야할까?\n    -   그대로 시작하면 애플리케이션 실패되면서 에러가 뜬다.\n\n\u003cbr\u003e\n\n1.  스프링은 의존성 주입 대상을 찾을 때 **정의되어 있는 타입을 기준**으로 찾는다. 현재는 PayService라는 타입으로 검색된다.\n2.  이렇게 타입을 기준으로 여러 Bean이 검색되었다면, 스프링은 Bean의 이름을 기준으로 의존성을 주입한다.\n    -   이때, 주입하는데 사용되는 메서드의 매개변수 명과 등록된 빈의 이름이 일치하는지 체크한다.\n    -   생성자 매개변수 명을 naverPayService로 바꿔주면, 자동으로 naverPayService 빈이 주입되고 생성에 성공한다.\n    -   하지만, 이런식으로 매개변수 명을 바꿔버리면 수동으로 kakaoPayService를 주입해야하는 경우에 헷갈리고 자동으로 주입하는 빈을 바꿀때도 귀찮을 것\n3.  스프링이 제공하는 @Qualifier 애노테이션 사용\n\n\u003cbr\u003e\n\n```java\n@Service\n@Qualifier(\"mainPayService\")\npublic class NaverPayService implements PayService {\n\n}\n```\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class PayController {\n\tprivate final PayService payService;\n\n\tpublic PayController(@Qualifier(\"mainPayService\") PayService payService) {\n\t\tthis.payService = payService;\n\t}\n}\n```\n\n-   @Qualifier 애노테이션 안에 해당 빈의 구분자를 지정할 수 있음\n-   NaverPayService에 `@Qualifier(\"mainPayService\")` 를 붙여서 지정\n-   의존성을 주입받을 부분에 동일하게 @Qualifier 애노테이션 작성하면 네이버 페이 서비스가 주입된다.\n\n\u003cbr\u003e\n\n4. 스프링이 제공하는 @Primary 애노테이션 사용\n\n\u003cbr\u003e\n\n```java\n@Service\n@Primary\npublic class NaverPayService implements PayService {\n\n}\n```\n\n\u003cbr\u003e\n\n```java\n@Controller\npublic class PayController {\n\tprivate final PayService payService;\n\n\tpublic PayController(PayService payService) {\n\t\tthis.payService = payService;\n\t}\n}\n```\n\n- @Primary 애노테이션이 붙은 빈은 해당 타입으로 의존성을 검색할 때 우선적으로 주입된다. 일종의 기본 빈이 되는 것이다.\n\n\u003cbr\u003e\n\n5.  @Qualifier vs @Primary\n    -   @Qualifier가 @Primary보다 우선권을 가짐\n\n\u003cbr\u003e\n\n**스프링 의존성 주입 기준**\n\n타입 → @Qualifier → @Primary → 변수 명\n\n\u003cbr\u003e\n\n## 스프링 컨테이너\n\n스프링 컨테이너\n- ==**IoC와 DI의 원리가 이 스프링 컨테이너에 적용**==\n- 자바 객체의 생명 주기를 관리\n- 생성된 자바 객체들에게 추가적인 기능을 제공하는 역할\n- 대표적으로 BeanFactory, ApplicationContext가 있음\n\t- 둘 다 Bean을 등록하고 생성하고 조회하고 돌려주는 등 Bean을 관리하는 역할\n\t- ApplicationContext가 BeanFactory의 빈 관리 기능들을 상속받았고, 그 외에 국제화 등의 추가적인 기능을 갖고 있어 스프링 컨테이너라고 하면 보통 ApplicationContext라고 한다.\n\n\u003cbr\u003e\n\n## 참고\n\n- https://www.youtube.com/watch?v=8lp_nHicYd4","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/dog-study/dog-week04":{"title":"4주차 - Spring 웹","content":"\n\u003chr\u003e\n\n\u003e[!note] 4주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC** \u003cbr\u003e\n\u003e - Web Server, WAS\n\u003e - Servlet, Servlet Container\n\u003e - Filter, Interceptor\n\u003e - AOP\n\n\u003cbr\u003e\n\n## Web Server, WAS\n\n\u003cbr\u003e\n\n**Web Server**\n-   인터넷을 기반으로 클라이언트에게 웹 서비스를 제공하는 컴퓨터\n\n\u003cbr\u003e\n\n**흐름 과정**\n\n-   클라이언트 : 웹서버에게 주소(url)를 가지고 통신 규칙(http)에 맞게 요청하면 알맞은 내용(html)을 응답받음\n-   서버 : 클라이언트의 요청을 기다리고, 웹 요청(http)에 대한 데이터를 만들어서 응답한다. 이때, 데이터는 웹에서 처리할 수 있는 html, css, 이미지 등 ==**정적인 데이터**==로 한정\n-   DB에서 데이터를 가져와서 전달해주는, 동적인 데이터를 줄 수 없을까? html은 프로그래밍 언어가 아니라서 이런게 불가능하다.\n\n\u003cbr\u003e\n\n**Web Application Server**\n\n-   웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크\n-   웹 애플리케이션을 실행시켜 필요한 기능을 수행하고 그 결과를 웹 서버에게 전달\n-   php, jsp, asp와 같은 언어들을 사용해서 ==**동적인 페이지**==를 생성할 수 있는 서버\n-   프로그램 실행 환경과 데이터베이스 접속 기능 제공\n-   비즈니스 로직 수행 가능\n-   ==**웹 서버 + 웹 컨테이너**==\n    -   컨테이너 : jsp, servlet을 실행시킬 수 있는 소프트웨어\n    -   자바 계열에서는 웹 애플리케이션 컨테이너라고 부름\n    -   웹 애플리케이션 컨테이너 : 웹 애플리케이션이 배포되는 공간\n\n\u003cbr\u003e\n\n**예시**\n\n-   Web Server : Apache, nginx, Microsoft IIS\n-   Web Application Server : Tomcat, Jetty, JBoss, IBM WebSphere, 티맥스 JEUS(제우스)\n\n**결론 : “상황에 따라 변하는 정보를 제공할 수 있는가”**\n\n-   Web Server : No. 정적인 페이지만!\n-   Web Application Server : Yes. 동적인 페이지 가능!\n\n\u003cbr\u003e\n\n### WAS 앞 단에 Web Server\n\nQ. **그러면 드는 생각이, WAS가 어차피 다 해주는 Web Server가 굳이 왜 필요할까?**\n\n( = Web Server를 같이 사용했을 때의 장점 )\n\n\u003cbr\u003e\n\n1.  **책임 분할을 통한 서버 부하 방지**\n    -   정적 컨텐츠는 Web Server, 동적 컨텐츠는 WAS가 담당\n    -   WAS는 DB 조회 등 페이지를 만들기 위한 다양한 로직을 처리하는데, 단순한 정적 컨텐츠를 WAS에서 제공한다면 다른 작업에 사용하는 리소스들로 인해 지연이 생겨날 수 있다. (그런데, tomcat 5.5 이상부터는 성능이 크게 떨어지지 않는다고 한다.)\n\n2.  **여러 대의 WAS 로드밸런싱**\n    -  WAS가 처리해야 하는 요청을 여러 WAS가 나누어서 처리할 수 있도록 설정\n    - 앞 단에 Web Server를 두고 뒷단에 여러대의 WAS를 둔다면, WAS가 처리해야하는 요청을 Web Server에서 여러 WAS에 뿌려주는 것\n\n3. 여러 대의 WAS Health check\n\t- \u003cdetails\u003e\u003csummary\u003e\u003cstrong\u003eHealth check란?\u003c/strong\u003e\u003c/summary\u003e \n\t    Web Server가 로드밸런싱 해주다보면, 특정 WAS에서 동작이 제대로 안 될 수 있는 경우가 있는데, 웹 서버에서 WAS가 정상적으로 동작하고 있는지 http 요청을 보내서 서버의 상태를 확인하는 기능\u003c/details\u003e\n\t -   서버에 주기적으로 HTTP 요청을 보내 서버의 상태를 확인\n\t    (ex. 특정 url 요청에 200 응답이 오는지? 200이 오면 정상, 안오면 비정상이니까 비정상 서버로 인지를 하고 서버로 요청 전달하지 않게 설정 가능)\n\t-   Interval : health check를 통해 서버 상태를 확인하는 요청을 날리는 주기 (default : 5초)\n\t-   Fails : 아래의 경우 3회 연속 실패하면 서버가 비정상이라고 인지 (default : 1회)\n\t-   Passes : 서버가 다시 복구되어 요청이 2번 연속 성공하면 서버가 정상으로 인지 (default : 1회)\n\n4.  **보안**\n\t-   리버스 프록시를 통해 실제 서버를 외부에 노출하지 않을 수 있다.\n\t -   WAS 같은 경우, DB 관련 로직이나 DB 접근 권한을 가질 수 있기에 외부에 노출하면 위험할 수 있지만, 앞단에 웹 서버를 둬서 외부에 노출시키지 않는 것이다.\n\t-   물리적으로 분리하여 보안 강화\n\t    -   SSL에 대한 암복호화 처리에 Web Server를 사용\n\t    -   공격에 대해 Web Server를 앞 단에 두어 중요한 정보가 당긴 DB나 로직까지 (WAS까지) 전파되지 못하게 한다.\n\n\u003cbr\u003e\n\n\u003e [!note] Reverse Proxy \u003cbr\u003e\n\u003e 클라이언트 - 웹 - Reverse Proxy Server - 서버의 구조로 서버의 정보를 클라이언트에게 감춰주는 녀석\n\u003e 1.  캐싱 (Forward Proxy와 동일)\n\u003e 2.  보안 : 서버 정보를 클라이언트로부터 숨김 \u003cbr\u003e\n\u003e \t- 클라이언트는 요청할 때 서버 정보를 직접 알지 못함 \u003cbr\u003e\n\u003e \t- 리버스 프록시가 자신이 알고있는 서버들에게 요청을 전달 \u003cbr\u003e\n\u003e \t- Client는 Reverse Proxy를 실제 서버라고 생각하여 요청을 보낸다. 실제 서버의 IP가 노출되지 않는다.\n\u003e 3. Load Balancing\n\n\u003cbr\u003e\n\n### 여러 대의 WAS 장점\n\n1.  위에서 말한 것처럼 Load Balancing을 통한 서버 부하 분산\n2.  fail over (장애극복), fail back\n3.  뭐 이것도 보안이 있을 수 있겠네\n4.  대용량 웹 애플리케이션의 경우 (여러 개의 서버 사용) Web Server와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다.\n5.  다른 종류의 WAS로 서비스 가능\n\n- fail over는 위에서 처럼 하나의 WAS가 작동을 중지한 경우 다른 WAS들로 돌릴 수도 있다는 개념\n- fail back은 작동이 중지된 서버를 다시 재작동 시킨다는 의미\n- 다른 종류의 WAS로 서비스 가능하다는건 하나의 서버에서 PHP application, Java application을 함께 사용할 수 있다는 말이다. 서버는 가운데에다가 두고 하나의 WAS에는 php application~ 다른 WAS에는 java application~ 이런 방식으로!\n\n\u003cbr\u003e\n\n## Servlet, Servlet Container\n\n- Servlet : WAS 안의 웹 컨테이너에 위치하며, **동적인 페이지**를 만드는데 사용되는 서버 프로그램\n\t- 서블릿이 존재하기 전에는 요청이 들어오면 HTTP 요청 메시지를 파싱하는 것부터 여러 부가 작업을 개발자가 수행해야 했다. 하지만 서블릿이 나오면서 부가적인 작업을 대신해주게 되었고, 개발자는 실직적인 비즈니스 로직에만 집중 할 수 있게 되었다.\n\n- Servlet Container : WAS가 Web Server + Web Container라고 했었는데, Java 애플리케이션 진영에서는 이 웹 컨테이너를 Servlet Container라고도 한다.\n\t- 서블릿 컨테이너는 **서블릿의 생명주기**를 관리\n\t-   `init()` : 서블릿 초기화\n\t-   `service()` : HTTP 요청 유형을 확인하고 맞게 doGet, doPost, doPut 등 메서드를 호출하여 요청 처리\n\t-   `destroy()` : 서블릿 제거\n\t- ==서블릿 객체도 **싱글톤** 으로 관리되기 때문에 최초 요청 시점에 서블릿 객체를 초기화해서 서블릿 컨테이너에 보관하고 이후에는 같은 서블릿을 공유해서 사용한다.==\n\n\u003cbr\u003e\n\n**대략적인 동작 과정**\n\n1.  사용자가 URL을 클릭하면 HTTP Request를 Servlet Container로 보낸다.\n    \n2.  **Servlet Container는 쓰레드 풀에서 쓰레드를 꺼내 할당**해주고 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.\n    \n3.  사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다.\n    \n4.  서블릿 컨테이너에 존재하지 않으면 초기화하고 있다면 가져와서 service() 메서드를 호출한다.\n    \n\t-   Spring MVC의 경우 DispatcherServlet이 초기화되고 호출된다.\n\n5.  service 메서드가 수행이 끝나면 HttpServletResponse 객체에 응답을 보낸다.\n\n\u003cbr\u003e\n\n### Dispatcher Servlet\n\n **Spring Web MVC에서는 이 Servlet을 어떻게 사용할까? 없던 시절에는 어떻게 하였을까?**\n\n-   Spring Web MVC가 없던 시절에서는 URL마다 서블릿이 한 개 필요했었고, get만 쓰고 싶다고 해도 서블릿 전체를 만들어야 했다. 또, servlet을 만들 때마다 Web.xml에 servlet 마다 mapping을 시켜줬어야 했었다.\n-   Spring Web MVC 등장으로 Servlet이 Dispatcher Servlet 하나만 있어도 된다. 또, 디스패처 서블릿을 도입하면서 view를 강제로 분리시켜주는 효과가 생김\n\n\u003cbr\u003e\n\n**Dispatcher Servlet의 동작**\n\n1.  클라이언트의 요청을 디스패처 서블릿이 받음 (Dispatcher Servlet)\n2.  요청 정보를 통해 요청을 위임할 컨트롤러를 찾음 (Handler Mapping)\n3.  요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달함 (Handler Adapter)\n4.  핸들러 어댑터가 컨트롤러로 요청을 위임함 (RestController)\n5.  비지니스 로직을 처리함 (Service - Business Logic, Repository - Data access, Database)\n6.  컨트롤러가 반환값을 반환함 (Response Entity)\n7.  핸들러 어댑터가 반환값을 처리함\n8.  서버의 응답을 클라이언트로 반환함\n\n\u003cbr\u003e\n\n## Filter, Interceptor\n\n\u003cbr\u003e\n\nFilter\n-   Dispatcher Servlet에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리하는 기능을 제공하는 것\n-   톰캣과 같은 웹 컨테이너(웹 애플리케이션 WAS 단)에서 동작 하기 때문에 Spring과 무관한 자원에 대해 동작\n-   Spring Context 외부에서 동작하는 것\n\n\u003cbr\u003e\n\nFilter 메서드\n-   `init()`\n\t-   필터 객체를 초기화하고 서비스에 추가하기위한 메서드\n\t-   웹 컨테이너(WAS 단)에서 1회 init 메서드를 호출하여 필터 객체를 초기화하면 이후 요청들은 doFilter를 통해 전/후 처리가 된다.\n-   `doFilter()`\n\t-   url-pattern에 맞는 모든 HTTP 요청이 디스패처 서블릿으로 전달되기 전/후에 웹 컨테이너에 의해 실행되는 메서드\n\t-   doFilter의 파라미터로 FilterChain이 있는데, FilterChain의 doFilter 를 통해 다음 대상으로 요청을 전달한다.\n-   `destroy()`\n\t-   필터 객체를 서비스에서 제거하고 사용하는 자원을 반환하는 메서드\n\t-   웹 컨테이너에 의해 1번 호출된다.\n\n\u003cbr\u003e\n\nInterceptor\n-   Spring이 제공하는 기술로, Dispatcher Servlet이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공하는 것\n-   스프링 컨텍스트에서 동작\n-   Spring Context 내부에서 동작하므로 @ControllerAdvice 을 사용하여 예외 처리\n\n\u003cbr\u003e\n\nInterceptor 메서드\n-   `preHandle()`\n\t- 컨트롤러가 호출되기 전에 실행되어 컨트롤러 이전에 처리해야 하는 전처리 작업이나 요청 정보를 가공하거나 추가하는 경우에 사용할 수 있다.\n\t- 리턴값이 boolean이다. 리턴이 true 일경우 preHandle() 실행후 핸들러에 접근한다. false일경우 작업을 중단하기 때문에 컨트롤러와 남은 인터셉터가 실행되지 않는다.\n-   `postHandle()`\n\t- 컨트롤러 호출된 후에 실행되어 컨트롤러 이후에 처리해야하는 후처리 작업이 있을 때 사용할 수 있다. 핸들러가 실행은 완료 되었지만 아직 View가 생성되기 이전에 호출된다.\n\t- 보통 컨트롤러가 반환하는 ModelAndView 타입의 정보가 제공되는데, Controller에서 View 정보를 전달하기 위해 작업한 Model 객체의 정보를 참조하거나 조작할수 있다.\n-   `afterCompletion()`\n\t-   모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후에 실행된다.\n\t-   요청 처리 중에 사용한 리소스를 반환할 때 사용하기 적합하다.\n\t- 뷰가 렌더링 된 이후에 사용되는데, ==**최근에는 React와 Vue 같이 SPA를 사용하면서 뷰를 따로 사용하는 것이 아닌 Json 형태로 데이터를 제공하는 REST API 기반의 컨트롤러가 사용되면서 잘 사용하지 않는다.**==\n\n\u003cbr\u003e\n\n### 실행과정\n\n![](brain/image/dog-week04-1.png)\n\n1.  서버 실행 시 Servlet이 올라오는 동안 init 후 doFilter 실행\n2.  Dispatcher Servlet을 지나쳐 Interceptor의 PreHandler 실행\n3.  컨트롤러를 거쳐 내부 로직 수행 후, Interceptor의 PostHandler 실행\n4.  doFilter 실행\n5.  Servlet 종료 시 destory\n\n\u003cbr\u003e\n\n### 둘의 차이\n\n-   필터는 웹 컨테이너(서블릿 컨테이너)에서 실행, 인터셉터는 스프링 컨택스트에서 실행 ⇒ 실행시점 다름\n-   필터는 디스패처 서블릿 전후, 인터셉터는 컨트롤러의 전후 다룸\n-   필터는 스프링과 무관하게 전역적으로 처리하는 작업, 입력으로 들어온 파라미터 자체 검증\n-   인터셉터는 스프링으로 들어온 요청과 관련되어 전역적으로 처리하는 작업\n-   인터셉터는 @ControllerAdvice, @ExceptionHandler를 사용하여 예외처리 가능, 필터는 이것이 불가능하여 doFilter() 메서드 주변을 try-catch로 감싸서 예외 핸들링\n\n\u003cbr\u003e\n\n| 대상 | 필터(Filter) |인터셉터(Interceptor) |\n|-----|-------------|--------------------|\n| 관리 컨테이너 | 웹 컨테이너 | 스프링 컨테이너 |\n| Request/Response 조작 여부 | 가능 | 불가능 |\n| 용도 | 보안 관련 공통 작업+ 이미지/데이터 압축 및 문자열 인코딩+ 모든 요청에 대한 로깅 또는 감사+ ServletRequest 커스터마이징 | 인증/인가 등과 같은 공통 작업+ Controller로 넘겨주는 정보의 가공+ API 호출에 대한 로깅 |\n\n\u003cbr\u003e\n\n==**인터셉터가 조작 여부가 불가능하다는 것은 HttpServletRequest, HttpServletResponse 객체를 제공받으므로 객체 자체는 조작할 수 없다는 의미이고, 내부 값들은 조작할 수 있다.**==\n\n\u003cbr\u003e\n\n## AOP\n\n**AOP(Aspect Oriented Programming)**\n\n관점 지향 프로그래밍으로 **공통 관심 사항과 핵심 관심 사항을 분리** 하는 것을 의미한다.소스 코드에서 여러 번 반복해서 사용하는 코드(흩어진 관심사)를 Aspect로 모듈화하여 핵심 로직에서 분리해 재사용하는 것이라고 볼 수 있다.여러 객체에 공통으로 적용할 수 있는 기능을 구분함으로써 재사용성을 높여주는 프로그래밍 기법이다.특정 로직(로그, 성능테스트, 권한)을 모든 메서드에 적용하고 싶을 때, 일일이 추가하는 것이 아니라 로직을 만들어서 적용할 수 있다.따라서, 비즈니스 로직 앞/뒤에 공통 관심 사항을 수행해 중복 코드를 줄인다.\n\n-   관점지향 프로그래밍으로, 횡단 관심사에 따라 프로그래밍 하는 것. OOP를 보완하기 위해 나온 개념\n-   예를 들어, 로깅/트랜잭션/권한검사/성능측정 등 부가 기능인 인프라 로직의 중복이 횡단으로 나타나는 경우 이를 모듈화하여 생각하는 것을 말함\n-   AOP는 일종의 패러다임이라, 각 언어마다 AOP의 구현체가 있음. 대표적으로 자바는 AspectJ\n\n\u003cbr\u003e\n\n### AOP 용어\n\n-   Aspect\n\t-   흩어진 관심사를 모듈화 한 것\n\t-   모듈 : 외부에서 재사용할 수 있는 패키지들을 묶은 것\n\t-   advice + pointcut을 모듈화 한 것\n-   Target\n\t-   advice의 대상이 되는 객체\n\t-   Target object는 비즈니스 클래스 같은 핵심 모듈이라고 할 수 있음\n\t-   Pointcut으로 결정\n-   Advice\n\t-   실질적인 부가 기능 로직을 정의하는 곳\n\t-   특정 조인 포인트에서 Aspect에 의해 취해지는 조치\n-   Join point\n\t-   **추상적인 개념** 으로 advice가 적용될 수 있는 모든 위치\n\t-   ex) 메서드 실행 시점, 생성자 호출 시점, 필드 값 접근 시점 등등..\n\t-   **스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메서드 실행 지점**\n-   Point cut\n\t-   Join point의 상세한 스펙을 정의한 것, 구체적으로 실제 advice가 적용될 지점\n\t-  스프링 AOP는 프록시 기반이기 때문에 조인 포인트가 메서드 실행 시점 뿐이 없고 포인트 컷도 메서드 실행 시점만 가능 ( = 실제 advice가 적용될 메서드 )\n-   Advisor\n    -   스프링 AOP에서만 사용되는 용어로 advice + pointcut 한 쌍\n-   Weaving\n    -   pointcut으로 결장한 타겟의 join point에 advice를 적용하는 것\n-   AOP 프록시\n    -   AOP 기능을 구현하기 위해 만든 프록시 객체\n    -   스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시\n\n\u003cbr\u003e\n\n### AOP 적용 방식\n\n-   컴파일 시점\n\t-   .java 파일을 컴파일러를 통해 .class를 만드는 시점에 부가 기능 로직을 추가\n\t-   모든 지점에 적용 가능\n\t-   AspectJ가 제공하는 특별한 컴파일러를 사용해야 하기 때문에 특별할 컴파일러가 필요한 점과 복잡하다는 단점이 있다.\n-   클래스 로딩 시점\n\t-   .class 파일을 JVM 내부의 클래스 로더에 보관하기 전에 조작하여 부가 기능 로직 추가\n\t-   모든 지점에 적용 가능\n\t-   특별한 옵션과 클래스 로더 조작기를 지정해야하므로 운영하기 어렵다.\n-   **런타임 시점**\n\t-   **Spring AOP가 사용하는 방식**\n\t-   컴파일이 끝나고 클래스 로더에 이미 다 올라가 자바가 실행된 다음에 동작하는 런타임 방식\n\t-   실제 대상 코드는 그대로 유지되고 프록시를 통해 부가 기능이 적용\n\t-   **프록시는 메서드 오버라이딩 개념으로 동작하기 때문에 메서드에만 적용 가능** -\u003e **스프링 빈에만 AOP를 적용 가능**\n\t-   특별한 컴파일러나, 복잡한 옵션, 클래스 로더 조작기를 사용하지 않아도 스프링만 있으면 AOP를 적용할 수 있기 때문에 스프링 AOP는 런타임 방식을 사용\n\n\u003cbr\u003e\n\n### Spring에서 AOP 구현\n\n-   XML 기반의 POJO(Java 하드코딩?) 클래스를 이용한 AOP 구현\n\t-   부가 기능을 제공하는 Advice 클래스를 작성하고 XML 설정파일에 Aspect 설정 (Advice, Pointcut)\n-   @Aspect 어노테이션을 이용한 AOP 구현\n\t-   @Aspect 애노테이션을 이용해서 부가기능을 제공하는 Aspect 클래스 작성\n\t-   Aspect 클래스 생성 → Advice 구현 → Pointcut 구현\n\n기본적인 작동 원리\n- Spring AOP에서는 프록시 패턴을 채택\n- 어떤 target 클래스를 부가 기능을 제공하는 프록시로 감싸서 실행하는 방법\n\n\u003cbr\u003e\n\n### Spring AOP vs AspectJ\n\n\u003cbr\u003e\n\n| | Spring AOP | AspectJ |\n| -- | ------- | ------- |\n| 목표 | 간단한 AOP 기능 제공 | 완벽한 AOP 기능 제공 |\n| join point | 메서드 레벨만 지원 | 생성자, 필드, 메서드 등 다양하게 지원 |\n| weaving | 런타임 시에만 가능 | 런타임은 제공 X |\n| 대상 | Spring Container가 관리하는 Bean에만 가능 | 모든 Java Object에 가능 |\n\n- weaving은 AOP를 끼워주는, 바느질하는 시기\n\t- AspectJ는 Spring에서 제공하는 IoC와 DI가 없어서 런타임 제공하지 않음\n- Spring Container가 어떤 객체 생성을 관리해주기 때문에 런타임 시에만 가능한 것이다.\n\t- target object도 Spring 컨테이너가 관리하는 Bean에만 가능하게 되는 것\n\t- 그래서, Spring에서 코드를 작성할 때, @Aspect **애노테이션을 붙여 이 클래스가 Aspect를 나타내는 클래스라는 것을 명시하고 @Component를 붙여 스프링 빈으로 등록한다.**\n\n\u003cbr\u003e\n\n### AOP vs Interceptor\n\n\u003ca href='/brain/Interview/dog-study/dog-week04/#실행과정'\u003eFilter, Interceptor, AOP의 실행과정\u003c/a\u003e에서 보다시피, 스프링 컨택스트 내부의 Interceptor와 AOP는 역할이 비슷하게 보인다. 이 둘의 차이는 뭘까?\n\n-  Interceptor나 Filter와는 달리 AOP는 ==**메소드 전후**==의 지점에 자유롭게 설정이 가능하다.\n-  Interceptor와 Filter는 주소로 대상을 구분해서 걸러내야하는 반면, AOP는 주소, 파라미터, 애노테이션 등 다양한 방법으로 대상을 지정할 수 있다.\n-  AOP의 Advice와 HandlerInterceptor의 가장 큰 차이는 파라미터의 차이다.\n\t-  Advice의 경우 JoinPoint나 ProceedingJoinPoint 등을 활용해서 호출한다.\n\t-  반면 HandlerInterceptor는 Filter와 유사하게 HttpServletRequest, HttpServletResponse를 파라미터로 사용한다.\n\n\u003cbr\u003e\n\n### (심화) AOP 적용 안되는 경우\n\nAutoController -\u003e AuthServce\u0026\u0026프록시 -\u003e AuthService와 같은 경우를 생각해보자.\n- AuthService\u0026\u0026프록시가 AuthService를 감싸고 있으니, AuthService 타입을 가지겠지?\n- 그러면, AuthService 안에 있는 private 메서드에다가 AOP를 적용하면 어떻게 될까?\n\n\u003cbr\u003e\n\n```java {title=\"AuthService.java\"}\npublic void join(AuthService authService) {\n\tinner();\n\tmemberRepository.save(authService.toMember());\n}\n```\n\n\u003cbr\u003e\n\n```java\n@PerformanceCheck\nprivate void inner() {\n\tSystem.out.println(\"여기인가\");\n}\n```\n\n\u003cbr\u003e\n\n1.  AuthService에 join이라는 메서드에는 AOP를 적용하지 않았음\n2.  그 안에 private 메서드로 inner 메서드를 만들었음\n3.  여기에 `@PerformanceCheck` 이라는 AOP를 적용했음\n4.  join 메서드에서 inner 메서드를 호출\n\n\u003cbr\u003e\n\n결과는, ==**PerformanceCheck이 불려지지 않는다.**==\n\n- proxy로 감싼 객체가 실제로 target object의 join 메서드를 실행할 때\n- ==**inner 메서드가 aop로 감싼 proxy 객체가 아니기 때문에** ==\n- 자기 자신을 호출할 때는 AOP로 감싸지지 않는 메서드가 호출되는 것\n\n\u003cbr\u003e\n\n**정리하자면,**\n1.  자기가 자신의 메서드를 호출할 때, target object가 target object에 있는 메서드를 실행할 때는 AOP가 적용이 안된다.\n2. 자기가 자신의 메서드를 실행할 때에는 target object에서 실행한 메서드 내부에 있는 메서드이기 때문에 AOP가 적용이 안된 그냥 target object의 메서드를 그대로 실행하기 때문이다.\n3. 동일 클래스 메서드를 실행할 때, 자기가 자신의 메서드를 실행할 때 AOP가 적용이 되지 않은채로 실행이 된다.\n\n\u003cbr\u003e\n\n### @Transactional 문제도 여기!?\n\n- 우리가 service에서 private 메서드에다가 @Transactional을 붙였을 때 그 Transaction이 작동하지 않는 이유가 바로 이것 때문이다.\n- 갑자기 @Transactional? → 이것도 AOP 중 하나라서.\n\t- 서비스 로직을 하나의 트랜잭션으로 만들 때, 원래는 로직의 시작점에 Transaction을 열어주고 로직이 끝나는 시점에 Transaction을 커밋하는 코드가 항상 들어가야한다.\n\t- 하지만, `@Transactional` 을 통해서 개발자는 비즈니스 로직에만 집중할 수 있고, Transaction이라는 인프라 로직은 AOP로 분리를 하게 된다.\n\n\u003cbr\u003e\n\n## 참고\n\n- https://velog.io/@backtony/%EB%A9%B4%EC%A0%91-%EC%8B%9C%EB%A6%AC%EC%A6%882-Spring-JPA#filter-interceptor\n- https://popo015.tistory.com/115\n- https://www.youtube.com/watch?v=NyhbNtOq0Bc\n- https://www.youtube.com/watch?v=2pBsXI01J6M\n- https://www.youtube.com/watch?v=Hm0w_9ngDpM","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/dog-study/dog-week05":{"title":"5주차 - Spring 응용","content":"\n\u003chr\u003e\n\n\u003e[!note] 5주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC** \u003cbr\u003e\n\u003e - Bean 정의\n\u003e \t- 생명주기\n\u003e \t- 스코프\n\u003e - 싱글턴 vs 스프링 싱글턴\n\u003e - Annotation\n\u003e - Spring Annotation\n\u003e - MVC 패턴\n\u003e \t- MVVM MVP MVI\n\u003e - 레이어드 아키텍쳐\n\n\u003cbr\u003e\n\n## Spring Bean\n\n- ==**Spring Bean : Spring IoC Container가 관리하는 객체**==\n- ==**Spring IoC Continaer : Spring Bean을 관리하는 객체**==\n\nSpring Bean 이 왜 필요할까?\n- Spring IoC Container가 특정 객체 Lifecycle을 관리한다는 것을 나타내기 위하여\n\nSpring IoC Container는 왜 Bean을 관리하는 것일까?\n- 의존성을 자동 주입하여 개발자들이 해당 의존성을 사용하는 로직에만 집중할 수 있도록 도와주는 역할\n- 의존성을 주입할 때 사용되는 객체가 항상 동일함을 보장하기 위해\n\n\u003cbr\u003e\n\n### Bean을 쓰지 않는 경우 문제점\n\n객체를 Bean으로 등록하지 않고 직접 의존성 주입을 도입한다면 어떤 문제가 있을까?\n\n\u003cbr\u003e\n\n```java\npublic class Service {\n\tprivate final Dao dao;\n\n\tpublic Service(Dao dao) {\n\t\tthis.dao = dao;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\nService service = new Service(new JdbcDao());\n```\n\n\u003cbr\u003e\n\n이렇게 Dao 구현체를 의존성 주입 한다고 하자. 그렇다면 어디에선가 new 키워드를 사용하여 객체를 생성해야 한다. 이때 Dao 구현체가 변경된다면 어떻게 될까?\n\n\u003cbr\u003e\n\n```java\nService service = new Service(new TestDao());\n```\n\n\u003cbr\u003e\n\nService를 생성할 때 의존성 주입으로 Dao를 초기화하면서 어떤 Dao의 구현체를 선택할 것인지에 대한 책임을 가지기 때문에 Service를 생성하는 곳에서도 변경이 일어난다. \n\n\u003cbr\u003e\n\n```java\nService service = new Service(new Test1Dao(), new Test2Dao(), new Test3Dao());\n```\n\n\u003cbr\u003e\n\n또, 이렇게 의존성 주입을 여러 개 하는 경우 해당 의존성 주입의 순서와 관계를 모두 파악해야해서 번거로움이 생긴다.\n\n따라서, 아래와 같이 Bean을 사용해보자.\n\n- 의존성 주입이 필요한 객체를 Bean으로 등록\n- 스프링 IoC 컨테이너가 객체의 생성과 의존성 주입을 관리하도록 함\n- 장점 : 개발자가 주입된 의존성 부분에만 집중할 수 있게 됨\n\n\u003cbr\u003e\n\n### Bean 생명주기\n\n==**스프링 IoC 컨테이너 생성 → 스프링 빈 객체 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료**==\n\n\u003cbr\u003e\n\nBean의 Lifecycle의 관리자 =\u003e Spring Container\n- Bean의 Lifecycle 관련 **callback 메서드를 호출**하여, Bean 객체의 생성, 초기화, 소멸의 Lifecycle을 관리한다.\n- callback 메서드 : 어떤 이벤트에 의해 호출되는 함수\n\nBean의 Lifecycle에서 callback의 필요성\n- Database Connection, 네트워크 소켓 연결 등 시작 지점에 미리 연결한 뒤 애플리케이션 종료 시점에 연결을 종료해야하는 경우 =\u003e 객체의 초기화 및 종료 작업이 필요할 것\n- 예를 들어, Connection Pool의 connect \u0026 disconnect\n- Spring Bean도 동일한 원리로 **초기화 작업**과 **종료 작업**이 나눠서 진행됨\n\t- Spring Bean은 의존관계 주입이 끝나야만 사용이 가능하기 때문에 그때 **초기화 콜백 메서드**를 호출해서 사용하는 것이니까. 끝나고 나면 다시 **소멸 전 콜백 메서드**로 종료!\n\n\u003cbr\u003e\n\n**Spring이 Bean Lifecycle Callback을 관리하는 방법**\n\n- Spring의 인터페이스 (InitializingBean, DisposableBean)\n\n```java\nclass MySpringBean implements InitializingBean {\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\n\t}\n}\n```\n\n\u003cbr\u003e\n\n- JSR-250 애노테이션 지원\n\t- `@PostConstruct`, `@PreDestroy` 사용\n\t- ==**Spring에서 Bean 초기화, 소멸 시 권장하는 방식**==\n\t- 단점 : 외부 라이브러리에는 적용 못함\n\n```java\n@PostConstruct\npublic void postConstruct() {\n\n}\n\n@PreDestroy\npublic void preDestroy() {\n\n}\n```\n\n\u003cbr\u003e\n\n- `@Bean` 애노테이션에 속성을 추가\n\t- JSR-250 애노테이션이 외부 라이브러리에는 적용 못하기 때문에 그럴 경우 `@Bean` 애노테이션에 속성을 추가하는 방식을 사용함\n\t- 설정 정보에 초기화 메서드, 종료 메서드 지정\n\n```java\n@Bean(initMethod = \"onInitialize\", destroyMethod = \"onDestroy\")\npublic MySpringBean mySpringBean() {\n\treturn new MySpringBean();\n}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eBean의 생성 Lifecycle 상세\u003c/strong\u003e\u003c/summary\u003e\n\n1. Spring이 Bean 객체를 인스턴스화 한다.\n2. 의존 관계를 주입한다.\n3. `BeanNameAware.setBeanName()` 메서드를 호출한다.\n\t- setBeanName의 파라미터로 넘어온 문자열 값으로 빈의 이름 설정\n4. `BeanFactoryAware.setBeanFactory()` 메서드를 호출한다.\n\t- BeanFactory 객체를 주입하기 위해서 사용\n5. `ApplicationContextAware.setApplicationContext()` 메서드를 호출한다.\n\t- ApplicationContext 객체를 주입하기 위해서 사용\n6. `BeanPostProcessor.postProcessBeforeInitialization()` 메서드를 호출한다.\n7. `@PostConstruct`이 붙은 메서드, `InitializingBean.afterPropertiesSet()` 메서드, `@Bean`의 initMethod로 지정한 메서드 순서로 호출\n8. `BeanPostProcessor.postProcessAfterInitialization()` 메서드를 호출한다.\n\nQ. Bean의 생성과 초기화를 분리하는 이유는?\n- 생성자에서 초기화라는 무거운 작업을 하는 것보다 분리하여 유지보수에 용이하도록 하기 위하여.\n\nQ. Spring에서 BeanFactory 컨테이너보다 ApplicationContext를 권장하는 이유?\n- BeanFactory는 스프링 컨테이너의 최상위 인터페이스이고 ApplicationContext는 BeanFactory를 상속하여 만들어져서, BeanFactory의 모든 기능을 포함하며 그보다 더 다양한 기능을 제공하기 때문이다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eBean의 소멸 Lifecycle 상세\u003c/strong\u003e\u003c/summary\u003e\n\n1. Spring IoC 컨테이너가 종료된다.\n2. `@PreDestory` 애노테이션이 붙은 메서드, `DisposableBean.destroy()` 메서드, `@Bean`의 destroyMethod로 지정한 메서드 순서로 실행된다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\nBean의 default 설정은 싱글턴이다. Spring IoC Container에 객체로 Bean을 등록하지 않고 개발자가 객체를 싱글턴으로 만들어서 사용하면 어떤 문제가 있을까?\n\n\u003cbr\u003e\n\n```java\npublic class DatabaseConnection {\n\tprivate static final DatabaseConnection databaseConnection = new DatabaseConnection();\n\n\tprivate DatabaseConnection() {\n\t}\n\n\tpublic static DatabaseConnection getConnection() {\n\t\treturn databaseConnection;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n1. 다형성을 이용하지 못함. 싱글턴이라서 private을 썼기 때문에 해당 객체는 상속이 불가능하게 됨.\n2. 단위 테스트가 어렵다. 메모리 절약에는 이점이 있겠지만, 해당 객체는 공유 객체가 되므로 단위 테스트를 실행할 때마다 테스트의 순서에 따라 결과가 달라지게 된다.\n\n\u003cbr\u003e\n\n객체를 싱글턴으로 만들어서 사용했을 때 단점들은 스프링 IoC 컨테이너가 어떻게 해결했을까? 스프링 IoC 컨테이너가 Bean의 LifeCycle을 관리하는 과정을 보면 해답을 찾을 수 있다.\n\n1. 객체 생성 + property 설정\n2. 의존 설정\n3. 초기화\n4. 사용\n5. 소멸\n\n\u003cbr\u003e\n\n**객체 생성 + property 설정**\n\n- Spring IoC 컨테이너가 생성되면 빈 스코프가 싱글턴인 객체를 생성\n-  Bean으로 등록하기 위해 애노테이션 기반, Java 설정 클래스 기반, xml 기반 등 다양한 configuration 메타 데이터를 이용하여 **통일된 Bean Definition을 생성**한다.\n- Bean으로 등록할 POJO + Bean Definition 정보를 이용하여 Bean 생성\n- 이 과정에서 싱글턴 패턴을 사용하는 것이 아니라 평범한 Java class를 이용하여 객체를 생성\n\n그리고, Spring IoC Container에는 Singleton Registry 기능이 있다.\n- Registry는 CS 전반적으로 사용되는 개념. Key-Value 형태로 데이터를 저장하는 방법\n- Spring IoC Container는 Bean Scope가 Singleton인 객체에 **Bean의 이름을 Key, 객체를 Value로 저장**한다.\n- 의존성이 주입되어야하는 **객체가 빈으로 등록되어 있을 때 Spring은 빈의 이름을 이용하여 항상 동일한 Single Object를 반환하게 되는 것**\n\n\u003cbr\u003e\n\n**의존 설정**\n\n- Bean 객체가 생성되면 IoC 컨테이너가 의존 설정을 함\n- 이 \u0008과정에서 의존성이 자동 주입되게 된다.\n\n\u003cbr\u003e\n\n**겍체 초기화, 사용, 소멸**\n\n- 초기화 : 모든 객체가 초기화 될 필요는 없고, Connection Pool처럼 사용전에 초기화 과정이 필요한 객체들이 초기화 됨\n- 사용 : 초기화가 끝나면 Bean을 사용할 수 있음\n- 소멸 : Spring Container가 종료될 때 Bean scope가 싱글턴인 객체들도 함께 소멸\n\n\u003cbr\u003e\n\n### Bean 스코프\n\n==**Bean 스코프 : 빈이 생성되고 존재하고 적용되는 범위를 지정할 수 있는 것**==\n- `@Scope` 애노테이션을 사용하여 설정 가능\n- default 타입은 싱글턴 타입\n\n- 싱글턴\n\t- Spring Framework의 default scope\n\t- Spring Continaer 시작과 종료까지 1개의 객체로 유지\n\t- 빈 스코프를 싱글턴으로 설정할 경우 상태를 가지면 안된다.\n\t\t- 싱글턴 스코프의 빈이 value라는 상태를 가지고 있고 Thread 1이 value의 값을 증가시키고 Thread 2가 value라는 값을 가져와서 사용한다고 가정해보면, 해당 빈의 상태를 항상 예측할 수 없어서 의도한 결과가 항상 나온다고 보장할 수 없게 된다.\n\t- Spring이 시작할 때 생성됨\n\n- 프로토타입\n\t- 빈의 생성, 의존관계 주입, 초기화까지만 관여하고 이후에는 컨테이너에서 관리하지 않는 스코프\n\t- 이 때문에 매번 요청마다 새로 만들어진다. \n\t\t- 모든 스레드에서 공유하는 것이 아니므로 싱글턴과는 다르게 해당 객체는 상태를 가질 수 있다.\n\t- 요청할 때 생성됨\n\n-   웹 스코프\n    -   request : 각 요청이 들어오고 나갈때까지 유지\n    -   session : 세션이 생성되고 종료될때까지 유지\n    -   application : 웹의 서블릿 컨텍스트와 동일한 생명주기를 갖는 스코프\n        -   서블릿 컨텍스트는 **web application내에 있는 모든 서블릿들을 관리하며 정보공유할 수 있게 도와 주는 역할** 을 하는데, 톰캣 컨테이너가 실행 시 애플리케이션 하나당 한개의 서블릿컨텍스트가 생성된다.\n        -   생명 주기는 보통 톰캣의 시작과 종료와 일치한다.\n\n\u003cbr\u003e\n\n### Bean 설정 시 주의점\n\n1. 빈 스코프를 싱글턴으로 설정할 경우 상태를 가지면 안된다.\n2. 의존성을 자동 주입해야 할 인터페이스에 구현체가 두 개 이상이라면, Spring은 어떤 구현체를 자동 주입할 지 정하지 못해서 충돌이 발생함.\n\n\u003cbr\u003e\n\n```java\n@Repository\npublic class InMemoryStationDao implements StationDao {\n\n}\n\n@Repository\npublic class JdbcStationDao implements StationDao {\n\n}\n\n@Service\npublic class StationService {\n\tprivate final StationDao stationDao;\n\n\tpublic StationService(final StationDao stationDao) {\n\t\tthis.stationDao = stationDao;\n\t}\n}\n\n// 둘 중 어떤 구현체를 넣어야 할 지 Spring은 모른다\n```\n\n\u003cbr\u003e\n이 경우, 애노테이션을 이용하여 의존성 주입 시 우선순위를 정할 수 있음.\n\n1. 의존성을 자동 주입해야 하는 구현체가 하나인 경우\n\t- `@Primary` 애노테이션\n2. 상황에 따라 다른 구현체를 자동 주입 되도록\n\t- `@Qualifier` 애노테이션\n\n\u003ca href='/brain/Interview/dog-study/dog-week03' target='_blank'\u003e3주차 - Spring 기본 # 주입하고자 하는 의존성이 여러 개 참고\u003c/a\u003e\n\n\u003cbr\u003e\n\n## 싱글턴\n\n프로그램 전역에서 사용되는 유일한 클래스를 만드는 방법이 **싱글턴 패턴, 정적 클래스**이다.\n\n싱글턴 패턴 : 디자인 패턴 중 하나로, ==**객체 인스턴스가 오로지 한 개만 생성 되도록 설계하는 패턴이다.**== 따라서, 애플리케이션 내에서 인스턴스가 유일해야 한다.\n\n\u003chr\u003e\n\n### 싱글턴 패턴의 순수한 구현\n\n- 인스턴스를 private static 변수\n- `getInstance()`에서 인스턴스 생성\n- 외부 생성자를 private으로 막는다.\n- 문제점 : Thread-safe하지 않다.\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e상세 설명 보기\u003c/strong\u003e\u003c/summary\u003e\n\n- 클래스의 인스턴스를 정적 필드에 저장 (`private static 변수`)\n- 정적 메서드로 `getInstance()`에서 인스턴스 생성\n\t- 사용자가 인스턴스를 요청할 때마다 만약에 인스턴스가 존재하지 않으면 만들어서 반환하고 존재한다면 인스턴스를 반환\n- 외부에서 인스턴스를 생성할 수 없도록 생성자를 private으로 막음\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n```java\npublic class Settings {\n\tprivate static Settings instance;\n\n\tprivate Settings() {\n\t}\n\n\tpublic static Settings getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Settings();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n하지만, 이와 같은 구현은 ==멀티 스레드 환경에서 싱글턴이 보장되지 않는다. 즉, Thread-safe 하지 않다는 의미이다.==\n\n스레드 A와 B가 동시에 요청을 보낸 상황\n- A가 if문을 통과하여 인스턴스를 생성하기 전에 B도 통과한다고 가정해보자. 그러면 각각 다른 인스턴스가 생길 가능성이 존재한다.\n\n\u003chr\u003e\n\n### 동기화(Synchronized)\n\n- 인스턴스를 private static 변수\n- **synchronized** `getInstance()`\n- 외부 생성자를 private으로 막는다.\n- 문제점 : 리소스 낭비\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e상세 설명 보기\u003c/strong\u003e\u003c/summary\u003e\n\n- 위와 같은 문제를 해결하기 위해 synchronized 키워드를 이용한 동시성 문제 해결\n- 현재 메서드를 사용하고 있는 스레드를 제외하고 나머지 스레드가 메서드에 접근할 수 없도록 막아준다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n```java\npublic class Settings {\n\tprivate static Settings instance;\n\n\tprivate Settings() {\n\t}\n\n\tpublic synchronized static Settings getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Settings();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n하지만, 이와 같은 구현은 ==리소스가 낭비된다==는 단점이 있다. 멀티 스레드 환경에서 인스턴스를 하나만 만들기 위해서 synchronized 키워드를 사용했는데, 인스턴스가 존재하는 경우에는 더이상 필요 없기 때문이다.\n- 괜히, 메서드를 실행할 때마다 Lock이 걸리게 되어 리소스 낭비가 발생\n\n\u003chr\u003e\n\n### DCL\n\nDCL(Double Checked Locking)은 두 번 체크하여 리소스 낭비를 줄여본 버전이다.\n\n- **synchronized 시점 지연**\n- private static **volatile** 인스턴스\n- 외부 생성자를 private으로 막는다.\n- 문제점 : volatile 키워드\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e상세 설명 보기\u003c/strong\u003e\u003c/summary\u003e\n\n- 현재, `getInstance()` 메서드를 호출할 때마다 인스턴스가 있을 때는 synchronized 블록이 스킵되는 것이다. 즉시 인스턴스만 반환하게 되어 리소스 낭비를 없앨 수 있다.\n- 이때, 클래스 변수에 정의해놨던 인스턴스를 `volatile` 키워드를 사용해야 한다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003evolatile 키워드?\u003c/strong\u003e\u003c/summary\u003e\n\n원래, 스레드를 이용하게 되면 각각의 스레드는 성능을 위하여 CPU 레지스터의 캐시 메모리를 사용하게 된다. 첫 번째 스레드 -\u003e 캐시 메모리 -\u003e 메인 메모리 순서로 값을 대입한다면, 다음 스레드는 메인 메모리에 담긴 값을 메인 메모리 -\u003e 캐시 메모리 -\u003e 두 번째 스레드 순서로 가져온다.\n\n문제는, 첫 번째 스레드가 메인 메모리에 값을 넣기 이전인 상황에 두 번째 스레드가 메인 메모리에서 값을 읽으려고 할 때 발생한다. 이때 volatile 키워드를 사용하면 대입과 읽는 것 모두 메인 메모리에서 하도록 만들어서 시간차를 극복할 수 있다.\n\nJava에서 volatile 키워드는 변수의 값을 다른 스레드에서 **변경할 수 있도록** 하며, 클래스를 thread-safe하게 만드는 데 사용된다. 이는 여러 스레드가 동시에 메소드와 클래스 인스턴스를 사용할 수 있게 하고 문제가 발생하지 않도록 한다. volatile 키워드는 기본형 혹은 객체와 함께 사용할 수 있다.\n\nvolatile 키워드는 상호배제(mutual exclusion)를 제공하지 않고도 데이터 변경의 가시성(visibility) 측면을 보장해주므로 매우 유용하다. 다중 스레드가 코드 블록을 병렬로 실행하는 것이 문제가 되지 않지만 가시성 속성을 보장해야 하는 경우에 사용한다. 또한 happens-before ordering을 수행한다.\n\nvolatile 키워드는 두 가지 다른 용도로 사용한다. JVM이 **레지스터(register)에서 값을 읽지 않도록 하고, 값을 메인 메모리에서 읽도록 하여**== 메모리 불일치 오류(memory in-consistency errors)의 위험을 줄인다.== 또한, JVM이 레지스터에서 값을 읽지 않도록 하고, 값을 메모리에서 읽도록 함으로써 ==메모리 일관성 오류(memory consistency errors)를 방지==한다.\n\n정리하자면, Java에서 volatile 키워드는 다중 스레드 환경에서 변수의 가시성을 보장하고, 메모리 일관성 오류를 방지하며, 다중 스레드가 동시에 클래스와 메소드 인스턴스를 사용할 수 있게 하기 위해 사용된다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n```java\npublic class Settings {\n\tprivate static volatile Settings instance;\n\n\tprivate Settings() {\n\t}\n\n\tpublic static Settings getInstance() {\n\t\tif (instance == null) {\n\t\t\tsynchronized (Settings.class) {\n\t\t\t\tif (instance == null) {\n\t\t\t\t\tinstance = new Settings(); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n\u003cbr\u003e\n\n하지만, 이 코드도 완벽하지 않다. 이는 \u003ca href='/brain/Interview/dog-study/dog-week01/' target='_blank'\u003e개발바닥 1주차 면접스터디\u003c/a\u003e의 DLCP 지양에 관한 이야기에서도 다룬 내용이다.\n\n문제점은 volatile 키워드 자체가 JDK 1.5 이상에서만 구현가능하다는 점이 있고, JVM에 따라서 thread-safe 하지 않는 경우가 발생할 수 있다는 것이다. 자바의 메모리 모델이 \"out-of-order-write\"를 지원하기 때문에 메모리에 작성되는 순서를 보장하지 않기도 하다.\n\n\u003chr\u003e\n\n### Bill Pugh Solution\n\n**Bill Pugh Solution (Initialization on demand holder idiom)** : 싱글턴을 구현할 때 권장되어지는 방법 중의 하나이다. 구현 방법은 Holder 역할을 하는 `private static` 클래스를 이용하는 것이다.\n\n- static inner class 인스턴스\n- 생성자를 private\n- 문제점 : 클라이언트가 임의로 싱글턴을 파괴할 수 있다.\n\n```java\npublic class Settings {\n\tprivate Settings() {\n\t}\n\n\tprivate static class SettingsHolder {\n\t\tprivate static final Settings SETTINGS = new Settings();\n\t}\n\n\tpublic static Settings getInstance() {\n\t\treturn SettingsHolder.SETTINGS;\n\t}\n}\n```\n\n먼저, JVM의 ClassLoader에 의해 클래스가 로드될 때 실행하는 `loadClass()` 메서드의 내부를 봐보자.\n\n![](brain/image/dog-week05-1.png)\n\n여기서 보면 내부적으로 `synchronized`가 실행되는 것을 볼 수 있다. 그래서 명시적으로 synchronized를 이용하지 않고 동일한 효과를 낼 수 있다.\n\n왜냐하면, 해당 SettingsHolder 클래스는 static 이므로 메서드가 실행될 때 JVM의 static initializer에 의해 초기화되고 메모리로 올라간다. **따라서, thread-safe와 lazy-loading을 둘 다 만족하는 싱글턴이 구현 가능하다.**\n\n해당 코드의 문제점도 살펴보자. 클라이언트가 임의로 싱글턴을 파괴할 수 있다는 문제가 있다. 리플렉션과 직렬화를 통해 파괴할 수 있다고 한다.\n\n\u003cbr\u003e\n\n### Enum\n\n- enum 자체가 싱글턴이다.\n- 애초에 생성자를 private으로 갖게 만들거고 상수만 갖는 클래스이기 때문에 싱글턴의 성질을 가진다.\n- 리플렉션과 직렬화로 싱글턴을 깰 수도 없음.\n- 문제점 : 싱글턴을 해제할 때 번거러움, Enum 이외 클래스 상속 불가\n\n```java\npublic enum Settings {\n\tINSTANCE;\n}\n```\n\n\u003cbr\u003e\n\n### 권장 방법\n\n1. Bill Pugh 방법\n\t- Lazy Loading\n\t- thread-safe\n\n2. enum\n\t- thread-Safe\n\t- 간편하다\n\n\n\u003cbr\u003e\n\n### 정적 클래스\n\nstatic class : static method만 갖고 있는 클래스를 의미한다. 자바에서는 따로 정적 클래스라는 것이 존재하지는 않는다.\n\n\u003cbr\u003e\n\n```java\npublic class Setting {\n\tprivate Setting() {\n\t}\n\n\t// static 메서드들\n\tpublic static void setMap() {\n\t\n\t}\n}\n```\n\n\u003cbr\u003e\n\n싱글턴과의 공통점\n1. 스레드가 공유하는 메인 메모리쪽에 static이 올라가니까 전역적으로 사용 가능\n2. 인스턴스를 따로 생성하지 않아서 유일성을 보장받을 수 있다.\n\n싱글턴과의 차이점\n1. 인스턴스를 생성할 수 없기 때문에 클래스 메서드를 이용한다는 점\n\n\u003cbr\u003e\n\n**싱글턴 패턴 vs 정적 클래스**\n\n- 싱글턴 패턴\n\t- 상속 받아서 사용할 수 있다.\n\t- 메서드 파라미터로 사용할 수 있다.\n\t- 권장 환경\n\t\t- 완벽한 객체지향을 필요로 할 때 ( = 애플리케이션 내에서 객체처럼 사용하고 싶을 때 )\n\t\t- lazy-loading이 필요할 때 ( = 인스턴스 생성 할 때 리소스가 많이 드는 경우 )\n- 정적 클래스\n\t- 객체처럼 사용할 수는 없지만 컴파일 시 정적바인딩이 되기 때문에 보통 싱글턴보다 효율이 좋다.\n\t- 권장 환경\n\t\t- 유틸 메서드를 보관하는 용도로 사용할 때 ( = 유틸 클래스처럼 객체 성질이 필요 없을 때 사용하는 것을 권장 )\n\t\t- 다형성이나 상속이 필요없는 클래스\n\n\u003cbr\u003e\n\n### Spring 싱글턴\n\n사실, 위에서 언급한 다양한 싱글턴 패턴 구현의 단점들은 Spring 프레임워크를 사용하면서 모든 단점들이 없어지게 된다. 스프링에서 Bean 생성 시 별 다른 설정이 없으면 default로 싱글턴이 적용되는데, 이때 스프링은 컨테이너를 통해 직접 싱글턴 객체를 생성하고 관리한다.\n\n==**객체의 생성을 스프링에 위임함으로써 스프링 컨테이너가 관리하기 때문에 그러하다.**==\n\n스프링에서 DI(Dependency Injection)하는 방법으로 싱글턴 패턴을 적용하였다. \n\n- 싱글턴 : 농사를 하는 경우, 농부가 매번 삽을 만들면 삽을 만드는 것에 대한 리소스 낭비가 심할 것이기 때문에 공용 삽을 1개만 만들어 놓고 이를 돌려가면서 사용\n\n- DI : 농부의 손에 아무것도 쥐게 하지 않고, 손에 쥘 수 있도록 준비만 해놓은 상태에서 대감마님이 농사 도구를 손에 쥐어주는 상황\n\n싱글턴으로 공용 삽을 만들어놓은 상황에 알아서 사용하면 충분하지 않냐고 생각할 수 있다. 하지만, 그렇게 하면 삽을 만드는 시간, 메모리를 절약할 수 있는 장점이 있지만 **의존성이 높아져서 테스트하기 어려운 단점**이 있다.\n\n예를 들어, 공용 삽과 호미 각각 1개를 농부 10명이 돌려쓰는 경우가 있다. 공용 삽과 공용 호미가 땅을 파는(Digging) 기능이 잘 되는지 테스트 해보고 싶은데, 삽이 단 1개, 호미가 단 1개이기 때문에 돌려 가면서 테스트하기 힘들다. 이때, 대감마님이 나서서 너부터 이걸로 테스트 해봐. 다음은 너가 이걸로 테스트 해봐. 교통정리 해주면 해결될 것이다.\n\n농부가 땅파기 기능이 있는 도구를 받을 준비를 한 것이 생성자를 만들어 놓은 상태이다. 그리고 땅파 기 기능이 있는 인터페이스를 만들어놓으면 살과 호미는 땅파기 기능을 구현만 하면 된다. 이후, 대감 마님이 농사 도구를 농부에게 넘겨주는 식으로 하면 해결 !\n\n결과적으로, 스프링에서 싱글턴 패턴을 사용하면서 얻게 되는 장점에는\n- private 생성자가 필요 없어지게 되니까 상속이 가능해진다.\n- 의존성이 높아져서 테스트하기 어려웠던 문제를 해결하여 테스트하기 편해진다.\n- 프레임워크를 통해 1개의 객체 생성을 보장받을 수 있게 된다.\n- static 메서드를 사용하지 않아서 객체지향적으로 개발할 수 있다.\n\n\u003cbr\u003e\n\n## Annotation\n\n==**Annotation(주석) : 코드 사이에 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술이다.**==\n\n- 메타 데이터의 일종\n\t- 애플리케이션이 처리해야 할 데이터가 아니라 컴파일러를 위한 정보를 제공하기 위한 용도\n- 용도\n\t- 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공\n\t- 소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공\n\t- 실행 시(런타임 시) 특정 기능을 실행하도록 정보 제공\n- 동작 순서\n\t- 애노테이션 정의\n\t- 원하는 위치에 배치\n\t- 코드가 실행되는 중 Reflection을 이용하여 추가 정보를 획득하여 기능 실시\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eReflaction 상세보기\u003c/strong\u003e\u003c/summary\u003e\n\n-   Reflection이란 프로그램이 실행 중에 자신의 구조와 동작을 검사하고, 조사하고, 수정하는 것\n-   Reflection을 사용하면 컴파일 타임에 인터페이스, 필드, 메소드의 이름을 알지 못해도 실행 중에 클래스, 인터페이스, 필드 및 메소드에 접근할 수 있다. 또한 새로운 객체의 인스턴스화 및 메소드 호출을 허용한다.\n-   **Annotation 자체는 아무런 동작을 가지지 않는 단순한 표식일 뿐이지만, Reflection을 이용하면 Annotation의 적용 여부와 엘리먼트 값을 읽고 처리할 수 있다.**\n-   **Spring 컨테이너(BeanFactory)에서 객체가 호출되면 객체의 인스턴스를 생성하게 되는데 이 때 필요하게 된다. 즉, 프레임워크에서 유연성있는 동작을 위해 쓰인다.**\n-   Reflection을 이용하면 Annotation 지정만으로도 원하는 클래스를 주입할 수 있다.\n-   Class에 적용된 Annotation 정보를 읽으려면 java.lang.Class를 이용하고  \n    필드, 생성자, 메소드에 적용된 어노테이션 정보를 읽으려면 Class의 메소드를 통해 java.lang.reflect 패키지의 배열을 얻어야 한다.  \n    - Class.forName(), getName(), getModifier(), getFields() getPackage() 등등 여러 메소드로 정보를 얻을 수 있다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### Java Annotation\n\n자바 표준 애노테이션은 자바에서 기본적으로 제공하는 애노테이션이다. 가장 많이 사용하는 4가지 애노테이션은 아래와 같다.\n\n`@Override`\n- 선언한 메서드가 오버라이드 되었다는 것을 나타냄\n- 상위(부모) 클래스(혹은 인터페이스)에서 해당 메서드를 찾을 수 없으면 컴파일 에러 발생\n\n`@Deprecated`\n- 해당 메서드가 더 이상 사용되지 않음을 표시\n- 컴파일러에게 이 메서드는 없어질 것이라는 걸 알려주고 사용하지 말라고 경고하는 것\n\n`@SuppressWarnings`\n- 선언한 곳의 컴파일 경고를 무시\n\n`@FunctionalInterface`\n- Java 8부터 지원, 함수형 인터페이스를 지정\n- 메서드가 존재하지 않거나, 1개 이상의 메서드 (default 메서드 제외)가 존재할 경우 컴파일 오류 발생\n\n### Meta Annotation\n\n사용자가 직접 정의하여 사용하는 Custom Annotation을 만들 때 사용하는 것이 Meta Annotation이며, 프레임워크나 API 등을 만들어서 사용할 때 주로 사용한다. Custom Annotation은`@interface`를 통해 애노테이션 클래스를 작성할 수 있다. 이때 애노테이션은 내부에 값을 가질 수 있고 설정할 수 있는데, 설정하려면 `default 값` 형태로 설정해야 한다.\n\n`@Retention`\n- 애노테이션이 유지되는 기간을 정하기 위해 사용\n\n`@Target`\n- 애노테이션을 정의할 때 적용 대상을 지정할 때 사용\n\n`@Documented`\n- 애노테이션 정보를 javadoc로 작성된 문서에 포함\n\n`@Inherited`\n- 애노테이션이 하위 클래스에 상속되도록 함\n\n`@Repeatable`\n- 애노테이션을 반복해서 적용할 수 있게 함\n\n\u003cbr\u003e\n\n### Spring Annotation\n\n해당 Annotation에 대한 설명은 \u003ca href='https://velog.io/@ruinak_4127/Annotation%EC%9D%B4%EB%9E%80#annotation-%EC%A2%85%EB%A5%98' target='_blank'\u003eSpring Annotation 총정리\u003c/a\u003e에서 몇 가지 가져온 것이다.\n\n-   **@ComponentScan**\n    -   @Component, @Service, @Repository, @Controller, @Configuration이 붙은 클래스 Bean들을 찾아서 Context에 bean을 등록해주는 애노테이션\n    -   전부 다 @Component를 사용하지 않고 @Repository 등으로 분리해서 사용하는 이유는, 예를 들어 @Repository는 DAO에서 발생할 수 있는 unchecked exception들을 스프링의 DataAccessException으로 처리할 수 있기 때문이다.\n    -   또한 가독성에서도 해당 애노테이션을 갖는 클래스가 무엇을 하는지 단 번에 알 수 있다.\n-   **@EnableAutoConfiguration**\n    -   autoConfiguration도 Configuration중 하나에 해당한다.\n    -   spring.factories 내부에 여러 Configuration들이 있고 조건에 따라 Bean이 등록되게 되는데 메인 클래스 @SpringBootApplication을 실행하면 @EnableAutoConfiguration에 의해 spring.factories 안에 있는 수많은 자동 설정들이 조건에 따라 적용되어 수 많은 Bean들이 생성된다.\n    -   간단하게 정리하면, **Application Context를 만들 때 자동으로 빈설정이 되도록 하는 기능이다.**\n-   @Component\n    -   개발자가 직접 작성한 class를 Bean으로 등록하기 위한 애노테이션\n-   @Bean\n    -   개발자가 직접 제어가 불가능한 외부 라이브러리등을 bean으로 만들려할 때 사용되는 애노테이션\n-   @Configuration\n    -   @Configuration을 클래스에 적용하고 @Bean을 해당 class의 메서드에 적용하면 @autowired로 Bean을 부를 수 있다.\n-   @Autowired\n    -   스프링이 Type에 따라 알아서 Bean을 주입해준다.\n    -   Type을 먼저 확인한 후 못 찾으면 Name에 따라 주입한다.\n    -   강제로 주입하고자 하는 경우 @Qulifier을 같이 명시\n-   @Qualifier\n    -   같은 타입의 빈이 두 개 이상 존재하는 경우 스프링이 어떤 빈을 주입해야할 지 알 수 없어서 스프링 컨테이너를 초기화하는 과정에서 예외가 발생한다.\n    -   @Qualifier는 @Autowired와 함께 사용하여 정확히 어떤 bean을 사용할지 지정하여 특정 의존 객체를 주입할 수 있다.\n-   **@Resource**\n    -   **@Autowired와 마찬가지로 Bean 객체를 주입해주는데 차이점은 Autowired는 타입으로, Resource는 이름으로 연결해준다.**\n    -   **애노테이션 사용으로 인해 특정 Framework에 종속적인 애플리케이션을 구성하지 않기 위해서 @Resource 사용을 권장한다.**\n-   @Controller\n    -   API와 view를 동시에 사용하는 경우에 사용\n    -   보통 view 화면 return을 목적으로 사용한다.\n-   @RestController\n    -   view가 필요 없이 API만 지원하는 서비스에서 사용\n-   @SpringBootApplication\n    -   @Configuration, @EnableAutoConfiguration, @ComponentScan 3가지를 하나로 합친 애노테이션\n\n\u003cbr\u003e\n\n## Spring MVC\n\nMVC 패턴은 디자인 패턴이다. 디자인 패턴이란, SW 개발 방법을 공식화 한 것으로 이해하자.\n\n==**MVC 패턴 : Model \u0026 View \u0026 Controller 웹 애플리케이션을 3가지 역할로 구분한 개발 방법론이다. 모듈 간 결합도를 낮추고 응집도를 높이기 위해 사용하는 패턴이다.**==\n\n- Controller : 클라이언트로부터 요청을 받아서 Model, View와 상호작용하며 적절한 응답을 제공하는 중계자의 역할\n- Model : 시스템에서 사용하는 도메인 모델 등을 의미\n- View : 클라이언트에게 제공하는 화면단을 의미\n\n도메인이란 화면, UI, 기술 인프라 등등의 영역을 제외한 **시스템이 구현해야 하는 핵심 비즈니스 업무 영역** 을 말한다. 컨트롤러는 도메인이 아니고, 엔티티와 리포지토리 등이 도메인으로 볼 수 있다.\n\n\u003cbr\u003e\n\n### 모델1\n\nMVC 패턴 이전에는 웹 애플리케이션 아키텍쳐로 모델 1을 주로 사용하였다.\n\n구성\n- JSP + JavaBean(Service)\n- 뷰와 로직이 섞인다.\n- JSP가 흔히 아는 View, JavaBean을 Model이라고 생각하자.\n\n장점\n- 구조가 단순하다.\n\n단점\n- 출력과 로직 코드가 섞여 JSP 코드가 복잡해진다.\n- 프론트엔드와 백엔드가 혼재되어 분업이 용이하지 않다.\n- 유지보수가 어렵다.\n\n\u003cbr\u003e\n\n### 모델2 = MVC패턴\n\n모델1의 단점때문에 나오게 된 모델2이다.\n\n구성\n- JavaBean(Service) + JSP + 서블릿\n- JavaBean이 Model, JSP가 View, 서블릿이 Controller\n\n장점\n- 뷰와 로직의 분리로 모델1에 비해 덜 복잡하다.\n- 분업이 용이하다.\n- 유지보수가 쉽다.\n\n단점\n- 모델1에 비해 습득이 어렵고 작업량이 많다.\n\n\u003cbr\u003e\n\n### MVC 흐름\n\n![](brain/image/dog-week05-3.png)\n\n1. 사용자는 원하는 기능을 처리하기 위한 모든 요청을 Controller에 보냄\n2. Controller는 Model을 사용하고, Model은 알맞은 비즈니스 로직 수행\n3. Controller는 사용자에게 보여줄 View를 선택\n4. 선택된 View는 사용자에게 알맞는 결과 화면을 보여준다. 이때, 사용자에게 보여줄 데이터는 Controller를 통해서 전달받는다.\n\n\u003cbr\u003e\n\n**Model : 값과 기능을 가지고 있는 객체**\n\n\u003cbr\u003e\n\n```java\npublic class Triangle {\n\tprivate static final int SIZE = 3;\n\tprivate static final String NAME = \"삼각형\";\n\tprivate List\u003cPoint\u003e points;\n\n\tTriangle(List\u003cPoint\u003e points) {\n\t\tthis.points = points;\t\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**View : 모델에 포함된 데이터의 시각화**\n\n\u003cbr\u003e\n\n**Controller : 모델 객체로의 데이터 흐름을 제어, 뷰와 모델의 역할을 분리**\n\n\u003cbr\u003e\n\n```java\npublic void run() {\n\ttry {\n\t\tString inputPoints = InputView.inputCoordinates();\n\t\tFigure figure = FigureFactory.create(generatePoints(inputPoints));\n\t\tOutputView.showCoordinatePlane(figure.getXYCoordinates());\n\t\tOutputView.print(figure.getAreaInfo());\n\t} catch (Exception e) {\n\t\tSystem.err.println(e);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### MVC 장점\n\nMVC는 개인용 컴퓨터에서 작동하는 애플리케이션의 개발을 목적으로 만들어진 패턴이지만, WWW(World Wide WEB) 애플리케이션을 사용하기 위한 용도로도 폭넓게 사용되고 있다.\n\n- 각 컴포넌트의 코드 결합도를 낮추기 위해\n- 코드의 재사용성을 높이기 위해\n- 구현자들 간의 커뮤니케이션 효율성을 높이기 위해\n\n\u003cbr\u003e\n\n### MVC 주의 포인트\n\n1. Model에서 View에 접근하거나 View의 역할을 수행해버리는 경우\n\t- 예를 들어, Model에서 toString을 쓰는데 출력 로직을 여기다가 사용해버리는 경우가 있다.\n\n2. View에서 일어나는 \"과한\" 값 검증과 예외 처리\n\t- InputView에서 받은 값을 Presentation Layer에서 체크하지 않고 InputView에 입력 외의 역할을 부여하면 **단일책임원칙에 위반**되어, 추후에 입력 채널이 달라질 경우 유효성 체크 로직도 옮겨가야한다는 문제가 발생할 수 있다.\n\t- 사용자의 권한, 논리적인 값(존재 여부, 일치 여부) 등은 Service Layer에서 체크하면 좋다.\n\t- 값 형식은 유효하지만, 도메인 모델에서 확인해야할 부분들은 생성자에서 체크하는 것이 좋다. (예를 들어, player의 이름은 몇 글자 이상이어야한다 등)\n\t- 생성자에서는 유효성 체크만 하고 다른 로직은 추가하지 않는 것이 좋다.\n\n3. View에서 일어나는 비즈니스 로직\n\t- View에서 Model을 생성한다던가 Model끼리 연산 해버린다던가 등\n\n\u003cbr\u003e\n\n**모범적인 컨트롤러 사용법**\n\n- View들을 컨트롤러가 연결만 하고 있다.\n- 비즈니스 로직은 없음!!\n- 어.. 그런데 여기서도 InputView에서 players와 rewards를 만들어서 사용하기 때문에 뺐으면 어땠을까? 하는 생각이 있다.\n\n\u003cbr\u003e\n\n```java\npublic static void main(String[] args) throws Exception {\n\tPlayers players = InputView.createPlayers();\n\tRewards rewards = InputView.createRewards();\n\n\tLadder ladder = LadderFactory.createLadder(players.countOfPeople(), InputView.get);\n\tOutputView.printLadder(players, ladder, rewards);\n\n\tMatchingResult matchingResult = ladder.play();\n\tLadderResult result = matchingResult.map(players, rewards);\n\n\tOutputView.printResult(result);\n}\n```\n\n\u003cbr\u003e\n\n### 서비스가 커질수록\n\n서비스 규모가 커질수록, 사실 생각대로 MVC를 점점 지키기 힘들어질 것이다. 예를 들어, 쇼핑몰이라고 한다면 게시판에서도 회원 정보를 보여주고, 상품목록 보기에서도 회원 정보를 보여줘야 한다면 회원 정보를 읽어오는 코드는 어떻게 해야할까?\n\nController에서 중복 발생 ! =\u003e 별도의 객체로 분리, 별도의 메서드로 분리\n\n\u003cbr\u003e\n\n### Service\n\n==**Service : 비즈니스 로직(Business Logic)을 수행하는 메서드를 가지고 있는 객체**==\n\n비즈니스 메서드를 별도의 Service 객체에서 구현하도록 하고 컨트롤러는 Service 객체를 사용하도록 한다. 예를 들어, 컨트롤러 1, 컨트롤러 2, 컨트롤러 3이 있다고 하고 회원 Service, 상품 Service, 게시판 Service가 있다고 하면 컨트롤러 1,2,3이 이 서비스들을 막 사용하는 형태로!\n\n서비스는 하나의 트랜잭션을 가지게 된다.\n\n\u003cbr\u003e\n\n**Transaction?**\n\n- 특징으로 ACID를 가진다.\n\t1. 원자성 (Atomicity) : 하나의 원자 트랜잭션은 모두 성공하거나 or 모두 실패한다.\n\t2. 일관성 (Consistency) : 트랜잭션 작업처리 결과가 항상 일관성이 있어야 한다.\n\t3. 독립성 (Isolation) : 어느 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다.\n\t4. 지속성 (Durability) : 트랜잭션이 성공적으로 완료되었을 경우, 결과는 영구적으로 반영되야 한다.\n\n\u003cbr\u003e\n\n### Repository\n\nRepository : DAO(Data Access Object), 데이터 액세스 메서드를 별도의 Repository 객체에서 구현하는 것이다. Service는 Repository 객체를 사용한다.\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eRepository, DAO 차이\u003c/strong\u003e\u003c/summary\u003e\n\nSpring에서 Repository와 DAO의 차이점은 무엇일까?\n\n- DAO(Data Access Object)는 데이터 영속성(persistence)의 추상화이고 Repository는 개체 컬렉션의 추상화이다. (컬렉션은 개별 객체들을 단일 단위로 표현하는 그룹을 의미함. 자바 컬렉션은 검색, 정렬, 삽입, 조작 및 삭제와 같은 모든 데이터 작업을 수행할 수 있음)\n\n- DAO는 데이터베이스(스토리지 시스템)와 더 가까운 저수준 개념이며, 주로 테이블 중심적인 구조를 가지는 반면에 Repository는 도메인(비즈니스 로직)에 더 가까운 상위수준 개념이다.\n\n- DAO는 데이터 매핑/액세스 레이어로 작동하며 못생긴 쿼리를 숨기면서 데이터 소스와의 연결 관리와 데이터 저장소에서 데이터를 가져오고 저장하는 데 필요한 액세스 메커니즘을 구현한다. Repository는 도메인과 데이터 액새스 사이의 레이어로 데이터를 수집하고 도메인 개체를 준비하는 복잡성을 숨긴다.\n\n- DAO는 Repository를 사용하여 구현할 수 없지만 Repository는 스토리지에 접근하기 위해 DAO를 사용할 수 있다.\n\n따라서, Repository와 DAO는 데이터 액세스를 추상화하는 패턴으로 사용되지만, 다른 추상화 계층을 가지며, Repository는 비즈니스 객체를 처리, DAO는 데이터 액세스 메커니즘을 처리하는 역할의 차이가 있다. \n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n## Layered Architecture\n\n==**레이어드 아키텍처 패턴은 소프트웨어 아키텍처의 일반적인 패턴 중 하나이다. 일반적으로 사용자 상호 작용 레이어, 비즈니스 로직 레이어, 데이터 액세스 레이어, 데이터베이스 레이어로 구성된다.**==\n\n레이어드 아키텍처 패턴은 백엔드 API 코드에 가장 널리 적용되는 패턴인데, **코드를 논리적인 부분 혹은 역할에 따라 독립된 모듈로 나누어서 구성하는 패턴**이다.\n\n**레이어드 아키텍처의 핵심 요소**\n- 단방향 의존성 : 각각의 레이어는 오직 자기보다 하위에 있는 레이어에만 의존\n- 각 레이어의 역할이 명확하다\n\n**레이어드 아키텍처의 장점**\n- 핵심 요소로 인하여, 각 레이어가 독립적이고 역할이 분명하다.\n- 이로 인하여, 코드의 확장성이 높아진다.\n- 코드의 구조를 파악하기 쉽고 재사용 가능성이 높아진다.\n- 역할이 명확하여 각 레이어를 테스트하는 테스트 코드의 작성이 수월해짐\n\n**레이어드 아키텍처 주의점 - 싱크홀 안티 패턴**\n- 아키텍처 싱크홀 안티 패턴을 조심하자.\n- 요청이 한 레이어에서 다른 레이어로 이동할 때 각 레이어가 아무 비즈니스 로직도 처리하지 않고 그냥 통과하는 것을 의미한다.\n-  이런 흐름은 불필요한 객체 초기화 및 처리를 빈번하게 유발하고 쓸데없이 메모리를 소모하며 성능에도 부정적인 영향을 준다.\n-  물론 싱크홀 안티패턴이 없을 순 없다. 전체 요청의 20%가 싱크홀인 정도면 그런대로 괜찮은 수준이다.\n\n![](brain/image/dog-week05-2.png)\n\n\u003cbr\u003e\n\n### Presentation Layer\n\nPresentation Layer(User Interface) : 사용자 상호작용 레이어로, 해당 시스템을 사용하는 사용자 혹은 클라이언트 시스템과 직접적으로 연결되는 부분이다. 사용자가 애플리케이션과 상호 작용할 수 있는 스크린, 폼, 메뉴, 리포트 등을 포함한다.\n\n웹 사이트에서는 UI 부분, 백엔드 API에서는 엔드포인트 부분에 해당한다. 그래서 백엔드 API 관점에서 보면, **Presentation layer에서 API의 엔드포인트들을 정의하고 전송된 HTTP request를 읽는 로직을 구현한다. 이 이상의 역할은 담당하지 않고 실제 시스템이 구현하는 비즈니서 로직은 다음 레이어로 넘긴다.**\n\n- EndPoint\n- Authentication (인증)\n- JSON Translation\n\n\u003cbr\u003e\n\n### Business Layer\n\nBusiness Layer(Business Logic) : 애플리케이션의 비즈니스 로직을 처리하는 레이어이다. Presentation layer에서 전송된 요청을 읽어들여 요청에 맞게 동작하는 로직을 구현하면 된다. 예를 들어 회원가입 요청 시 필수적인 요소들이 다 포함되어 있지 않으면 거부한다던가 하는 로직 등이 비즈니스 로직이다.\n\n-   Business Logic\n-   Validation (사용자 중심의 시스템 검증)\n-   Authorisation (권한 부여)\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e영단어 Verification vs Validation\u003c/strong\u003e\u003c/summary\u003e\n\n- **Verificaion**은 개발자 중심의 시스템 검증 과정이며, 무언가를 만드는 **\"과정\"을 잘 지켰는지**를 의미 ( 스펙에 대한 요구사항을 충족했니? )\n- **Validation**은 사용자 중심의 시스템 검증 과정이다. 무언가를 **최종적으로 만든 결과물이 잘 나왔는지**를 말한다. ( 사용자에 대한 요구사랑을 충족했니? )\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### Persistence Layer\n\nPersistence Layer(Data Access)는 데이터베이스와 상호 작용하며 데이터를 검색하고 저장한다. 즉, 데이터베이스와 관련된 로직을 구현하는 부분이다. Business Layer에서 필요한 데이터를 생성, 수정, 읽기 등을 처리하여 실제로 데이터베이스에서 데이터를 저장, 수정, 읽어오기를 하는 역할이다.\n\n- Storage Logic\n\n\u003cbr\u003e\n\n### Spring Layered Architecture\n\nSpring도 레이어드 아키텍터로 구성된다. 레이어는 자신의 고유 역할을 수행하고 인접한 다른 레이어에 무언가를 요청하거나 응답하기 때문에 각 레이어는 자신의 역할에만 충실하면 된다.\n\n**따라서 시스템 전체를 수정하지 않고 특정한 레이어의 기능을 개선하거나 교체할 수 있기 때문에 재사용성이 좋고 유지 보수하기에도 유리하다.  또한, 레이어별로 테스트 구현이 편해지고 코드 가독성도 높아진다.**\n\n![](brain/image/dog-week05-4.png)\n\n\u003cbr\u003e\n\n![](brain/image/dog-week05-5.png)\n\n- Presentation Layer\n\t- Controller가 여기에 속한다. view를 담당하는 부분으로, 클라이언트와 직접적으로 맞닿는 부분이다.\n- Business Layer\n\t- Service가 여기에 속한다. 비즈니스 핵심 로직을 처리하는 부분이기 때문인데, 이때 Service 객체라는 것은 **하나의 트랜잭션**으로 구성되어 작동한다.\n- Persistence Layer\n\t- Repository가 여기에 속한다.\n\n\u003cbr\u003e\n\n### 레이어드 아키텍처 확장\n\n만약, 레이어드 아키텍처를 가지는 서비스가 굉장히 커져서 확장을 해야한다는 상황이 온다고 가정하자. 어떤 고민들을 해볼래?\n\n1. 도메인 주도 설계(DDD)로 멀티모듈화하여 레이어드 아키텍처를 그대로 가져가는 방향\n2. 헥사고날 (이 부분은 추가공부 필요)\n3. MSA는,, 웬만하면 꺼내지는 말고 추가적인 공부는 해놓자.\n\n\u003cbr\u003e\n\n## 참고\n\n- [우테코 10분 테코톡 - 주디의 Spring Bean](https://www.youtube.com/watch?v=3gURJvJw_T4\u0026t=392s)\n- [프로그래머스 데브코스 - Bean의 LifeCycle 정다현](https://www.youtube.com/watch?v=5CBZPb3o0XI)\n- [우테코 10분 테코톡 - 아서의 싱글턴 패턴과 정적 클래스](https://www.youtube.com/watch?v=5oUdqn7WeP0)\n- [Java Annotation](https://bangu4.tistory.com/199)\n- [Custom Annotation](https://ittrue.tistory.com/m/158)\n- [Spring Annotation 총정리](https://velog.io/@ruinak_4127/Annotation%EC%9D%B4%EB%9E%80#annotation-%EC%A2%85%EB%A5%98)\n- [우테코 10분 테코톡 - 해리\u0026션의 MVC 패턴](https://www.youtube.com/watch?v=uoVNJkyXX0I)\n- [소프트웨어 아키텍처 패턴](https://velog.io/@vov3616/MVVM-MVC-MVP-MVI-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%BC%EA%B9%8C)\n- [레이어드 아키텍처 패턴](https://kimjingo.tistory.com/159)\n- [스프링 부트 레이어드 아키텍처](https://www.javatpoint.com/spring-boot-architecture)\n- [싱크홀 안티 패턴](https://velog.io/@gmtmoney2357/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%A0%88%EC%9D%B4%EC%96%B4%EB%93%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98Layered-architecture)\n- [https://www.petrikainulainen.net/software-development/design/understanding-spring-web-application-architecture-the-classic-way](https://www.petrikainulainen.net/software-development/design/understanding-spring-web-application-architecture-the-classic-way)","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/dog-study/dog-week06":{"title":"6주차 - Spring Data","content":"\n\u003chr\u003e\n\n\u003e[!note] 6주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC** \u003cbr\u003e\n\u003e - POJO\n\u003e - DAO\n\u003e - DTO\n\u003e - ORM\n\u003e - 영속성 컨텍스트\n\u001f\n\n\u003cbr\u003e\n\n## POJO\n\n==**POJO(Plain Old Java Object)는 직역하자면 오래된 방식의 간단한 자바 객체라는 의미이다. 이는 특정 기술에 종속되지 않는 순수한 자바 객체를 의미한다.**==\n\n**객체 지향적인 원리에 충실**하면서 **환경과 기술에 종속되지 않고** 필요에 따라 **재활용될 수 있는 방식으로 설계된 오브젝트**를 말하고 POJO에 애플리케이션의 핵심로직과 기능을 담아 설계하고 개발하는 방법을 POJO 프로그래밍이라고 할 수 있다.\n\n예를 들어, ORM(Object Relationship Mapping) 기술을 사용하려면 ORM을 지원하는 프레임워크를 사용해야한다. 만약에 Java 객체가 ORM 기술을 사용하기 위해 Hibernate 프레임워크를 직접 의존하는 순간 POJO라고 할 수 없다. \"특정 기술에 종속되었기 때문\"이다.\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003ePOJO 코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\n아래는 기본적인 자바 기능인 getter, setter를 사용하여, 특정 기술에 종속되어 있지 않은 순수 자바 객체의 예시이다. 아래 객체는 POJO라고 할 수 있다.\n\n```java\npublic class Student {\n\tprivate String name;\n\tprivate String age;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic String getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n}\n```\n\n\u003chr\u003e\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n\u003e 오해하면 안되는게, 클래스를 상속한다던가 인터페이스를 구현한다고 \u003cbr\u003e\n\u003e POJO가 아니라는 의미는 아니다. \u003cbr\u003e\n\u003e 프레임워크나 특정한 기술에 의해 종속적이지 않기만 하면 상관없다. \u003cbr\u003e\n\u003e 자바에서 기본적으로 클래스 상속, 인터페이스 구현을 하는데 질문이 좀 이상하네 ㅋㅋ\n\n\u003cbr\u003e\n\n\u003e [!note] POJO 단어의 등장 배경 \u003cbr\u003e\n\u003e 마틴 파울러가  2000년 가을에 열렸던 어느 컨퍼런스의 발표를 준비하면서 처음 만들어낸 말이다. \u003cbr\u003e\u003cbr\u003e\n\u003e 마틴 파울러는 EJB(Enterprise JavaBean)보다는 단순한 자바 오브젝트에 도메인 로직을 넣어 사용하는 것이 여러가지 장점이 있는데도 왜 사람들이 그 EJB가 아닌 '평범한 자바 오브젝트'를 사용하기를 꺼려 하는지에 대해 의문을 가졌다. \u003cbr\u003e\u003cbr\u003e\n\u003e 그리고 그는 단순한 오브젝트에는 EJB와 같은 그럴듯한 이름이 없어어서 그 사용을 주저하는 것이라고 결론 내렸다. 그래서 만든 단어가 POJO이다.\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eEJB가 뭔데? + 왜 POJO를 지향해야하는가?\u003c/strong\u003e\u003c/summary\u003e\n\nEJB(Enterprise Java Bean)는 기업 환경의 시스템을 구현하기 위한 서버 측 컴포넌트 모델이다. Java 개발에 있어서 로우레벨 개발을 신경쓰지 않고 애플리케이션을 쉽게 만들어준 기술이다.\n\n하지만, EJB의 사용과 프로그램의 규모가 커지면서 특정 기술과 환경에 종속되어 의존성이 높아진 Java 코드는 가독성이 떨어져 유지보수에 어려움이 생겼고, 특정 기술의 클래스를 상속받도록 강제된다는 점이나, 기술에 직접 의존한다는 특징 때문에 확장성이 매우 떨어져 점점 객체지향성을 감소시켰다는 치명적인 단점이 있었다.\n\n즉, POJO를 지원하는 Spring 이전에는 원하는 엔터프라이즈 기술이 있으면 그 기술을 **직접적으로 사용하는 객체를 설계**했다는 의미이다. 객체지향 설계의 장점을 잃어버렸기 때문에 POJO라는 개념이 나오게 되었다. POJO를 지향하는 것은 진정한 객체지향 개발을 위해서이다.\n\n\u003chr\u003e\n\n\u003c/details\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n### POJO 프레임워크\n\n하지만, 단순히 EJB 이전으로 돌아간다는건 아무 의미가 없다. 로우레벨 개발을 다시 신경써야 한다는 의미이기 때문이다. 그래서 POJO의 장점과 EJB에서 제공하는 엔터프라이즈 서비스와 기술을 사용할 수 있도록 도와주는 것이 **POJO 프레임워크**이다. 대표적인 POJO 프레임워크에는 Spring과 Hibernate가 있다.\n\n\u003e 엔터프라이즈 시스템(Enterprise System)은 단어 그대로 기업 시스템을 의미한다. 기업의 업무 프로세스를 자동화하고 관리하기 위한 소프트웨어 시스템이다.\n\n\u003cbr\u003e\n\n==**Spring은 POJO를 지원하는 대표적인 프레임워크이다.**==\n- Spring은 엔터프라이즈 서비스들을 POJO 기반으로 만든 비즈니스 오브젝트에서 사용할 수 있게 해준다.\n- POJO를 지원하기에 스프링 컨테이너에 저장되는 자바 객체는 특정한 인터페이스를 구현하거나 클래스를 상속받지 않아도 된다.\n- POJO 기반의 구성으로 기존에 작성한 자바 코드를 수정할 필요 없고, 객체를 구성하는 방식 그대로 스프링에서 사용할 수 있다. 이때문에 높은 생산성을 가진다.\n- Java에서 제공하는 API 이외에는 종속되지 않기에 간편하고 유연한 테스트가 가능하다.\n- 도메인과 비즈니스 로직을 수행하는 **대상**이 **POJO 대상**이 될 수 있다.\n\n\u003e 도메인(domain)은 화면, UI, 기술, 인프라 등의 영역을 제외한 **시스템이 구현해야하는 핵심 비즈니스 업무 영역**을 의미한다. 컨트롤러는 도메인이 아니고, 엔티티와 리포지토리 등을 도메인으로 볼 수 있다.\n\n![](brain/image/dog-week06-1.png)\n\n이렇게, Spring에서 POJO는 핵심이라고 볼 수 있다. 스프링의 주요기술인 IoC/DI, AOP, PSA는 애플리케이션을 POJO로 개발 가능하게 해준다.\n\n\u003cbr\u003e\n\n==**Hibernate는 대표적인 POJO 프레임워크이다.**==\n- 영속성(Persistence) 기술과 오브젝트-관계형 DB 매핑을 순수한 POJO를 이용해서 사용할 수 있게 해주는 POJO기반의 Persistence Framework이다.\n- JDBC API를 직접 사용해 개발하는 것 못지 않은 퍼포먼스를 보여주고 복잡한 퍼시스턴스 로직을 개발 가능하게 해준다.\n- 하이버네이트가 사용하는 POJO 엔티티들은 객체지향적인 설계와 구현이 가능하다.\n\n\u003cbr\u003e\n\n### POJO의 조건\n\n특정 기술규약과 환경에 종속되지 않으면 모두 POJO라고 말할 수 있을까? 그렇지 않다. ==**진정한 POJO는**== 위에서 말한것처럼 ==**객체 지향적인 원리에 충실하면서 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트**==를 의미한다.\n\n1. 특정 규약에 종속되지 않는다.\n\t- Java와 꼭 필요한 API 이외에는 종속되면 안된다.\n\t- 예를 들어, EJB와 같이 특정 규약을 따라 만들게 하는 경우에 대부분 규약에서 제시하는 **특정한 클래스를 상속하도록 요구한다.**\n\t- 자바는 다중 상속이 불가능해서 객체지향 설계 기법에 문제가 생기게 된다.\n\n2. 특정 환경에 종속되지 않는다.\n\t- 특정 기업의 프레임워크나 서버에서만 동작 가능한 코드는 POJO라고 할 수 없다. POJO는 환경에 독립적이어야 한다.\n\t- 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경 정보, 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안된다.\n\t- 예를 들어, 비즈니스 로직을 담은 코드에 HTTPServletRequest, HttpSession, 캐시와 관련된 API가 등장한다면 진정한 POJO라고 할 수 없다.\n\n3. 객체지향적 원리에 충실한다.\n\t- 책임과 역할이 다른 코드를 몰아넣어 덩치가 큰 만능 클래스를 만들고 상속과 다형성을 적용하지 않고 if문, switch문이 가득한 설계 오브젝트라면 POJO라고 하기 어렵다.\n\n\u003cbr\u003e\n\n### POJO의 장점\n\n- 깔끔한 코드 작성 가능\n- Java에서 제공하는 API 이외에는 종속되지 않기에 간편하고 유연한 테스트 가능\n- 객체지향적 설계를 자유롭게 이용\n\t- 객체지향 프로그램은 엔터프라이즈 시스템에서와 같이 복잡한 도메인을 가진 곳에서 가장 효과적으로 사용될 수 있다.\n\n\u003cbr\u003e\n\n### PSA와 JPA\n\n그런데 위에서 Java 객체가 ORM 기술을 사용하기 위해 Hibernate 프레임워크를 직접 의존하는 순간 POJO가 아니라고 했으면서, Spring은 어떻게 POJO를 유지하면서 Hibernate를 사용할까? 이는 Spring에서 정한 표준 인터페이스가 있기 때문이다.\n\nORM을 사용하기 위해 JPA(Java Persistence API)라는 표준 인터페이스를 정의해뒀고, ORM 프레임워크들은 JPA의 구현체가 되어 실행된다. 이것이 새로운 엔터프라이즈 기술을 도입하면서도 POJO를 유지하는 방법이고 이런 방법을 PSA라고 한다.\n\n==**PSA(Portable Service Abstraction)란 환경과 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 해주는 것을 의미한다.**== PSA가 적용된 대표적인 예시는 JDBC, JPA, Transaction Manager가 있다.\n\n좀 어렵게 표현하면, ==**추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공하는 것을 서비스 추상화(Service Abstraction)**==이라고 하는데 DB에 접근하는 여러가지 방법 중, 기본적으로 JDBC를 통해 접근할 수도 있고 ORM을 이용하려고 JPA를 통해서 접근할 수도 있고 어떠한 경우에도 `@Transactional` 애노테이션을 이용하여 트랜잭션을 유지하는 기능을 추가할 수도 있다. 이렇게 ==**하나의 추상화로 여러 서비스를 묶어둔 것을 Spring에서 PSA**==라고 한다.\n\n\u003chr\u003e\n\n## DAO\n\n==**DAO(Data Access Object)는 실제로 DB에 접근하는 객체를 의미한다. DAO는 데이터에 접근하도록 DB 접근 관련 로직을 모아둔 객체이다.**==  DAO 사용 목적으로는, 데이터베이스에 접근하기 위한 로직과 비즈니스 로직을 분리하기 위하여 사용된다.\n\n- 실제로 DB에 접근하여 데이터를 조회, 삽입, 삭제, 수정 등 CRUD 기능을 수행\n- Service 모델과 DB를 연결\n\n\u003cbr\u003e\n\n### DAO vs Repository\n\n사실 DAO와 Repository는 거의 같다고 생각해도 무방하지만, 엄밀히 말하면 조금은 다르다. \n\n- ==**Dao : 데이터에 접근하도록 DB 접근 관련 로직을 모아둔 객체**==\n- ==**Repository : 도메인(Entity) 객체를 보관하고 관리하는 저장소**==\n\t- 구현보다는 도메인 객체를 관리하는 역할에 초점이 맞춰짐\n\n\u003e 도메인(Entity) 객체는 비즈니스 로직을 캡슐화한 객체이다.\n\n\u003cbr\u003e\n\nSQL을 직접 다룰 때는 쿼리 중심이고 도메인 객체라는 것이 명확하게 없지만, JPA를 사용하면 아무래도 도메인 객체를 정하고(보통 엔티티로) 해당 도메인 객체들을 관리하기 때문에 Repository라는 단어가 더 맞다고 생각한다고 김영한 강사님은 설명하셨다.\n\n다만 MyBatis 같은 프레임워크를 사용하면 풀을 제공하기 때문에 DAO를 별도로 만드는 경우는 드물다. (JPA에서의 Repository의 기능과 동일한 역할을 수행한다고 볼 수 있겠다.)\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e커넥션 풀이란?\u003c/strong\u003e\u003c/summary\u003e\n\n애플리케이션이 데이터베이스를 사용하기 위해서는 커넥션을 맺어야 한다. 커넥션을 생성하고 소멸시키는 비용이 크기 때문에 커넥션 풀을 세팅해두고(기본 10) 애플리케이션이 시작하는 시점에 커넥션을 미리 다 만들어 놓고 이를 재활용하면서 사용한다. 스프링 부트 2.0부터는 hikariCP를 기본 커넥션 풀로 사용한다.\n\n\u003chr\u003e\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\nSpring에서 Repository와 DAO의 차이점에 대해서 \u003ca href='https://www.baeldung.com/java-dao-vs-repository' target='_blank'\u003ebaeldung 사이트\u003c/a\u003e에서는 이렇게 소개한다.\n\n- DAO\n\t- 데이터 영속성(persistence)의 추상화\n\t- 데이터베이스(스토리지 시스템)와 더 가까운 저수준 개념, 주로 테이블 중심적인 구조를 가짐\n\t- 데이터 매핑/액세스 레이어로 작동하며 못생긴 쿼리를 숨기면서 데이터 소스와의 연결 관리와 데이터 저장소에서 데이터를 가져오고 저장하는 데 필요한 액세스 메커니즘을 구현\n\t- DAO는 Repository를 사용하여 구현할 수 없음\n- Repository\n\t- 개체 컬렉션의 추상화 (컬렉션은 개별 객체들을 단일 단위로 표현하는 그룹을 의미함. 자바 컬렉션은 검색, 정렬, 삽입, 조작 및 삭제와 같은 모든 데이터 작업을 수행할 수 있음)\n\t- 도메인(비즈니스 로직)에 더 가까운 상위수준 개념\n\t- 도메인과 데이터 액세스 사이의 레이어로 데이터를 수집하고 도메인 개체를 준비하는 복잡성을 숨김\n\t- Repository는 스토리지에 접근하기 위해 DAO를 사용할 수 있음\n\n따라서, Repository와 DAO는 데이터 액세스를 추상화하는 패턴으로 사용되지만, 다른 추상화 계층을 가지며, Repository는 비즈니스 객체를 처리, DAO는 데이터 액세스(접근) 메커니즘을 처리하는 역할의 차이가 있다. \n\n\u003chr\u003e\n\n## DTO\n\n==**DTO(Data Transfer Object)는 계층 간(Controller, View, Business Layer(Model)) 데이터 교환을 위한 객체이다.**==\n- 로직을 가지지 않고 Getter, Setter메서드만 가진 클래스이다. 단지 계층간 데이터 교환이 이루어질 수 있도록 하는 객체라서 특별한 로직을 가지지않고 순수한 데이터 객체여야 한다.\n\t- 보내는 쪽에서 setter를 사용해 데이터를 DTO에 담아보내고 받는 쪽에서 getter를 사용해 전달받은 DTO로부터 데이터를 꺼내는 방식\n- DB에서 꺼낸 데이터를 저장하는 Entity를 이용하여 만드는 일종의 Wrapper Class\n- Entity를 계층에 직접 전달하지 않고 DTO를 이용해 데이터를 교환하는 것\n\n\u003cbr\u003e\n\n### VO\n\n==**VO(Value Object)는 DTO와 달리 Read-Only 속성을 지닌 값 오브젝트이다. 값 그 자체를 의미한다.**==\n- VO는 값 자체를 표현하기 때문에 불변객체여야 한다.\n- 따라서, setter 메서드를 포함하면 안되고 생성자를 통해서만 값을 초기화해야한다.\n- DTO와는 달리 로직이 있는 메서드 사용 가능\n- 완전한 VO를 위해 객체를 속성값들로만 비교하도록 `hashCode()`, `equals()`를 모두 오버라이딩 해줘야한다.\n\n\u003cbr\u003e\n\n예를 들어, Hash 이름을 가지는 컬렉션 프레임워크들인 HashSet, HashMap, HashTable은 두 객체가 동등한지 비교할 때 `hashCode() 리턴값`을 먼저 비교하고 같으면 `equals() 리턴값`을 비교한다. 즉, `hashCode()`, `equals()` 과정을 모두 거쳐야 비로소 동등한 객체인 것이다.\n\n\u003cbr\u003e\n\n|             | DTO                                         | VO                                      |\n| ----------- | ------------------------------------------- | --------------------------------------- |\n| 용도        | 레이어 간 데이터 전달                       | 값 자체 표현                            |\n| 동등 결정   | 속성 값이 모두 같다고 하여 같은 객체가 아님 | 속성 값이 모두 같으면 같은 객체         |\n| 가변/불변 | setter 존재 시 가변, setter 없으면 불변     | 불변                                    |\n| 로직        | getter, setter 이외의 로직 없음             | getter, setter 이외의 로직 가질 수 있음 | \n\n\u003cbr\u003e\n\n### DTO setter 지양?\n\n많은 블로그에서 \"DB에서 꺼낸 값을 DTO에서 임의로 조작할 필요가 없기 때문에 DTO에는 Setter를 만들 필요가 없고 생성자에서 값을 할당한다. 개인적으로는 생성자 또한 사용하지 않고 Entity처럼 Builder 패턴을 통해 값을 할당하는 것이 가장 좋은 것 같다.\"와 같이 설명하는데, 이 부분에서 의문점이 들었다.\n\n어차피 Entity에 빌더 패턴을 적용하고 이를 Wrapper한 것이 DTO라면 굳이 DTO에 또 빌더패턴을 적용해야하나? 싶었다.\n\n\u003ca href='https://www.inflearn.com/questions/161417/dto-%EC%82%AC%EC%9A%A9%EC%97%90%EB%8C%80%ED%95%B4-%EA%B6%81%EA%B8%88%ED%95%A9%EB%8B%88%EB%8B%A4' target='_blank'\u003e김영한님의 답변\u003c/a\u003e에서도 설명하지만 ==**Entity는 비즈니스 로직이 있고, 실제 데이터도 변경되기 때문에 Setter를 최대한 사용하지 않는 편이 좋다고 하시지만 DTO는 목적 자체가 어떤 로직이 있다기 보다는 단순히 데이터를 전달하는 것이기 때문에 getter, setter를 자유롭게 사용해도 된다고 하셨다.**==\n\n\u003cbr\u003e \n\n그런데 또, 테코톡 영상을 보면 DTO에서 setter 메서드를 삭제하고 생성자를 통해 속성 값들을 초기화하게 만들어 불변객체로 만들면 DTO가 전달하는 데이터가 전달 과정 중에 변조되지 않음을 보장할 수 있어서 좋다. 데이터 불변성을 보장할 수 있다는 의미이다.\n\n\u003chr\u003e\n\n## Persistence\n\n==**Persistence는 영속성이라는 뜻으로, 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성을 의미한다.**== 프로그램이 종료되더라도 같은 상태를 가지는 객체로 만들어내기 위하여 객체의 상태를 데이터베이스에 저장하는데, 이를 객체에게 영속성을 부여했다고 한다.\n\n그렇다면 영속성을 부여하는 방법은 어떤 방법이 있을까? Persistence Layer를 어떻게 구현하느냐에 따라 JDBC, SQL Mapper, ORM 3가지 관점으로 비교할 수 있다. JDBC만을 이용하는 방법과 Persistence Framework를 이용하는 방법 2가지로 나눌 수도 있다.\n\n\u003cbr\u003e\n\n### JDBC\n\n==**JDBC(Java Database Connectivity)는 Java에서 DB에 접속할 수 있도록 해주는 자바 API이다.**==\n- 자바 애플리케이션에서 DBMS에 종속적이지 않고 하나의 JDBC API를 이용해서 DB작업 처리\n- JDBC 인터페이스를 구현한 각각의 DBMS 드라이버만 갈아끼우면 어느 DB에서든 접근 가능\n\n보통 JDBC를 사용할 때 방법은 아래와 같다.\n1. DriveManager : 이용하여 드라이버를 로드\n2. Connection : DB와 연결하는 통로 역할을 할 Connection 객체 생성\n3. Statement : Statement 객체를 생성하고 이를 통해 쿼리문 생성 및 실행\n4. ResultSet : SQL문 결과물을 ResultSet 객체로 얻음\n5. 열었던 순서 반대로 자원을 해제\n\n단순히 JDBC만을 이용하여 영속성을 부여하면 아래와 같은 단점들이 있다.\n- 간단한 SQL을 실행하는데도 중복된 코드 반복적 사용\n- DB에 따라 일관성 없는 정보를 가진 채로 Checked Exception(SQLException) 처리\n- Connection과 같은 공유 자원을 제대로 릴리즈(반환)하지 않으면 시스템의 자원이 바닥나는 버그 발생\n\n\u003cbr\u003e\n\n### Persistence Framework\n\nJDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발하게 해주는 것이 Persistence Framework이다. 모든 Persistence Framework는 내부적으로 JDBC API를 이용하며, 이를 SQL Mapper와 ORM으로 나눌 수 있다.\n\n\u003cbr\u003e\n\n### SQL Mapper\n\n==**SQL Mapper : Java Persistence Frame 중 하나이며, 객체(Object)와 SQL 문을 매핑하여 데이터를 객체화하는 것**==\n- 주의! 객체와 관계를 매핑하는 것이 아니라 직접 작성한 SQL문의 쿼리 결과와 객체의 필드를 매핑하여 데이터를 객체화하는 것이다.\n\nSpring JDBC Template이 SQL Mapper 기능을 제공하는데, 이를 사용함으로써 쿼리 수행 결과와 객체의 필드를 매핑하여 반환 받을 수 있고 RowMapper를 재활용 할 수도 있었다. 또, JDBC에서 반복되는 많은 작업들을 대신해줘서 실행할 SQL과 바인딩 할 파라미터를 넘겨주거나 쿼리 실행 결과를 어떤 객체에 넘겨받을 지만 지정하면 된다.\n\n\u003cbr\u003e\n\nSQL Mapper에 속하는 대표적인 프레임워크로 MyBatis가 있다.\n\n==**MyBatis : 반복적인 JDBC 프로그래밍을 단순화하며 SQL 쿼리들을 XML 파일에 작성하여 코드와 SQL을 분리하여 관리하는 프레임워크이다.**==\n- JDBC만 사용하면 결과를 가져와서 객체의 인스턴스에 매핑하기 위한 많은 코드가 필요하겠지만 마이바티스는 그 코드들을 작성하지 않아도 되게 해준다.\n- DB에 접근하기 위해 특별한 작업없이 Mapper 인터페이스와 Mapping FIle만 구현하면 자연스럽게 객체의 필드와 SQL문이 매핑된다.\n\n\n\n\u003chr\u003e\n\n## Entity\n\n위에서 JPA를 사용하는 경우 도메인 객체를 Entity로 설정한다고 했는데 ==**Entity가 뭘까? 간단하게 설명하면 테이블과 매칭되는 개념으로 ORM을 이루는 기반 개념 중 하나이다. 객체와 RDB 간 연결시켜주는 존재이다.**==\n\n\u003cbr\u003e\n\n==**Entity 클래스는 DB의 테이블에 존재하는 Column들을 필드로 가지는 객체를 말한다.**==\n- Entity는 DB의 테이블과 1:1로 매핑된다. \n\t- 따라서 테이블이 가지지 않는 컬럼을 필드로 가져서는 안된다. \n- Entity 클래스는 다른 클래스를 상속받거나 인터페이스의 구현체여서는 안된다.\n- Entity 클래스에서는 도메인 로직만을 가지고 있어야하고 서비스 로직은 가지고 있으면 안된다. 여기서, 도메인 로직이란 도메인 데이터를 조작하는 `update()`와 같은 로직을 의미한다.\n- JPA를 사용할 때 Entity 클래스에는 `@Entity` 애노테이션을 붙여 Entity임을 명시해줘야 하며, 내부의 필드에는 `@Column`, `@Id` 애노테이션 등을 사용한다.\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eEntity 클래스 사용 예시 코드\u003c/strong\u003e\u003c/summary\u003e\n\n\u003ca href='https://velog.io/@maketheworldwise/DAO-DTO-VO-ENTITY' target='_blank'\u003e코드 출처\u003c/a\u003e\n\n```java\n@Entity\n@Getter\n@AllArgsConstructor\n@NoArgsConstructor\n@EqualsAndHashCode\n@ToString\npublic class User implements Serializable {\n    private static final long serialVersionUID = 7342736640368461848L;\n\t\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @JsonProperty\n    private Long id;\n    \n    @Column(nullable = false)\n    @JsonProperty\n    private String email;\n    \n    @Column(nullable = false)\n    @JsonProperty\n    private String password;\n    \n    public User updatePassword(String password) {\n    \tthis.password = password;\n    \treturn this;\n    }\n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### Setter 지양, Builder 패턴\n\n**Entity에서 Setter를 지양하는 이유**\n- Setter의 사용이 Entity의 일관성을 해칠 수 있기 때문\n- Setter를 무분별하게 사용하면 Entity의 인스턴스 값들이 언제 어디서 변하는지 명확히 알 수 없음\n- Setter 대신 다른 방법으로 필드에 값을 넣어주는 것이 좋다.\n\t- 이때, 일반적으로 생각할 수 있는 인스턴스의 생성 시점에 생성자로 필드에 값을 넣어주는 방법 또한 좋지 않다. 생성자에 현재 넣는 값이 어떤 필드인지 명확히 알 수 없고, 파라미터끼리 순서가 바뀌더라도 코드가 모두 실행되기 전까지 문제를 알 수 없다는 단점이 있기 때문\n\t- ==**Builder 패턴을 사용하는 것이 가장 좋음**==\n\n\u003cbr\u003e\n\n**Entity에서 Setter를 안쓰고 필드에 값을 넣는 방법으로 Builder를 추천하는 이유**\n- 멤버 변수가 많아지더라도 어떤 값을 어떤 필드에 넣는지 코드를 통해 확인 가능\n- 필요한 값만 집어넣는 것이 가능\n\n\u003cbr\u003e\n\n### Builder 패턴이란?\n\n==**Builder 패턴은 GoF(Gang of Four)의 23개 디자인패턴 중 생성 패턴에 해당하는 것으로, 복잡한 객체들을 단계별로 생성할 수 있도록 도와주는 패턴이다.**==\n- 복잡한 객체를 생성하는 클래스와 표현하는 클래스를 분리하여, 동일한 프로세스를 통해서도 서로 다른 표현을 생성하는 방법을 제공\n- 생성해야하는 객체가 Optional한 속성을 많이 가질 때 더 좋음\n- 인자들이 최소 4개 이상으로 많은 경우에 더 좋음\n- 앞으로 추가될 인자들이 많은 경우에 더 좋음\n\n빌더 패턴은 객체를 생성할 때 **생성자(Constructor)만 사용할 때 발생할 수 있는 문제를 개선하기 위해서 고안**되었다.\n- 가독성이 좋아진다.\n- 휴먼에러를 줄일 수 있다.\n- 확장에 용이해진다. (원래라면 null값을 일일이 넣어줘야 했음)\n\n\u003cbr\u003e\n\n```java\n// 생성자 패턴으로 생성했을 때\n// 28, 1, 5000이 어떤 인자인지 알기 힘듦\nMember member = new Member(\"신재윤\", 28, 1, 5000);\n\n// 빌더 패턴으로 생성했을 때\nMember member = Member.builder()\n\t\t\t\t\t\t\t.name(\"신재윤\")\n\t\t\t\t\t\t\t.age(28)\n\t\t\t\t\t\t\t.experience(1)\n\t\t\t\t\t\t\t.salary(5000)\n\t\t\t\t\t\t\t.build();\n```\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eBuilder 패턴 사용 예시 코드\u003c/strong\u003e\u003c/summary\u003e\n\n\u003ca href='https://velog.io/@ohzzi/Entity-DAO-DTO%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C' target='_blank'\u003e코드 출처\u003c/a\u003e\n\n```java\n@Getter\n@Entity\n@NoArgsConstructor\npublic class Membmer member {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private long id;\n    private String name;\n    private String email;\n    @Column(length = 13, nullable = false)\n    private String phoneNumber;\n \n    @Builder\n    public Member(long id, String name, String email, String phoneNumber) {\n        this.id = id;\n        this.name = name;\n        this.email = email;\n        this.phoneNumber = phoneNumber;\n    }\n}\n\n// 사용 방법\nMember member = new member.builder()\n        .name(\"신재윤\")\n        .email(\"wlwhsvkdlxh@gmail.com\")\n        .phoneNumber(\"010-1234-5678\")\n        .build();\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### Entity와 DTO를 분리하는 이유\n\nEntity의 값이 변하면 Repository 클래스의 Entity Manager의 flush가 호출될 때 DB에 값이 반영되고, 이는 다른 로직들에도 영향을 미친다. 때문에 View와 통신하면서 필연적으로 데이터의 변경이 많은 DTO 클래스를 분리해주어야 한다. \n\n또한 도메인 설계가 아무리 잘 되었다 해도 Getter만을 이용해서 원하는 데이터를 표시하기 어려운 경우가 발생할 수 있는데, 이 경우에 Entity와 DTO가 분리되어 있지 않다면 Entity 안에 Presentation을 위한 필드나 로직이 추가되게 되어 객체 설계를 망가뜨리게 된다. 때문에 이런 경우에는 분리한 DTO에 Presentation 로직 정도를 추가해서 사용하고, Entity에는 추가하지 않아서 도메인 모델링을 깨뜨리지 않는다.\n\n\u003cbr\u003e\n\n**Entity 클래스**\n- 절대로 요청이나 응답 값을 전달하는 클래스로 사용하면 안됨\n- 데이터베이스와 매핑되어 있는 핵심 클래스이기 때문\n- 엔티티 클래스를 기준으로 테이블이 생성되고 스키마가 변경됨\n\n예를 들어, View는 비즈니스 요구사항에서 자주변경되는 부분인데, 만약에 Entity 클래스를 요청이나 응답 값을 전달하는 클래스로 사용한다면 뷰가 변경될 때마다 Entity 클래스를 그에 맞춰서 매번 변경해야할 것이다.\n\n수많은 Service 클래스나 비즈니스 로직들이 Entity 클래스를 기준으로 동작하는데 Entity 클래스를 변경하면 관련되어 얽혀있는 무수히 많은 클래스들에 영향을 끼친다.\n\n따라서, View 변경에 따라 다른 클래스들에게 영향을 끼치지 않고 자유롭게 변경할 수 있는 DTO를 사용해야한다. 또한, 응답 값으로 여러 테이블을 조인한 결과값을 줘야할 경우가 빈번해서 Entity 클래스만으로는 응답값을 표현하기 어려운 경우가 많다.\n\n\u003cbr\u003e\n\n### EntityManager\n\nEntityManager는 엔티티를 관리하는 역할을 한다.\n- 엔티티 매니저\n\n\u003cbr\u003e\n\n## 참고\n\n- \u003ca href='https://doing7.tistory.com/81' target='_blank'\u003eSpring POJO란?\u003c/a\u003e\n- \u003ca href='https://blog.naver.com/sillllver/220593543939' target='_blank'\u003eSpring \u0026 EJB 비교\u003c/a\u003e\n- \u003ca href='https://dev-coco.tistory.com/82' target='_blank'\u003edev-coco POJO 정리\u003c/a\u003e\n- \u003ca href='https://sabarada.tistory.com/127' target='_blank'\u003esabarada님의 PSA\u003c/a\u003e\n- \u003ca href='https://velog.io/@ohzzi/Entity-DAO-DTO%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C' target='_blank'\u003eohzzi님의 Entity, Dao, DTO가 무엇이며 왜 사용할까\u003c/a\u003e\n- \u003ca href='https://www.youtube.com/watch?v=z5fUkck_RZM' target='_blank'\u003e테코톡 인비의 DTO vs VO\u003c/a\u003e\n- \u003ca href='https://dev-youngjun.tistory.com/197' target='_blank'\u003edev-youngjun님의 빌더 패턴 포스팅\u003c/a\u003e\n- \u003ca href='https://www.inflearn.com/questions/111159/domain%EA%B3%BC-repository-%EC%A7%88%EB%AC%B8' target='_blank'\u003e김영한님 질의응답\u003c/a\u003e","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/dog-study/dog-week07":{"title":"7주차 - Spring 트랜잭션","content":"\n\u003e[!note] 7주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC** \u003cbr\u003e\n\u003e - DataSource\n\u003e - Connection Pool\n\u003e - 데이터베이스 트랜잭션\n\u003e - 트랜잭션 동기화\n\u003e - 트랜잭션 추상화\n\u003e - Spring 트랜잭션\n\n\n\u003cbr\u003e\n\n\n## DataSource\n\n![](brain/image/dog-week07-4.png)\n\n==**DataSource는 물리적인 데이터베이스에 연결하기 위한 팩토리이다.**== \n- DataSource 인터페이스는 JDBC API에 있고, DataSource가 DB에 연결하기 위해 드라이버이름/아이디/비밀번호/URL을 사용한다. \n- 커넥션 관련 기술은 다양하여 코드가 다 다르기 때문에, **커넥션을 획득하는 역할을 추상화**시킨   DataSource가 등장한 것이다.\n- 실질적인 커넥션 로직은 DataSource에 의존하도록 하면 구현 기술이 바뀔때마다 DataSource의 구현체만 바꾸면 되기 때문이다.\n\n다양한 커넥션 관련 기술은 아래와 같다.\n- DriverManager : DriverManager 클래스는 `Class.forName()` 메서드를 통해서 생성되는데, 인터페이스 드라이버를 구현하는 작업을 한다. 특정 클래스를 로딩하면 자동으로 객체가 생성되고 DriverManager에 등록된다. **특징적으로는 사용자가 요청할 때마다 드라이버를 로드하고 커넥션 객체를 생성하여 연결하고 종료한다는 점이다. 또, 따로 DataSource를 구현하지 않기 때문에 Spring에서 DriverManagerDataSource라는 구현 클래스를 제공한다.**\n\t- 매번 커넥션을 생성하기 때문에 전체적인 리소스 낭비가 심하다.\n\t- 이 단점을 보완하기 위한 것이 커넥션 풀, DBCP(DataBase Connection Pool)이다.\n- Connection Pool 이용 (아래에서 설명)\n\n\u003chr\u003e\n\n## Connection Pool\n\n==**DataBase Connection Pool(DBCP, 커넥션 풀)은 웹 컨테이너(WAS)가 실행되면서 일정량의 Connection 객체를 미리 만들어서 pool에 저장했다가 클라이언트 요청이 오면 Connection 객체를 빌려주고 해당 객체의 임무가 끝나면 다시 Connection 객체를 반납 받아서 pool에 저장하는 방법이다.**==\n\n요청이 적은 경우에는 상관없지만, 요청이 많은 경우 매번 커넥션을 생성하는 것은 리소스 낭비가 심해서 나오게 된 방법이다. 대표적인 커넥션 풀의 시로는 아래와 같다.\n\n- commons-dbcp\n\t- 아파치에서 제공하는 라이브러리\n- tomcat-jdbc-pool\n\t- tomcat에 내장되어 있고 Apache Commons DBCP 라이브러리를 바탕으로 만들어져있다.\n\t- Spring Boot 2.0.0 하위 버전의 default DBCP이다.\n- HikariCP\n\t- ==**Spring Boot 2.0.0 부터 default JDBC Connection Pool이다.**==\n\t- Connection Pool을 제공하는 JDBC DataSource의 구현체이다.\n\t- tomcat-jdbc-pool과 비교해 벤치마크 성능이 잘 나온다.\n\t\t- 이는 zero-overhead의 특징 때문이다.\n\t\t- overhead : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 및 메모리\n\n\u003cbr\u003e\n\n### DBCP의 과정\n\n1. WAS가 실행되면서 Pool 내에 Connection 객체들을 미리 생성해둔다. (default : 10)\n2. HTTP의 요청이 올 때 Pool 내에서 Connection 객체를 가져가서 사용\n3. 사용이 완료된 Connection 객체는 Pool 내에 반환\n\n\u003cbr\u003e\n\n스프링부트 2.0 이후의 default Connection Pool인 HikariCP의 동작 원리도 살펴보자.\n\n1. Thread가 Connection을 요청하면 Connection Pool이 유휴 Connection 객체를 찾아서 반환한다. HikariCP는 이전에 사용했던 Connection이 존재하는지 확인하고 이를 우선적으로 반환하는 특징이 있다.\n\t1. Connection 요청 들어옴\n\t2. Connection pool이 이전 사용했던 Connection이 존재하는지 확인\n\t3. 이전 사용했던 Connection 목록 중 사용 가능한 Connection 존재하는지 확인\n\t4. 전체 Connection 목록 중 사용 가능한 Connection 존재하는지 확인\n\t\t- 2, 3, 4 과정은 순서대로 실행되며, 사용 가능한 커넥션이 존재하면 다음 과정 생략 후 반환\n\t5. Connection 반환\n\n2. 가능한 Connection이 없으면 HandOffQueue를 Polling (상태를 주기적으로 검사하여 일정한 조건을 만족하면 송수신 등의 자료처리를 하는 방식) 하면서 다른 Thread가 Connection을 반납하기를 기다린다.\n\t- 지정된 TimeOut 시간까지 대기하다가 시간이 만료되면 예외를 던짐\n\n3. 최종적으로 Connection을 반납하면 Connection Pool이 사용 내역을 기록하고 HandOffQueue에 반납된 Connection을 삽입\n\t- HandOffQueue Polling 하던 Thread는 Connection을 얻고 작업 시작\n\n\u003cbr\u003e\n\n### DBCP 특징/고려사항\n\n**DBCP 장점**\n- Connection 객체를 미리 만들어 연결하여 메모리 상에 등록해 놓기 때문에 불필요한 작업(커넥션 생성, 삭제)이 사라지므로 클라이언트가 빠르게 DB에 접속이 가능하다.\n- DB 접속 모듈을 공통화하여 DB 서버의 환경이 바뀔 경우 쉬운 유지 보수가 가능하다.\n- 연결이 끝난 Connection을 재사용함으로써 새로 객체를 만드는 비용을 줄일 수 있다.\n- Connection 수를 제한할 수 있어서 과도한 접속으로 인한 서버 자원 고갈 방지가 가능하다.\n\n\u003cbr\u003e\n\n**DBCP 고려사항**\n\n- Connection 수가 제한되어 있어서 동시 접속자가 많으면 Connection 반납까지 대기해야함\n\t- Connection Pool을 크게 설정 -\u003e 메모리 소모 커짐, 대신 많은 사람의 대기시간 감소\n\t- Connection Pool을 작게 설정 -\u003e 메모리 소모 감소, 대신 많은 사람의 대기시간 증가\n- Connection을 사용하는 주체가 Thread 임으로 함께 고려해야 한다.\n\t- `Thread Pool 크기 \u003c Connection Pool 크기`\n\t\t- Thread Pool에서 트랜잭션을 처리하는 Thread가 사용하는 Connection 외에 남는 Connection은 실질적으로 메모리 공간만 차지함\n\t- `Thread Pool 크기, Connection Pool 크기 모두 증가`\n\t\t- Thread Pool이 커지면서 Thread 수가 늘어나 더 많은 Context Switching 발생\n\t\t\t- 오버헤드가 더 많이 발생\n\t\t- Disk 경합 측면에서 성능 한계 발생\n\t\t\t- DB는 하드디스크 하나 당 하나의 I/O를 처리하므로 블로킹이 발생한다.\n\t\t\t- 즉, 특정 시점부터는 성능적인 증가가 Disk 병목으로 인해 미비해짐\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eContext Switching? 블로킹?\u003c/strong\u003e\u003c/summary\u003e\n\n**컨택스트 스위칭(Context Switching)** 은 프로세스나 스레드의 상태를 저장하고, 나중에 해당 상태를 복원하여 실행을 재개하고, 이전에 저장한 다른 상태를 복원하는 과정을 의미한다. 이를 통해 여러 프로세스가 하나의 중앙 처리 장치(CPU)를 공유할 수 있으며, 멀티태스킹 운영 체제의 필수 기능이다.\n\n**블로킹**은 호출된 함수나 작업이 완료될 때까지 대기하며, **논블로킹**은 비동기적으로 작업을 처리하며, 호출된 함수나 작업이 완료되지 않아도 다음 코드를 실행하는 것을 의미한다. 입출력(I/O)에서도 블로킹과 논블로킹이 중요한데 블로킹 I/O는 데이터가 준비될 때까지 대기하며, 논블로킹 I/O는 즉시 반환하는 것이다. 그러나 논블로킹 I/O는 즉시 반환된다고 해서 항상 데이터를 반환하는 것은 아니기도 하다.\n\n\u003c/details\u003e\n\n\n\u003chr\u003e\n\n## 데이터베이스 트랜잭션\n\n==**Transaction은 정보 교환과 관련된 작업에서 일련의 순서를 나타내고 요청을 충족시키기 위해 데이터 무결성을 보장하기 위해 여러 개의 작업을 하나로 작업으로 묶은 작업 단위이다.**== 메시지 큐 트랜잭션 같은 것도 있지만, 보통 말하는 것이 DB 트랜잭션을 의미한다. ==**DB 트랜잭션은 데이터베이스의 상태를 변경시키는 작업의 단위이다.**==\n\n\u003cbr\u003e\n\n### 트랜잭션 성질\n\n트랜잭션이기 위해서는 ==**ACID**==라는 4가지 성질을 만족해야 한다. 이 중 가장 중요한 성질은 원자성!! 애초에 여러 작업을 하나의 트랜잭션 단위로 묶는데, 이 원자성이 깨져버리면 나머지 속성이 의미가 없는 것이다.\n\n**원자성(Atomicity)** \n- 트랜잭션에 속한 각각의 쿼리(읽기, 쓰기, 업데이트, 삭제)를 하나의 단위로 취급\n- 트랜잭션의 연산이 모두 성공하거나, 모두 실패하는 성질\n\t- 전체를 실행하거나 어떤 부분도 실행하지 않거나 둘 중 하나이다. 애매하게 실행하다가 끝 이런건 없다.\n\n**일관성(Consistency)**\n- 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효하여, DB 상태가 일관되어야 하는 성질\n- 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다는 의미\n\n**격리성(Isolation)**\n- 여러 사용자가 같은 테이블에서 동시에 읽고 쓰는 작업을 할 때, 각각의 트랜잭션을 경리하여 동시 트랜잭션이 서로 방해하거나 영향을 끼치지 않도록 하는 것\n- 실제로 동시에 여러 개의 트랜잭션들이 수행될 때, 각 트랜잭션은 고립(격리)되어 있어서 연속으로 실행된 것과 동일한 결과를 나타냄\n\n**지속성(Durability)**\n- 하나의 트랜잭션이 성공적으로 수행되었다면, 해당 트랜잭션에 대한 로그가 남아야하는 성질\n- 런타임 오류나 시스템 오류가 발생하더라도, 해당 기록은 영구적이어야 한다는 뜻\n\n\u003cbr\u003e\n\n### JDBC api 트랜잭션\n\nJDBC API를 이용하여 개발하는 상황이라고 하자. 예를 들어, 체스 말을 움직이는 메서드를 비즈니스 로직에서 사용하는데, move 메서드는 한 칸씩 이동하는 메서드라 두 번 움직이게 하려고 메서드를 두 번 사용했다고 하자.\n- 두 번의 update 쿼리를 날림. 각 update는 새로운 트랜잭션 생성하여 DB에 저장\n- 각 쿼리마다 DB에 트랜잭션을 커밋함. 첫 번째 쿼리 정상 커밋 -\u003e RuntimeException -\u003e 두 번째 쿼리는 빈 값을 커밋 -\u003e DB에 정보 어디감!? 이렇게 된다.\n\n\u003cbr\u003e\n\n이를 해결하기 위해 하나의 비즈니스 로직은 단일(같은) 트랜잭션으로 관리하기로 했다.\n- 서비스 단의 비즈니스 로직 시작 전에 트랜잭션을 시작하고 비즈니스 로직 끝난 후에 트랜잭션을 끝내야함\n\t- 이를 **트랜잭션 경계를 설정했다고 한다.**\n\n대신, 이렇게 하면 ==**단점**==이 있다.\n1. Service 코드가 복잡해진다.\n2. Connection 유지를 어떻게 할 것인가?\n3. 데이터 액세스 기술에 의존적인 코드를 작성한다.\n\t- 예를 들어, JDBC가 아닌 JPA를 사용하겠다고 하면 다바꿔야한다.\n\t- 트랜잭션을 중복해서 사용할 일도 있을 것, \n4. 비즈니스 로직과는 다른 관심사의 일을 수행한다.\n\t- DB 연결은 비즈니스 로직과 관심사가 다르니까\n\n\u003chr\u003e\n\n## Spring 트랜잭션\n\nJDBC API 트랜잭션에서 언급했던 단점을 Spring Framework를 사용하면서 깔끔하게 해결해준다.\n\n**트랜잭션 동기화**\n- 순수 JDBC는 커넥션 유지를 위해 Connection 객체를 계속 메서드의 파라미터로 넣었다.\n- 이를 해결하기 위해 스프링에서는 현재 스레드에 대한 트랜잭션 동기화를 활성한다.\n\t- TransactionSynchronizationManager\n\n**트랜잭션 추상화**\n- 데이터 액세스 기술과 트랜잭션, 서비스 사이의 종속성(dependency) 제거\n- 트랜잭션 기능을 쉽게 활용해주도록\n\n**선언적 트랜잭션**\n- 비즈니스 로직과 트랜잭션 관련 로직을 완전히 분리해줌\n\n\u003cbr\u003e\n\n### 트랜잭션 동기화\n\nJDBC를 이용하면서 여러 개의 작업을 하나의 트랜잭션으로 관리할 때 Connection 객체를 유지해야해서 얻는 불편함이 발생했었다. Spring Framework에서 제공하는 트랜잭션 동기화 기술은 어떤 방식으로 해결할까?\n\n==**트랜잭션을 시작하기 위한 Connection 객체를 특별한 저장소에 보관해 두고 필요할 때 꺼내 쓰는 방식으로 기술을 제공한다.**== 이 특별한 저장소를 **트랜잭션 동기화 매니저**라고 한다.\n- 트랜잭션 동기화 매니저는 스레므다마 Connection 객체를 독립적으로 관리하므로, 멀티 스레드 환경에서 충돌이 발생하지 않는다.\n- 따라서, 트랜잭션 동기화 매니저는 Thread-safe하다.\n\n\u003cbr\u003e\n\n**트랜잭션 동기화 매니저 동작 과정**\n1. 서비스에서 트랜잭션이 시작하면 트랜잭션 동기화 매니저가 커넥션을 생성하고 autoCommit을 false로 세팅한 이후 트랜잭션 동기화 매니저의 thread 로컬에 커넥션을 보관\n\t- 커넥션 풀을 사용하면 커넥션 풀에서 커넥션 가져옴\n2. 리포지토리 레이어에서 트랜잭션 동기화 매니저의 스레드 로컬에서 해당 커넥션을 가져와서 사용\n3. 서비스에서 트랜잭션을 종료할 때는 트랜잭션 동기화 매니저에서 해당 커넥션을 가져와서 commit 혹은 rollback을 수행하고 리소스를 정리 후 커넥션을 닫으면서 반환\n\t- 커넥션 풀을 사용하면 커넥션 풀에 커넥션 반환\n\n\u003cbr\u003e\n\n하지만, 만약에 JDBC가 아니라 Hibernate와 같은 기술을 사용한다면? 트랜잭션 동기화도 완벽하지 않다. -\u003e ==**트랜잭션 동기화 코드가 JDBC에 종속적이기 때문이다.**== 왜냐하면, 데이터 접근 기술이 아래와 같이 다르기 때문이다.\n- JDBC : Connection\n- JPA : EntityManager\n- Hibernate : Session\n\n\u003cbr\u003e\n\n### 트랜잭션 추상화\n\nJDBC, JPA, Hibernate가 하는 일은 모두 동일할 것이다.\n\n1. 트랜잭션을 가져오고 생성\n2. 해당 트랜잭션을 커밋\n3. 해당 트랜잭션을 롤백\n\n구현 방식에 상관없이 동일한 임무를 수행하는 구현체이기 때문에 이에 대한 추상화가 가능하다. Spring Framework가 제공하는 ==**트랜잭션 추상화 기술은 트랜잭션 관리 부분을 추상화한 기술을 의미한다.**== Spring은 **PlatformTransactionManager** 인터페이스를 생성해서 JDBC, JPA, Hibernate 각 구현체들이 트랜잭션을 가져오는 방식을 명세로 추상화 해두었다.\n- 이로 인해, 애플리케이션은 각 구현체에 종속적인 코드를 이용하지 않으면서 일관되게 트랜잭션을 처리할 수 있게 되었다.\n\n트랜잭션 추상화의 장점적인 부분은 많은 트랜잭션 기능을 제공해주는 것 이외에도 POJO에 가깝게 구현하여 테스트에 용이하다는 장점이 있다. 하지만 반대로, 추상화라는 것 자체가 코드 레벨이 깊어진다는 의미라 테스트가 용이하지 않게 되는 단점이 될 수도 있다.\n\n\u003cbr\u003e\n\n### 선언적 vs 프로그래밍\n\n스프링에서는 트랜잭션 처리를 2가지 방식으로 지원한다.\n\n**프로그래밍 방식 트랜잭션**\n- 위와 같이 PlatformTransactionManager나 TransactionTemplate을 직접 사용해서 프로그래밍 코드를 작성하는 방식\n- Spring docs에서는 TransactionTemplate을 사용하는 것을 권장\n- 트랜잭션 로직을 직접 하드코딩으로 관리 가능\n\t- 트랜잭션의 시작, 종료 시점을 명시적으로 결정하여 트랜잭션 경계를 개발자가 설정하도록\n- 트랜잭션의 유연한 관리 가능\n- 다수의 트랜잭션 관리하기에 힘들다\n- 적은 양의 트랜잭션이 사용될 때 사용하는 것을 권장\n\n==**선언적 트랜잭션**==\n- `@Transactional` 애노테이션을 사용한 트랜잭션 관리 방식\n- Spring AOP를 통해 구현되어지는 방색\n- **트랜잭션 로직과 비즈니스 로직을 분리하여 관리 가능**\n- 유지보수 쉬움\n- 다수의 트랜잭션 관리할 때 선호\n- **AOP로 구현되므로, 내부 메서드 transaction으로는 사용 불가능**\n\n\u003cbr\u003e\n\n프로그램상에 트랜잭션이 적을 때는 트랜잭션 프록시를 설정하지 않을수 있기 때문에 TransactionTemplate을 이용하는 것이 좋다고 하고, 다수의 트랜잭션 작업이 있는 경우 트랜잭션 관리를 비즈니스 로직에서 제외시키고 구성할수 있기 때문에 유지보수에 편리할 수 있다고 한다.\n\n\u003cbr\u003e\n\n### AOP 이용 트랜잭션 분리\n\nJDBC를 이용하여 여러 작업을 단일 트랜잭션으로 관리하게 되었다. 하지만, 코드가 매우 복잡해지고 Connection 객체 유지를 위해 메서드에 불편하게 넣어야했다. 이를 해결하기 위해 Spring에서 제공하는 트랜잭션 동기화 기술은 트랜잭션 동기화 매니저를 통해 Connection 객체를 관리하게 되었고, 데이터베이스 접근 기술에 의존적이던 부분은 트랜잭션 추상화 기술을 통해 해결했다. **마지막으로 남은 문제가 서비스의 비즈니스 로직과는 관심사가 다른 부분이다.**\n\n위에서도 잠깐 언급했지만 ==**선언적 트랜잭션 방식인 `@Transactional` 애노테이션을 활용해 이를 해결한다.**==\n- 트랜잭션 로직을 클래스 밖으로 빼내서 별도의 모듈로 만드는 AOP를 고안하였었다.\n- 이를 적용한 것이 트랜잭션 애노테이션이다.\n- `@Transactional`을 사용하면 감싸는 프록시를 사용하기 때문에 추가적인 코드를 작성할 필요 없이 간편하게 사용할 수 있다.\n\n\u003chr\u003e\n\n## @Transactional\n\n`@Transactional` 애노테이션은 AOP로 구성되어있다고 했다. \n- 클래스, 메서드 위에 ==**애노테이션 선언하면 트랜잭션 기능이 적용된 프록시 객체가 생성**==\n\t- 클래스에 붙으면 클래스의 전체 `public 메서드`에 트랜잭션 처리가 된 프록시가 빈으로 등록\n\t- `public, protected, default`가 아닌 **private 접근제한자가 붙은 메서드의 경우 트랜잭션 처리 되지 않음**\n\t\t- 프록시가 메서드 오버라이딩 개념이라 public으로 열려있지 않고 private으로 닫혀있으면 안되는 거임\n\t\t- 추가로, **static, final이 붙어도 `@Transactional`이 작동하지 않는다.** non-public이라서이다. 자세한 내용은 non-public methods should not be @transactional로 검색해보자.\n- 프록시로 동작하므로 메서드 오버라이딩 개념으로 동작\n\t- 요청이 오면 프록시 객체가 요청을 받고 프록시 객체에서 트랜잭션을 시작\n\t- 적용하고자 하는 실제 객체의 메서드에서 invoke하여 사용하고 트랜잭션 커밋/롤백\n- `@Transactional`은 auto commit을 false로 하고 마지막에 커밋/롤백 한다.\n\n\u003cbr\u003e\n\n### 선언적 트랜잭션 문제점\n\n선언적 트랜잭션은 ==**내부 호출 문제**==가 있다.\n\n`@Transactional`을 사용한 메서드를 같은 객체 안에서 불러온다고 생각해보자.\n- ==**선언적 트랜잭션은 프록시 객체이기 때문에 같은 내부에서 호출하면 트랜잭션이 정상 작동하지 않음**==\n- 객체 변경 감지는 트랜잭션이 커밋될 때 작동하는데, Spring이 `@Transactional`을 선언한 메서드가 호출되기 전에 트랜잭션을 시작하는 코드를 삽입하고, 실행 이후에 commit 코드를 삽입하여 객체 변경 감지를 수행하도록 유도하기 때문이다.\n\t- **Spring에서 이 방식으로 프록시 객체로 한 번 더 감싸기 때문에 프록시 객체가 제공하는 메서드를 사용해야만 트랜잭션이 수행된다.**\n\n==**핵심은 AOP 프록시를 씌우려면 타겟 메서드를 감싸야 한다는 말이다. 그냥 코드인 메서드 자체를 호출한 것인지 프록시를 통해 접근했는지 잘 확인해야한다.**== \n\n\u003cbr\u003e\n\n**같은 객체 내부에서 선언하면 작동 안함**\n\n```java\n@Service\npublic class MemberService {\n\n  private final MemberRepository memberRepository;\n\n  public void memberInserts(List\u003cMember\u003e members) {\n    members.forEach(it -\u003e this.memberInsert(it));\n  }\n  \n  @Transactional\n  public void memberInsert(Member member) {\n    memberRepository.save(member);\n  }\n}\n```\n\n\u003cbr\u003e\n\n**내부가 아닌 외부에서 호출해야 작동함**\n- 이 경우도 타겟 메서드 위에다가 잘 붙여야함\n\n```java\n@Controller\npublic class MemberController {\n\n\tprivate final MemberService memberService;\n\n\t@RequestMapping(\"memberInsert\")\n\tpublic Member memberInsert(Member member) {\n    \tmemberService.memberInsert(Lists.newArray(member));\n    }\n}\n\n@Service\npublic class MemberService implements MemberRepository {\n  \n  private final MemberRepository memberRepository;\n  \n  @Transactional\n  public void memberInsert(List\u003cMember\u003e members) {\n  \tmembers.forEact(it -\u003e memberRepository.save(it));\n  }\n}\n```\n\n\u003cbr\u003e\n\n## Transactional 속성\n\n`@Transactional` 애노테이션을 선언하면 6가지 속성을 지정해 트랜잭션을 세부적으로 이용할 수 있다.\n\n- 전파(propagation)\n- 고립(isolation)\n- 읽기동작(read-only)\n- 타임아웃(timeout)\n- rollbackFor, noRollbackFor\n\n\u003cbr\u003e\n\n### Propagation\n\n- 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있는 지 유무에 따라 어떻게 동작할 지를 결정하는 것\n- 여러 트랜잭션 적용 범위를 묶어서 커다란 하나의 트랜잭션 경계를 만들 수 있다.\n- 트랜잭션 경계의 시작 지점에서 트랜잭션 전파 속성을 참조해서 해당 범위의 트랜잭션을 어떤 식으로 진행할지 결정할 수 있다.\n\n\n\u003cbr\u003e\n\n|                   | **진행 중인 트랜잭션 O**                     | **진행 중인 트랜잭션 X** |\n| ----------------- | -------------------------------------------- | ------------------------ |\n| **REQUIRED**      | 해당 트랜잭션 사용                           | 새로운 트랜잭션 생성     |\n| **MANDATORY**     | 해당 트랜잭션 사용                           | 예외 발생                |\n| **REQUIRES_NEW**  | 해당 트랜잭션 보류 \u003cbr\u003e 새로운 트랜잭션 생성 | 새로운 트랜잭션 생성     |\n| **SUPPORTS**      | 해당 트랜잭션 사용                           | 트랜잭션 없이 진행       |\n| **NOT_SUPPORTED** | 해당 트랜잭션 보류                           | 트랜잭션 없이 진행       |\n| **NEVER**         | 예외 발생                                    | 트랜잭션 없이 진행       |\n| **NESTED**        | 중첩 트랜잭션 생성                           | 새로운 트랜잭션 생성                         |\n\n\u003cbr\u003e\n\n==**REQUIRED**==\n- 전파의 default 속성, 모든 트랜잭션 매니저가 지원\n- 만약, REQUIRED 속성일 때 하나의 트랜잭션이 시작된 후 다른 트랜잭션 경계가 설정된 메서드를 호출하면 자연스럽게 같은 트랜잭션으로 묶임\n\n**MANDATORY** \n- 혼자서 독립적으로 트랜잭션을 진행하면 안되는 경우에 사용 가능\n\n**REQUIRES_NEW**\n- 항상 새로운 트랜잭션을 시작해야하는 경우에 사용\n\n**SUPPORTS**\n- 진행 중인 트랜잭션이 없는 경우에는, 트랜잭션이 없더라도 해당 경계 안에서 Connection 객체나 Hibernate의 Session 등은 공유할 수 있음\n\n==**NESTED** ==\n- 이미 진행중인 트랜잭션이 있으면 중첩 트랜잭션을 시작, 트랜잭션 안에 다시 트랜잭션을 만드는 것\n- **REQUIRES_NEW는 독립적인 트랜잭션을 만드는 것**이다. NESTED와는 다르다.\n- ==**따라서, NESTED는 먼저 시작된 부모 트랜잭션의 커밋과 롤백에 영향을 받는다. 하지만 자식의 커밋과 롤백은 부모 트랜잭션에 영향을 주지 않는다.**==\n- 예를 들어, 어떤 중요한 작업을 진행하면서 작업 로그를 DB에 저장해야 한다고 하자. 그런데 로그를 저장하는 작업은 실패를 하더라도 메인 작업의 트랜잭션까지는 롤백하지 말아야 하는 경우가 있다. 왜냐하면 힘들게 처리한 중요한 작업을 로그를 남기지 못해서 모두 실패로 만들 수 없기 때문이다. 반면에 핵심 작업에서 예외가 발생한다면 이때는 저장된 로그도 제거해야 한다.\n\n\u003cbr\u003e\n\n### Isolation\n\n- 동시에 여러 트랜잭션이 진행될 때, 트랜잭션의 작업 결과를 타 트랜잭션에게 어떻게 노출할 지 결정하는 속성\n\n\u003cbr\u003e\n\n**DEFAULT**\n- 사용하는 데이터 액세스 기술이나 DB Driver의 디폴트 설정을 따름\n- 드라이버의 격리 수준 -\u003e DB의 격리 수준 따름\n- 오라클 -\u003e READ_COMMITED\n- MySQL -\u003e REPETABLE_READ\n\n\u003cbr\u003e\n\n**READ_UNCOMMITTED**\n\n![](brain/image/dog-week07-5.png)\n\n- 가장 낮은 격리 수준\n- 하나의 트랜잭션이 커밋되기 이전, 변화가 다른 트랜잭션에 그대로 노출\n- ==**더티리드**== 현상 발생 가능\n\t- 트랜잭션 1이 만약 트랜잭션을 끝마치지 못하고 롤백한다면 트랜잭션 2는 무효가 된 데이터 값을 읽고 처리하기 때문에 문제가 발생\n- ==**Non_Repetable_Read**== 현상 발생 가능\n- ==**Phantom Read**== 현상 발생 가능\n- 하지만 가장 빠름. 데이터의 일관성이 떨어지더라도 성능 극대화 위해 사용\n\n\u003cbr\u003e\n\n**READ_COMMITTED**\n\n![](brain/image/dog-week07-6.png)\n\n- 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음\n- 하나의 트랜잭션이 읽은 row를 다른 트랜잭션이 수정할 수 있음\n\t- 이 때문에 읽는 시점에 따라 같은 row를 읽어도 다른 데이터일 수 있음\n- ==**Non-Repetable Read**== 현상 발생 가능\n\t- 같은 트랜잭션 내에서 select 문을 두 번 조회했을 때 두 값이 다른 값이 나오는 데이터 불일치 문제\n- ==**Phantom Read**== 현상 발생 가능\n\n\u003cbr\u003e\n\n**REPEATABLE_READ**\n\n![](brain/image/dog-week07-7.png)\n\n- 하나의 트랜잭션이 읽은 row를 다른 트랜잭션이 수정할 수 없게 막음\n- 하지만, 새로운 row를 추가하는 것은 막지 않음\n- SELECT로 조건에 맞는 row를 전부 가져오는 경우 트랜잭션이 끝나기 전에 추가된 row가 발견될 수 있음\n- 트랜잭션 시작 시점에 스냅샷을 생성해서 그때 읽어온 정보들을 스냅샷으로 만든다. 스냅샷에서 정보를 가져오기 때문에 커밋되기 이전에 데이터가 반영 안됨\n- ==**Phantom Read**== 현상 발생 가능\n\t- Non-Repetable Read의 한 종류\n\t- 조건이 걸렸든 안 걸렸든 select 문을 사용할 때 나타날 수 있는 현상\n\t- 해당 쿼리로 읽히는 데이터에 들어가는 row가 새로 생기거나 없어져 있는 현상\n\n\u003cbr\u003e\n\n**SERIALIZABLE**\n\n![](brain/image/dog-week07-8.png)\n\n- 가장 강력한 트랜잭션 격리 수준. 이름 그대로 트랜잭션을 순차적으로 진행\n- 여러 트랜잭션이 동시에 같은 테이블의 정보를 액세스 할 수 없음\n- 극단적으로 안전한 작업이 필요한 경우 아니면 성능이 가장 떨어지니까 사용 X\n\n\u003cbr\u003e\n\n### Timeout\n\n- 트랜잭션에 제한시간을 지정할 수 있음. 같은 int 타입의 초 단위로 지정할 수 있고, 문자열로 지정하고 싶으면 timeoutString을 사용하면 됨\n- 기본 옵션에는 제한시간이 없음. 그래서 설정할 수 있게 해주는거임\n- REQUIRED, REQUIRES_NEW와 같이 새로운 트랜잭션을 시작하는 전파속성과 함께 사용 가능하도록 보완한 것\n\n\u003cbr\u003e\n\n### readOnly\n\n2가지 목적으로 읽기 전용 설정이 가능\n- 트랜잭션 내에서 데이터를 조작하려는 시도를 막음 (쓰기 작업)\n- 읽기 전용으로 설정하여 성능을 최적화\n\n\u003cbr\u003e\n\n**ReadOnly 성능 이점**\n- JPA를 사용할 경우, `readOnly = true` 설정을 주면 영속성 컨텍스트에 플러시가 일어나지 않으므로 쓰기, 수정, 삭제 작업이 동작하지 않는다. 또한, 스냅샷 저장, 비교 등의 무거운 작업을 하지 않아서 성능이 향상된다.\n- 데이터베이스가 master와 slave로 나누어져 있다면, `readOnly = true` 설정을 주었을 때 읽기 전용인 slave를 호출하게 된다. 즉, 상황에 따라 데이터베이스 서버 부하를 줄일 수 있다.\n\n\u003cbr\u003e\n\n### 롤백/커밋\n\nSpring은 디폴트로 **UnCheckedException** 과 **Error**에 대해서 롤백 정책을 설정한다. ==**`@Transactional`에서 런타임 예외가 발생하면 롤백하고, 예외가 발생하지 않았거나 체크 예외가 발생하였다면 커밋한다는 의미이다.**== \n\n- CheckedException을 커밋 대상으로 삼은 이유?\n\t- 체크 예외가 예외적인 상황에서 사용되기 보다는 반환값을 대신하여 비즈니스 적인 의미를 담은 결과로 많이 사용되기 때문\n- UnCheckedException을 롤백 대상으로 삼은 이유?\n\t- 데이터 액세스 기술의 예외는 런타임 예외로 전환하여 던지므로\n\n\u003cbr\u003e\n\n**rollback-for**\n- 기본적으로 RuntimeException 발생 시 롤백\n- CheckedException 이지만 롤백 대상으로 삼고 싶으면 사용\n\n\u003cbr\u003e\n\n**no-rollback-for**\n- 롤백 대상인 RuntimeException을 커밋 대상으로 지정\n\n\n\u003chr\u003e\n\n## 참고\n\n- \u003ca href='https://www.youtube.com/watch?v=PNnB8mN0v-o\u0026t=465s' target='_blank'\u003e프로그래머스 데브코스 OSIV - 이건우\u003c/a\u003e\n- \u003ca href='https://steady-coding.tistory.com/564' target='_blank'\u003e제이온 님의 Connection Pool 내용 블로그\u003c/a\u003e\n- \u003ca href='https://steady-coding.tistory.com/570' target='_blank'\u003e제이온 님의 스프링이 제공하는 트랜잭션의 핵심 기술 내용 블로그\u003c/a\u003e\n- \u003ca href='https://www.youtube.com/watch?v=cc4M-GS9DoY' target='_blank'\u003e테코톡 - 후니의 스프링 트랜잭션\u003c/a\u003e\n- \u003ca href='https://taes-k.github.io/2019/09/04/spring-transaction/' target='_blank'\u003eTase-k Devlog spring annotation 트랜잭션\u003c/a\u003e\n- \u003ca href='https://www.youtube.com/watch?v=e9PC0sroCzc\u0026t=533s' target='_blank'\u003e테코톡 - 예지니어스의 트랜잭션\u003c/a\u003e","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/dog-study/dog-week08":{"title":"8주차 - Spring JPA","content":"\n\u003e[!note] 8주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC** \u003cbr\u003e\n\u003e - OSIV\n\u003e - JPA\n\u003e - N+1 문제\n\u003e - fetch join 한계\n\u003e \t- OneToMany fetch join 페이징 쿼리 성능 이슈\n\u003e \t- MultipleBagFetchException\n\u003e - OneToOne 양방향 관계 Lazy 로딩 주의\n\u003e - 상속관계 매핑\n\n\u003cbr\u003e\n\n## OSIV\n\n==**OSIV(Open Session In View)는 영속성 컨택스트를 View 단까지 열어준다는 의미이다.**== \n- Spring에서 Presentation Layer(View, Controller)에는 트랜잭션이 없기 때문에 엔티티를 수정할 수는 없다.\n- **Spring에서는 OSIV 기능이 default로 켜져있다.** 따라서, View 단을 렌더링 하면서 쿼리가 나갈 수 있다고 WARN을 띄워주는데 이를 없애려면 명시적으로 OSIV 기능을 설정하면 된다.\n\t- 영속성 컨택스트를 요청이 들어올 때 미리 만들고, 응답할 때까지 유지시켜준다.\n\t- **서블릿의 필터** 혹은 **스프링의 인터셉터**에서 미리 영속성 컨택스트를 만들어서 사용한다.\n- OSIV 덕분에 영속성 컨택스트가 살아있어서 **Lazy Loading이 가능**하다.\n\t- 이로 인해 Service에 초기화를 위한 코드를 작성하지 않아도 된다.\n\n\u003e 영속성 컨택스트는 엔티티를 영구 저장하는 환경이다. \u003cbr\u003e\n\u003e 영속성 컨택스트는 트랜잭션이 시작될 때 만들어지고 트랜잭션이 커밋된 이후 없어진다. \u003cbr\u003e\n\n\u003cbr\u003e\n\n\u003e 즉시 로딩이란 객체 A를 조회할 때 A와 연관된 객체들을 한 번에 가져오는 것이고 \u003cbr\u003e\n\u003e **지연 로딩**이란 객체 A를 조회할 때는 A만 가져오고 연관된 애들은 프록시 초기화 방법으로 가져오는 것이다.\n\n\u003cbr\u003e\n\n### OSIV의 필요성, 단점\n\nOSIV는 왜 나오게 되었을까? 아래를 한 번 살펴보자.\n\n![](brain/image/dog-week07-2.png)\n\n\u003cbr\u003e\n\n- 서비스에서 트랜잭션이 시작되면서 영속성 컨택스트가 만들어져 엔티티는 영속 상태가 되고, 서비스가 끝나면 트랜잭션도 끝나고 밖으로 나오면서 준영속 상태가 된다.\n- 그런데, 만약 Post와 User가 다대일 연관관계로 매핑이 되어있는 경우에 Post entity를 Controller까지 가져와서 PostDto로 변환하려고 하면 어떻게 될까?\n\t- Service가 끝났으니까 트랜잭션 종료되면서 영속성 컨택스트도 사라짐\n\t- Controller까지 끌고온 Post는 다대일 연관관계라서 Lazy Loading을 시도했을 것\n\t- 그런데 컨트롤러에 트랜잭션이 있을까? 없다. 따라서 영속성 컨택스트도 없다. 그래서 `could not initialize proxy` 오류를 뱉을 것이다.\n\n\u003cbr\u003e\n\n이런 이유로 ==**트랜잭션 외부에서도 영속성 컨택스트가 존재하여 DB 커넥션을 유지하고, 영속성 컨택스트를 사용할 수 있는 기능의 필요성을 느끼게 된 것이다.**==\n \n\u003cbr\u003e\n\n그러나, ==**이러한 특성으로 인해 OSIV에는 단점이 있다.**==\n- 같은 영속성 컨택스트를 여러 트랜잭션이 공유할 수 있다.\n- Presentation Layer에서 엔티티를 수정하고 Service Layer의 트랜잭션으로 들어오면 엔티티가 수정된다.\n- Presentation Layer에서 Lazy Loading에 의한 SQL이 실행되기 때문에 성능 튜닝 시 확인해야할 부분이 Presentation Layer까지 넓어진다.\n- DB 커넥션 시작 시점부터 응답이 나갈 때까지 DB 커넥션을 유지하는거라서 커넥션이 부족할 수 있다.\n\n\u003chr\u003e\n\n## JPA\n\n==**JPA(Java Persistence API)는 RDBMS와 OOP 객체 사이의 불일치에서 오는 패러다임을 해결하기 위해 자바 진영에서 만들어낸 ORM(Object-Relational Mapping) 기술의 표준 명세이다.**==\n\n- Java에서 제공하는 API이다. Spring에서 제공하는 것이 아니다.\n- [6주차 스터디](/brain/Interview/dog-study/dog-week06)에서 언급한 것처럼, Spring Framework의 PSA(Portable Service Abstraction)에 의해 POJO를 사용하면서 특정 기술인 ORM을 사용하기 위해 정해둔 표준 인터페이스이다.\n- SQL을 매핑하지 않고 ==**자바 클래스와 DB 테이블을 매핑**==\n\t- 객체가 테이블이 되도록 매핑시켜주는 것\n\n![](brain/image/dog-week08-2.png)\n\n![](brain/image/dog-week08-1.png)\n\n\u003cbr\u003e\n\n## 질문내용\n\n### OSIV\n\n1.  **OSIV란?**\n\t- 영속성 컨텍스트를 뷰까지 열어두는 기능\n\n2.  **OSIV의 특징**\n\t-   **클라이언트 요청이 들어올 때 영속성 컨텍스트를 생성**해서 **요청이 끝날 때까지 영속성 컨텍스트를 유지** → 뷰에서도 지연 로딩을 사용할 수 있음\n\t-   **트랜잭션 없이 읽기(Nontransactional reads)**\n\t\t-   트랜잭션이 없는 프레젠테이션 계층은 지연 로딩을 포함해 **조회만 할 수 있다.**\n\t\t-   **수정**은 **트랜잭션이 있는 계층에서만 동작**한다.\n\t-   spring.jpa.open-in-view: true가 기본 값\n    \n\n3.  **OSIV가 켜져있는 경우 장단점**\n\t- 장점\n\t\t-   데이터베이스 커넥션을 유지해서 지연 로딩이 가능하다.\n\t- 단점\n\t\t-   실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자를 수 있다. → 장애 유발\n\t\t- ex) 컨트롤러에서 외부 API를 호출하면 외부 API 대기 시간 만큼 커넥션 리소스를 반환하지 못하고, 유지해야 한다.\n\n4.  **OSIV가 꺼져있는 경우 장단점**\n\t- 장점\n\t\t-   커넥션 리소스를 낭비하지 않는다.\n\t- 단점\n\t\t-   모든 지연 로딩을 트랜잭션 안에서 처리해야 한다.\n\t\t-   view, controller에서 지연로딩을 사용한 경우 모두 트랜잭션 안으로 넣어야 한다.\n\n5.   **OSIV의 동작 순서**\n\n\t\t1. 클라이언트의 요청이 들어오면 서블릿 필터나, 스프링 인터셉터에서 **영속성 컨텍스트를 생성**한다. 단 이 시점에서 **트랜잭션은 시작하지 않는다.**\n\t\t2. **서비스 계층**에서 `@Transactional`로 트랜잭션을 시작할 때 1번에서 미리 생성해둔 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.\n\t\t3. 서비스 계층이 끝나면 **트랜잭션을 커밋**하고 **영속성 컨텍스트를 플러시**한다. 이 시점에 트랜잭션은 끝내지만 **영속성 컨텍스트는 종료되지 않는다.**  \n\t\t4.  **컨트롤러와 뷰까지 영속성 컨텍스트가 유지**되므로 조회한 엔티티는 영속 상태를 유지한다.  \n\t\t5.  **서블릿 필터나, 스프링 인터셉터로 요청**이 돌아오면 **영속성 컨텍스트를 종료**한다. 이때 **플러시를 호출하지 않고 바로 종료**한다.  \n\n6.  **현재 스프링 프레임워크가 제공하는 OSIV 트랜잭션 작동 범위**  \n\t- 영속성 컨텍스트는 사용자의 요청 시점에서 생성이 되지만, 데이터를 쓰거나 수정할 수 있는 트랜잭션은 비즈니스 계층에서만 사용할 수 있도록 트랜잭션이 일어난다.\n\n7.  **트랜잭션 범위 밖에서 엔티티 수정할 경우 수정 사항이 DB에 반영될까요?**\n\n\t- 스프링이 제공하는 OSIV는 요청이 끝나면 플러시를 호출하지 않고 em.close()로 영속성 컨텍스트만 종료한다. 따라서 반영되지 않는다.\n\n8.  **그렇다면 프레젠테이션 계층에서 em.flush()를 호출하더라도 데이터가 수정되지 않나요?**\n\n\t- 프레젠테이션 계층에서 em.flush()를 호출하여 **강제로 플러시해도** 트랜잭션 범위 밖이므로 **데이터를 수정할 수 없다는 예외**가 발생한다.(javax.persistence.TransactionRequiredException)\n\n9. **OSIV 사용시 주의사항**\n\n\t- **자원**\n\t\t- OSIV의 전략은 트랜잭션 시작처럼 **최초 데이터베이스 커넥션 시작 시점**부터 **API 응답이 끝날 때까지** **영속성 컨텍스트와 데이터베이스 커넥션을 유지**한다. 그래서 View Template이나 API 컨트롤러에서 지연 로딩이 가능하다.\n\t\t- 지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지한다. 이것 자체가 큰 장점이다.\n\t\t- 하지만 이 전략은 오래동안 데이터베이스 커넥션 리소스를 사용하기 때문에, **실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있다.** 이것은 결국 장애로 이어진다.\n\t- 예를 들어서 컨트롤러에서 외부 API를 호출하면 외부 API 대기 시간 만큼 커넥션 리소스를 반환하지 못하고, 유지해야 한다.\n\t\t- → 영속성 컨텍스트가 종료될 때까지 DB Connection을 유지하므로, Connection 자원 소모가 크다.\n\n10. **엔티티가 수정되고 트랜택션이 있는 비즈니스 로직이 호출되면 수정 사항이 DB에 반영될까요?**\n\n\t- 같은 영속성 컨텍스트를 **여러 트랜잭션이 공유**할 수 있으므로 **수정이 발생**한다.하지만 보통 컨트롤러는 비즈니스 로직을 먼저 호출하고 그 결과를 조회하므로 이런 문제는 거의 발생하지 않는다.\n\n### JPA\n\n1.  **JPA란?**\n\n\t- 자바 진영의 **ORM** 기술 표준 인터페이스\n\n2.  **JPA를 사용하는 이유?**\n\t-   SQL 중심적인 개발에서 객체 중심의 개발\n\t-   1차 캐시와 동일성 보장\n\t\t1.  같은 트랜젝션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상\n\t\t2. 따라서 같은 instance로 판단된다.\n\t-   트랜젝션을 지원하는 쓰기 지원\n\t\t- 트랜잭션을 커밋할 때까지 insert sql 모은다\n\t\t-   JDBC BATCH SQL 기능을 사용해서 한 번에 SQL 전송\n\t-   지연 로딩 사용 가능\n\t-   유지 보수\n\t-   데이터 접근 추상화와 벤더 독립성\n\t-   특정 데이터베이스 기술에 종속되지 않음\n\t-   변화에 유연하게 대응 가능\n\t-   엔티티로 관리되므로 스키마 변경시 엔티티만 수정하게 되면 엔티티를 사용하는 관련 쿼리는 자동으로 변경된 내역이 반영된다.\n\t-   객체지향적으로 데이터를 관리할 수 있다.\n\n3.  **JPA의 단점에는 무엇이 있을까요?**\n\t-   러닝 커브 존재\n\t-   통계 처리와 같은 복잡한 쿼리 처리 어려움\n\t    -   Native Query, JPQL, queryDsl 등을 사용하여 해결\n\t-   성능\n\t    -   객체 간의 올바른 매핑 설계가 이뤄지지 않으면 성능 저하 발생 가능\n\t    -   자동으로 생성되는 쿼리가 많기 때문에, 개발자가 의도하지 않은 쿼리로 성능이 저하 발생 가능\n\t        -   N + 1 문제\n\t        -   FetchType\n\t        -   FetchJoin\n\t        -   Proxy\n\n4.  **JPA의 단점을 보완하는 방법에는 무엇이 있을까요?** -\u003e 3번 참조\n\n### N+1문제\n\n1.  **N+1문제란?**\n\t- 요청이 1개의 쿼리로 처리되길 기대했는데 N개의 추가 쿼리가 발생하는 현상\n\n2.  **N+1문제가 발생하는 이유**\n    \n\t-   JPA Repository로 find 시 실행하는 첫 쿼리에서 하위 엔티티까지 한 번에 가져오지 않고, 하위 엔티티를 사용할 때 추가로 조회하기 때문이다.\n\t-   JPQL은 기본적으로 글로벌 Fetch 전략을 무시하고 JPQL만 가지고 SQL을 생성하기 때문이다\n\n3.  **즉시 로딩, 지연 로딩이란?**\n\t- 즉시로딩: 특정 엔티티를 조회할 때 연관된 모든 엔티티를 같이 로딩하는 것\n\t- 지연 로딩: 필요한 시점에 연관된 객체의 데이터를 불러오는 것\n    \n3.  **즉시 로딩, 지연 로딩에서 N+1 문제가 발생하는 과정**\n    \n    **EAGER(즉시 로딩)인 경우**\n    \n    1.  JPQL에서 만든 SQL을 통해 데이터를 조회\n        \n    2.  이후 JPA에서 Fetch 전략을 가지고 해당 데이터의 연관 관계인 하위 엔티티들을 추가 조회\n        \n    3.  2번 과정으로 N + 1 문제 발생\n        \n    \n    **LAZY(지연 로딩)인 경우**\n    \n    1.  JPQL에서 만든 SQL을 통해 데이터를 조회\n        \n    2.  JPA에서 Fetch 전략을 가지지만, 지연 로딩이기 때문에 추가 조회는 하지 않음\n        \n    3.  하지만, 하위 엔티티를 가지고 작업하게 되면 추가 조회가 발생하기 때문에 결국 N + 1 문제 발생\n        \n4.  **N+1문제 해결법**\n    \n    -   **fetch Join**\n    \n\t    - JPQL을 사용하여 DB에서 데이터를 가져올 때 처음부터 연관된 데이터까지 같이 가져오게 하는 방법이다. (SQL Join 문을 생각하면 된다. )\n    \n    -   **@EntityGraph**\n    \n\t    - `@EntityGraph`의 `attributePaths`에 **쿼리 수행 시 바로 가져올 필드 명**을 지정하면 Lazy가 아닌 Eager 조회로 가져오게 됩니다.\n    \n    -   **Batch Size**\n    \n\t    - 이 옵션은 정확히는 N+1 문제를 안 일어나게 하는 방법은 아니고 N+1 문제가 발생하더라도 select * from user where team_id = ? 이 아닌 select * from user where team_id in (?, ?, ? ) 방식으로 N+1 문제가 발생하게 하는 방법이다.\n    \n\t    - 이렇게 하면 100번 일어날 N+1 문제를 1번만 더 조회하는 방식으로 성능을 최적화할 수 있다.\n    \n\t    - 단 Batch Size의 한계값은 1000 정도\n    \n### fetch join 한계 - OneToMany fetch join 페이징 쿼리 성능 이슈\n    \n1.  발생 이유\n    \n\t- JPA에서 @ToMany 관계에 대해 Paging + fetch join을 수행할 때, One Entity 기준으로 Many Entity에 대한 데이터를 join하게 되어 데이터의 수가 변한다. \n\t- ex) Review 2개, Image 3개일 때 row는 총 6개가 생김. **`(2 != 6)`** \n\t- **따라서 JPA는 어떤 데이터를 기준으로 Paging을 수행해야 하는 지 알 수 없게 된다.**\n    \n2.  해결 방법\n    -   중복 데이터\n\t    - → JPQL에서 지원하는 distinct를 사용하여 해결\n\t    - 같은 식별자를 가진 엔티티 중복 제거\n    -   `xToMany`에서 페이징이 불가능하다.\n\t    - limit 쓰면 OOM(Out of Memory) 발생\n\t\t    - 데이터를 전부 가져오고나서 메모리에서 페이징을 하기 때문\n\t- → 지연로딩으로 조회, `@BatchSize` 적용\n\t- → N의 테이블의 기준으로 fetchJoin하여 findAll로 Paging + 합치기\n        \n    \n### fetch join 한계 - MultipleBagFetchException\n\n1. 어떨 때 발생하는 exception?\n\t- **2개 이상의 OneToMany 자식 테이블에 Fetch Join을 사용**했을 때 발생\n        \n2.  이러한 fetch join 문제들 해결하는 방법?\n        \n\t-   `hibernate.default_batch_fetch_size`를 **글로벌 설정**으로 사용해 N+1 문제를 최대한 `in` 쿼리로 기본적인 성능을 보장하게 한다.\n\t\t-   한계값 1000 존재\n\t- `@OneToOne`, `@ManyToOne`과 같이 1 관계의 자식 엔티티에 대해서는 **모두 Fetch Join**을 적용하여 한방 쿼리를 수행한다.\n\t- `@OneToMany`, `@ManyToMany`와 같이 N 관계의 자식 엔티티에 관해서는 **가장 데이터가 많은 자식쪽에 Fetch Join**을 사용한다.\n\t\t- Fetch Join이 없는 자식 엔티티에 관해서는 위에서 선언한 `hibernate.default_batch_fetch_size` 적용으로 100~1000개의 `in` 쿼리로 성능을 보장한다.\n    \n### OneToOne 양방향 관계 Lazy 로딩 문제\n    \n1. OneToOne 양방향 관계 Lazy Loading 문제가 무엇인가요?\n\t- **외래키를 가지고 있는 주인** 테이블을 조회할 때는 **지연 로딩이 동작**하지만, mappedBy 속성으로 연결된 외래키를 가지지 않은 쪽에서 테이블을 조회할 경우 **지연 로딩이 동작하지 않고 N+1 문제가 발생**하는 것\n    \n2. 발생 이유?\n\n\t- 외래키를 가지지 않은 테이블에서는 주인 테이블 객체가 **null 인지 아닌지를 조회해보기 전까지는 알 수 없습니다.** LAZY 로딩으로 설정이 되어있는 엔티티를 조회할 때는 프록시로 감싸서 동작하게 되는데, **프록시는 null을 감쌀 수 없기 때문에** 지연 로딩으로 설정하여도 즉시 로딩이 수행되게 되는 문제가 발생합니다.\n    \n3.  해결 방안\n\t1.  구조 변경하기\n\t\t-   양방향 매핑이 반드시 필요한 상황인지 다시한번 생각해본다.\n\t\t-   OneToOne -\u003e OneToMany 또는 ManyToOne 관계로 변경이 가능한지 생각해본다.\n\t2.  구조를 유지한채 해결하기\n\t\t- CART를 조회할때 USER도 함께 조회한다. (Fetch Join)\n\t\t- batch fetch size를 사용한다.\n\t3. 외래키가 어디있냐에 따라 장단점이 있다.\n\t\t- 주 테이블에 두는 경우는 주 테이블만 확인해도 대상 테이블과의 연관관계를 확인할 수 있다.\n\t\t-  반면에 대상 테이블에 두는 경우는 일대다로의 확장이 좋다는 장점이 있지만 양방향 매핑을 무조건 해야한다는 단점이 있다.\n\n### **@OneToMany는 괜찮나?**\n\n- 양방향일 때 외래키를 관리하는 쪽(연관관계의 주인)은 다 쪽이다.\n- 일(One)쪽에는 다의 존재를 알 수 있는 방법이 없다.\n- 그러면 마찬가지로 Lazy loading을 못할까? 그렇지 않다.\n\t- 이유는 컬렉션이다. 컬렉션이기에 null을 표현할 방법이 있다. \n\t- 무조건 프록시 객체를 만들어놓고 막상 조회해보니 없어 미안! 하고 빈 컬렉션을 리턴하면 표현이 가능하다! (null을 리턴하지 않고 null과 같이 연관 관계가 없음을 표현할 size=0이 있기 때문이다.\n    \n### 상속관계 매핑\n    \n1. 상속관계 매핑이 무엇인가요?\n\t- 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑하는 것\n    \n2. 상속관계 매핑의 목적이 무엇인가요?\n\t- 객체는 상속관계가 존재하지만, 관계형 데이터베이스는 상속 관계가 없다. \n\t- 이러한 OOP와 ORM의 패러다임 불일치를 해결하기 위해 다양한 전략이 사용된다.\n    \n3.  방법 3가지?\n\t- 조인 전략, 단일 테이블 전략. 구현 클래스마다 테이블 전략\n    \n4.  각각 장단점?\n\n\t1. 조인 전략\n\t\t- ![](brain/image/dog-week08-3.png)\n        \n\t\t**장점**\n        \n        -   테이블 정규화\n        -   외래 키 참조 무결성 제약조건 활용 가능\n        -   저장공간 효율\n        \n        **단점**\n        \n        -   조회 시 조인을 많이 사용, 성능 저하\n        -   조회 쿼리 복잡함\n        -   데이터 저장 시 INSERT SQL 2번 호출\n        -   단일 테이블에 비해 복잡하다.\n        \n\t2. 단일 테이블 전략\n\t\t- ![](brain/image/dog-week08-4.png)\n        \n        **장점**\n        \n        -   조인이 필요 없으므로 조회 성능이 빠르다\n        -   조회 쿼리가 단순하다\n        \n        **단점**\n        \n        -   자식 엔티티가 매핑한 컬럼은 모두 null 허용\n        -   단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있는 상황에 따라서 조회 성능이 오히려 느려질 수도 있다.\n        \n\t3. 구현 클래스마다 테이블 전략\n\t\t- ![](brain/image/dog-week08-5.png)\n        \n        **장점**\n        \n        -   서브타입을 명확하게 구분해서 처리할 때 효과적\n        -   NOT NULL 제약조건 사용 가능\n        \n        **단점**\n        \n        -   여러 자식 테이블이 함께 조회할 때 성능이 느림\n        -   자식 테이블을 통합해서 쿼리하기 어려움\n        \n        ⇒ **추천 X**\n        \n### 선학님 질문\n\n1. **fetch Join 과 join의 차이점은 뭘까요?**\n\t- 답 : fetch Join = 조회하는 쿼리에서 단일 게시물이 갖고 있는 데이터를 하나의 쿼리문으로 조회\n\t- Join = 조회하는 쿼리에서 단일 게시물이 갖고있는 pk값만 조회 후 조회 쿼리 N번 수행 (FetchType.EAGER) 일시, 즉 fetch Join은 조회 주체 엔티티와 연관 관계 엔티티, 2개의 엔티티 모두 영속성 컨텍스트로 관리\n\t- 일반 Join은 조회 주체가 되는 엔티티만 조회하고 영속화\n        \n2. **OSIV에 단점을 설명해 주시고 이러한 단점이 있는데 실무에서 사용을 할까요?**\n\t- 답 : 실무에서 관리자 즉 Admin Application에서는  OSIV를 true로 사용하고 실시간 트래픽이 중요한 Application에서는 성능이 더 중요하기 때문에 false로 설정합니다. (대규모 서비스에 예제)\n\t- 소규모 서비스는 보통 true로 설정하고 진행\n        \n3. **One-To-One 관계에서 Lazy 로딩이 특정 조건에서 사용되는데 어디쪽에서 동작을 할까요?**\n\t- 답 : 연관관계 주인 Entity 측에서 Lazy 로딩이 작동\n        \n4. **그렇다면 3번 문제에서 Lazy로딩이 연관관계 주인쪽에서만 동작한다고 했는데 이를 해결하는 방법은 뭐가 있을까요?**\n\t- 답 : fetch Join을 활용해야한다.\n        \n5. **fetch Join을 활용했을때에 단점은 뭐가 있을까요?**\n\t-  답: 연관관계 주인 테이블이 무거워지는 단점이 있습니다.\n        \n6. **그렇다면 실무에서는 어떤게 더 좋은 방향일까요?**\n\t- 답: 실제 상황에 따라 트레이드 오프를 고려해서 선택하면 됩니다.\n        \n7. **JPA 사용 시 성능 저하 위험이 있는데 이는 어떤 위험도를 가지고 있을까요?**\n\t- 답 : 객체 간의 맵핑 설계를 잘못했을 때 성능저하 + 자동으로 생성되는 쿼리가 개발자가 의도하지 않는 쿼리로 인해 성능이 저하됩니다.\n\n8. **연관관계를 사용하면 FK를 걸어줘야하는데 실무에서는 사용할까요?**\n\t- 답 : 회사 By 회사\n\t- 이유는 : FK 자체가 데이터베이스를 샤딩하는 데 방해가 되고 FK가 성능에 영향을 미칠 수도 있습니다. 이런거 때문에 대규모 프로젝트를 할때는 연관관계를 걸지 않습니다. 그냥 @Column으로 정의해주고 JPQL 혹은 QueryDSL로 조인을 걸어서 사용합니다.\n\n\u003chr\u003e\n\n## 참고\n\n- \u003ca href='https://velog.io/@modsiw/JPAJava-Persistence-API%EC%9D%98-%EA%B0%9C%EB%85%90' target='_blank'\u003emodsiw님의 JPA 정리 게시글\u003c/a\u003e\n- \u003ca href='https://incheol-jung.gitbook.io/docs/study/jpa/2020-04-07-jpa-chap1' target='_blank'\u003eIncheol님의 김영한님 JPA 책 정리 게시글\u003c/a\u003e\n- \u003ca href='https://ultrakain.gitbooks.io/jpa/content/chapter1/chapter1.3.html' target='_blank'\u003eultrakain gitbooks - JPA\u003c/a\u003e","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/dog-study/dog-week09":{"title":"9주차 - Spring 심화","content":"\n\u003e[!note] 9주차 스터디\n\u003e\u003cbr\u003e\n\u003e **TOPIC** \u003cbr\u003e\n\u003e - Querydsl\n\u003e - Spring Batch\n\u003e - Monolithic vs MSA\n\u003e - DDD\n\n\u003cbr\u003e\n\n## Querydsl\n\n==**Querydsl은 정적 타입을 이용하여 SQL, JPQL 같은 쿼리를 코드로 작성할 수 있도록 도와주는 빌더 오픈소스 프레임워크이다.**==\n\n\u003cbr\u003e\n\n### 사용 이유\n\n1. 문자가 아닌 **코드**로 작성\n2. ==컴파일 시점에 문법 오류 발견==\n3. IDE의 도움을 받아 코드 자동완성 가능\n\t- 수십개의 칼럼명을 외우고 다닐거 아니잖아. \n4. 단순하고 쉽고 코드 모양이 JPQL과 거의 비슷함\n5. ==복잡한 쿼리나 동적 쿼리 작성 수월==\n6. 자바 \"코드\"이기 때문에 메서드 추출과 같은 기능을 이용해 재사용 가능\n7. ==원하는 필드만 뽑아서 DTO로 만드는 기능도 지원==\n\n\u003cbr\u003e\n\nJPA의 특징 중 메서드 이름만으로 JPQL 쿼리를 생성하는 것이 있다.\n\n```java\npublic interface MemberRepository extends JpaRepository\u003cMember, Long\u003e {\n\tList\u003cMember\u003e findByName(String username);\n}\n```\n\n\u003cbr\u003e\n\n```java\nList\u003cMember\u003e member = memberRepository.findByName(\"hello\");\n\n// 실행된 SQL\n// SELECT * FROM MEMBER M WHERE M.NAME = 'hello'\n```\n\n\u003cbr\u003e\n\n혹은, `@Query`를 사용해서 직접 JPQL을 지정할 수 있다.\n\n```java\npublic interface MemberRepository extends JpaRepository\u003cMember, Long\u003e {\n\t@Query (\"select m from Member m where m.username = ?1\")\n\tMember findByName(String username, Pageable pageable);\n}\n```\n\n\u003cbr\u003e\n\n여기서 문제가 발생하는데, ==**SQL, JPQL은 문자열로 작성하기 때문에 컴파일 시점에서 오류가 발생했는 지 알 수 없다.**== 예를 들어, `select m from Memberrr` 이렇게 오타가 났다고 하자. 문자열로 쿼리를 작성했으니 컴파일 시점에 오류를 알 수 없고 런타임 시점이 되어서야 JPQL에 문제가 있음을 파악할 수 있다.\n\n\u003cbr\u003e\n\n특히, Querydsl의 강점은 동적 쿼리를 다룰 때 나타난다. Spring Data JPA를 다룰 때 동적쿼리를 다루는 것을 보면, 코드가 사람이 직관적으로 이해하기 너무 힘들고 수많은 버그의 향연이 펼쳐질 수 있다. JPA Criteria를 쓴다고 해도 이 문제는 해결하기 힘들다.\n- 이런 이유로, where, and 같은 것을 다룰 때나 동적쿼리를 다룰 때 Mybatis가 아주 편하기 때문에 많이 사용되는 것이다.\n- 하지만, 우리는 JPA를 포기할 수 없다... 그래서 Querydsl 등장!\n\n\u003cbr\u003e\n\n### 사용 방법\n\n1. gradle에서 세팅을 마치고 `compileQuerydsl`  실행\n2. `@Entity`로 등록된 자바 파일을 기반으로 `QClass` 라는 Querydsl 전용 객체가 생성됨\n\t- 컴파일 단계에서 엔티티를 기반으로 생성된 것이 QClass\n3. `JpaQueryFactory 생성자`에 `EntityManager`를 주입해주고 `Q 파일` 인스턴스를 생성해서 사용하면 됨 (물론, JpaQueryFactory는 빈으로 등록해놔야 함)\n\n```java\n// JpaQueryFactory 빈으로 등록\n\n@Configuration\npublic class QuerydslConfiguration {\n    @Autowired\n    EntityManager em;\n\n    @Bean\n    public JPAQueryFactory jpaQueryFactory() {\n       return new JPAQueryFactory(em);\n    }\n}\n```\n\n\u003cbr\u003e\n\n```java\nJpaQueryFactory query = new JpaQueryFactory();\nQMember m = QMember.member;\n\nList\u003cMember\u003e hello = query\n\t\t\t\t.selectFrom(m)\n\t\t\t\t.where(m.age.gt(18).and(m.name.contains(\"hello\")))\n\t\t\t\t.fetch();\n```\n\n\u003cbr\u003e\n\n동적 쿼리도 코드로써 아주 쉽게 다룰 수 있음.\n- 예제에서는 `Boolean Builder`를 설명했지만, 실제로 if문이 많아지면 어떤 동적쿼리인지 파악하기 힘드니까 `BoolenExpression`을 사용하도록 하자.\n\n```java\nString name = \"member\";\nint age = 12;\n\nQMember m = QMember.member;\n\nBooleanBuilder builder = new BooleanBuilder();\nif (name != null) {\n\tbuilder.and(m.name.contains(name));\n}\nif (age != 0) {\n\tbuilder.and(m.age.gt(age));\n}\n\nList\u003cMember\u003e list =\n\tquery.selectFrom(m)\n\t\t.where(builder)\n\t\t.fetch();\n```\n\n\u003cbr\u003e\n\n### 많이하는 질문\n\n1. ORM 프레임워크를 사용하면 SQL과 DB는 잘 몰라도 되나?\n\t- 오히려 더 잘 알아야함. ORM은 객체와 SQL 사이를 매핑해주는거라 더 잘 알아야함\n2. 성능이 느리진 않은가?\n\t- 오히려 잘 쓰면 최적화 포인트가 더 많음\n3. 통계 쿼리처럼 매우 복잡한 SQL은 어떻게?\n\t- 거의 다 Querydsl로 DTO로 바로 뽑아버린다.\n\t- 진짜 필요한 상황이라면 MyBatis를 붙여서 네이티브 쿼리를 쓴다\n\n\u003chr\u003e\n\n## Spring Batch\n\n\u003cbr\u003e\n\n### 배치 애플리케이션\n\n**batch** : (명사) 집단, (동사) 일괄 처리를 위해 함께 묶다\n\n**배치 처리** : 컴퓨터에서 사람과 ==상호 작용 없이== 이어지는 프로그램(작업)들의 실행\n- 사람과의 상호작용이 주력인 웹 애플리케이션과는 지향점이 다르다.\n\n**Web** - 실시간 처리 / 상대적인 속도 / QA 용이성\n- 개발자가 인지하지 못했던 부분을 QA가 잘 찾아줄 수 있음\n\n**Batch** - 후속 처리 / 절대적인 속도 / QA 복잡성\n- QA가 DB 까보고 자바 코드 까보지는 않으니까 힘들다\n\n\u003cbr\u003e\n\n==**배치 애플리케이션 : 개발자가 정의한 작업을 한 번에 일괄처리하는 애플리케이션, 단발성으로 대용량의 데이터를 처리하는 애플리케이션**==\n- ex) 매출 데이터를 이용한 일매출 집계\n- ex) 매우 큰 데이터를 활용한 보험급여 결정\n- ex) 트랜잭션 방식으로 포맷, 유효성 확인 및 처리가 필요한 내부 및 외부 시스템에서 수신한 정보를 기록 시스템으로 통합\n- ex) 대용량 데이터를 활용한 크롤링을 해야한다. 사용자의 접속이 거의 없는 시간대에 주기적으로 시도하기 위해 배치를 적용할 수도 있음\n\n\u003cbr\u003e\n\n==**배치 애플리케이션이 필요한 상황**==\n- **일정 주기**로 실행해야 할 때\n- 실시간 처리가 어려운 **대량의 데이터**를 처리해야 할 때\n- 어떤 작업을 하나의 애플리케이션에서 수행하면 성능 저하를 유발할 수 있으니 배치 애플리케이션을 구현해보자.\n\n\u003cbr\u003e\n\n==**웹 애플리케이션이 아닌 배치 애플리케이션으로 하는 이유**==\n\n- 전 날의 데이터를 집계하는 상황에, 웹 애플리케이션(톰캣 + Spring MVC)를 이용한다면, 아주 큰 데이터를 읽고, 가공하고, 저장하는 동안에 해당 서버는 순식간에 CPU, I/O 등의 자원을 다 써서 다른 요청을 처리하지 못하게 될 것\n- 집계 기능이 하루에 1번만 수행된다고 하면, 이 기능을 위해 API를 구성하는 것은 낭비\n- 데이터가 너무 많아서 처리 중 실패하면, 다시 처음부터 해야하는데, 이어서 할 수 없을까\n\n\u003cbr\u003e\n\n==**배치 애플리케이션의 조건**==\n\n-   대용량 데이터 : 배치 어플리케이션은 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리를 할 수 ​​있어야 함\n-   자동화 : 배치 어플리케이션은 심각한 문제 해결을 제외하고는 **사용자 개입 없이 실행**되어야 함\n-   견고성 : 배치 어플리케이션은 잘못된 데이터를 충돌/중단 없이 처리할 수 있어야 함\n-   신뢰성 : 배치 어플리케이션은 무엇이 잘못되었는지를 추적할 수 있어야 함 (로깅, 알림)\n-   성능 : 배치 어플리케이션은 **지정한 시간 안에 처리를 완료**하거나 동시에 실행되는 **다른 어플리케이션을 방해하지 않도록 수행**되어야 함\n\n\u003cbr\u003e\n\n### 배치 vs 스케쥴러\n\n**스케쥴링이란?** : 매 시간, 지정한 시간에 지정한 동작을 수행하는 행위\n- 일괄처리를 뜻하는 배치와는 다른 의미이다.\n\nSpring Batch와 스케쥴러인 Spring Quartz를 비교하는 경우가 있는데 이는 잘못된 비교이다.\n- 둘의 역할은 완전 다름\n- Quartz는 스케쥴러의 역할이다. **Batch처럼 대용량 데이터 배치 처리에 대한 기능 지원 X**\n- Batch는 배치 처리의 역할이다. **Quartz처럼 다양한 스케쥴 기능 지원 X**\n- 따라서, 보통 Batch와 Quartz를 조합해서 함께 사용\n\n==**정해진 스케쥴마다 Quartz가 Spring Batch를 실행하는 구조**==\n\n\u003cbr\u003e\n\n### 배치 도메인 용어\n\n![](brain/image/dog-week09-1.png)\n\n- **Job** : 배치처리 과정을 하나의 단위로 만들어 놓은 객체\n\t- JobInstance : 논리적인 Job의 실행 단위, JobParameters를 이용하여 구분\n\t\t- ex) 1월 1일 실행, 1월 2일 실행 ...\n\t- JobParameters : String, Double, Long, Date 4가지 형식만 지원\n\t- JobExecution : JobInstance에 대한 실행 시도 관련 객체\n\t\t- 상태/시작시간/종료시간/생성시간 등의 정보 가짐\n- **JobLauncher** : Job을 실행하기 위한 런처\n- **Step** : 하나의 Job은 여러 Step으로 구성될 수 있음\n\t- Item : 작업에 사용하는 데이터를 의미\n\t- ItemReader : Step에서 Item을 읽어오는 인터페이스\n\t- ItemWriter : 처리된 Data를 Writer 할 때 사용, **기본적으로 Item을 Chunk로 묶어 처리**\n\t- ItemProcessor : Reader에서 읽어온 item 데이터를 처리하는 역할\n- **JobRepository** : Job, JobLauncher, Step에 대한 정보 관리\n\n\u003cbr\u003e\n\n![](brain/image/dog-week09-2.png)\n\n- **Step** : Batch Job의 독립적이고 순차적인 단계를 함축한 Domain 객체\n\t- 고유한 JobExecution과 관련된 개별 **StepExecution 존재**\n- **StepExecution** : Step의 단일 실행을 시도하는 기술적인 개념, 각각의 Step 마다 StepExcecution이 생성되며, Step이 실패하면 이후 Step을 실행하지 않음\n\t- 각 Step에는 ExecutionContext를 포함\n- **ExecutionContext** : 통계, 상태 정보와 같이 일괄 실행에서 유지해야하는 모든 데이터를 의미. 재시작에 용이한 것이 이것 때문\n\n\u003cbr\u003e\n\n### Spring Batch 활용\n\n![](brain/image/dog-week09-3.png)\n\n- 프레임워크를 이용하기 때문에 JobLanucher, JobRepository는 고려 X\n\n\u003cbr\u003e\n\n![](brain/image/dog-week09-4.png)\n\n- Job은 여러 개의 Step, Step은 여러 개의 Tasklet으로 구성\n\t- Tasklet은 하나의 메서드로 구성되어 있는 간단한 인터페이스\n\t- 이 메서드는 실패를 알리기 위해 예외를 반환하거나 throw 할 때까지 execute 반복호출\n- Tasklet은 **익명 Tasklet** / **Chunk Oriented Tasklet**으로 나뉨\n\n\u003cbr\u003e\n\n![](brain/image/dog-week09-5.png)\n\n==**Chunk 지향 처리**== \n- Spring Batch에서 Chunk는 **커밋 row 수**를 의미\n- 배치 처리에서 commit되는 row 수라는 의미는 chunk 단위로 트랜잭션을 수행하니까 실패시 chunk 단위 만큼 rollback 된다는 의미\n- 읽기(Read) : Database에서 배치처리를 할 Data를 읽어옴\n- 처리(Processing) : 읽어온 Data를 가공, 처리 (필수사항X)\n- 쓰기(Write) : 가공, 처리한 데이터를 Database에 저장\n\n\u003cbr\u003e\n\n==**Spring Batch에는 다양한 ItemReader, ItemWriter가 존재**==\n- 대용량 배치 처리 시, Item을 읽어올 때 Cursor 기반 처리보다 Paging 처리하는 것이 효과적\n\t- Cursor 기반 처리는 데이터를 한 건씩 처리 + 모든 결과를 메모리에 할당해서 메모리 사용량 증가 + 모든 데이터 처리까지 커넥션 유지 + 멀티스레드 환경에서 동시성 이슈 발생으로 동기화 처리 필요\n\t- Paging 기반 처리는 페이지 사이즈만큼 데이터를 한 번에 처리 + 페이지 사이즈 만큼 커넥션을 맺고 끊음 + 페이징 결과만 메모리에 할당 + 멀티스레드 환경에서 thread-safety를 보장하여 별도 동기화 처리 불필요\n- Spring Batch Reader에서 이러한 Paging 처리 지원\n- 적절한 Paging 처리 + Chunk Size(한 번에 처리될 트랜잭션)를 설정하여 효과적인 배치 처리 가능\n\n\u003cbr\u003e\n\n==**Paging Size와 Chunk Size를 동일하게 설정하는 것을 권장**==\n- 예를 들어, Paging size가 5, Chunk size가 10인 경우 2번의 read 이후 1번의 트랜잭션 수행됨\n- 즉, 한 번의 트랜잭션을 위해 2번의 쿼리 수행이 발생하는 것\n- 1번의 read 쿼리 수행 시 1번의 트랜잭션을 위해 두 설정의 값을 일치시키는게 좋은 성능 향상방법\n\n\u003cbr\u003e\n\n### Batch 실행\n\n==**스프링 배치 실행 방법**==은 크게 두가지로 나뉨\n1. **커맨드 라인 러너(CommaindLineRunner)** : jar로 만들어놓고 CLI로 실행\n2. **애플리케이션 러너(ApplicationRunner)** : 자바 코드 내에서 실행\n\n\u003cbr\u003e\n\n==**스프링 배치 관리 도구**==\n- Cron\n\t- 리눅스 작업 스케쥴러대로 jar 실행\n- Spring MVC + API Call\n\t- 코드 내에 rest api 같이 만들어놓고 호출해서 실행하는 방법\n\t- 권장하지 않음\n- Spring Batch Admin\n\t- Deprecated 되었음\n- ==**Quartz + Admin**==\n\t- 스케쥴러 프레임워크 + 관리자 페이지 구현\n- ==**CI Tool (Jenkins, Teamcity 등등)**==\n\n\u003cbr\u003e\n\nCI Tool과 Spring Batch가 너무 잘어울린다. Jenkins의 장점을 살펴보면\n\n- **Integration** (Slack, Email 등)\n\t- 실패하면 성공하면 슬랙이나 이메일로 알림 보내! 메일 보내!\n- **실행 이력 / 로그 관리 / Dashboard** 등 UI가 잘되어있음\n- **다양한 실행 방법**\n\t- Rest API / 스케쥴링 / 수동 실행\n- **계정 별 권한 관리**\n- **파이프라인**\n\t- ![](brain/image/dog-week09-6.png)\n\t- Job 내부에 Step을 여러 개 설계하는 것보다 젠킨스 파이프라인 내부에 여러 Job을 넣는 것을 권장함\n\t- Job을 단독으로 실행할 수 있도록 설계하는 것이 유지보수에 더 좋아서\n- **Web UI + Script** 둘 다 사용 가능\n- **Plugin** (Ansible, Github, Logentries 등)\n\n\u003cbr\u003e\n\n### Chunk 최적화\n\n- 구체적인 가이드 존재 X\n- 설계한 비즈니스 로직에 대해 가장 효율적인 단위 설정해야 함\n- 여러 개의 배치 작업을 구성하는 경우, 다른 배치 작업에 영향 주면 안됨\n\t- 스프링 배치에서는 chunk 사이즈만큼 메모리에 데이터를 적재해야 하기 때문에 다른 배치에서 사용할 수 있는 메모리가 줄어들 수 있음\n\n\u003chr\u003e\n\n## 아키텍처\n\n### 모놀리식 아키텍처\n\n==**모놀리식 아키텍처 (Monolithic Architecture)**==\n- 전통의 아키텍처를 지칭\n- 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어 있는 형태\n- 애플리케이션의 한 프로세스에 대한 수요가 급증하면 아키텍처 전체를 확장해야함\n- 일반적으로 성능 향상을 위해 서버 스펙을 향상시키는 scale up을 고려\n\n\u003cbr\u003e\n\n==**모놀리식 아키텍처에서 프로젝트 규모가 너무 커지면 어떻게 분리할까?**==\n- **멀티 모듈**을 이용하여 분리\n- 응집도는 커지되, 결합도는 낮아짐\n\n\u003cbr\u003e\n\n==**모놀리식 아키텍처에서 배포속도가 느린 단점을 완화하는 방식은?**==\n- 무중단 배포 이용\n\t- 블루-그린 배포\n\t- 카나리 배포\n\t- 롤링 배포\n\t- 위에서부터 주로 사용하는 것 순서\n\t- \u003ca href='https://hudi.blog/zero-downtime-deployment/' target='_blank'\u003e링크 참조\u003c/a\u003e\n\n\u003cbr\u003e\n\n### MSA\n\n==**마이크로 서비스 아키텍처 (MSA, Micro Service Architecture)**==\n- 하나의 큰 애플리케이션을 여러 개의 작은 서비스 유닛으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처\n- 각 마이크로 서비스는 상호 통신 가능 -\u003e 이를 통해 전체 서비스 구성\n- 애플리케이션이 독립적인 구성 요소로 구축, 각 애플리케이션 프로세스가 서비스로 실행\n\t- 이러한 서비스는 경량 API를 사용하여 잘 정의된 인터페이스를 통해 통신\n\t- 서비스는 비즈니스 기능을 위해 구축, 서비스마다 한 가지 기능을 수행\n\n\u003cbr\u003e\n\n==**MSA의 장애추적, 모니터링, 매니징의 어려움과 같은 단점을 해결할 수 있는 방안?**==\n- ELK (ElasticSearch 분석엔진 , Logstash 데이터 수집 및 로그 파싱 엔진, Kibana 분석 및 시각화 플랫폼)\n- EFK (데이터 콜렉터를 Logstash가 아닌 Fluentd를 사용)\n\n\u003cbr\u003e\n\n==**MSA의 테스트/트랜잭션을 다루기 어려움과 같은 단점을 해결할 수 있는 방안?**==\n-   보상 트랜잭션 : 한 트랜잭션 처리에서 오류 발생 시, 에러 처리 로직을 구현해줌으로써 트랜잭션 일관성 유지\n-   복합 서비스 : 트랜잭션을 묶어야 하는 두 개의 시스템을 트랜잭션을 지원하는 네이티브 프로토콜을 이용해서 구현 후 API로 노출시키는 방법\n-   유즈케이스를 하나 두는거! 이 데이터가 맞아!? 아냐!? 검증해주는 역할\n\n### 모놀리식 vs MSA\n\n-   ==**Monolithic(모놀리식)**==\n    -   장점\n        -  개발 환경이 같아서 복잡하지 않다. 소규모 테스트에서 합리적\n        -  개발, 빌드, 배포, 테스트가 용이\n\t        - End-To-End 테스트가 용이 (MSA의 경우 필요한 서비스들을 모두 동작시켜야함)\n\t    - 서비스 간 통신을 위해 네트워크를 타지 않아도 돼서 빠르다\n    -   단점\n        -   프로젝트가 커지면 **빌드, 배포 시간이 오래걸린다.**\n        -   작은 수정사항이 있어도 전체를 다시 빌드하고 배포해야 함\n        -   많은 양의 코드가 몰려있어 개발자가 모두를 이해하는데 어렵고 유지보수하기도 어렵다.\n        -   **일부분의 오류가 전체에 영향을 미친다.**\n-   ==**MSA**==\n    -   장점\n        -   서비스 단위로 개발을 진행하기에 해당 부분을 온전히 이해하기 쉽다.\n        -   독립적인 서비스로 배포가 빠르고 모놀리식보다 가벼움\n        -   각 서비스에 따라 개별적으로 서버를 나눌 수 있어 메모리 및 cpu 관리에 효율적\n        -   **새로 추가되는 부분은 빠르게 수정 및 배포가 가능하다.**\n        -   해당 기능에 맞는 기술, 언어 등을 선택하여 사용할 수 있다.\n        -   **문제가 생기면 해당 기능에만 문제가 생긴다.**\n\t        - 서버 및 프로세스 장애 시, 격리 및 복구가 쉬워 장애가 전체 서비스로 확장될 가능성이 적음\n    -   단점\n        -   **서비스가 분산되어 있어 관리하기 어렵다.**\n\t        - 트랜잭션 관리, 장애 추적 및 테스트 등이 쉽지 않음\n\t        - 서비스마다 DB가 분리되어 데이터의 조회가 어렵고 데이터의 중복 발생\n        -   **테스트가 불편하다.**\n        -   서비스 간 호출 시 REST API 사용으로 인한 통신비용, Latency(지연시간) 증가\n        - 전체 서비스가 커짐에 따라 복잡도가 기하급수적으로 높아질 수 있음\n\n\n\u003chr\u003e\n\n## DDD\n\n**도메인(domain)**\n- 사용자가 사용하는 것, 소프트웨어로 해결하고자 하는 문제 영역\n- 비즈니스 영역\n\n==**DDD(Domain-Driven-Design, 도메인 주도 설계) : 도메인에 관련된 문제를 해결하도록 도메인 패턴을 중심에 놓고 설계하는 방식**==\n- 일반적으로 사용하는 데이터 중심의 접근법을 탈피하여 순수한 도메인의 모델과 로직에 집중\n- 복잡한 도메인을 해결하는 것을 높은 우선순위로 생각해 서비스를 만들어 나가는 방법\n- 도메인의 복잡성을 조금 더 쉽게 다룰 수 있게 도와주는 도구\n\n\u003cbr\u003e\n\n예를 들어, 개발 프로세스를 생각해보자\n\n![](brain/image/dog-week09-7.png)\n\n1. 요구사항 분석\n2. 설계\n3. 구현\n\n\u003cbr\u003e\n\n![](brain/image/dog-week09-8.png)\n\n- 개발자가 모델링 과정에서 참여하지 않았다면 이렇게 불일치가 발생할 수 있음\n- 이로 인해 DDD는 **보편적인(ubiquitous) 언어**의 사용이라고 함\n\t- 도메인 전문가와 소프트웨어 개발자 간의 커뮤니케이션 문제를 없앰\n\t- 상호가 이해할 수 있고 모든 문서와 코드에 이르기까지 동일한 표현과 단어로 구성된 단일화된 언어체계를 구축해나가는 과정임\n\n\u003cbr\u003e\n\n==**데이터 주도 설계?**==\n- 객체가 가져야 할 데이터에 초점을 두고 설계하는 방식\n- 객체 자신이 포함하고 있는 데이터를 조작하는 데 필요한 행동을 정의\n\n```java\npublic class Movie {\n    private String title;\n    private Duration runningTime;\n    private Money fee;\n    private List\u003cDiscountCondition\u003e discountConditions;\n\n    private MovieType movieType;\n    private Money discountAmount;\n    private double discountPercent;\n\n    // getter, setter..\n}\n```\n\n- 설계 시 협력에 대한 고민을 하지 않아서 **과도한 접근자와 수정자가 탄생**\n\t- 객체가 어디서 사용될 지 모르니까 최대한 많이 만들어서 그럼\n- 대부분의 구현이 노출되기 때문에 **캡슐화의 원칙을 위배함**\n- 내부 구현이 public interface에 노출되며, 이때문에 다른 객체들과 **강하게 결합**함\n\n\u003cbr\u003e\n\n### DDD 사용 이유\n\n- 도메인 모델의 적용 범위를 구현까지 확장하여 도메인 지식을 구현 코드에 반영\n- 공통의 언어(유비쿼터스 언어)를 사용하여 도메인과 구현을 충분히 만족하는 모델 생성\n- 실제 코드로 구현 가능한 현실성 있는 도메인 모델 분석과 그것을 추상화하는 설계\n- 쉽게 말해서, ==**모듈간의 의존성 최소화 (결합도 낮추기), 응집성 최대화 하는 것이 목표**==\n\n\n\u003chr\u003e\n\n## 참고\n\n- \u003ca href='https://ittrue.tistory.com/292' target='_blank'\u003eQuerydsl이란\u003c/a\u003e\n- \u003ca href='https://www.youtube.com/watch?v=zMAX7g6rO_Y' target='_blank'\u003e이동욱님의 우아콘2020, 수십억건에서 Querydsl 사용하기\u003c/a\u003e\n- \u003ca href='https://velog.io/@youngerjesus/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%98%95%EC%A0%9C%EB%93%A4%EC%9D%98-Querydsl-%ED%99%9C%EC%9A%A9%EB%B2%95' target='_blank'\u003e우아한 형제들의 Querydsl 활용법\u003c/a\u003e\n- \u003ca href='https://www.youtube.com/watch?v=BnS6343GTkY' target='_blank'\u003e김영한님의 우아콘2020, 배달의민족 마이크로서비스 여행기\u003c/a\u003e\n- \u003ca href='https://jojoldu.tistory.com/324?category=902551' target='_blank'\u003e이동욱 님의 Spring Batch 가이드\u003c/a\u003e\n- \u003ca href='https://khj93.tistory.com/entry/Spring-Batch%EB%9E%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0' target='_blank'\u003e히진쓰의 서버사이드 기술 블로그 Spring Batch란? 이해하고 사용하기\u003c/a\u003e\n- \u003ca href='https://heowc.dev/programming-study/repo/spring/spring-batch/domain-launage-of-batch.html' target='_blank'\u003e허원철의 개발 블로그 - spring batch\u003c/a\u003e\n- \u003ca href='https://www.youtube.com/watch?v=_nkJkWVH-mo' target='_blank'\u003e이동욱님의 우아한테크세미나2019, 우아한 스프링배치\u003c/a\u003e\n- \u003ca href='https://www.youtube.com/watch?v=1xJU8HfBREY\u0026t=49s' target='_blank'\u003e테코톡 - 라빈의 Spring Batch\u003c/a\u003e\n- \u003ca href='https://www.youtube.com/watch?v=VIfNipL5KkU' target='_blank'\u003e테코톡 - 라테의 도메인 주도 설계\u003c/a\u003e\u0004\n- \u003ca href='https://incheol-jung.gitbook.io/docs/q-and-a/architecture/ddd' target='_blank'\u003eIncheol's TECH BLOG - DDD\u003c/a\u003e","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/iv/":{"title":"기술면접 대비","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/iv/db":{"title":"면접 - 데이터베이스","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/iv/dsAlgo":{"title":"면접 - 자료구조/알고리즘","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/iv/java":{"title":"면접 - Java","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/iv/network":{"title":"면접 - 네트워크","content":"\n\u003cdetails\u003e\u003csummary\u003e6-1. HTTP란 무엇인지 설명해주세요. (창작 문제)\u003c/summary\u003e\n\n  \n\n\u003cbr\u003e\n\n  \n\n- HTTP(HyperText Transfer Protocol)는 문서 간 링크를 통하여 연결할 수 있는 HTML 같은 Hyptertext를 전송하는 프로토콜\n\n  \n\n- 애플리케이션 레이어에 위치\n\n  \n\n\u003c/details\u003e\n\n  \n\n\u003cbr\u003e","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/iv/os":{"title":"면접 - 운영체제","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/iv/spring":{"title":"면접 - Spring","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Interview/iv/web":{"title":"면접 - 웹/공통","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/":{"title":"Java","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/GC":{"title":"Garbage Collector","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/JVM":{"title":"Java Virtual Machine","content":"\n","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/Java":{"title":"Java 특징","content":"\n1996년 01월에 공식적으로 발표한 객체지향 프로그래밍 언어\n- [Java의 실행 원리](brain/Java/JavaExecute)는 너무나 중요하다.\n- 대표적인 [Java 버전](brain/Java/JavaVersion)은 Java 8, Java 11, Java 17이다.\n- 다양한 [환경설정](brain/Java/java-settings)을 통해 편리하게 사용하자\n\n\u003cbr\u003e\n\n## Java의 특징\n\n1. ==**운영체제에 독립적**==\n\t- Java Application은 운영체제나 하드웨어가 아닌 [JVM](brain/Java/JVM)하고만 통신\n\t- JVM이 Java Applcation으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달\n\t- Java로 작성된 프로그램은 운영체제에 독립적, JVM은 운영체제에 종속적\n\t- **한번 작성하면, 어디서나 실행된다(Write once, run anywhere)**\n\n2. 객체지향언어\n\t- 상속, 캡슐화, 다형성이 잘 적용된 순수 객체지향언어\n\n3. ==**자동 메모리 관리(Garbage Collection)**==\n\n\t- [Garbage Collector](brain/Java/GC)가 자동적으로 메모리 관리\n\t- 프로그래머가 보다 프로그래밍에 집중할 수 있게\n\n4. 네트워크, 분산처리 지원\n\t- 다양한 네트워크 프로그래밍 라이브러리(Java API) 지원\n\n5. ==**멀티스레드 지원**==\n\t- Java에서 개발된 멀티스레드 프로그램은 시스템과 관계없이 구현가능\n\t- 여러 스레드에 대한 [스케쥴링(scheduling)](brain/CS/OS/Scheduling)을 자바 인터프리터가 담당\n\n6. ==**동적 로딩(Dynamic Loading)을 지원**==\n\t- Java Application은 여러 개의 클래스로 구성\n\t- 동적 로딩 덕분에 실행 시 모든 클래스 로딩 X\n\t- 필요 시점에 클래스를 로딩 O\n\t- 일부 클래스가 변경되어도 전체 Application을 다시 컴파일하지 않아도 됨\n\t- 변경사항이 발생해도 비교적 적은 작업으로 유연한 Application 작성 가능","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/JavaExecute":{"title":"Java 실행원리","content":"\n![](brain/image/JavaExecute-1.png)\n\n![](brain/image/JavaExecute-2.png)\n\n![](brain/image/JavaExecute-3.png)\n\n![](brain/image/JavaExecute-4.png)","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/JavaVersion":{"title":"Java 버전별 특징","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/design/":{"title":"Design Pattern","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/design/behavioral/":{"title":"Behavioral","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/design/creational/":{"title":"Creational","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/design/structural/":{"title":"Structural","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Java/java-settings":{"title":"Java 환경설정","content":"\n\u003chr\u003e\n\n## Java 코딩 컨벤션\n\n- 클래스 이름 : 대문자로 시작\n\n- 패키지 이름 : 모두 소문자로\n\n- public 클래스는 단 하나, public 클래스 이름과 자바 파일이름은 동일하게\n\n- 변수, 메서드 이름 : 소문자로 시작, 이름이 길어지는 경우 camel notation이용하여 중간중간 대문자로 구분하기\n\n\u003chr\u003e\n\n## Java settings\n\n### Windows\n\n\u003ca href='https://suzxc2468.tistory.com/141' target='_blank'\u003e환경 변수 설정법 링크\u003c/a\u003e\n\n1. https://www.oracle.com/java/technologies/downloads/ 에서 Java 8에 Java SE Development Kit 8u341를 windows x64 다운로드 받기\n\n2. 검색창 - 내 pc(클릭 X, 마우스 우클릭) 속성 - 고급 시스템 설정 - 환경 변수\n\n\t- 아래 시스템 변수 - 새로 만들기\n\t\t- 변수 이름 : JAVA_HOME\n\t\t- 변수 값 : C:\\Program Files\\Java\\jdk1.8.0_341 (자바 JDK 설치 경로)\n\t- 아래 시스템 변수 - Path - 편집 - 새로 만들기\n\t\t- %JAVA_HOME%\\bin\n\t- 아래 시스템 변수 - 새로 만들기\n\t\t- 변수 이름 : CLASSPATH\n\t\t- 변수 값 : %JAVA_HOME%\\lib\n\n3. 환경변수 설정 이후 확인하려면 cmd에서 `javac -version` 입력\n\n4. 자바11 쓸거면 JAVA_HOME의 JDK 설치 경로만 11로 바꿔주면 됨\n\n\u003cbr\u003e\n\n### WSL2\n\n1. `sudo vi /etc/apt/sources.list`에서 카카오 미러서버 되어있는지 부터 확인\n\t- 안되어 있으면 `%s /기존주소/mirror.kakao.com` 으로 변경하고 저장\n\n2. `sudo apt-get update`로 우분투 패치\n\n3. `sudo apt install openjdk-11-jdk`로 자바11 JDK 설치\n\n\u003cbr\u003e\n\n- 환경설정\n\n1. `which java`로 java 위치 파악, 결과 `/usr/bin/java`로 뜰 것\n\n2. `readlink -f /usr/bin/java` 하면 결과 `/usr/lib/jvm/java-8-openjdk-amd64/bin/java`로 뜰 것, 여기서 `/usr/lib/jvm/java-8-openjdk-amd64`를 기억\n\n3. `sudo vi /etc/environment`에서 기존에 있던거 지우고 `JAVA_HOME=/usr/lib/jvm/java-11-openjdk-arm64` 입력 후 저장\n\n4. `source /etc/environment`로 환경설정 파일 적용\n\n5. `echo $JAVA_HOME`로 JAVA 환경변수 작동 확인. 경로 나오면 제대로 된거\n\n\u003cbr\u003e\n\n- 버전관리\n\n1. \u003ca href='https://codechacha.com/ko/ubuntu-install-open-jdk11/' target='_blank'\u003e블로그 링크\u003c/a\u003e를 따라하려고 했는데.. 나랑은 뭔가 달라서 일단\n\n2. `sudo apt install openjdk-8-jdk`로 자바8 jdk 설치\n\n3. `sudo update-alternatives --config java` 이거 해보면 알아서 적용 되어있음. 아마 환경설정할때 경로 다 날리고 JAVA_HOME만 냅둬서 그런듯\n\n4. 저기서 원하는 모드 선택하면 버전 왔다갔다 끝\n\n\u003cbr\u003e\n\n### Mac (M1)\n\nhomebrew를 이용한 jdk 설치는 인텔 맥을 기반으로 되어있어서, arm 칩셋인 M1은 다른 방식으로 설치하여야 한다.\n\n\u003cbr\u003e\n\n\u003ca href='https://www.azul.com/downloads/?version=java-17-lts\u0026os=macos\u0026architecture=arm-64-bit\u0026package=jdk' target='_blank'\u003ezulu\u003c/a\u003e에서 제공하는 java 버전, ARM-64bit, JDK를 선택하고 설치가 편한 dmg파일로 설치한다.\n\n- `/usr/libexec/java_home -V` : 설치된 자바 버전 목록\n\n- `java -version` : 현재 설정된 자바 버전 (상세한 버전)\n\n- `javac -version` : 현재 설정된 자바 버전 (간단히)\n\n\u003cbr\u003e\n\n이후 환경변수 설정을 위하여 zsh 설정 파일을 연다. (bash 쓰면 bash로)\n\n- `code ~/.zshrc`\n\n- 혹시 zsh 커맨드가 안먹으면 vscode 명령 팔레트에서 **셀 명령 : PATH에 코드 명령 설치**를 이용하여 설치하자.\n\n\n```bash\n# JAVA settings\nexport JAVA_HOME=$(/usr/libexec/java_home -v 1.8)\nalias setJava8='export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)'\nalias setJava11='export JAVA_HOME=$(/usr/libexec/java_home -v 11)'\nalias setJava17='export JAVA_HOME=$(/usr/libexec/java_home -v 17)'\nexport PATH=${PATH}:$JAVA_HOME/bin:\n```\n\n이와 같은 코드를 추가한다. alias를 추가해준 이유는 버전 왔다갔다하면서 사용하려고 추가한 것이다.\n\n\u003chr\u003e\n\n## IntelliJ 단축키\n\n- `psvm` : public static void main\n\n- `sout` : System.out.println()\n\n- `soutv` : System.out.println( 여기다가 연관된 변수 같이 넣어줌 )\n\n- `cmd + D` : 드래그한거 밑에 복제해줌\n\n- `shift + F6` : 복제한거 변수 이름 똑같은거 편하게 바꿀 수 있음\n\n- `option + cmd + V` : 지금 쓰고 있던거 앞에 변수 추가해줌\n\n![](brain/image/화면-기록-2023-03-25-오후-2.47.26.gif)\n\n- `cmd + P` : 메서드 파라미터에 기대되는 값 보기\n\n- `cmd + E` : 최근 파일 목록 열기\n\n- `shift + shift` : 파일 검색\n\n- `control + shift + R` : 내가 찍은걸로 바꿔서 실행\n\n- `control + R` : 지금 찍혀있는걸로 실행\n\n- `control + enter` : Generator 열기\n\n- `/** + enter` : 이쁜 주석문\n\n- `cmd + X` : 한 줄 삭제\n\n- `control + T` : 리팩토링과 관련된 단축키. 예를 들어 method 뽑아낼 때 (검색도 가능)\n\n- `cmd + shift + T` : 테스트케이스 파일 편하게 만들어주기\n\n- `cmd + option + L` : 코드 정렬\n\n- `command + 1` : 왼쪽 메뉴 창으로 이동, esc키 누르면 다시 코드\n\n- `command + N` : 새로운 파일 생성 (패키지든 클래스든)\n\t- 이걸 코드창에서 쓰면 Generator 열기\n\n- 번역 플러그인 (Translation) 설치\n\t- `ctrl + cmd + i` : 번역기 팝업 띄우기\n\t- `ctrl + cmd + u` : 영어 → 한글 번역\n\t- `ctrl + cmd + o` : 한글 → 영어 번역 (변수명 지을 때 편함)\n\n- `command + B` : 정의된 곳으로 이동\n\n\u003chr\u003e\n\n## IntelliJ settings\n\n1. 인텔리제이 pro버전 다운로드 체크는 전부 다 체크하고 맨 밑에 association만 java파일 연관 체크\n\n2. 깃허브 권한 설정으로 아이디 연동\n\n\u003cbr\u003e\n\n### IntelliJ plugins\n\n- Material Theme UI\n\t- 인텔리제이 테마 설정 플러그인\n\t- Monokai Pro 이용 중, 우측 하단에서 설정 가능\n\n![](brain/image/java-settings-1.png)\n\n\u003cbr\u003e\n\n- Atom Material Icons\n\t- 인텔리제이 폴더 아이콘 플러그인\n\n![](brain/image/java-settings-2.png)\n\n\u003cbr\u003e\n\n- CodeGlance Pro\n\t- 코드 우측에 vscode 처럼 작은 화면 뜨는거\n\t- 클릭하면 해당 위치로 바로 이동 가능\n\n![](brain/image/java-settings-3.png)\n\n\u003cbr\u003e\n\n- Commit Message Template\n\t- commit 메시지 템플릿 생성\n\t- Settings - Tools - Commit Message Template\n\t- 좌측 메뉴바 - commit - 연필모양\n\n![](brain/image/java-settings-4.png)\n\n![](brain/image/java-settings-5.png)\n\n![](brain/image/java-settings-6.png)\n\n\u003cbr\u003e\n\n- Embedded Web Browser\n\t- 프로그래머스 같은 문제 풀 때 인터넷 창 띄워놓기\n\t- 우측 메뉴바에 Embedded Web Browser 클릭\n\t- 링크는 찾아서 붙여넣기\n\n![](brain/image/java-settings-7.png)\n\n\u003cbr\u003e\n\n- Key Promoter X\n\t- 마우스로 수행한 동작 단축키 알려줌\n\n![](brain/image/java-settings-8.png)\n\n![](brain/image/java-settings-9.png)\n\n\u003cbr\u003e\n\n- Presentation Assistant\n\t- 키보드로 수행한 동작 단축키 보여줌\n\n![](brain/image/java-settings-10.png)\n\n![](brain/image/java-settings-11.png)\n\n\u003cbr\u003e\n\n- Nyan Progress bar\n\t- 진행바 귀여운 고양이 표시\n\n![](brain/image/java-settings-12.png)\n\n\u003cbr\u003e\n\n- Rainbow Brackets\n\t- 중괄호 구분하기 쉽게 색깔 표시\n\n![](brain/image/java-settings-13.png)\n\n\u003cbr\u003e\n\n- Discord Integration\n\t- 디스코드 게임 활동 중에 인텔리제이 뜨도록\n\n![](brain/image/java-settings-14.png)\n\n\u003cbr\u003e\n\n## 참고\n\n- https://suzxc2468.tistory.com/141\n- https://codechacha.com/ko/ubuntu-install-open-jdk11/\n- https://www.azul.com/downloads/?version=java-17-lts\u0026os=macos\u0026architecture=arm-64-bit\u0026package=jdk","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/":{"title":"강의","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/":{"title":"Algorithm","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/":{"title":"패캠 - 알고리즘","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part1-4/":{"title":"Part 1 - Part 4","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch00":{"title":"Part1 - Part4 강의소개","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의\n\n[Part1 - 4 기본강의](brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch00.md), [Part5 - 단기완성](brain/Lecture/algo/fastcampus-algo/part5/p5-ch00.md), [Part6 - SQL코테](brain/Lecture/algo/fastcampus-algo/part6/p6-ch00.md)  중 **Part1-4 기본강의**를 정리한 내용\n\n\u003chr\u003e\n\n## 목차\n\n1. [문자열](brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch01.md)\n2. [시간복잡도](brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch02.md)\n3. [배열](brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch03.md)\n4. [완전탐색/시뮬레이션](brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch04.md)\n\n\n\u003chr\u003e\n\n### 코딩테스트\n\n1. 문제 요구사항 (지문, 디스크립션 등)\n\t- 주어질 데이터와 구해야 할 답에 대한 설명\n2. 입/출력 데이터에 대한 명세\n3. 예제 (테스트케이스)\n\n\u003cbr\u003e\n\n- 표준 입출력인 stdin(standard in)으로 입력을 받고 stdout(standard out)으로 출력하는 형식\n- Java에서는 `System.in`이 stdin, `System.out`이 stdout\n\n\u003cbr\u003e\n\n### 문제 해결 과정\n\n**요구사항 이해 -\u003e 설계/검증 -\u003e 기능 구현 -\u003e 결과**\n- 결과가 안맞다면? 분석/디버깅 과정을 통하여 설계/검증으로 다시 돌아가기\n\n\u003cbr\u003e\n\n### 백준\n\n- \u003ca href='https://help.acmicpc.net/judge/info' target='_blank'\u003e백준 채점 방식과 결과\u003c/a\u003e\n- \u003ca href='https://help.acmicpc.net/question' target='_blank'\u003e백준 기타 질문사항\u003c/a\u003e\n\n\u003cbr\u003e\n\n### 입출력 참고 (개인필기)\n\n백준은 입출력 관련해서 웬만하면 기본으로 깔고 할 것\n\n1. `import java.util.*;`\n\t- 컬렉션, StringTokenizer 등\n2. `import java.io.*;`, main 메서드 뒤에 `throws IOException`\n\t- 버퍼리더 입출력 때문에\n3. `Scanner`느리니까 쓰지말고 `BufferedReader` 사용\n\n```java {title=\"BaekJoon - 1000\"}\nimport java.io.*;  \nimport java.util.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        System.out.println(Integer.parseInt(st.nextToken()) + Integer.parseInt(st.nextToken()));  \n    }  \n}\n```\n\n\u003chr\u003e","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch01":{"title":"Ch01 - 문자열","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 문자열\n\n- 문자로 구성된 자료형\n- String 클래스를 지원함\n- String은 불변이라 인스턴스 생성되면 수정 못함\n\t- 부분적으로 변경할 수는 없고 새로 만들어야함\n\t- **`charAt()`**  : String 인덱스에 해당하는 char 출력\n\n```java\nchar[] arr = {'A', 'B', 'C'};\narr[2] = 'D';\nSystem.out.println(arr);\n// ABD\n\nString str = \"ABC\";\nstr[2] = 'D';\nSystem.out.println(str);\n// 컴파일에러\n\nSystem.out.println(str.charAt(2));\n// C\n```\n\n\u003cbr\u003e\n\n### String 내용 바꾸기\n\n**String 값의 변경은 불가능하지만, 새 String을 만들어서 변경할 수 있음**\n\n1. 덮어쓰기\n\n```java\nString str = \"ABCD\";\nstr = \"ABCDE\";\nSystem.out.println(str);\n// ABCDE\n```\n\n\u003cbr\u003e\n\n2. 한글자씩 떼어난 char 배열 생성해서 수정\n\t- **`toCharArray()`** : String을 char 배열로 변경\n\n```java\nString str = \"ABCD\";  \nchar[] arr = str.toCharArray();  \narr[3] = 'E';  \nstr = new String(arr);  \nSystem.out.println(str);\n// ABCE\n```\n\n\u003cbr\u003e\n\n3. **`substring()`** : String 에서 부분만 뽑아내기\n\n```java\nString str = \"ABCD\";  \nstr = str.substring(0,2) + 'E' + str.substring(3,4);  \nSystem.out.println(str);\n// ABED\n```\n\n\u003cbr\u003e\n\n### String 내용 비교\n\n\u003cbr\u003e\n\n```java\nString str1 = \"java\";\nString str2 = \"java\";\nString str3 = new String(\"java\");\nString str4 = new String(\"java\");\n\nSystem.out.println(str1 == str2);  \nSystem.out.println(str1 == str3);  \nSystem.out.println(str3 == str4);\n\n// true\n// false\n// false\n```\n\n- 리터럴로 생성한건 String Pool(=String Costant Pool)에 한 번만 생성되고 기존 값 참조\n- 인스턴스 생성한건 Heap 영역에 매번 새로 생성됨\n- 따라서 `==`는 참조하는 대상이 같은지를 비교하는 것이다.\n- `st3.equals(str4)` 처럼 **`equals()`** 를 이용해야 String의 내용이 같은지를 물어보는 \u001c것\n\n\u003cbr\u003e\n\n### String 메서드\n\n\u003cbr\u003e\n\n| **Method Name**                                             | **Return value** | **Description**                                 |\n| ----------------------------------------------------------- | ---------------- | ----------------------------------------------- |\n| charAt(int index)                                           | char             | index에 위치한 문자                             |\n| length()                                                    | int              | 문자열 길이                                     |\n| equals(Object anObject)                                     | boolean          | 문자열 값의 비교                                |\n| compareTo(String anotherString)                             | int              | 두 문자열을 사전순으로 비교한 결과              |\n| toCharArray()                                               | char\\[]          | 문자열을 변환한 char 배열                       |\n| toLowerCase()                                               | String           | 모든 문자를 소문자로 변경한 새 문자열           |\n| toUpperCase()                                               | String           | 모든 문자를 대문자로 변경한 새 문자열           |\n| contains(CharSequence s)                                    | boolean          | 문자열을 포함하는지 여부                        |\n| replace(CharSequence target, \u003cbr\u003e CharSequence replacement) | String           | target을 모두 replacement로 바꾼 새 문자열      |\n| split(String regex)                                         | String\\[]        | 정규표현식에 맞게 문자열을 여러 문자열로 분할   |\n| substring(int beginIndex, int endIndex)                     | String           | \\[beginIndex, endIndex]를 갖는 새 문자열 반환   |\n| indexOf(int ch, int fromIndex)                              | int              | fromIndex부터 ch 문자가 나타나는 가장 첫 인덱스 |\n| ...                                                         | ...              | ...                                                |\n\n\u003cbr\u003e\n\n### 2744번 문제\n\n\u003cbr\u003e\n\n```java\nimport java.io.*;\n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        char[] arr = br.readLine().toCharArray();  \n        for (int i = 0; i \u003c arr.length; i++) {  \n            if ('A' \u003c= arr[i] \u0026\u0026 arr[i] \u003c= 'Z') {  \n                arr[i] = (char)('a' + arr[i] - 'A');  \n            } else {  \n                arr[i] = (char)('A' + arr[i] - 'a');  \n            }  \n            System.out.print(arr[i]);  \n        }  \n    }  \n}\n```\n\n- 이렇게 아스키코드 차이인 32를 굳이 안외워도 구할 수 있다.\n\t- 대문자 65 ~ 90  \n\t- 소문자 97 ~ 122\n- 소문자로 바꾸는 과정이니까 베이스 'a' 에다가 (어떤 대문자 - 대문자 기준인 'A') 를 더하면 되겠네\n\n\u003cbr\u003e\n\n### 1919번 문제\n\n\u003cbr\u003e\n\n1. 단순구현\n\n```java\nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        String a = br.readLine();  \n        String b = br.readLine();  \n  \n        int[] countA = new int[26];  \n        int[] countB = new int[26];  \n  \n        for (int i = 0; i \u003c a.length(); i++) {  \n            countA[(a.charAt(i) - 'a')]++;  \n        }  \n  \n        for (int i = 0; i \u003c b.length(); i++) {  \n            countB[(b.charAt(i) - 'a')]++;  \n        }  \n  \n        int result = 0;  \n  \n        for (int i = 0; i \u003c 26; i++) {  \n            if (countA[i] \u003e countB[i]) {  \n                result += countA[i] - countB[i];  \n            }  \n            else if (countB[i] \u003e countA[i]) {  \n                result += countB[i] - countA[i];  \n            }  \n        }  \n        System.out.println(result);  \n    }  \n}\n```\n\n2. 중복을 메서드로 빼보기\n\n```java\nimport java.io.*;  \n  \npublic class Main {  \n    public static int[] getAlphabetCount(String str) {  \n        int[] count = new int[26];  \n        for (int i = 0; i \u003c str.length(); i++) {  \n            count[(str.charAt(i) - 'a')]++;  \n        }  \n        return count;  \n    }  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        String a = br.readLine();  \n        String b = br.readLine();  \n  \n        int[] countA = getAlphabetCount(a);  \n        int[] countB = getAlphabetCount(b);  \n  \n        int result = 0;  \n  \n        for (int i = 0; i \u003c 26; i++) {  \n            result += Math.abs(countA[i] - countB[i]);  \n        }  \n        System.out.println(result);  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### 1157번 문제\n\n\u003cbr\u003e\n\n```java\nimport java.io.*;  \n  \npublic class Main {  \n    public static int[] AlphabetCount(String str) {  \n        int[] count = new int[26];  \n        for (int i = 0; i \u003c str.length(); i++) {  \n            count[(str.charAt(i) - 'A')]++;  \n        }  \n  \n        return count;  \n    }  \n  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        String str = br.readLine().toUpperCase();  \n        int[] count = AlphabetCount(str);  \n  \n        int maxCount = -1;  \n        char maxAlphabet = '?';  \n        for (int i = 0; i \u003c 26; i++) {  \n            if (count[i] \u003e maxCount) {  \n                maxCount = count[i];  \n                maxAlphabet = (char)('A' + i);  \n            } else if (count[i] == maxCount) {  \n                maxAlphabet = '?';  \n            }  \n        }  \n        System.out.println(maxAlphabet);  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### 1543번 문제\n\n**pseudo-coe**\n\n**1번 :  문서의 첫 글자부터 순회** \u003cbr\u003e\n\n```java\nfor (int i = 0; i \u003c docs.length(); i++) {\n\n}\n```\n\n**2번 : 문서의 지금 글자부터 주어진 단어와 한 글자씩 비교** \u003cbr\u003e\n\n```java\nfor (int i = 0; i \u003c docs.length(); i++) {\n\tfor (int j = 0; j \u003c word.length(); j++) {\n\t\tif (docs.charAt(i+j) != word.charAt(j)) {\n\t\t\t// 문서에서 i번째 인덱스부터 시작하는 단어는\n\t\t\t// 주어진 단어와 일치하지 않는다.\n\t\t}\n\t}\n}\n```\n\n![](brain/image/p1-ch01-1.png)\n\n\u003cbr\u003e\n\n**3번 : 단어와 완전히 일치하면 개수를 올리고, 해당 단어가 등장한 이후부터 2번 과정 반복** \u003cbr\u003e\n\n**4번 : 단어와 매치되지 않았다면 다음 글자에서 2번 과정 반복** \u003cbr\u003e\n\n```java\nfor (int i = 0; i \u003c docs.length(); i++) {\n\tboolean isMatch = true;\n\tfor (int j = 0; j \u003c word.length(); j++) {\n\t\tif (docs.charAt(i+j) != word.charAt(j)) {\n\t\t\tisMatch = false;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n- 그런데, 여기서 `i = docs.length() - 1`이고 `j = 1`이면, `i + j = docs.length()`가 되버리니까 index 범위 넘어서 런타임에러 발생\n- 인덱스를 다룰 때는 항상 범위체크하자.\n\n```java\nfor (int i = 0; i \u003c docs.length(); i++) {\n\tboolean isMatch = true;\n\tfor (int j = 0; j \u003c word.length(); j++) {\n\t\tif ( i + j \u003e= docs.length() || docs.charAt(i+j) != word.charAt(j)) {\n\t\t\tisMatch = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isMatch) {\n\t\tcount++;\n\t\ti += word.length() - 1;\n\t}\n}\n```\n\n- 중복되지 않는 단어를 찾아야함. 지금 찾은거랑 중복되면 안됨.\n- `word.length()` ? `word.length() - 1` 뭐 더해?\n\t- i 루프가 1을 더해주니까 그걸 감안해서 -1을 해줘야함\n\t- `(( length() -1 ) + 1)`\n\n\u003cbr\u003e\n\n**`indexOf(word, startIndex)`** 메서드 사용하면 더 편함!\n- docs 문자열의 startIndex부터 처음으로 등장하는 word 문자열을 찾음\n- 찾았다면 일치하는 시작 인덱스 반환, 찾지 못하면 -1 반환\n\n```java\nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        String docs = br.readLine();  \n        String word = br.readLine();  \n  \n        int count = 0;  \n        int startIndex = 0;  \n        while (true) {  \n            int findIndex = docs.indexOf(word, startIndex);  \n            if (findIndex \u003c 0)  \n                break;  \n            count++;  \n            startIndex = findIndex + word.length();  \n        }  \n        System.out.println(count);  \n    }  \n}\n```\n\n- for문에서 인덱스에 더해주던것과는 다르게 여기서는 더해주는 값이 없으니까 그냥 바로 `word.length()`를 해줬음\n\n\u003cbr\u003e\n\n**`replace()` 이용**\n\n```java\nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        String docs = br.readLine();  \n        String word = br.readLine();  \n  \n        String replaced = docs.replace(word, \"\");  \n        int length = (docs.length() - replaced.length()) / word.length();  \n        System.out.println(length);  \n    }  \n}\n```\n\n- docs가 \"aaaaaaaa\", word가 \"aaa\"라고 하자.\n- docs.length는 8, word.length는 3이다.\n- 중복되는걸 없애고 나면 \"aa\"만 남게 될 것이고 length는 2이다.\n- 그럼 결과적으로 몇 번 중복됐는지를 확인하려면 word의 길이만큼 나누면 되겠네\n- `docs.length() - replaced.length()`를 하고 나누기 `word.length()`\n\n\u003cbr\u003e\n\n### 13223번 문제\n\n**HH:MM:SS 포맷에서 쪼개는 방법 3가지** \n\n1. 각 단위 인덱스에서 10의 자리와 1의 자리 구해서 계산\n\t- 아스키코드 빼주고 자릿수 곱하기\n\n```java\nString time = \"09:02:43\"\nint hour = (time.charAt(0) - '0') * 10 + (time.charAt(1) - '0');\nint min = (time.charAt(3) - '0') * 10 + (time.charAt(4) - '0');\nint sec = (time.charAt(6) - '0') * 10 + (time.charAt(7) - '0');\n```\n\n\u003cbr\u003e\n\n2. `substring(시작인덱스, 끝인덱스)` 시작 인덱스부터 끝 인덱스 전까지\n\n```java\nString time = \"09:02:43\"\nint hour = Integer.parseInt(time.substring(0, 2));\nint min = Integer.parseInt(time.substring(3, 5));\nint sec = Integer.parseInt(time.substring(6, 8));\n```\n\n\u003cbr\u003e\n\n3. `split(\"\")`\n\n```java\nString[] time = \"09:02:43\".split(\":\");\nint hour = Integer.parseInt(time[0]);\nint min = Integer.parseInt(time[1]);\nint sec = Integer.parseInt(time[2]);\n```\n\n\u003cbr\u003e\n\n**시간 계산법 2가지**\n\n1. 가장 작은 단위부터 음수가 나오면 더 큰 단위에서 내림하여 가져오기\n\n```java\nif (sec \u003c 0) {\n\tsec += 60;\n\tmin--;\n}\n\nif (min \u003c 0) {\n\tmin += 60;\n\thour--;\n}\n\nif (hour \u003c 0) {\n\thour += 24;\n}\n```\n\n\u003cbr\u003e\n\n2. 계층적으로 표현되는 각 단위 계산 시, 가장 작은 단위로 통일\n\n```java\nint now_calc = now_hour * 3600 + now_min * 60 + now_sec;\nint insert_calc = insert_hour * 3600 + insert_min * 60 + insert_sec;\n\nint result_calc = insert_calc - now_calc;  \n\nif (result_calc \u003c 0)  \n    result_calc += 24 * 3600;  \n  \nint result_hour = result_calc / 3600;  \nint result_min = (result_calc % 3600) / 60;  \nint result_sec = result_calc % 60;\n```\n\n- 1시간 = 60분 = 3600초\n- 예를 들어, 10000초라고 해보자.\n- `10000초 = 3600 * (2시간) + 2800초`\n\t- 몫이 2, 나머지 2800\n- `2800초 = 60 * (46분) + 40초`\n- `10000초 = 2시간 46분 40초`\n\n\u003cbr\u003e\n\n**문자열 포맷 코드로 출력**\n\n\u003cbr\u003e\n\n| 코드 | 설명                      |\n|:----:| ------------------------- |\n|  %s  | 문자열(String)            |\n|  %c  | 문자 1개(character)       |\n|  %d  | 정수 (Integer)            |\n|  %f  | 부동소수 (floating-point) |\n|  %o  | 8진수                     |\n|  %x  | 16진수                    |\n| %\\%  | Literal % (문자 % 자체)   | \n\n\u003cbr\u003e\n\n```java\nSystem.out.printf(\"%02d:%02d:%02d\", h, m, s);\n```\n\n- C에서처럼 똑같이 `printf` 쓰기\n- `%02d`는 정수를 출력할건데, 최소 2자리수로 맞춰주고 자리가 남으면 앞에 0으로 채우라는 의미\n- `%3.f`는 소수를 출력할건데, 소수점 아래 3자리까지 출력\n\n\u003cbr\u003e\n\n**작은 단위로 통일한 코드 버전**\n\n```java\nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        String[] now_time = br.readLine().split(\":\");  \n        String[] insert_time = br.readLine().split(\":\");  \n  \n        int now_hour = Integer.parseInt(now_time[0]);  \n        int now_min = Integer.parseInt(now_time[1]);  \n        int now_sec = Integer.parseInt(now_time[2]);  \n        int now_calc = now_hour * 3600 + now_min * 60 + now_sec;  \n  \n        int insert_hour = Integer.parseInt(insert_time[0]);  \n        int insert_min = Integer.parseInt(insert_time[1]);  \n        int insert_sec = Integer.parseInt(insert_time[2]);  \n        int insert_calc = insert_hour * 3600 + insert_min * 60 + insert_sec;  \n  \n        int result_calc = insert_calc - now_calc;  \n        if (result_calc \u003c= 0)  \n            result_calc += 24 * 3600;  \n  \n        int result_hour = result_calc / 3600;  \n        int result_min = (result_calc % 3600) / 60;  \n        int result_sec = result_calc % 60;  \n  \n        System.out.printf(\"%02d:%02d:%02d\", result_hour, result_min, result_sec);  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n**생각하고 푼 버전**\n\n```java\nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        String[] now = br.readLine().split(\":\");  \n        String[] insert = br.readLine().split(\":\");  \n  \n        int h = Integer.parseInt(insert[0]) - Integer.parseInt(now[0]);  \n        int m = Integer.parseInt(insert[1]) - Integer.parseInt(now[1]);  \n        int s = Integer.parseInt(insert[2]) - Integer.parseInt(now[2]);  \n  \n        if (s \u003c 0) {  \n            s += 60;  \n            m--;  \n        }  \n  \n        if (m \u003c 0) {  \n            m += 60;  \n            h--;  \n        }  \n  \n        if (h \u003c 0) {  \n            h += 24;  \n        }  \n  \n        if (h == 0 \u0026\u0026 m == 0 \u0026\u0026 s == 0) {  \n            h = 24;  \n        }  \n  \n        System.out.printf(\"%02d:%02d:%02d\", h, m, s);  \n    }  \n}\n```","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch02":{"title":"Ch02 - 시간복잡도","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 시간 복잡도\n\n- 입력 크기와 알고리즘 간의 관계\n- 알고리즘의 복잡도를 나타내는 지표 중 하나\n- 입력 크기에 대해 프로그램의 동작시간을 가늠해볼 수 있는 수단\n- Big-O / Big-Omega / Big-Theta 표기법\n\t- 주로 Big-O를 사용, 정의된 입력 데이터 중 **가장 최악의 상황을 포함한 시간의 상한선**\n\n\u003cbr\u003e\n\n**코딩테스트에서의 시간복잡도**\n- 보편적으로 문제마다 시간 제한이 주어짐\n- 시간 제한이 1초라면, 최악의 테스트케이스에서도 해당 시간 내에 프로그램이 답을 구할 수 있어야 한다.\n- 시간 제한을 넘어가면 시간 초과뜨고 프로그램 종료\n- ==**편의상 1초에 약 1억 번 연산을 기준으로 소요시간을 가늠할 수 있다.**==\n\t- 상수/최적화 등에 따라 시간 복잡도가 1천만 밖에 되지 않아도 1초를 넘기거나 시간 복잡도로 10억이 넘어도 1초 안에 실행될 수 있다.\n\t- 절대적 기준이 아닌 상대적 지표\n\n\u003cbr\u003e\n\n**적합한 알고리즘 선택 기준**\n- 정답을 구하는 알고리즘이 여러 개인 경우\n\t- 시간이 넉넉하다? =\u003e 구현이 쉬운 방법\n\t- 제한이 있다? =\u003e 시간/메모리상으로 효율적인 방법\n\n\u003cbr\u003e\n\n**배열의 최댓값을 구하는 예시**\n\n1. 반복문 이용 =\u003e O(n)\n\n```java\npublic static int getMaxIntArray(int[] arr) {\n\tint maxValue = arr[0];\n\tfor (int i = 1; i \u003c arr.length; i++) {\n\t\tif (arr[i] \u003e maxValue)\n\t\t\tmaxValue = arr[i];\n\t}\n\treturn maxValue;\n}\n```\n\n2. 정렬 메서드 이용 =\u003e O(n log n), O(n\u003csup\u003e2\u003c/sup\u003e)\n\n```java\npublic static int getMaxIntArray(int[] arr) {\n\tArrays.sort(arr);\n\treturn arr[arr.length - 1];\n}\n```\n\n\u003cbr\u003e\n\n예를 들어, 입력 n이 1000만이라고 하자. =\u003e 1번 방법 선택\n\n만약, 시간 제한이 크지는 않다면 ? n이 작다면? =\u003e 편한 방법 고르기 \n\n\u003cbr\u003e\n\n3. (번외) 스트림\n\n```java\npublic static int getMaxIntArray(int[] arr) {\n\treturn Arrays.stream(arr).max.getAsInt();\n}\n```\n\n\u003cbr\u003e\n\n### 시간복잡도를 통한 추론\n\n![](brain/image/p1-ch02-1.png)\n\n\u003cp align=\"center\"\u003e\u003cstrong\u003eO(1) \u003c O(log\u003csub\u003e2\u003c/sub\u003en) \u003c O(n) \u003c O(n log\u003csub\u003e2\u003c/sub\u003en) \u003c O(n\u003csup\u003e2\u003c/sup\u003e) \u003c O(2\u003csup\u003en\u003c/sup\u003e)\u003c/strong\u003e\u003c/p\u003e\n\n\u003cbr\u003e\n\n| **N의 범위**                                          | **시간 복잡도**            |\n| ----------------------------------------------------- | -------------------------- |\n| **N \u003c= 10 ~ 11**                                          | O(N!)                      |\n| **N \u003c= 24 ~ 25**                                          | O(2\u003csup\u003eN\u003c/sup\u003e)           |\n| **N \u003c= 300 ~ 500**                                        | O(N\u003csup\u003e3\u003c/sup\u003e)           |\n| ==**N \u003c= 5,000 ~ 10,000**==                                   | ==O(N\u003csup\u003e2\u003c/sup\u003e)==           |\n| **N \u003c= 50,000 ~ 100,000**                                 | O(N 루트 N)                |\n| ==**N \u003c= 100,000 ~ 1,000,000**==                              | ==O(N log\u003csub\u003e2\u003c/sub\u003eN)==      |\n| ==**N \u003c= 10,000,000**==                                       | ==O(N)==                       |\n| **N개의 데이터가 입력이 아닌 \u003cbr\u003e 범위 등으로 주어질 때** | O(루트 N) , O(log N), O(1) | \n\n\u003cbr\u003e\n\n### 10158번 문제\n\n- 해설은 강의내용을 참고하도록 하자.\n- 내가 생각한 포인트는 x축과 y축을 별개로 나눠서 따로 구하는 것까지는 생각했음\n- 그러나, 시간제한 때문에 반복문을 아예 안쓰는걸로 생각해서 더 나아가지 못했다.\n\t- 반복문을 사용하면 시간제한이 O(N)이 되버리니까 당연히 시간초과\n\n여기에서 개미가 움직이는걸 보다보면 주기성이 있다는 것을 확인할 수 있음.\n\n=\u003e **주기성이 있다 = 반복된다 = 모듈러(`%`) 연산으로 연산 횟수를 낮출 수 있다. = 반복문을 사용하더라도 시간복잡도가 O(N)이 아니게 할 수 있다.**\n\n\u003cbr\u003e\n\n1. 기본적인 입력값은 받아왔음\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        int w = Integer.parseInt(st.nextToken());  \n        int h = Integer.parseInt(st.nextToken());  \n        st = new StringTokenizer(br.readLine());  \n        int x = Integer.parseInt(st.nextToken());  \n        int y = Integer.parseInt(st.nextToken());  \n        int t = Integer.parseInt(br.readLine());       \n    }  \n}\n```\n\n\u003cbr\u003e\n\n2. 기초로직\n\t- w나 h에 이를 곱하는건 왔다갔다 하는거니까\n\t- 1시간에 1만큼 이동하니까, 거리 1을 1시간으로 볼 수도 있겠네\n\t\t- 따라서, 시작 위치가 (2, ?), w = 6 이었다고 하자.\n\t\t- (2 ~ 6) 4만큼 + (6 ~ 0) 6만큼 + (0 ~ 2) 2만큼 =\u003e 12\n\t\t- 12번마다 처음으로 돌아오네! 주기가 12\n\t\t\t- 여기서 처음은 위치와 가는 방향까지 동일한거 의미함\n\t- 그러면, 시간이 30이라고 하면 `(시간 % 주기)`를 하면 나머지니까 마지막 위치 나오겠네.\n\n```java\n// 시간복잡도 O(2W)\nint dx = 1;\nint timeX = t % (2 * w);\nwhile (timeX-- \u003e 0) {\n\tif (x == w)\n\t\tdx = -1;\n\n\telse if (x == 0)\n\t\tdx = 1;\n\n\tx += dx;\n}\n```\n\n\u003cbr\u003e\n\n```java\n// 시간복잡도 O(2H)\nint dy = 1;\nint timeY = t % (2 * h);\nwhile (timeY-- \u003e 0) {\n\tif (y == h)\n\t\tdy = -1;\n\t\t\n\telse if (y == 0)\n\t\tdy = 1;\n\t\t\n\ty += dy;\n}\n```\n\n\u003cbr\u003e\n\n처음에 문제 범위가 `2 \u003c= W, H \u003c= 40,000` , `1 \u003c= T \u003c= 200,000,000` 이었다. 따라서 기초로직의 시간복잡도는 `O(max(W, H))` 이기 때문에 통과할 것이다.\n\n하지만, W, H가 40,000보다 더 커지면 어떻게 할거냐? 시간 복잡도 더 줄여보자\n\n\u003cbr\u003e\n\n3. 시작을 시작위치가 아니라 0에서부터 시작\n\t- 아까 위치 1만큼 1시간이라고 했으니까 그냥 시간으로 볼 수도 있다고 했다.\n\t- 그러면 0부터 시작하고 `(현재위치 + 걸린시간)` 하면 되지않을까?\n\n```java\nint dx = 1;\nint timeX = (x + t) % (2 * w);\nwhile (timeX-- \u003e 0) {\n\tif (x == w) \n\t\tdx = -1;\n\t\t\n\telse if (x == 0)\n\t\tdx = 1;\n\n\tx += dx;\n}\n```\n\n\u003cbr\u003e\n\n```java\nint dy = 1;\nint timeY = (y + t) % (2 * h);\nwhile (timeY-- \u003e 0) {\n\tif (y == h) \n\t\tdy = -1;\n\t\t\n\telse if (y == 0)\n\t\tdy = 1;\n\n\ty += dy;\n}\n```\n\n\u003cbr\u003e\n\n- 다음으로 더 나아가서 0부터 시작했고, 주기가 2W니까 가운데 W를 기점으로 값이 바뀌잖아? 이를 이용하면\n- `x \u003c= w`이면 값 그대로 x좌표이다.\n- `x \u003e w`이면 w를 만나 방향이 전환되므로 식을 세울 수 있다. w로부터 멀어지는데 현재 위치인 x와 w 만큼의 차이만큼 멀어짐!\n\t- `w - (x - w)` \n\t- `2w - x`\n\n\u003cbr\u003e\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        int w = Integer.parseInt(st.nextToken());  \n        int h = Integer.parseInt(st.nextToken());  \n        st = new StringTokenizer(br.readLine());  \n        int x = Integer.parseInt(st.nextToken());  \n        int y = Integer.parseInt(st.nextToken());  \n        int t = Integer.parseInt(br.readLine());  \n  \n        int currentX = (t + x) % (2 * w);  \n        int currentY = (t + y) % (2 * h);  \n        if (currentX \u003e w)  \n            currentX = 2 * w - currentX;  \n        if (currentY \u003e h)  \n            currentY = 2 * h - currentY;  \n  \n        System.out.println(currentX + \" \" + currentY);  \n    }  \n}\n```\n\n- 이렇게 최종적으로 반복문을 쓰지않고 `O(1)`을 만들면서 문제를 끝낼 수 있다.","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch03":{"title":"Ch03 - 배열","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 배열\n\n- ==**순서(index)를 가진 데이터의 집합**== \n\t- 가장 기본적인 자료구조\n\t- 생성과 동시에 ==**크기가 고정됨**==\n\t- **전체 원소가 메모리 상에 일렬로 저장됨**\n\n```java\nScanner sc = new Scanner(System.in);\nint N = sc.nextInt();\n\n// 배열의 생성\nint[] arr = new int[N];\n\n// 배열의 저장\nfor (int i = 0; i \u003c N; i++) {\n\tarr[i] = sc.nextInt();\n}\n\nlong sum = 0;\nfor (int i = 0; i \u003c N; i++) {\n\t// 배열의 탐색, 원소의 접근\n\tsum += arr[i];\n}\n\n// 원하는 값으로 배열을 생성\nint[] arr2 = {7, 9, 4, -1, 4, 10, 0, 2};\nlong sum2 = 0;\n\n// 배열의 크기\nint len = arr2.length;\n\nfor (int i = 0; i \u003c len; i++) {\n\t// 배열의 탐색, 원소의 접근\n\tsum += arr2[i];\n}\n```\n\n\u003cbr\u003e\n\n### 배열 시간복잡도\n\n- 원소에 접근하거나 변경하는건 O(1)로 빠르지만, 중간에 뭘 빼거나 지우면 최대 O(N) 만큼 걸린다.\n\n\u003cbr\u003e\n\n| **method name**              | **description**                      |\n| ---------------------------- | ------------------------------------ |\n| `get(int index)`             | index번째 원소 반환                  |\n| `change(int index, int val)` | index번째 원소 val로 변경            |\n| `append(int val)`            | 가장 뒤에 원소 삽입                  |\n| `insert(int index, int val)` | 현재 index번째 원소의 앞에 원소 삽입 |\n| `erase(int index)`           | index번째 원소 삭제                  | \n\n\u003cbr\u003e\n\n### get() 메서드\n\n`get(int index)` : **시간 복잡도 O(1)**\n- 메모리가 연속적이기 때문에 배열의 시작 주소부터 index만큼 떨어진 원소의 주소를 바로 계산하고 접근할 수 있다.\n- 예를 들어, 시작 주소가 1000번이라고 하자.\n\t- 방 1개에 정수는 4byte이니까, 4번 원소에 접근 하려면 `4 * 4`로 계산해서 바로 1016번 주소로 갈 수 있다.\n\n```java\npublic static int getElement(int[] arr, int index) {\n\treturn arr[index];\n}\n```\n\n\u003cbr\u003e\n\n### change() 메서드\n\n`change(int index, int val)` : **시간 복잡도 O(1)**\n- change(4, 100)이라고 하면 index 4번의 값을 100으로 바꾸는 것\n- 마찬가지로 `[]` 연산자를 통해 index 번째 원소에 바로 접근하고 값을 변경할 수 있다.\n\n```java\npublic static void changeElement(int[] arr, int index, int val) {\n\tarr[index] = val;\n}\n```\n\n\u003cbr\u003e\n\n### append() 메서드\n\n`append(int val)` : **시간 복잡도 O(1)**\n- append(5)라고 하면 제일 뒤에 5라는 값을 추가\n- 현재 배열에 담긴 원소의 개수를 알면 해당 인덱스에 요청받은 원소를 넣는다.\n- 근데 만약, **배열의 크기가 10인데, 10칸에 값이 다 채워져있다고 하자. 여기에서 append로 추가하려고 하면 어떻게 될까?**\n\t- 추가되지 않는다. 배열의 크기는 고정적이기 때문이다.\n\t- 배열이 꽉 찬 상태에서 값을 추가하려고 하면 더 큰 배열을 새로 생성하고 옮겨닮아야한다.\n\n```java\npublic static boolean appendElement(int[] arr, int arrCount, int val) {\n\tif (arrCount == arr.length)\n\t\treturn false;\n\t\n\tarr[arrCount] = val;\n\treturn true;\n}\n```\n\n- arrCount는 배열 안에 들어있는 원소의 개수\n- 배열이 꽉 차있으면 false 반환\n- 어차피 if 하나밖에 없어서 시간복잡도는 상수시간\n\n\u003cbr\u003e\n\n### insert() 메서드\n\n`insert(int index, int val)` : **시간 복잡도 O(N)**\n- insert(4, 5)라고 한다면 인덱스가 4인 원소 앞에다가 5를 추가하라는 것\n\t- change(4, 5)는 인덱스가 4인 원소의 값을 5로 바꾸는 거라면 insert는 그 사이에 끼워넣는 것이다.\n- **추가되는 원소의 뒷 원소들이 전부 한 칸씩 뒤로 밀림**\n\n```java\npublic static boolean insertElement(int[] arr, int arrCount, int index, int val) {\n\tif (index \u003e arrCount || arrCount \u003e= arr.length)\n\t\treturn false;\n\tfor (int i = arrCount; i \u003e index; i--)\n\t\tarr[i] = arr[i - 1];\n\tarr[index] = val;\n\treturn true;\n}\n```\n\n- `index \u003e arrCount`는 (삽입하고자 하는 위치)가 (배열 안에 들어있는 원소의 개수)보다 큰 것을 말하는거다. 이는 연속적인 배열을 의미하는 것이 아니라 한 칸 이상 건너뛴 것을 의미\n- 앞에서부터 뒤로 차례대로 미는 것 말고 끝에서부터 한 칸씩 앞으로 땡기는 이유는?\n\t- 원본값을 유지하지 못하기 때문 ! 추가된 값이 뒤로 쮸르륵 덮어씌워질거임\n\n\u003cbr\u003e\n\n### erase() 메서드\n\n`erase(int index)` :  **시간 복잡도 O(N)**\n- erase(4)라고 한다면 인덱스가 4번째인 곳을 지우고 빈틈이 없게 연속적으로 뒤에서 한 칸씩 앞으로 땡겨와서 이동해야한다.\n\n```java\npublic static boolean eraseElement(int[] arr, int arrCount, int index) {\n\tif (index \u003e= arrCount)\n\t\treturn false;\n\tfor (int i = index; i \u003c arrCount; i++)\n\t\tarr[i] = arr[i + 1];\n\treturn true;\n}\n```\n\n\u003cbr\u003e\n\n### 1236번 문제\n\n\u003cbr\u003e\n\n- 행, 열 따로 보기\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        int h = Integer.parseInt(st.nextToken());  \n        int w = Integer.parseInt(st.nextToken());  \n        char[][] input = new char[h][w];  \n        for (int i = 0; i \u003c h; i++)  \n            input[i] = br.readLine().toCharArray();  \n  \n        int rowCount = 0;  \n        for (int i = 0; i \u003c h; i++) {  \n            boolean exist = false;  \n            for (int j = 0; j \u003c w; j++) {  \n                if (input[i][j] == 'X') {  \n                    exist = true;  \n                    break;  \n                }  \n            }  \n            if (exist) rowCount++;  \n        }  \n  \n        int colCount = 0;  \n        for (int i = 0; i \u003c w; i++) {  \n            boolean exist = false;  \n            for (int j = 0; j \u003c h; j++) {  \n                if (input[j][i] == 'X') {  \n                    exist = true;  \n                    break;  \n                }  \n            }  \n            if (exist) colCount++;  \n        }  \n        int resultRow = h - rowCount;  \n        int resultCol = w - colCount;  \n        System.out.println(Math.max(resultRow, resultCol));  \n    }  \n}\n```\n\n- 행,열 같이 보기\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        int r = Integer.parseInt(st.nextToken());  \n        int c = Integer.parseInt(st.nextToken());  \n        char[][] input = new char[r][c];  \n        for (int i = 0; i \u003c r; i++)  \n            input[i] = br.readLine().toCharArray();  \n  \n        boolean[] existRow = new boolean[r];  \n        boolean[] existCol = new boolean[c];  \n  \n        for (int i = 0; i \u003c r; i++) {  \n            for (int j = 0; j \u003c c; j++) {  \n                if (input[i][j] == 'X') {  \n                    existRow[i] = true;  \n                    existCol[j] = true;  \n                }  \n            }  \n        }  \n  \n        int resultRowCount = r;  \n        int resultColCount = c;  \n        for (int i = 0; i \u003c r; i++) {  \n            if (existRow[i]) resultRowCount--;  \n        }  \n  \n        for (int i = 0; i \u003c c; i++) {  \n            if (existCol[i]) resultColCount--;  \n        }  \n  \n        System.out.println(Math.max(resultRowCount, resultColCount));  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### 10431번 문제\n\n- 일단 이 문제는 사실은 굉장히 비효율적인 정렬임. insert 하면 뒤로 하나씩 다 밀려야하니까\n\t- 이 정렬은 **삽입정렬 (insertion sort)** 이다.\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        int t = Integer.parseInt(br.readLine());  \n        int[] input = new int[20];  \n  \n        for (int num = 0; num \u003c t; num++) {  \n            StringTokenizer st = new StringTokenizer(br.readLine());  \n            st.nextToken();  \n            for (int i = 0; i \u003c 20; i++) {  \n                input[i] = Integer.parseInt(st.nextToken());  \n            }  \n  \n            int count = 0;  \n            for (int i = 0; i \u003c 20; i++) {  \n                for (int j = 0; j \u003c i; j++) {  \n                    if (input[j] \u003e input[i]) {  \n                        count++;  \n                    }  \n                }  \n            }  \n            System.out.println((num + 1) + \" \" + count );  \n        }  \n    }  \n}\n```\n\n1. 자신보다 먼저 줄을 선 학생 중 자신보다 키가 큰 학생이 있는지 찾음\n\t- 자신보다 큰 학생 없으면 맨 뒤로 가서 서기\n2. 자신보다 큰 학생 중 가장 앞에 있는 학생(A) 앞에 서기\n3. A 학생, A 뒤의 모든 학생은 한 발씩 뒤로 이동해야함\n\n6 2 3 7 5 1 4 배열이 있다고 하자.\n- 6은 그냥 서면 됨 -\u003e count = 0\n- 2보다 큰 애가 6 있네. -\u003e count = 1\n- 3보다 큰 애가 (2, 6)에서 6 있네. -\u003e count = 1\n- 7보다 큰 애가 없네. -\u003e count = 0\n- 이런식으로 0 + 1 + 1 + 0 + 2 + 5 + 3 = 12번 뒤로 가야겠네.\n\n이런식으로 이 문제 푸는거에서 정렬은 딱히 안해도 되고 그냥 앞에서 자기보다 큰 애만 찾으면 되기는 함. 근데 정렬도 한번 해보자. 정렬 할거면 안전하게 크기의 배열 하나 만들어놓고 거기에다가 넣어보자.\n\n\u003cbr\u003e\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        int t = Integer.parseInt(br.readLine());  \n        int[] input = new int[20];  \n        int[] sorted = new int[20];  \n  \n        for (int num = 0; num \u003c t; num++) {  \n            int count = 0;  \n            StringTokenizer st = new StringTokenizer(br.readLine());  \n            st.nextToken();  \n            for (int i = 0; i \u003c 20; i++) {  \n                input[i] = Integer.parseInt(st.nextToken());  \n            }  \n  \n            for (int i = 0; i \u003c 20; i++) {  \n                // 1. 줄 서있는 학생 중 자신보다 큰 학생 찾기  \n                // 1-1. 찾지 못하면, 줄의 가장 뒤에 섬  \n                boolean find = false;  \n                for (int j = 0; j \u003c i; j++) {  \n                    if (sorted[j] \u003e input[i]) {  \n                        // 2. 찾았다면, 그 학생의 앞에 섬  \n                        // 3. 그 핵상과 그 뒤의 학생은 모두 1칸씩 뒤로  \n                        // 앞에서부터 값을 땡겨나가면 그 값만 복사하니까 뒤에서부터 동작하자  \n                        find = true;  \n                        for (int k = i - 1; k \u003e= j; k--) {  \n                            sorted[k + 1] = sorted[k];  \n                            count++;  \n                        }  \n                        sorted[j] = input[i];  \n                        break;  \n                    }  \n                }  \n                if (!find) sorted[i] = input[i];  \n            }  \n            System.out.println((num + 1) + \" \" + count);  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### 15552번 문제 (버퍼)\n\n- Java의 경우 Scanner와 System.out.println은 매우 느린편이다.\n\t- N의 개수가 1,000,000 정도만 넘어가더라도 입출력이 반복되는 경우가 발생할 수 있어서 느리다.\n- 따라서, BufferedReader와 BufferedWriter를 사용하도록 하자.\n\n\u003ca href='https://www.acmicpc.net/blog/view/56' target='_blank'\u003e백준 입력 속도 비교\u003c/a\u003e\n- `BufferedReader, Integer.parseInt` =\u003e 0.6585(s)\n- `Scanner` =\u003e 4.8448(s)\n\n\u003ca href='https://www.acmicpc.net/blog/view/57' target='_blank'\u003e백준 출력 속도 비교\u003c/a\u003e\n- `BufferedWriter, bf.write(i + \"\\n\");` =\u003e 0.9581(s)\n- `StringBuilder를 이용해 문자열 하나로 만든 다음, System.out.println(sb);` =\u003e 1.1881(s)\n- `BufferedWriter, bf.write(Integer.toString(i)); bf.newLine();` =\u003e 1.2556(s)\n- `PrintWriter` =\u003e 1.954(s)\n- `System.out.println(i);` =\u003e 30.013(s)\n\n\u003cbr\u003e\n\n```java\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int t = Integer.parseInt(br.readLine());\n        for (int i = 0; i \u003c t; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            int sum = a + b;\n            bw.write(sum + \"\\n\");\n        }\n        bw.close();\n    }\n}\n```\n\n- **`bw.write()`는 스트림에 쓰기만 할 뿐 출력이 되는 것이 아니다!**\n- ==**출력하려면 반드시 `bw.flush()`로 내보내거나 `bw.close()`로 스트림을 닫아줘야한다.**==\n- `bw.write()`로 버퍼에 작성할 때는 `\"\\n\"`로 개행문자 넣어줘야함\n\n\n\u003cbr\u003e\n\n### 10989번 문제\n\n- 내가 푼 방법은 `Arrays.sort()` 이용\n- 맞기는 맞았는데, `Arrays.sort()`나 `삽입정렬`는 시간복잡도가 최악의 경우 O(n\u003csup\u003e2\u003c/sup\u003e)이다.\n\t- 문제에서 N(10,000,000)개의 자연수 \\[1, 10000]이라고 했기때문에 아마 통과한 것 같지만, 자연수 범위가 없었다면..? 틀렸을 것\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  \n        int num = Integer.parseInt(br.readLine());  \n        int[] arr = new int[num];  \n        for (int i = 0; i \u003c num; i++) {  \n            arr[i] = Integer.parseInt(br.readLine());  \n        }  \n  \n        Arrays.sort(arr);  \n  \n        for (int i = 0; i \u003c num; i++) {  \n            bw.write(arr[i] + \"\\n\");  \n        }  \n        bw.flush();  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n영단어 알파벳 문제에서 풀었던 것처럼 **카운트 배열 이용**\n- 대신 이 방법은 한계가 있다.\n\t- 만약 자연수가 10억까지 들어올 수 있다고 하면 10억 1칸 짜리 배열을 만들어놔야하잖아\n\t- `1,000,000,000 * 4byte = 4,000MB = 4GB` 공간복잡도 개높음!\n\t- 숫자의 범위가 커지면 카운트 배열이 힘들고, 숫자로 나타낼 수 없는 배열이면 나타내기 힘들잖아.\n- 번외로 정수 범위가 \\[-100, 100]은 가능하다. `cnt[100 + x]`로 기록하면 되니까.\n\n```java\nint[] cnt = new int[10001];\n// O(N)\nfor (int i = 0; i \u003c N; i++) {\n\tcnt[sc.nextInt()]++;\n}\n\n// O(max(10000, N))\nfor (int i = 1; i \u003c= 10000; i++) {\n\twhile(cnt[i]-- \u003e 0) {\n\t\tSystem.out.println(i);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        BufferedWriter bw = new BufferedWriter((new OutputStreamWriter(System.out)));  \n  \n        int N = Integer.parseInt(br.readLine());  \n        int[] cnt = new int[10001];  \n        for (int i = 0; i \u003c N; i++) {  \n            cnt[Integer.parseInt(br.readLine())]++;  \n        }  \n  \n        for (int i = 1; i \u003c= 10000; i++) {  \n            while (cnt[i]-- \u003e 0) {  \n                bw.write(i + \"\\n\");  \n            }  \n        }  \n  \n        bw.flush();  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### 3273번 문제\n\n- 시간복잡도 생각해보면 이중반복문 안됨\n- 카운트배열 써보자\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  \n        int n = Integer.parseInt(br.readLine());  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        int x = Integer.parseInt(br.readLine());  \n  \n        int[] input = new int[n];  \n        for (int i = 0; i \u003c n; i++) {  \n            input[i] = Integer.parseInt(st.nextToken());  \n        }  \n  \n        int[] cnt = new int[1000001];  \n        for (int i = 0; i \u003c n; i++) {  \n            cnt[input[i]]++;  \n        }  \n  \n        int ans = 0;  \n        for (int i = 0; i \u003c n; i++) {  \n            int pair = x - input[i];  \n            if (0 \u003c= pair \u0026\u0026 pair \u003c= 1000000)  \n                if (cnt[pair] == 1) {  \n                    ans++;  \n                }  \n        }  \n        bw.write(ans / 2 + \"\\n\");  \n        bw.flush();  \n    }  \n}\n```\n\n- 나누기 2 해준건 중복되는거 빼주려고 그랬음\n\n\n\u003cbr\u003e\n\n**반복문 도는 부분을 X 부분까지만 돌아보자. 두 수의 합이니까 X보다 큰거까진 돌 필요 없지**\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  \n        int n = Integer.parseInt(br.readLine());  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        int x = Integer.parseInt(br.readLine());  \n  \n        int[] input = new int[n];  \n        for (int i = 0; i \u003c n; i++) {  \n            input[i] = Integer.parseInt(st.nextToken());  \n        }  \n  \n        int[] cnt = new int[1000001];  \n        for (int i = 0; i \u003c n; i++) {  \n            cnt[input[i]]++;  \n        }  \n  \n        int ans = 0;  \n  \n        for (int i = 1; i \u003c= (x - 1) / 2; i++) {  \n            if (i \u003c= 1000000 \u0026\u0026 x - i \u003c= 1000000)  \n                if (cnt[i] == 1 \u0026\u0026 cnt[x-i] == 1)  \n                    ans++;  \n        }  \n  \n        bw.write(ans + \"\\n\");  \n        bw.flush();  \n    }  \n}\n```\n\n- x에서 1을 빼준건, x가 홀수라면 딱 정 가운데지만 x가 짝수라면 정 가운데가 아니니까 -1 해줬음\n- 여기서 2를 미리 나눠주면 밑에 ans는 2를 안나눠도 되겠네","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch04":{"title":"Ch04 - 완탐/시뮬","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 완전 탐색\n\n==**완전탐색 : 그냥 모든 경우의 수를 시도하는 것**==\n- 문제 해결의 가장 기본적인 방법\n- 정답률 100% 보장\n- 별도의 최적화 없이, 효율성을 고려하지 않는 풀이법\n- **Brute Force 방식**이라고도 함\n\t- ex) 4자리 숫자 암호를 찾으려면 0000~9999까지 1만개 전부 해보는거\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 시뮬레이션","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part5/":{"title":"Part 5 - 단기완성","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part5/p5-ch00":{"title":"Part5 - 단기완성","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의\n\n[Part1 - 4 기본강의](brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch00.md), [Part5 - 단기완성](brain/Lecture/algo/fastcampus-algo/part5/p5-ch00.md), [Part6 - SQL코테](brain/Lecture/algo/fastcampus-algo/part6/p6-ch00.md)  중 **Part5 단기완성 강의**를 정리한 내용\n\n\u003chr\u003e\n\n## 목차\n\n1. [완전탐색(브루트포스)](brain/Lecture/algo/fastcampus-algo/part5/p5-ch01.md)\n2. [정렬](brain/Lecture/algo/fastcampus-algo/part5/p5-ch02.md)\n\n\u003chr\u003e\n\n### 좋은 습관\n\n\u003cbr\u003e\n\n1. 문제를 올바른 **순서**로 이해하자.\n\t- ==읽기==\n\t\t- 시간, 메모리 제한\n\t\t- 문제 전체를 반드시 **꼼꼼하게**\n\t- ==이해하기==\n\t\t- 제공되는 정보(변수들) 정리\n\t\t- 예제 데이터에 대한 이해\n\t- ==파악하기==\n\t\t- 가능한 최대, 최소 정답에 맞는 데이터를 직접 생성\n\t\t- 키워드가 되는 단어들을 체크\n\n\u003cbr\u003e\n\n2. **시간**과 **공간 복잡도**를 계산하자.\n\t- 시간을 아끼기 위해서. \"짤 가치가 있나?\"\n\t- 예를 들어, N이 10만이라면, O(N\u003csup\u003e2\u003c/sup\u003e) = 100억이다. 이건 이중 for문으로 짜봤자 안되는 것을 알 수 있겠지. O(N log N)은 대략 180만이니까 가능하겠지?\n\n\u003cbr\u003e\n\n3. 코드를 효율적으로 **함수화**해서 구현하자.\n\t- 예를 들어, 다익스트라 20줄짜리를 3번 구현하면 60줄 짜야하겠지? 함수화해서 불러서 쓰면 훨씬 단축될 것.\n\n\u003cbr\u003e\n\n4. 코딩테스트에서 **부분 점수**를 챙기자.\n\t- 노력이라도 한 모습을 보이면 부분 점수를 받는다.\n\n\u003cbr\u003e\n\n### 입력 메서드\n\n- 호석님은 입력 메서드 관련하여 일단 넣고 시작하시는 코드가 있다고 하셨다.\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    static StringBuilder sb = new StringBuilder();  \n    //정답은 sb에 append 를 사용하여 출력  \n    //만약 개행까지 출력하고 싶으면 append('\\n')을 추가  \n  \n    static void input(){  \n        FastReader scan = new FastReader();  \n    }  \n  \n    public static void main(String[] args) {  \n        input();  \n    }  \n  \n    static class FastReader {  \n        BufferedReader br;  \n        StringTokenizer st;  \n  \n        public FastReader() {  \n            br = new BufferedReader(new InputStreamReader(System.in));  \n        }  \n  \n        public FastReader(String s) throws FileNotFoundException {  \n            br = new BufferedReader(new FileReader(new File(s)));  \n        }  \n  \n        String next() {  \n            while (st == null || !st.hasMoreElements()) {  \n                try {  \n                    st = new StringTokenizer(br.readLine());  \n                } catch (IOException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            return st.nextToken();  \n        }  \n  \n        int nextInt() {  \n            return Integer.parseInt(next());  \n        }  \n  \n        long nextLong() {  \n            return Long.parseLong(next());  \n        }  \n  \n        double nextDouble() {  \n            return Double.parseDouble(next());  \n        }  \n  \n        String nextLine() {  \n            String str = \"\";  \n            try {  \n                str = br.readLine();  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }  \n            return str;  \n        }  \n    }  \n}\n```\n\n\u003chr\u003e\n","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part5/p5-ch01":{"title":"Ch01 - 완전탐색","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 완전탐색 - 기초\n\n\u003cbr\u003e\n\n**완전 탐색(Brute Force)**\n- 문제 해결을 위해 모든 경우를 전부 탐색하는 방법\n- 그 중에서도 백 트래킹(Back-Tracking)을 통해야 하는 상황 해결\n- 모든 코테 문제에서 기본적으로 접근해봐야 한다. 많은 연습이 필요하다.\n\n\u003e 장점 : 부분점수 얻기 좋음 \u003cbr\u003e\n\u003e 단점 : 시간복잡도가 일반적으로 높음\n\n\u003cbr\u003e\n\n### 완전탐색 종류\n\n1. N개 중 중복을 허용해서\n2. N개 중 중복 없이\n3. M개를 순서있게 나열\n4. M개를 고르기\n\n(1 ,3) \\/ (1, 4) \\/ (2, 3) \\/ (2, 4) - 4가지\n\n완전 탐색은 함수 정의에서 50%는 먹고 들어간다.\n\n```java\n// Recurrence Function (재귀 함수)\n// 만약 M개를 전부 고름 =\u003e 조건에 맞는 탐색을 한 가지 성공한 것\n// 아직 M개를 고르지 않음 =\u003e k번째부터 M번째 원소를 조건에 맞게 고르는 방법을 시도\nstatic void rec_func(int k) { }\n\npublic static void main(String[] args) {\n\tinput();\n\t// 1번째 원소부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 탐색해줘\n\trec_func(1);\n\tSystem.out.println(sb.totring());\n}\n```\n\n\u003cbr\u003e\n\n### 완전탐색 복잡도\n\n\u003cbr\u003e\n\n![](brain/image/p5-ch01-1.png)\n\n\u003cbr\u003e\n\n### (1+3) 방법\n\n**N개 중 중복을 허용하여 M개를 순서있게 나열**\n\n- 15651번 문제\n\n예를 들어, N = 4, M = 3이라고 하자. 그러면 (\\_ \\_ \\_) 3칸이 있고 각각 1~4까지 들어갈 수 있다.\n\n\u003cbr\u003e\n\n1. 시간 복잡도 계산\n\t- `4 * 4 * 4` 일 것이다.\n\t- 일반화하면 O(N\u003csup\u003eM\u003c/sup\u003e)이다. 문제에서 N과 M의 최대가 7이었으니 7\u003csup\u003e7\u003c/sup\u003e 하면 대략 82만이다. 완탐 써도 될듯?\n\n\u003cbr\u003e\n\n- 강의 코드\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    static StringBuilder sb = new StringBuilder();  \n  \n    static void input(){  \n        FastReader scan = new FastReader();  \n        N = scan.nextInt();  \n        M = scan.nextInt();  \n        // M번째 까지 받지만, M+1 (= 다 찬 경우) 확인을 위해  \n        selected = new int[M + 1];  \n    }  \n  \n    static int N, M;  \n    static int[] selected;  \n  \n    // Recurrence Function (재귀 함수)  \n    // 만약 M개를 전부 고름 =\u003e 조건에 맞는 탐색을 한 가지 선공한 것  \n    // 아직 M개를 고르지 않음 =\u003e k번째부터 M번째 원소를 조건에 맞게 고르는 방법을 시도  \n    static void rec_func(int k) {  \n        if (k == M + 1) {   // 다 골랐다 !            // selected[1...M] 배열이 새롭게 탐색된 결과  \n            for (int i = 1; i \u003c= M; i++) sb.append(selected[i]).append(' ');  \n            sb.append('\\n');  \n        } else {  \n            for (int cand = 1; cand \u003c= N; cand++) {  \n                selected[k] = cand;  \n                // k + 1 번째부터 ~ M 번을 모두 탐색하는 일을 해야하는 상황  \n                rec_func(k + 1);  \n                // 끝나면 더이상 기록할 필요 없으니까  \n                selected[k] = 0;  \n            }  \n        }  \n    }  \n  \n    public static void main(String[] args) {  \n        input();  \n  \n        // 1 번째 원소부터 M 번째 원소를 조건에 맞는 모든 방법을 찾아줘  \n        rec_func(1);  \n        System.out.println(sb.toString());  \n    }  \n  \n    static class FastReader {  \n        BufferedReader br;  \n        StringTokenizer st;  \n  \n        public FastReader() {  \n            br = new BufferedReader(new InputStreamReader(System.in));  \n        }  \n  \n        public FastReader(String s) throws FileNotFoundException {  \n            br = new BufferedReader(new FileReader(new File(s)));  \n        }  \n  \n        String next() {  \n            while (st == null || !st.hasMoreElements()) {  \n                try {  \n                    st = new StringTokenizer(br.readLine());  \n                } catch (IOException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            return st.nextToken();  \n        }  \n  \n        int nextInt() {  \n            return Integer.parseInt(next());  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n- 줄인 코드\n\n```java\nimport java.io.*;  \nimport java.util.*;  \n  \npublic class Main {  \n    static int N, M;  \n    static int[] selected;  \n    static StringBuilder sb = new StringBuilder();  \n  \n    static void recv_func(int k) {  \n        if (k == M + 1) {  \n            for (int i = 1; i \u003c= M; i++) sb.append(selected[i]).append(' ');  \n            sb.append('\\n');  \n        } else {  \n            for (int cand = 1; cand \u003c= N; cand++) {  \n                selected[k] = cand;  \n                recv_func(k + 1);  \n                selected[k] = 0;  \n            }  \n        }  \n    }  \n  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        N = Integer.parseInt(st.nextToken());  \n        M = Integer.parseInt(st.nextToken());  \n  \n        selected = new int[M + 1];  \n        recv_func(1);  \n        System.out.println(sb.toString());  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### (2+3) 방법\n\n**N개 중 중복을 허용없이 M개를 순서있게 나열**\n\n- 15649번 문제\n\n1. 이중 for문으로 시간 복잡도가 더 높은 버전\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    static StringBuilder sb = new StringBuilder();  \n    static int N, M;  \n    static int[] selected;  \n  \n    static void recv_func(int k) {  \n        if (k == M + 1) {  \n            for (int i = 1; i \u003c= M; i++) {  \n                sb.append(selected[i]).append(' ');  \n            }  \n            sb.append('\\n');  \n        } else {  \n            for (int cand = 1; cand \u003c= N; cand++) {  \n                boolean isUsed = false;  \n                for (int j = 1; j \u003c k; j++) {  \n                    if (cand == selected[j])  \n                        isUsed = true;  \n                }  \n                if (!isUsed) {  \n                    selected[k] = cand;  \n                    recv_func(k + 1);  \n                    selected[k] = 0;  \n                }  \n            }  \n        }  \n    }  \n  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        N = Integer.parseInt(st.nextToken());  \n        M = Integer.parseInt(st.nextToken());  \n  \n        selected = new int[M + 1];  \n        recv_func(1);  \n        System.out.println(sb.toString());  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n2. for문 1번만 쓰고 시간 복잡도 줄인 버전\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    static StringBuilder sb = new StringBuilder();  \n    static int N, M;  \n    static int[] selected, used;  \n  \n    static void recv_func(int k) {  \n        if (k == M + 1) {  \n            for (int i = 1; i \u003c= M; i++) {  \n                sb.append(selected[i]).append(' ');  \n            }  \n            sb.append('\\n');  \n        } else {  \n            for (int cand = 1; cand \u003c= N; cand++) {  \n                if (used[cand] == 1) continue;  \n                selected[k] = cand;  \n                used[cand] = 1;  \n                recv_func(k + 1);  \n                selected[k] = 0;  \n                used[cand] = 0;  \n            }  \n        }  \n    }  \n  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        N = Integer.parseInt(st.nextToken());  \n        M = Integer.parseInt(st.nextToken());  \n  \n        selected = new int[M + 1];  \n        used = new int[N + 1];  \n        recv_func(1);  \n        System.out.println(sb.toString());  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### (1+4) 방법\n\n**N개 중 중복을 허용하여 M개를 고르기**\n\n- 15652번 문제\n\n```java\nimport java.io.*;  \nimport java.util.*;  \n  \npublic class Main {  \n    static int N, M;  \n    static int[] selected;  \n    static StringBuilder sb = new StringBuilder();  \n  \n    static void recv_func(int k) {  \n        if ( k == M + 1) {  \n            for (int i = 1; i \u003c= M; i++) sb.append(selected[i]).append(' ');  \n            sb.append('\\n');  \n        } else {  \n            int start = selected[k-1];  \n            if (start == 0) start = 1;  \n            for (int cand = start; cand \u003c= N; cand++) {  \n                selected[k] = cand;  \n                recv_func(k + 1);  \n                selected[k] = 0;  \n            }  \n        }  \n  \n    }  \n  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        N = Integer.parseInt(st.nextToken());  \n        M = Integer.parseInt(st.nextToken());  \n  \n        selected = new int[M + 1];  \n        recv_func(1);  \n        System.out.println(sb.toString());  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### (2+4) 방법\n\n**N개 중 중복없이 M개를 고르기**\n\n- 15650번 문제\n\n```java\nimport java.io.*;  \nimport java.util.*;  \n  \npublic class Main {  \n    static int N, M;  \n    static int[] selected;  \n    static StringBuilder sb = new StringBuilder();  \n  \n    static void recv_func(int k) {  \n        if ( k == M + 1) {  \n            for (int i = 1; i \u003c= M; i++) sb.append(selected[i]).append(' ');  \n            sb.append('\\n');  \n        } else {  \n            for (int cand = selected[k-1] + 1; cand \u003c= N; cand++) {  \n                selected[k] = cand;  \n                recv_func(k + 1);  \n                selected[k] = 0;  \n            }  \n        }  \n  \n    }  \n  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        N = Integer.parseInt(st.nextToken());  \n        M = Integer.parseInt(st.nextToken());  \n  \n        selected = new int[M + 1];  \n        recv_func(1);  \n        System.out.println(sb.toString());  \n    }  \n}\n```\n\n- used 써서 한번 해봤음\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    static int N, M;  \n    static int[] selected, used;  \n    static StringBuilder sb = new StringBuilder();  \n  \n    static void recv_func(int k) {  \n        if (k == M + 1) {  \n            for (int i = 1; i \u003c= M; i++) sb.append(selected[i]).append(' ');  \n            sb.append('\\n');  \n        } else {  \n            int start = selected[k-1];  \n            if (start == 0) start = 1;  \n  \n            for (int cand = start; cand \u003c= N; cand++) {  \n                if (used[cand] == 1) continue;  \n                selected[k] = cand;  \n                used[cand] = 1;  \n                recv_func(k + 1);  \n                selected[k] = 0;  \n                used[cand] = 0;  \n            }  \n        }  \n    }  \n  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        N = Integer.parseInt(st.nextToken());  \n        M = Integer.parseInt(st.nextToken());  \n  \n        selected = new int[M + 1];  \n        used = new int[N + 1];  \n        recv_func(1);  \n        System.out.println(sb.toString());  \n    }  \n}\n```\n\n\u003chr\u003e\n\n### BOJ 14888\n\n1. 출력을 잘 보면 연산자를 연산자를 어떻게 끼워넣어도 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과, 중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다는 의미를 주의\n\t- **int 범위 : -21억 ~ 21억** \n\t- 그냥 int형을 쓰지 말고 근거에 의해 사용하자.\n2. 연산자라는 카드가 N-1개의 카드 중에서 **중복 없이**(같은 카드는 한 번만 사용) N-1개를 **순서 있게 나열**\n\n\n- 시간복잡도 큰 버전\n\t- 탐색이 완료될 때마다 연산이 수행되어서 비효율적\n\n```java\nstatic int N, max, min;\nstatic int[] nums, operators, order;\n\n// order[1...N-1]에 연산자들이 순서대로 저장될 것\nstatic void rec_func(int k, int value) {\n\tif (k == N) { // 모든 연산자들을 전부 나열하는 방법을 찾은 상태\n\t\t// 정한 연산자 순서대로 계산해서 정답을 갱신\n\t} else { // k 번째 연산자는 무엇을 선택할 것인가?\n\t\t// 4가지의 연산자 중 뭘 쓸 것인지 선택하고 재귀호출하기\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    static FastReader scan = new FastReader();  \n    static StringBuilder sb = new StringBuilder();  \n  \n    static int N, max, min;  \n    static int[] nums, operators, order;  \n  \n    static void input(){  \n        N = scan.nextInt();\n        // 입력 숫자 N개  \n        nums = new int[N + 1];  \n        // 연산자 +, -, *, / 4개\n        operators = new int[5];\n        // 연산자 가능한거 N-1개\n        order = new int[N];  \n        for (int i = 1; i \u003c= N; i++) {  \n            nums[i] = scan.nextInt();  \n        }  \n        for (int i = 1; i \u003c= 4; i++) {  \n            operators[i] = scan.nextInt();  \n        }  \n  \n        max = Integer.MIN_VALUE;  \n        min = Integer.MAX_VALUE;  \n    }  \n  \n    // order[1...N-1]에 연산자들이 순서대로 저장  \n    static void rec_func(int k) {  \n        // k == (N - 1) + 1)  \n        // 모든 연산자들을 전부 나열하는 방법을 찾은 상태  \n        if (k == N) {  \n            // 정한 연산자 순서대로 계산해서 정답을 갱신  \n            int value = calculator();  \n            max = Math.max(max, value);  \n            min = Math.min(min, value);  \n  \n        } else {    // k번째 연산자는 무엇을 선택할 것인가?  \n            // 4가지 연산자 들 중 뭘 쓸 것인지 선택하고 재귀호출  \n            for (int cand = 1; cand \u003c= 4; cand++) {  \n                if (operators[cand] \u003e= 1) {  \n                    operators[cand]--;  \n                    order[k] = cand;  \n                    rec_func(k+1);  \n                    operators[cand]++;  \n                    order[k] = 0;  \n                }  \n            }  \n  \n        }  \n    }  \n  \n    // 완성된 식에 맞게 계산을 해서 정답에 갱신하는 작업  \n    static int calculator() {  \n        // nums, order  \n        int value = nums[1];  \n        for (int i = 1; i \u003c= N - 1; i++) {  \n            // value, order[i], nums[i+1]  \n            if (order[i] == 1) // +  \n                value = value + nums[i + 1];  \n            if (order[i] == 2) // -  \n                value = value - nums[i + 1];  \n            if (order[i] == 3) // *  \n                value = value * nums[i + 1];  \n            if (order[i] == 4) // /  \n                value = value / nums[i + 1];  \n        }  \n        return value;  \n    }  \n  \n    public static void main(String[] args) {  \n        input();  \n        rec_func(1);  \n        sb.append(max).append('\\n').append(min);  \n        System.out.println(sb.toString());  \n    }  \n  \n    static class FastReader {  \n        BufferedReader br;  \n        StringTokenizer st;  \n  \n        public FastReader() {  \n            br = new BufferedReader(new InputStreamReader(System.in));  \n        }  \n  \n        String next() {  \n            while (st == null || !st.hasMoreElements()) {  \n                try {  \n                    st = new StringTokenizer(br.readLine());  \n                } catch (IOException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            return st.nextToken();  \n        }  \n  \n        int nextInt() {  \n            return Integer.parseInt(next());  \n        }  \n  \n        String nextLine() {  \n            String str = \"\";  \n            try {  \n                str = br.readLine();  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }  \n            return str;  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n- 시간복잡도 최적화 버전\n\t- 연산 결과도 같이 들고 다니도록\n\n```java\nstatic int N, max, min;\nstatic int[] nums, operators, order;\n\n// order[1...N-1]에 연산자들이 순서대로 저장될 것\n// k - 1번째 연산자까지 계산한 결과가 value\nstatic void rec_func(int k, int value) {\n\tif (k == N) { // 모든 연산자들을 전부 나열하는 방법을 찾은 상태\n\t\t// value를 정답에 갱신\n\t} else { // k 번째 연산자는 무엇을 선택할 것인가?\n\t\t// 4가지의 연산자 중 뭘 쓸 것인지 선택하고\n\t\t// 연산자를 계산한 후에 재귀호출하기\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    static FastReader scan = new FastReader();  \n    static StringBuilder sb = new StringBuilder();  \n  \n    static int N, max, min;  \n    static int[] nums, operators, order;  \n  \n    static void input() {  \n        N = scan.nextInt();  \n        nums = new int[N + 1];  \n        operators = new int[5];  \n        order = new int[N];  \n        for (int i = 1; i \u003c= N; i++) {  \n            nums[i] = scan.nextInt();  \n        }  \n        for (int i = 1; i \u003c= 4; i++) {  \n            operators[i] = scan.nextInt();  \n        }  \n  \n        max = Integer.MIN_VALUE;  \n        min = Integer.MAX_VALUE;  \n    }  \n  \n    // order[1...N-1]에 연산자들이 순서대로 저장  \n    static void rec_func(int k, int value) {  \n        // k == (N - 1) + 1)  \n        // 모든 연산자들을 전부 나열하는 방법을 찾은 상태  \n        if (k == N) {  \n            // 정한 연산자 순서대로 계산해서 정답을 갱신  \n            //int value = calculator();  \n            max = Math.max(max, value);  \n            min = Math.min(min, value);  \n  \n        } else {    // k번째 연산자는 무엇을 선택할 것인가?  \n            // 4가지 연산자 들 중 뭘 쓸 것인지 선택하고 재귀호출  \n            for (int cand = 1; cand \u003c= 4; cand++) {  \n                if (operators[cand] \u003e= 1) {  \n                    operators[cand]--;  \n                    order[k] = cand;  \n                    rec_func(k + 1, calculator(value, cand, nums[k + 1]));  \n                    operators[cand]++;  \n                    order[k] = 0;  \n                }  \n            }  \n  \n        }  \n    }  \n  \n    // 피연산자 2개와 연산자가 주어졌을 때 계산해주는 함수  \n    static int calculator(int operand1, int operator, int operand2) {  \n        if (operator == 1) {  \n            return operand1 + operand2;  \n        }  \n        else if (operator == 2) {  \n            return operand1 - operand2;  \n        }  \n        else if (operator == 3) {  \n            return operand1 * operand2;  \n        }  \n        else {  \n            return operand1 / operand2;  \n        }  \n    }  \n  \n    public static void main(String[] args) {  \n        input();  \n        rec_func(1, nums[1]);  \n        sb.append(max).append('\\n').append(min);  \n        System.out.println(sb.toString());  \n    }  \n  \n    static class FastReader {  \n        BufferedReader br;  \n        StringTokenizer st;  \n  \n        public FastReader() {  \n            br = new BufferedReader(new InputStreamReader(System.in));  \n        }  \n  \n        String next() {  \n            while (st == null || !st.hasMoreElements()) {  \n                try {  \n                    st = new StringTokenizer(br.readLine());  \n                } catch (IOException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            return st.nextToken();  \n        }  \n  \n        int nextInt() {  \n            return Integer.parseInt(next());  \n        }  \n  \n        String nextLine() {  \n            String str = \"\";  \n            try {  \n                str = br.readLine();  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }  \n            return str;  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### BOJ 9663\n\n1. 아이디어의 전환, 반드시 2차원 배열일 필요는 없다.\n\t- 1차원 배열로 생각하고 index를 row로, `col[index]`를 col로 생각해보자\n\t- 1번 행에 놓을 퀸의 열, 2번 행에 놓을 퀸의 열, ... , N번 행에 놓을 퀸의 열을 재귀\n2. N개 중에서 **중복을 허용하여** N개를 **순서대로 나열하는** 모든 경우 탐색\n\n- 시간초과 버전\n\t- 연산을 무조건 다돌아서 체크한다.\n\t- N = 14일 때 21억을 넘을 수도 있어서, 일단 int로 정하고 N=14를 입력으로 넣어보고 확인하자.\n\t- `attack()` 메서드의 경우 열이 같은 경우, 대각선 정방향, 대각선 역방향을 계산해줬다.\n\t\t- 왜냐하면, 대각선은 행과 열의 합이나 차가 같으면 정방향, 역방향으로 알 수 있음\n\n\u003cbr\u003e\n\n```java\nstatic int N, count;\nstatic int[] col; // col[i] : i번 행의 퀸은 col[i]번 열에 놓았다는 기록\n// row번 ~ N번 행에 대해 가능한 퀸을 놓는 경우의 수 구하기\nstatic void rec_func(int row) {\n\tif (row == N + 1) { // 각 행마다 하나씩 잘 놓았다.\n\t\tif (validity_check()) { // 서로 공격하는 퀸들이 없는 경우\n\t\t\tcount++;\n\t\t}\n\t} else {\n\t\tfor (int c = 1; c \u003c= N; c++) {\n\t\t\tcol[row] = c;\n\t\t\trec_func(row + 1);\n\t\t\tcol[row] = 0;\n\t\t}\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static int N, count;\n    static int[] col;\n\n    static void rec_func(int row) {\n        if (row == N+1) {\n            if (check()) {\n                count++;\n            }\n        } else {\n            for (int c = 1; c \u003c= N; c++) {\n                col[row] = c;\n                rec_func(row + 1);\n                col[row] = 0;\n            }\n        }\n    }\n\n    static boolean check() {\n        for (int i = 1; i \u003c= N; i++) {\n            // (i, col[i])\n            for (int j = 1; j \u003c i; j++) {\n                // (j, col[j])\n                if (attack(i, col[i], j, col[j]))\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    static boolean attack(int r1, int c1, int r2, int c2) {\n        if (c1 == c2) return true;\n        if (r1 - c1 == r2 - c2) return true;\n        if (r1 + c1 == r2 + c2) return true;\n        return false;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        col = new int[N+1];\n        rec_func(1);\n        System.out.println(count);\n    }\n}\n```\n\n\u003cbr\u003e\n\n- 정답, 구현 스케치 심화\n\n\u003cbr\u003e\n\n```java\nstatic int N, count;\nstatic int[] col;  // col[i] : i번 행의 퀸은 col[i]번 열에 놓았다는 기록\n// row번 ~ N번 행에 대해서 가능한 퀸을 놓는 경우의 수 구하기\nstatic void rec_func(int row) {\n\tif (row == N + 1) {  // 1 ~ N번 행에 대해서 성공적으로 놓았다!\n\t\tcount++;\n\t} else {\n\t\tfor (int c = 1; c \u003c= N; c++) {\n\t\t\t// row 행의 c 열에 놓을 수 있으면\n\t\t\tcol[row] = c;\n\t\t\trec_func(row + 1);\n\t\t\tcol[row] = 0;\n\t\t}\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static int N, count;\n    static int[] col;\n    static StringBuilder sb = new StringBuilder();\n\n    static void rec_func(int row) {\n        if (row == N+1) {\n            count++;\n        } else {\n            for (int c = 1; c \u003c= N; c++) {\n                boolean possible = true;\n                for (int i = 1; i \u003c= row - 1; i++) {\n                    if (attack(row, c, i, col[i])) {\n                        possible = false;\n                        break;\n                    }\n                }\n                if (possible) {\n                    col[row] = c;\n                    rec_func(row + 1);\n                    col[row] = 0;\n                }\n            }\n        }\n    }\n\n    static boolean check() {\n        for (int i = 1; i \u003c= N; i++) {\n            // (i, col[i])\n            for (int j = 1; j \u003c i; j++) {\n                // (j, col[j])\n                if (attack(i, col[i], j, col[j]))\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    static boolean attack(int r1, int c1, int r2, int c2) {\n        if (c1 == c2) return true;\n        if (r1 - c1 == r2 - c2) return true;\n        if (r1 + c1 == r2 + c2) return true;\n        return false;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        col = new int[N+1];\n        rec_func(1);\n        System.out.println(sb.append(count));\n    }\n}\n```\n\n\u003cbr\u003e\n\n### BOJ 1182\n\n- 목표는 `S = 0`인 것\n- 부분 수열 : 수열의 일부 항을 선택해서 원래 순서대로 나열\n- 진 부분 수열들 중에서 합이 정확히 S가 되는 경우의 수\n\n\u003cbr\u003e\n\n- 1번 원소 ~ N번 원소\n- 1번 원소(0 or 1) , 2번 원소 (0 or 1), 3번 원소(0 or 1) , ... N번 원소(0 or 1)\n\t- 0 : 부분 수열에 포함시키지 않는다.\n\t- 1 : 부분 수열에 포함시킨다.\n\t- 이렇게 하면 하나의 부분수열 \n\t- 0 또는 1을 **중복해서 여러 개** 나열 가능 + **순서도 중요함**\n\t- `N = 2` , `M = 20` 문제를 푸는 것과 동일\n\n```java\nstatic int N, S, count;\nstatic int[] nums;\n// k번째 원소를 포함시킬 지 정하는 함수\n// value:=k-1 번째 원소까지 골라진 원소들의 합\nstatic void rec_func(int k, int value) {\n\tif (k == N + 1) { // 부분 수열을 하나 완성시킨 상태\n\t\t// value가 S랑 같은 지 확인\n\t} else {\n\t\t// k번째 원소를 포함시킬 지 결정하고 재귀호출\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\npublic static void main(String[] args) {\n\tinput();\n\t// 1번째 원소부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 탐색\n\trec_func(1, 0);\n\t// count가 정말 \"진 부분집합\"만 다루는 지 확인\n\tSystem.out.println(count);\n}\n```\n\n\u003cbr\u003e\n\n```java\nimport java.util.*;  \nimport java.io.*;  \n  \npublic class Main {  \n    static int N, S, count;  \n    static int[] input;  \n  \n    // k번째 원소를 진 부분수열에 포함시킬지 결정하는 함수  \n    // value는 k-1번째 원소까지 골라진 원소들의 합  \n    static void rec_func(int k, int value) {  \n        if (k == N + 1) {  \n            if (S == value) count++;  \n        } else {  \n            // k번째 원소를 포함시키고 넘기기  \n            rec_func(k+1, value + input[k]);  \n            // 포함 안시키고 넘기기  \n            rec_func(k+1, value);  \n        }  \n    }  \n  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        StringTokenizer st = new StringTokenizer(br.readLine());  \n        N = Integer.parseInt(st.nextToken());  \n        S = Integer.parseInt(st.nextToken());  \n  \n        input = new int[N+1];  \n        st = new StringTokenizer(br.readLine());  \n        for (int i = 1; i \u003c= N; i++) {  \n            input[i] = Integer.parseInt(st.nextToken());  \n        }  \n  \n        rec_func(1, 0);  \n        if (S == 0) {  \n            count--;  \n        }  \n        System.out.println(count);  \n    }  \n}\n```","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part5/p5-ch02":{"title":"Ch02 - 정렬","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 정렬문제 기초","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part6/":{"title":"Part 6 - SQL","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part6/p6-ch00":{"title":"Part6 - SQL 코테","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의\n\n[Part1 - 4 기본강의](brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch00.md), [Part5 - 단기완성](brain/Lecture/algo/fastcampus-algo/part5/p5-ch00.md), [Part6 - SQL코테](brain/Lecture/algo/fastcampus-algo/part6/p6-ch00.md)  중 **Part6 SQL코테**를 정리한 내용\n\n\u003chr\u003e\n\n## 목차\n\n1. [SQL코테 - 문법설명](brain/Lecture/algo/fastcampus-algo/part6/p6-ch01.md)\n2. [SQL코테 - 문제풀이](brain/Lecture/algo/fastcampus-algo/part6/p6-ch02.md)\n\n\u003chr\u003e\n\n### 강의 샘플데이터\n\n\u003cbr\u003e\n\n![](brain/image/p6-ch00-3.png)","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part6/p6-ch01":{"title":"SQL코테 - 문법설명","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의를 정리한 내용\n\n본 내용은 PostgreSQL 기준으로, MySQL과 차이가 있을 수 있음\n\n\u003chr\u003e\n\n## 기본 문법\n\n### 기본검색 및 정렬 (SFWO)\n\n\u003cbr\u003e\n\n```sql\nSELECT [속성명(s)] (\",\"를 통해서 구분)\nFROM [테이블명]\nWHERE [조건(s)] (and, or 연산자를 통해서 구분)\nORDER BY [속성명(s)] (\",\"를 통해서 구분)\n```\n\n- `SELECT`\n\t- 추출하여 **보고 싶은 데이터의 속성명**을 나열\n- `FROM`\n\t- 추출하고 싶은 **데이터가 존재하는 테이블**명\n- `WHERE`\n\t- FROM 절에서 나열한 테이블, SELECT 절에서 나열한 속성을 토대로 **어떤 조건으로 추출**할 것인지 조건\n- `ORDER BY`\n\t- SELECT 절에서 나열한 속성들을 FROM 절에서 명시한 테이블 내 속성 중 **어떤 속성으로 정렬**하여 보여줄지\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 그룹제어 (GROUP BY)\n\n\u003cbr\u003e\n\n```sql\nSELECT [GROUP BY에서 사용된 속성명(s), 집계함수]\nFROM [테이블명]\nWHERE [조건(s)]\nGROUP BY [속성명(s)] (\",\"를 통해서 구분)\nHAVING [GROUP BY절에 해당하는 조건들] (\",\"를 통해서 구분)\n```\n\n- `GROUP BY`\n\t- 앞의 **검색으로 얻은 데이터들을 특정 조건으로 그룹화하여 데이터를 추출**\n\t- 주의) ==**SELECT 절에 나열되는 속성들은 GROUP BY에서 사용한 속성들만 사용 가능**==\n\t\t- GROUP BY에서 사용하지 않은 속성들을 사용하고 싶으면 ==**필요에 따라 집계 함수를 SELECT 절에서 표현하여 사용 가능**==\n- `HAVING`\n\t- **GROUP BY로 생성된 그룹에 대하여 임의의 조건을 명시**\n\t- 주의) ==**HAVING 절에서도 GROUP BY에 명시된 속성만 사용 가능**==\n\t\t- 집계함수 또한 사용 가능\n\t- WHERE 절과 가장 큰 차이는 **HAVING 절은 집계 함수를 사용하여 조건을 표현할 수 있다는 점**\n\n\u003cbr\u003e\n\n1. WHERE 절에서의 조건을 만족하는 데이터들에 대하여\n2. GROUP BY로 그룹화 하고\n3. 해당 그룹에 HAVING을 통해서 조건을 명시하여 데이터 추출\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 분기문 (IF / CASE WHEN)\n\n- 기본적으로 `CASE - WHEN - THEN - ELSE - END`의 구조\n\t- MySQL은 CASE WHEN 대신 `IF 함수` 사용 가능\n\n```sql\n-- MYSQL에만 IF문 존재\nSELECT IF(5-3 \u003e 0, 'TRUE', 'FALSE');\n\n-- PostgreSQL\nSELECT CASE WHEN 5 - 3 \u003e 0 THEN 'TRUE' ELSE 'FALSE' END;\n```\n\n\u003cbr\u003e\n\n1. 간단한 case 표현식\n\n```sql\nSELECT\n\t(CASE [속성명] WHEN [비교값1] THEN [반환값1]\n\t\t\t\t WHEN [비교값2] THEN [반환값2] \n\t\t\t\t WHEN [비교값3] THEN [반환값3] \n\t\t\t\t WHEN [비교값4] THEN [반환값4] \n\t\t\t\t WHEN [비교값5] THEN [반환값5]\n\t\t\t\t\t\t\t .\n\t\t\t\t\t\t\t .\n\tELSE [WHEN절 이외의 조건일때 반환될 값]\n\tEND) AS [별칭 속성명]\nFROM [테이블명]\n```\n\n- `CASE`\n\t- 해당하는 속성명\n- `WHEN`\n\t- CASE의 속성과 비교될 수 있는 값\n- `THEN`\n\t- CASE의 속성과 WHEN의 비교가 참이라면 반환할 값\n- `ELSE`\n\t- WHEN의 이외의 조건일 때 반환할 값\n- `END`\n\t- CASE 구문 종료\n\n\u003cbr\u003e\n\n2. 검색된 케이스 표현식\n\n```sql\nSELECT\n\t(CASE WHEN [조건문1] THEN [반환값1]\n\t\t  WHEN [조건문2] THEN [반환값2] \n\t\t  WHEN [조건문3] THEN [반환값3] \n\t\t  WHEN [조건문4] THEN [반환값4] \n\t\t  WHEN [조건문5] THEN [반환값5]\n\t\t\t\t\t\t.\n\t\t\t\t\t\t.\n\tELSE [WHEN절 이외의 조건일때 반환될 값]\n\tEND) AS [별칭 속성명]\nFROM [테이블명]\n```\n\n- `CASE`\n\t- 여기에 속성 안적음\n- `WHEN`\n\t- 여기에 바로 조건 명시\n- `THEN`\n\t- 조건문이 참일 때 반환할 값\n- `ELSE`\n\t- WHEN절 이외의 조건일 때 반환할 값\n- `END`\n\t- CASE 구문 종료\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 집합연산 (UNION)\n\nUNION은 두 개 이상의 쿼리 결과를 하나로 합쳐주는 집합 연산자\n\n- **UNION 사용 조건**\n\t- 합쳐주는 **SELECT 부분의 ==반환 속성 개수와 순서==가 모든 쿼리에서 동일해야함**\n\t- 각 속성의 데이터 형식이 서로 호환되어야 함\n\n\u003cbr\u003e\n\n1. **UNION**\n\n```sql\nSELECT [속성1]\n\t\t,[속성2]\n\t\t,[속성3]\nFROM [테이블명1]\nUNION\nSELECT [속성1]\n\t\t,[속성2]\n\t\t,[속성3]\nFROM [테이블명2]\n```\n\n- 합쳐지는 SELECT 구문 중 중복되는 값이 있으면 중복을 제거하고 결과 보여줌\n\n\u003cbr\u003e\n\n2. **UNION ALL**\n\n```sql\nSELECT [속성1]\n\t\t,[속성2]\n\t\t,[속성3]\nFROM [테이블명1]\nUNION ALL\nSELECT [속성1]\n\t\t,[속성2]\n\t\t,[속성3]\nFROM [테이블명2]\n```\n\n- 중복되는 결과가 있더라도 모두 보여줌\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 순위집계 (RANK)\n\n- 그룹별 랭킹을 안넣고 싶으면 `PARTITION BY` 빼도 됨\n\n\u003cbr\u003e\n\n1. == **RANK : 동일한 값에 대하여 동일한 순위 부여하고 건너뛰기**==\n\n```sql\nSELECT RANK() OVER(\nPARTITION BY [그룹화할 속성들] \nORDER BY [순위를 매길 때 사용할 속성들]\n)\nFROM [테이블명1]\n\n-- 예) 1등(100점), 2등(90점), 3등(85점), 3등(85점), 3등(85점)\n-- 6등(80점), 7등(79점) ...\n```\n\n- 3등이 3명이면 3등을 3명에게 부여하고, 다음 순위는 6등\n\n\u003cbr\u003e\n\n2. == **DENSE_RANK : 동일한 값에 대하여 동일한 순위 부여하고 건너뛰기 X**==\n\n```sql\nSELECT DENSE_RANK() OVER(\nPARTITION BY [그룹화할 속성들] \nORDER BY [순위를 매길 때 사용할 속성들]\n)\nFROM [테이블명1]\n\n-- 예) 1등(100점), 2등(90점), 3등(85점), 3등(85점), 3등(85점)\n-- 4등(80점), 5등(79점) ...\n```\n\n- 3등이 3명이면 3등을 3명에게 부여하고, 다음 순위는 차례대로 4등을 부여\n\n\u003cbr\u003e\n\n3. == **ROW_NUMBER : 동일한 값에 대해서도 고유한 순위 부여**==\n\n```sql\nSELECT ROW_NUMBER() OVER(\nPARTITION BY [그룹화할 속성들] \nORDER BY [순위를 매길 때 사용할 속성들]\n)\nFROM [테이블명1]\n\n-- 예) 1등(100점), 2등(90점), 3등(85점), 4등(85점), 5등(85점)\n-- 6등(80점), 7등(79점) ...\n```\n\n- 85점이 동일하게 3명인데도 각각 3등, 4등, 5등의 고유한 순위 부여\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 조인 (JOIN)\n\n\u003cbr\u003e\n\n1. ==**INNER JOIN**==\n\t- 결과값을 결합하는 두 테이블 간에 `ON 절`에 명시된 속성으로 **양 쪽 모두 존재하는 데이터들만 결합하는 방법**\n\t- `INNER` 문구는 생략해도 됨\n\n![](brain/image/p6-ch01-1.png)\n\n```sql\nSELECT *\nFROM [테이블1] AS A\nINNER JOIN [테이블2] AS B\nON A.KEY = B.KEY\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n2. ==**OUTER JOIN**==\n\t- **LEFT OUTER JOIN**\n\t- **RIGHT OUTER JOIN**\n\t- 어디에 더 기준을 둘 것이냐에 따른 차이\n\t\t- LEFT면 왼쪽꺼 전부 결과에 추가 (null도)\n\t\t- RIGHT면 오른쪽꺼 전부 결과에 추가 (null도)\n\t- OUTER 생략하고 써도 무방\n\n![](brain/image/p6-ch01-2.png)\n\n![](brain/image/p6-ch01-3.png)\n\n```sql\n-- LEFT OUTER JOIN \nSELECT *  \nFROM [테이블1] AS A\nLEFT OUTER JOIN [테이블2] AS B \nON A.KEY = B.KEY\n\n-- RIGHT OUTER JOIN \nSELECT *  \nFROM [테이블1] AS A\nRIGHT OUTER JOIN [테이블2] AS B \nON A.KEY = B.KEY\n```\n\n\u003cbr\u003e\n\n3. ==**FULL OUTER JOIN**==\n\t- 좌측의 테이블 1을 기준으로 우측에 테이블 2를 붙이는 결과값\n\t- MySQL은 FULL OUTER JOIN 없음\n\t\t- LEFT OUTER JOIN, RIGHT OUTER JOIN을 **UNION해서 써야함**\n\n![](brain/image/p6-ch01-4.png)\n\n```sql\nSELECT *  \nFROM [테이블1] AS A\nFULL OUTER JOIN [테이블2] AS B \nON A.KEY = B.KEY\n```\n\n\u003cbr\u003e\n\n4. ==**SELF JOIN**==\n\t- 자기 자신과 조인\n\t- **하나의 테이블에 같은 데이터가 존재하면서 의미가 다르게 존재하는 경우 활용 가능**\n\t- 주의) 좌측, 우측 테이블 명이 같으니까 꼭 별칭 써서 구분하기\n\n![](brain/image/p6-ch01-5.png)\n\n```sql\nSELECT *  \nFROM [테이블1] AS A\nJOIN [테이블1] AS B \nON A.NAME = B.MANAGER\n```\n\n![](brain/image/p6-ch01-6.png)\n\n- ex) 하나의 테이블의 직업명이라는 속성에 \"김갑수\"라는 값이 존재하고 관리자명이라는 속성에도 \"김갑수\" 값이 존재할 경우, 위와 같이 사용 가능\n\t- 이렇게 하면, 관리자인 김갑수가 관리하는 직원의 이름 추출 가능\n\n\u003cbr\u003e\n\n5. ==**CROSS JOIN**==\n\t- 연결하는 `ON 절` 없이 두 테이블을 결합하여 모든 경우의 수가 발생하는 조인\n\t- 다른 말로 카테시안 곱\n\t- MySQL에서는 **`cross join = inner join = join`** 이다.\n\t\t-   원래는 **cross join**에 join condition이 따로 없으니까 `ON or USING`을 쓰면 안되는데 MySQL에서는 된다.\n\t\t- **cross join**에 `ON or USING`을 같이 쓰면 **inner join**으로 동작함\n\t\t- **inner join (or join)** 이 `ON or USING` 없이 사용된다면 **cross join**으로 동작함\n\n![](brain/image/p6-ch01-7.png)\n\n```sql\nSELECT *  \nFROM [테이블1] AS A\nCROSS JOIN [테이블2] AS B\n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 함수\n\n### 집계 함수\n\n1. **`MAX([속성명])`** \n\t- 명시된 ==**속성 내 값들 중 최대값을 반환**==\n\n2. **`MIN([속성명])`** \n\t- 명시된 ==**속성 내 값들 중 최소값을 반환**==\n\n3. **`COUNT([속성명])`**\n\t- 명시된 ==**속성 내 값의 전체 행 수를 반환 (NULL값 제외)**==\n\n4. **`SUM([속성명])`** \n\t- 명시된 ==**속성의 데이터 타입이 숫자일 경우, 해당 속성 내 모든 데이터의 합 반환 (NULL값 제외)**==\n\n5. **`AVG([속성명])`**\n\t- 명시된 ==**속성의 데이터 타입이 숫자일 경우, 해당 속성 내 모든 데이터의 평균 반환 (NULL값 제외)**==\n\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 문자열 함수\n\n1. **`SUBSTRING(string, int, int)`** \n\t- 명시한 문자열 첫 번째 int 부터, 두 번째 int의 개수만큼 부분 문자열을 잘라오기\n\n2.  **`LTRIM(string), LTRIM(string, string) / RTRIM(string), RTRIM(string, string)`**\n\t- 명시한 문자열의 좌측/우측 공백을 제거 , 특정 문자 제거\n\t- 중간 중간 공백을 제거하는 것 ❌\n\t- 첫 번째 string부터 문자열 안에 두 번째 string이 포함되어있다면 이를 제거\n    \n3.  **`LPAD(string, n, string) / RPAD(string, n, string)`**\n\t- 첫 번째 명시한 문자열에 길이가 n 이 되도록 좌측/우측부터 세 번째 명시한 문자열로 채운 표현식을 반환\n    \n4.  **`REPLACE(string, string_pattern, string_replacement)`**\n\t- 첫 번째 명시된 문자열 중 string_pattern에 해당하는 문자열을 string_replacement문자열로 변환한다.\n    \n5.  **`LENGTH(string)`**\n\t- 명시된 문자열의 길이를 구하여 반환한다.\n\n![](brain/image/p6-ch01-8.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 날짜 함수\n\n1. **`NOW()`**\n\t- 현재의 날짜 및 시간을 출력\n\n2. **`AGE(timestap, timestap) / AGE(timestap)`**\n\t- 두 날짜 사이의 시간 차이를 계산 / 현재 날짜와 첫 번째 명시한 날짜의 시간 차이를 계산\n\t- PostgreSQL에만 있는거임\n\n- MySQL의 날짜 시간차이 \u003ca href='https://velog.io/@12aeun/SQL-mysql%EC%97%90%EC%84%9C-%EB%82%A0%EC%A7%9C-%EC%8B%9C%EA%B0%84-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0' target='_blank'\u003e그냥 여기꺼 보셈\u003c/a\u003e\n- ==**`DATEDIFF(timestap, timestap)`**==\n- ==**`TIMESTAMPDIFF(형식, 앞날짜, 뒤날짜)`**==\n\t- 형식에는 year(년), quarter(분기), month(월), week(주), day(일), hour(시), minute(분), second(초)가 가능\n\n```sql\nSELECT DATEDIFF('2023-04-19 11:44:59', '2023-04-01 00:00:00');\n-- 결과 : 748\n\nSELECT TIMESTAMDIFF(minute, '2023-04-01 00:00:00', '2023-04-19 11:44:59');\n-- 결과 : 1077824\n```\n\n\u003cbr\u003e\n\n3. **`DATE_PART(text, timestamp)`**\n\t- 두 번째 명시한 timestamp에서 첫 번째 명시한 날짜 키워드 인자에 해당하는 값을 추출\n\n4. **`DATE_TRUNC(text, timestap)`**\n\t- 두 번째 명시된 timestamp에서 첫 번째 명시한 날짜 키워드 인자에 해당하는 값 이하의 날짜데이터를 Default처리하고 반환\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 그외 함수\n\n1. **`TO_CHAR(timestap, text)`**\n\t- 첫 번째로 명시된 timestamp 값을 두번째 인자의 포맷 문자열로 변환하여 반환\n\t- MySQL은 이거 없음 ==**`DATE_FORMAT(날짜, 포맷)`**==\n\n**MySQL 포맷**\n\n| 결과                 | DATE_FORMAT |\n| -------------------- | ----------- |\n| 연도(4자리)          | %Y          |\n| 연도(2자리)          | %y          |\n| 월(1~12)             | %m          |\n| 월(Jan~Dec)          | %b          |\n| 월(January~December) | %M          |\n| 일(1~31)             | %d          |\n| 일(Sun~Sat)          | %a          |\n| 시간(0~23)           | %H          |\n| 시간(1~12)           | %h          |\n| 분(0~59)             | %i          |\n| 초(0~59)             | %s            |\n\n\u003cbr\u003e\n\n```sql\n-- MySQL\nSELECT DATE_FORMAT(now(), '%Y-%m-%d');\n\u003e\u003e 2023-04-27\n```\n\n\u003cbr\u003e\n\n2.  **`COALESCE(value, ex1, ex2, ...)`**\n\t- 첫 번째로 명시된 인자가 null일 경우 두 번째 인자를 반환, 두 번째인자가 null일 경우 세 번째 인자를 반환... 순차적으로 반환\n    \n3.  **`CAST(source_type as target_type)`**\n\t- 첫 번째 명시된 source_type을 두 번째 인자로 명시된 target_type으로 변환하여 반환\n\t\t- MySQL에서 CAST 함수로 날짜 간격을 직접 계산하는 것은 지원X\n\t\t- BETWEEN을 이용한 비교 정도는 괜찮음. 3번문제 참조\n\t\t- 날짜 간격 계산하고싶으면 `DATE_SUB()` 써라.\n\t\t\t- `DATE_SUB(기준날짜, INTERVAL 1 SECOND)`\n\t\t\t- `DATE_SUB(기준날짜, INTERVAL 1 MINUTE)`\n\t\t\t- `DATE_SUB(기준날짜, INTERVAL 1 HOUR)`\n\t\t\t- `DATE_SUB(기준날짜, INTERVAL 1 DAY)`\n\t\t\t- `DATE_SUB(기준날짜, INTERVAL 1 MONTH)`\n\t\t\t- `DATE_SUB(기준날짜, INTERVAL 1 YEAR)`\n\t\t\t- `DATE_SUB(기준날짜, INTERVAL -1 YEAR)`\n    \n4.  **`ROUND(v numeric, s int)`**\n\t- 첫번째 명시된 v 값을 소수점 s자리까지 **반올림**하고 s자리 미만은 버림\n\t- MySQL에는 `TRUNCATE()`도 있는데, 이건 반올림안하고 무조건 버리는거\n\n\u003cbr\u003e\n","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/algo/fastcampus-algo/part6/p6-ch02":{"title":"SQL코테 - 문제풀이","content":"\n\u003ca href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'\u003e패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n유료강의의 문제를 직접 올릴 수는 없고, 해당하는 필기만 업로드 예정 ...","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/backend/":{"title":"Backend","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/backend/kim-spring/":{"title":"김영한 - Spring","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/backend/kim-spring/http/":{"title":"HTTP 웹","content":"","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/backend/kim-spring/http/section00":{"title":"HTTP 강좌 - 소개","content":"\n인프런 김영한님의 \u003ca href='https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC' target='_blank'\u003e모든 개발자를 위한 HTTP 웹 기본 지식\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n### 목차\n\n1. [섹션 1. 인터넷 네트워크](brain/Lecture/backend/kim-spring/http/section01.md)\n2. [섹션 2. URI와 웹 브라우저 요청 흐름](brain/Lecture/backend/kim-spring/http/section02.md)\n3. [섹션 3. HTTP 기본](brain/Lecture/backend/kim-spring/http/section03.md)\n4. [섹션 4. HTTP 메서드](brain/Lecture/backend/kim-spring/http/section04.md)\n5. [섹션 5. HTTP 메서드 활용](brain/Lecture/backend/kim-spring/http/section05.md)\n6. [섹션 6. HTTP 상태코드](brain/Lecture/backend/kim-spring/http/section06.md)\n7. [섹션 7. HTTP 헤더1 - 일반 헤더](brain/Lecture/backend/kim-spring/http/section07.md)\n8. [섹션 8. HTTP 헤더2 - 캐시와 조건부 요청](brain/Lecture/backend/kim-spring/http/section08.md)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### Intro\n\n- 모든 것이 HTTP 프로토콜 기반 위에서 동작\n\t- HTML, 영상, 이미지, 파일, 앱과 서버 통신, 서버와 서버 통신 등\n\n","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/backend/kim-spring/http/section01":{"title":"인터넷 네트워크","content":"\n인프런 김영한님의 \u003ca href='https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC' target='_blank'\u003e모든 개발자를 위한 HTTP 웹 기본 지식\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n### 인터넷 통신\n\n**인터넷 상에서 컴퓨터 둘은 어떻게 통신할까?**\n\n![](brain/image/section01-1.png)\n\n- 수많은 노드들을 지나며 통신하는데, 너무 복잡하다.\n- 이에 대한 이해를 위해 IP를 알아야한다.\n\n\u003cbr\u003e\u003chr\u003e\n\n### IP(인터넷 프로토콜)\n\n**IP 주소를 통해 통신이 가능해진다. 따라서, 먼저 IP를 부여받아야 함**\n- IP (Internet Protocol) 역할\n\t- 지정한 IP 주소(IP Address)에 데이터 전달\n\t- 패킷(Packet)이라는 통신 단위로 데이터 전달\n\n\u003cbr\u003e\u003cbr\u003e\n\n**메시지를 그냥 보내는 것이 아니라, IP 패킷에 정보를 담아서 보내야 한다.**\n- 출발지 IP, 목적지 IP, 등등\n\n![](brain/image/section01-2.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**그러나, IP 프로토콜은 한계가 있다**==\n- 비연결성\n\t- 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷이 전송됨\n- 비신뢰성\n\t- 중간에 패킷이 사라지면?\n\t- 패킷이 순서대로 안오면?\n- 프로그램 구분\n\t- 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?\n- 예시\n\t1. **대상이 서비스 불능, 패킷 전송** ![](brain/image/section01-3.png)\n\n\t2. **비신뢰성 - 패킷손실** ![](brain/image/section01-4.png)\n\n\t3. **비신뢰성 - 패킷 전달 순서 문제 발생** ![](brain/image/section01-5.png)\n\n\u003cbr\u003e\n\n이렇게 IP만으로 해결이 되지 않는 이유로, 아래에서 설명할 \u003ca href='/brain/Lecture/kim-spring/http/section01/#tcp-udp'\u003eTCP\u003c/a\u003e라던가 \u003ca href='/brain/Lecture/kim-spring/http/section01/#port'\u003ePORT\u003c/a\u003e라던가 혹은 \u003ca href='/brain/Lecture/kim-spring/http/section01/#dns'\u003eDNS\u003c/a\u003e 등의 개념이 나오게 되었다.\n\n\u003cbr\u003e\u003chr\u003e\n\n### TCP, UDP\n\n**IP (인터넷 프로토콜) 스택의 4계층**\n\n- 애플리케이션 계층 - HTTP, FTP\n- 전송계층 - TCP, UDP\n- 인터넷 계층 - IP\n- 네트워크 인터페이스 계층 - 랜카드, 랜드라이버 등등\n\n\u003cbr\u003e\u003cbr\u003e\n\n**프로토콜 계층**\n\n![](brain/image/section01-6.png)\n\n1. 소켓 라이브러리를 통해 OS 계층에다가 데이터를 넘김\n2. TCP 정보 생성해서 씌우기\n3. IP 패킷 생성해서 씌우기\n4. Ethernet Frame (실제 물리적인 주소 등) 씌워서 보내기\n\n\u003cbr\u003e\u003cbr\u003e\n\n**TCP/IP 패킷 정보**\n\n![](brain/image/section01-7.png)\n\n- 순서 제어와 같이 IP 만으로 해결안됐던 부분이 TCP 정보를 통해 해결됨\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**TCP (Transmission Control Protocol, 전송 제어 프로토콜) 특징**==\n- 연결지향, 신뢰할 수 있는 프로토콜, 현재는 대부분 TCP 사용\n\t- **TCP 3 way handshake** ==**(가상연결)**==\n\t- 개념적인 연결이지, 실제 물리적인 연결이 아님 논리적 연결\n\t- SYN : 접속 요청, ACK : 요청 수락, 3번에 ACK와 함께 데이터 전송 가능 \n\t\t![](brain/image/section01-11.png)\n- 데이터 전달 보증\n\t\t![](brain/image/section01-9.png)\n- 순서 보장\n\t\t![](brain/image/section01-10.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**UDP (User Datagram Protocol, 사용자 데이터그램 프로토콜) 특징**==\n- 하얀 도화지에 비유 (기능이 거의 ❌)\n- 연결지향 - TCP 3 way handshake ❌\n- 데이터 전달 보증 ❌\n- 순서 보장 ❌\n- **UDP**는 IP와 거의 같음\n\t- **IP에 PORT, 체크섬 정도가 추가**된 것\n\t- 애플리케이션에서 추가 작업 필요\n- 이렇게 보면 UDP 왜쓰지? 싶을거다\n\t- TCP는 3 way handshake에 걸리는 시간, 데이터의 양이 커지고, 전송속도를 더 빠르게 만들기 힘들다. 이미 인터넷이라는게 다 TCP 기반이라 튜닝하기 힘들다.\n\t- 이때, UDP는 하얀 도화지 상태라서 튜닝이 가능하다.\n\t- **TCP가 거의 90 몇프로 점유한 상태였는데, 이 SYN - SYN/ACK - ACK 과정도 다 줄여서 최적화해보자고 하여 HTTP 3의 경우에 UDP 프로토콜을 사용하면서 굉장히 뜨는 추세**\n\n\u003cbr\u003e\u003chr\u003e\n\n### PORT\n\n**한 번에 둘 이상 연결해야 하면?**\n- 내 IP로 패킷들이 날라올텐데, 이게 게임 패킷인지 웹 브라우저 응답 패킷인지 어떻게 구분해?\n- 그래서 PORT가 필요함\n\n\u003cbr\u003e\n\n==**PORT : 같은 IP 내에서 프로세스 구분**==\n\n![](brain/image/section01-12.png)\n\n- 어떻게 서버가 클라이언트의 포트를 알고 저기로 쏴?\n- \u003ca href='/brain/Lecture/kim-spring/http/section01/#tcp-udp'\u003e위에서\u003c/a\u003e 그림 보면 TCP/IP 패킷에 출발지 PORT도 있잖아~\n- ex) **아파트가 IP주소 ! 몇 동 몇 호가 포트번호!**\n\n\u003cbr\u003e\u003cbr\u003e\n\n**PORT 번호**\n\n- 0 ~ 65535 할당 가능\n- 0 ~ 1023 : 잘 알려진 포트, 사용하지 않는 것이 좋음\n\t- FTP - 20, 21\n\t- TELNET - 23\n\t- HTTP - 80\n\t- HTTPS - 443\n\n\u003cbr\u003e\u003chr\u003e\n\n### DNS\n\n**DNS가 나오게 된 배경**\n\n1. IP 주소는 기억하기 어렵다.\n2. IP 주소는 변경될 수 있다.\n\n\u003cbr\u003e\n\n==**DNS (Domain Name System, 도메인 네임 시스템)**==\n- 중간에 전화번호부 같은 서버를 제공해줌\n- 도메인 명은 IP 주소로 변환 가능\n\n![](brain/image/section01-13.png)\n","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/backend/kim-spring/http/section02":{"title":"URI \u0026 Web","content":"\n인프런 김영한님의 \u003ca href='https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC' target='_blank'\u003e모든 개발자를 위한 HTTP 웹 기본 지식\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n### URI\n\n==**URI (Uniform Resource Identifier) : 리소스를 식별하는 통합된 방법**==\n- 리소스를 식별한다는 것은, 사람을 주민등록번호로 식별하는 것처럼 **자원이 어디에 있는 지, 자원 자체를 식별하는 방법을 의미**\n\n\u003cbr\u003e\n\n==**URI? URL? URN?**==\n- URI는 로케이터(**L**ocator), 이름(**N**ame) 또는 둘 다 추가로 분류될 수 있음\n- URL : 리소스가 이 위치에 있어요 !\n- URN : 리소스의 이름이 이거에요 !\n\n![](brain/image/section02-1.png)\n\n![](brain/image/section02-2.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**URI의 단어 의미**\n- **U**niform : 리소스를 식별하는 통일된 방식\n- **R**esource : 자원, URI로 식별할 수 있는 모든 것 (제한 ❌)\n- **I**dentifier : 다른 항목과 구분하는데 필요한 정보\n\t- URL : Uniform Resource Locator\n\t- URN : Uniform Resource Name\n\n\u003cbr\u003e\n\n**URL, URN의 단어 의미**\n- URL - Locator : 리소스가 있는 위치를 지정\n- URN - Name : 리소스에 이름을 부여\n- **위치**는 변할 수 있지만, **이름**은 변하지 않는다.\n- `urn:isbn:8960777331` (어떤 책의 isbn URN)\n- URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음\n- ==앞으로 URI를 URL과 같은 의미로 이야기하겠음==\n\n\u003cbr\u003e\n\n**URL 분석해보기**\n\n![](brain/image/section02-3.png)\n\n`scheme://[userinfo@]host[:port][/path][?query][#fragment]`\n\n- 프로토콜 (`https`)\n- 호스트명 (`www.google.com`)\n- 포트번호 (`443`)\n- 자원 경로 (`/search`)\n- 쿼리 파라미터 (`q=hello\u0026hl=ko`)\n\n\u003cbr\u003e\n\n==**scheme**==\n\n **`scheme`**`://[userinfo@]host[:port][/path][?query][#fragment]`\n \n **`https`**`://www.google.com:443/search?q=hello\u0026hl=ko`\n \n - 주로 프로토콜 사용\n - 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속, 규약, 규칙\n\t - ex) http, https, ftp 등등\n- http는 80 포트, https는 443 포트를 주로 사용, **포트는 생략 가능**\n- https는 http에 보안이 추가된 형태 (HTTP Secure)\n\n\u003cbr\u003e\n\n==**userinfo**==\n\n`scheme://`**`[userinfo@]`**`host[:port][/path][?query][#fragment]` \n\n`https://www.google.com:443/search?q=hello\u0026hl=ko`\n\n- URL에 사용자 정보를 포함해서 인증\n- 거의 사용하지 않음\n\n\u003cbr\u003e\n\n==**host**==\n\n`scheme://[userinfo@]`**`host`**`[:port][/path][?query][#fragment]`\n\n`https://`**`www.google.com`**`:443/search?q=hello\u0026hl=ko`\n\n- 호스트명\n- 도메인명 or IP주소를 직접 사용 가능\n\n\u003cbr\u003e\n\n==**PORT**==\n\n`scheme://[userinfo@]host`**`[:port]`**`[/path][?query][#fragment]`\n\n`https://www.google.com:`**`443`**`/search?q=hello\u0026hl=ko`\n\n- 포트(PORT)\n- 접속 포트\n- 일반적으로 생략, 생략시 http는 80, https는 443\n\n\u003cbr\u003e\n\n==**path**==\n\n`scheme://[userinfo@]host[:port]`**`[/path]`**`[?query][#fragment]`\n\n`https://www.google.com:443/`**`search`**`?q=hello\u0026hl=ko`\n\n- 리소스가 있는 경로(path), **계층적 구조**\n- ex) `/home/file1.jpg`, `/members`, `/members/100`, `/items/iphone12`\n\n\u003cbr\u003e\n\n==**query**==\n\n`scheme://[userinfo@]host[:port][/path]`**`[?query]`**`[#fragment]`\n\n`https://www.google.com:443/search`**`?q=hello\u0026hl=ko`**\n\n- key=value 형태\n- ?로 시작, \u0026로 추가 가능 `?keyA=valueA\u0026keyB=valueB`\n- query parameter, query string 등으로 불림\n\t- 웹서버에 제공하는 파라미터, 문자 형태\n\n\u003cbr\u003e\n\n==**fragment**==\n\n`scheme://[userinfo@]host[:port][/path][?query]`**`[#fragment]`**\n\n`https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html`**`#getting-started-introducing-spring-boot`**\n\n- **html 내부 북마크** 등에 사용\n- **서버에 전송하는 정보 아님**\n\n\u003cbr\u003e\u003chr\u003e\n\n### Web Browser\n\n\u003cbr\u003e\n\n==**웹 브라우저 요청 흐름**==\n![](brain/image/section02-3.png)\n- 웹 브라우저의 주소창에 입력했을 때 일어나는 흐름을 살펴보자\n\n\u003cbr\u003e \u003chr\u003e\n\n\n==**1. 웹 브라우저가 DNS 서버 조회하여 IP 찾고, https 인 것을 이용하여  포트 정보 443 찾아내고 HTTP 요청 메시지 생성**==\n\n![](brain/image/section02-4.png)\n![](brain/image/section02-5.png)\n\n\u003cbr\u003e\n\n==**2. 생성한 HTTP 요청 메시지를 SOCKET 라이브러리를 통해 TCP/IP 계층으로 전달**==\n- SYN - SYN/ACK - ACK로 TCP/IP에 연결 (IP, PORT 정보 있으니까)\n- 그리고 데이터 전달\n\n![](brain/image/section02-6.png)\n\n\u003cbr\u003e\n\n==**3. HTTP 메시지를 감싸는 TCP/IP 패킷 생성하고, 최종적으로 물리적인 네트워크 인터페이스를 통해 인터넷 공간으로 나감**==\n\n![](brain/image/section02-9.png)\n\n\u003cbr\u003e\n\n==**4. 웹 브라우저에서 출발한 요청 패킷이 구글 서버로 전달**==\n- 패킷을 받으면, 구글 서버에서는 HTTP 메시지 빼고는 다 까서 버림\n- 마치 택배 도착한거 포장 까는것처럼\n\n![](brain/image/section02-12.png)\n\n![](brain/image/section02-11.png)\n\n\u003cbr\u003e\n\n==**6. 구글 서버에서 HTTP 응답 메시지 생성하고 웹 브라우저로 응답 패킷 전달**==\n\n![](brain/image/section02-13.png)\n\n![](brain/image/section02-14.png)\n\n![](brain/image/section02-15.png)\n\n\u003cbr\u003e\n\n==**7. 최종적으로 웹 브라우저가 응답 패킷을 까서 HTTP 메시지를 확인하고 렌더링해서 화면에 모습을 보여줌**==\n\n![](brain/image/section02-16.png)\n\n","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/backend/kim-spring/http/section03":{"title":"HTTP 기본","content":"\n인프런 김영한님의 \u003ca href='https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC' target='_blank'\u003e모든 개발자를 위한 HTTP 웹 기본 지식\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n### 모든 것이 HTTP\n\n\u003cbr\u003e\n\n**HTTP (HyperText Transfer Protocol) : 문서 간 링크를 통해 연결할 수 있는 HTML 같은 Hypertext를 전송하는 프로토콜**\n- 시작은 이러했지만, ==**현재는 모든 것을 HTTP 메시지에 담아 전송**==\n\t- HTML, TEXT\n\t- IMAGE, 음성, 영상, 파일\n\t- JSON, XML (API)\n- 거의 모든 형태의 데이터 전송 가능\n- 심지어, ==**서버 간 데이터를 주고 받을 때도 대부분 HTTP 사용**==\n\t- 실무에서도 서버 간에 통신할 때 TCP 프로토콜을 직접 연결해서 데이터를 전송하는 경우는 잘 없음\n\n\u003cbr\u003e\n\n==**HTTP 역사**==\n- `HTTP/0.9` 1991년 : GET 메서드만 지원, HTTP 헤더 X\n- `HTTP/1.0` 1996년 : 메서드, 헤더 추가\n- **`HTTP/1.1` 1997년 : 가장 많이 사용, 우리에게 가장 중요한 버전**\n\t- RFC2068 (1997) → RFC2616 (1999) → RFC7230~7235 (2014)\n- `HTTP/2` 2015년 : 성능 개선\n- `HTTP/3` 진행중 : TCP 대신 UDP 사용, 성능 개선\n\n\u003cbr\u003e\n\n**기반 프로토콜**\n- TCP : `HTTP/1.1`, `HTTP/2`\n- UDP : `HTTP/3`\n- 현재 `HTTP/1.1` 주로 사용\n\t- `HTTP/2`, `HTTP/3`도 점점 증가\n\n\u003cbr\u003e\n\n==**HTTP 특징**==\n- 기본적으로 클라이언트-서버 구조로 동작\n- **무상태 프로토콜(stateless)**, 비연결성\n- HTTP 메시지를 이용하여 통신 (보낼때도, 받을때도)\n- 단순함, 확장 가능\n\n\u003cbr\u003e\u003chr\u003e\n\n### 클라이언트-서버 구조\n\n\u003cbr\u003e\n\n==**클라이언트-서버 구조 : HTTP는 기본적으로 이 구조를 따름**==\n\n![](brain/image/section03-1.png)\n\n- Request Response 구조\n- HTTP에서 클라이언트는 HTTP 메시지로 서버에 요청을 보내고 응답 대기\n- HTTP에서 서버는 요청에 대한 결과를 HTTP 메시지로 만들어서 응답\n\n\u003cbr\u003e\n\n**클라이언트-서버 구조로 개념적으로 분리하는 것이 중요한 이유는?**\n- 비즈니스 로직, 데이터는 전부 서버에 밀어넣고, 클라이언트는 UI를 그리는 것, 사용성, UX 등에 집중할 수 있게 됨\n- 이렇게 분리하면 **클라이언트, 서버는 각각 독립적으로 발전할 수 있고, 각각의 분아야 집중할 수 있게 됨**\n\n\u003cbr\u003e\u003chr\u003e\n\n### Stateful, Stateless\n\n\u003cbr\u003e\n\n==**HTTP는 무상태 프로토콜 (Stateless)을 지향한다.**==\n- 무상태 프로토콜 (Stateless)\n\t- **서버가 클라이언트의 상태를 보존하지 않는 것**\n\t- 장점 : 서버 확장성 높음 (scale-out)\n\t- 단점 : 클라이언트가 추가로 데이터 전송\n\n\u003cbr\u003e\n\n==**Stateful, Stateless 차이 정리**==\n- **상태 유지(Stateful)** : 중간에 다른 점원으로 바뀌면 ❌\n\t- 중간에 다른 점원으로 바꿀거면 상태 정보를 다른 점원에게 미리 알려줘야함\n- **무상태(Stateless)** : 중간에 다른 점원으로 바뀌어도 🟢\n\t- 갑자기 고객이 증가해서 점원을 대거 투입할 수 있음\n\t- 즉, ==**갑자기 클라이언트 요청이 증가해도 서버 대거 투입 가능**==\n- 무상태는 응답 서버를 쉽게 바꿀 수 있다. → **무한한 서버 증설 가능**\n\n\u003cdetails\u003e\u003csummary\u003e\u003cstrong\u003e예시로 이해하기\u003c/strong\u003e\u003c/summary\u003e\n\t\n**Stateful, 상태유지 예시 1**\n\n\u003e 고객 : 이 ==노트북==은 얼마인가요? \u003cbr\u003e\n\u003e 점원 : 100만원 입니다. \u003cbr\u003e\n\u003e **(노트북 상태 유지)**\u003cbr\u003e\u003cbr\u003e\n\u003e 고객 : ==2개== 구매하겠습니다. \u003cbr\u003e\n\u003e 점원 : 200만원 입니다. ==신용카드==, ==현금== 중 어떤걸로 구매하시겠어요? \u003cbr\u003e\n\u003e **(노트북, 2개 상태 유지)**\u003cbr\u003e\u003cbr\u003e\n\u003e 고객 : 신용카드로 구매하겠습니다. \u003cbr\u003e\n\u003e 점원 : 200만원 결제 완료되었습니다.\u003cbr\u003e\n\u003e  **(노트북, 2개, 신용카드 상태 유지)**\n\n\u003cbr\u003e\n\n**Stateful, 상태유지 예시 2 - 점원이 중간에 바뀌면?**\n\n\u003e 고객 : 이 ==노트북==은 얼마인가요? \u003cbr\u003e\n\u003e 점원**A** : 100만원 입니다. \u003cbr\u003e\u003cbr\u003e\n\u003e 고객 : ==2개== 구매하겠습니다. \u003cbr\u003e\n\u003e 점원**B** : ?? 무엇을 2개 구매하시겠어요?\u003cbr\u003e\u003cbr\u003e\n\u003e 고객 : 신용카드로 구매하겠습니다. \u003cbr\u003e\n\u003e 점원**C** : ?? 무슨 제품을 몇 개 신용카드로 구매하시겠어요??\n\n\u003cbr\u003e\n\n**Stateless, 무상태 예시 1**\n\n\u003e 고객 : 이 ==노트북==은 얼마인가요? \u003cbr\u003e\n\u003e 점원 : 100만원 입니다. \u003cbr\u003e\u003cbr\u003e\n\u003e 고객 : ==노트북 2개== 구매하겠습니다. \u003cbr\u003e\n\u003e 점원 : 노트북 2개는 200만원 입니다. ==신용카드==, ==현금== 중 어떤걸로 구매하시겠어요?\u003cbr\u003e\u003cbr\u003e\n\u003e 고객 : ==노트북 2개를 신용카드==로 구매하겠습니다. \u003cbr\u003e\n\u003e 점원 : 200만원 결제 완료되었습니다.\n\n\u003cbr\u003e\n\n**Stateless, 무상태 예시 2 - 점원이 중간에 바뀌면?**\n\n\u003e 고객 : 이 ==노트북==은 얼마인가요? \u003cbr\u003e\n\u003e 점원**A** : 100만원 입니다. \u003cbr\u003e\u003cbr\u003e\n\u003e 고객 : ==노트북 2개== 구매하겠습니다. \u003cbr\u003e\n\u003e 점원**B** : 노트북 2개는 200만원 입니다. ==신용카드==, ==현금== 중 어떤걸로 구매하시겠어요?\u003cbr\u003e\u003cbr\u003e\n\u003e 고객 : ==노트북 2개를 신용카드==로 구매하겠습니다. \u003cbr\u003e\n\u003e 점원**C** : 200만원 결제 완료되었습니다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**Stateful (상태유지) - 항상 같은 서버가 유지되어야 함**==\n\n- 항상 같은 서버가 유지되어야 함  \n\n![](brain/image/section03-2.png)\n\n- 만약, 중간에 서버 장애나면?\n\n![](brain/image/section03-3.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**Stateless (무상태) - 아무 서버나 호출해도 됨**==\n\n- 아무 서버나 호출해도 됨\n\n![](brain/image/section03-4.png)\n\n- 만약, 중간에 서버 장애나면?\n\n![](brain/image/section03-5.png)\n\n- Scale Out - 수평 확장에 유리!!\n\n![](brain/image/section03-6.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**Stateless (무상태) 실무 한계**==\n- 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있음 \n- 무상태\n\t- ex) 로그인이 필요 없는 단순한 서비스 소개 화면 \n- 상태 유지\n\t- ex) 로그인  \n- 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지 \n- 일반적으로 브라우저 쿠키와 서버 세션 등을 사용해서 상태 유지 \n- 상태 유지는 최소한만 사용\n- 또, 단점은 **아무래도 데이터를 너무 많이보낸다는 점**\n\n\u003cbr\u003e\u003chr\u003e\n\n### 비 연결성\n\n\u003cbr\u003e\n\n**연결을 유지하는 모델 vs 연결을 유지하지 않는 모델**\n\n- 연결 유지 🟢\n\n![](brain/image/section03-7.png)\n\n\u003cbr\u003e\n\n- 연결 유지 ❌ - 통신이 끝나면 TCP/IP 연결 종료해버림\n\n![](brain/image/section03-8.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**비 연결성 (Conectionless)**==\n- **HTTP는 기본적으로(default) 연결을 유지하지 않는 모델**\n- 일반적으로 초 단위 이하의 빠른 속도로 응답\n- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음\n\t- ex) 웹 브라우저에서 계속 연속하여 검색 버튼을 누르지 않음\n- **서버 자원을 매우 효율적으로 사용할 수 있음**\n\n\u003cbr\u003e\n\n==**비 연결성의 한계와 극복**==\n- 근데, 연결을 유지하지 않는다는 것은 **TCP/IP 연결을 새로 맺어야 한다는 의미**\n\t- TCP 3 way handshake 시간 추가\n- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 css, javascript, 추가 이미지 등 **수많은 자원이 함께 다운로드**\n- ==**현재에는 HTTP 지속 연결(Persistent Connections)을 사용하여 문제 해결**==\n- `HTTP/2`, `HTTP/3`에서 더 많은 최적화\n\n\u003cbr\u003e\n\n**HTTP 초기 - 연결하고 종료하여 낭비되는 시간**\n\n![](brain/image/section03-11.png)\n\n\u003cbr\u003e\n\n**HTTP 지속 연결(Persistent Connections)**\n\n![](brain/image/section03-12.png)\n\n\u003cbr\u003e\n\n==**결론은, Stateless(무상태)를 반드시 기억하자 !**==\n- 서버 개발자들이 정말 어려워하는 업무\n- 같은 시간에 딱 맞추어 발생하는 대용량 트래픽\n\t- ex) 선착순 이벤트, 명절 KTX 예약, 학과 수업 등록\n\t- ex) 저녁 6:00 선착순 1000명 치킨 할인 이벤트 -\u003e 수만명 동시 요청\n- 어떻게든 머리를 쥐어짜내서 ==**stateless하게 설계하는 것이 중요**==\n\n\u003cbr\u003e\n\n\u003e [!note] 실무 TIP \u003cbr\u003e\n\u003e 이벤트 설계할 때, 첫 페이지는 로그인도 필요없는 정적 페이지로 일단 하나 뿌림. 아무 상태가 없는 HTML 하나 딱 두는 것이다. 그럼 사람들이 좀 보다가 버튼을 누르고 하니까.. 완전 동시에 버튼을 누르진 않게된다.\n\n\u003cbr\u003e\u003chr\u003e\n\n### HTTP 메시지\n\n\u003cbr\u003e\n\n**HTTP 메시지 구조 살펴보기**\n- ==**시작 라인 + 헤더 + 공백 라인 + 메시지 바디**==\n- 공백 라인인 CRLF 반드시 포함해야함\n\n![](brain/image/section03-13.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**RFC7230 공식 스펙에 명시된 내용**\n\n![](brain/image/section03-14.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**시작 라인 (start-line)**==\n- 시작 라인은 **요청 라인(request-line)** / **상태 라인(status-line)** 으로 나뉨\n\n\u003cbr\u003e\n\n==**시작 라인 - 요청 메시지**==\n\n```http\nGET /search?q=hello\u0026hl=ko HTTP/1.1\nHost: www.google.com\n공백\n```\n\n**start-line : request-line 구성**\n- `method SP request-target SP HTTP-version CRLF`\n- **HTTP 메서드** + 공백 + **요청 대상** + 공백 + **HTTP 버전** + 엔터\n- SP는 공백, CRLF는 엔터를 의미\n\n**요청 메시지 - HTTP 메서드**\n- 종류 : GET, POST, PUT, DELETE ...\n- 서버가 수행해야 할 동작 지정\n\t- GET : 리소스 조회 (서버야 이 리소스 줘~)\n\t- POST : 요청 내역 처리 (서버야 이 리소스 줄테니까 처리해줘~)\n\n**요청 메시지 - 요청 대상**\n- `absolute-path[?query]`\n- 절대경로=\"/\"로 시작하는 경로\n- 참고로, `*`, `http://...?x=y`와 같이 다른 유형의 경로지정 방법도 있는데. 걍 넘겨\n\n**요청 메시지 - HTTP 버전**\n- HTTP Version\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**시작 라인 - 응답 메시지**==\n\n```http\nHTTP/1.1 200 OK\nContent-Type: text/html;charset=UTF-8\nContent-Length: 3423\n\n\u003chtml\u003e\n\t\u003cbody\u003e...\u003c/body\u003e\n\u003c/html\u003e\n```\n\n**start-line : status-line 구성**\n- `HTTP-version SP status-code SP reason-phrase CRLF`\n- **HTTP 버전** + 공백 + **HTTP 상태 코드** + 공백 + **이유 문구** + 엔터\n- HTTP 상태 코드 : 요청 성공, 실패를 나타냄\n\t- 200 : 성공\n\t- 400 : 클라이언트 요청 오류\n\t- 500 : 서버 내부 오류\n- 이유 문구 : 사람이 이해할 수 있는 짧은 상태 코드 설명 글\n\n\u003cbr\u003e\n\n==**HTTP 헤더**==\n\n![](brain/image/section03-16.png)\n- `header-filed = field-name \":\" OWS field-value OWS`\n- **필드-이름** : OWS + **필드-값** + OWS\n\t- OWS는 띄어쓰기 해도되고 안해도된다는 의미\n\t- 그래서 `필드-이름: `는 되는데 `필드-이름 : ` 이거는 안됨\n\t- 참고로, 필드-이름은 대소문자 구분 ❌\n\t- 당연히, 필드-값은 값이니까 대소문자 구분 🟢\n\n\u003cbr\u003e\n\n**HTTP 헤더 - 용도**\n- HTTP 전송에 필요한 모~든 부가정보 (=메타데이터)\n\t- ex) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보 ...\n- 표준 헤더가 너무 많음\n- 필요시 임의의 헤더 추가 가능\n\t- `helloworld: hihi`\n\n\u003cbr\u003e\n\n==**HTTP 메시지 바디**==\n\n![](brain/image/section03-18.png)\n\n- 실제 전송할 데이터\n- HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능\n\n\u003cbr\u003e\u003cbr\u003e\n\n**HTTP 스펙 단순함!**\n- HTTP 단순해서 스펙도 읽어볼만 함\n- HTTP 메시지도 매우 단순\n- 이렇게, 크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/backend/kim-spring/http/section04":{"title":"HTTP 메서드","content":"\n인프런 김영한님의 \u003ca href='https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC' target='_blank'\u003e모든 개발자를 위한 HTTP 웹 기본 지식\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n### HTTP API 제작\n\n\u003cbr\u003e\n\n**요구사항 : 회원 정보 관리 API를 만들어라**\n- 회원 목록 조회\n- 회원 조회\n- 회원 등록\n- 회원 수정\n- 회원 삭제\n\n\u003cbr\u003e\n\n**API URI(Uniform Resource Identifier) 설계**\n- 회원 목록 조회 : `/read-member-list`\n- 회원 조회 : `/read-member-by-id`\n- 회원 등록 : `/create-member`\n- 회원 수정 : `/update-member`\n- 회원 삭제 : `/delete-member`\n\n이것은 좋은 URI 설계일까? 아니다. 가장 중요한 것은 ==**리소스 식별**==이다.\n\n\u003cbr\u003e\n\n==**API URI(Uniform Resource Identifier) 고민**==\n- 리소스의 의미는 뭘까?\n\t- 회원을 등록하고 수정하고 조회하는게 리소스가 아니다 !\n\t- ex) 미네랄을 캐라 → 미네랄이 리소스\n\t- **회원이라는 개념 자체가 바로 리소스**\n- 리소스를 어떻게 식별하는게 좋을까?\n\t- 회원을 등록하고 수정하고 조회하는 것을 모두 배제\n\t- **회원이라는 리소스만 식별하면 된다. → 회원 리소스를 URI에 매핑**\n\n\u003cbr\u003e\n\n**API URI(Uniform Resource Identifier) 설계**\n- **회원** 목록 조회\n- **회원** 조회\n- **회원** 등록\n- **회원** 수정\n- **회원** 삭제\n\n\u003cbr\u003e\n\n**API URI 설계 - 리소스 식별, URI 계층 구조 활용**\n- **회원** 목록 조회 : `/members`\n- **회원** 조회 : `/members/{id}`\n- **회원** 등록 : `/members/{id}`\n- **회원** 수정 : `/members/{id}`\n- **회원** 삭제 : `/members/{id}`\n- 참고 : **계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장**\n\t- member가 아닌 members\n\n==**그런데, 리소스인 회원만 가지고 설계하면 조회/등록/수정/삭제를 어떻게 구분하지?**==\n\n\u003cbr\u003e\n\n==**리소스와 행위를 분리 : 가장 중요한 것은 리소스를 식별하는 것**==\n- **URI는 리소스만 식별!**\n- **리소스**와 해당 리소스를 대상으로 하는 **행위**를 분리\n\t- 리소스 : 회원\n\t- 행위 : 조회, 등록, 삭제, 변경\n- 리소스는 명사, 행위는 동사\n- 행위(메서드)는 어떻게 구분할까?\n\t- → 이게 바로 ==**HTTP 메서드!!**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### HTTP 메서드 종류\n\n==**HTTP 메서드는 클라이언트가 서버에 요청할 때 기대하는 행동**==\n\n\u003cbr\u003e\n\n==**HTTP 주요 메서드**==\n- **GET** : 리소스 조회\n- **POST** : 요청 데이터 처리, 주로 등록에 사용\n\t- 무조건 데이터를 담아서 서버로 보내야함\n- **PUT** : 리소스를 대체, 해당 리소스가 없으면 생성\n- **PATCH** : 리소스 부분 변경\n- **DELETE** : 리소스 삭제\n\n\u003e 근데, 최근에는 이 resource라는 표현은 \u003cbr\u003e\n\u003e Representation으로 대체되었다.\n\n\u003cbr\u003e\n\n**HTTP 기타 메서드**\n- **HEAD** : GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환\n- **OPTIONS** : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)\n- **CONNECT** : 대상 자원으로 식별되는 서버에 대한 터널을 설정\n- **TRACE** : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행\n\n\u003cbr\u003e\u003chr\u003e\n\n### GET, POST\n\n\u003cbr\u003e\n\n==**GET**==\n\n```http\nGET /search?q=hello\u0026hl=ko HTTP/1.1\nHost: www.google.com\n```\n\n- 리소스 조회\n- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)을 통해서 전달\n- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하는 곳이 많지 않아서 권장 ❌\n\n\u003cbr\u003e\n\n**리소스 조회 1 : 클라이언트에서 GET으로 요청 메시지 전달** ![](brain/image/section04-1.png)\n\n\u003cbr\u003e\n\n**리소스 조회 2: 요청 메시지 서버 도착** ![](brain/image/section04-3.png)\n\n\u003cbr\u003e\n\n**리소스 조회 3. 서버가 요청받은거 기반으로 응답 메시지 만들어서 전달** ![](brain/image/section04-2.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**POST**==\n- 클라이언트가 서버로 데이터를 보내면서 이것 좀 처리해달라고 하는 것\n\n```http\nPOST /members HTTP/1.1\nContent-Type: application/json\n\n{  \n\t\"username\": \"hello\", \n\t\"age\": 20\n}\n```\n\n- 요청 데이터 처리\n- **메시지 바디를 통해 서버로 요청 데이터 전달**\n- 서버는 요청 데이터를 **처리**\n\t- 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능 수행\n- 주로 전달된 데이터로 ==신규 리소스 등록==, ==프로세스 처리에 사용==\n\n\u003cbr\u003e\n\n**리소스 등록 1 : 클라이언트에서 POST로 요청 메시지 전달** ![](brain/image/section04-4.png)\n\n\u003cbr\u003e\n\n**리소스 등록 2 : 서버에서 신규 리소스 생성** ![](brain/image/section04-5.png)\n\n\u003cbr\u003e\n\n**리소스 등록 3 : 응답 데이터 전달** ![](brain/image/section04-6.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**POST는 요청 데이터를 어떻게 처리한다는 의미일까?**==\n- 스펙 : POST 메서드는 **대상 리소스가 리소스의 고유한 의미 체계에 따라 포함된 표현을 처리하도록 요청**합니다. (구글 번역)\n\n**ex) POST는 다음과 같은 기능에 사용됨**\n- HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공\n\t- ex) HTML FORM에 입력한 정보로 회원가입, 주문 등에서 사용\n- 게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시\n\t- ex) 게시판 글쓰기, 댓글 달기\n- 서버가 아직 식별하지 않은 새 리소스 생성\n\t- ex) 신규 주문 생성\n- 기존 자원에 데이터 추가\n\t- ex) 한 문서 끝에 내용 추가하기\n- ==**정리하자면, 이 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할 지 리소스 마다 따로 정해야 함 → 정해진 것이 없음**==\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**POST 최종 정리**==\n1. **새 리소스 생성(등록)에 사용**\n\t- 서버가 아직 식별하지 않은 새 리소스 생성\n2. **요청 데이터 처리**\n\t- 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 **프로세스**를 처리해야 하는 경우\n\t\t- ex) 주문에서 결제완료 → 배달시작 → 배달완료 처럼 단순히 값 변경을 넘어서 프로세스의 상태가 변경되는 경우를 의미\n\t- POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음\n\t\t- ex) `POST /orders/{orderId}/start-delivery` (**컨트롤 URI**)\n3. **다른 메서드로 처리하기 애매한 경우**\n\t- ex) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우\n\t\t- GET 메서드는 보통 메시지 바디를 허용하지 않는 경우가 많아서, 이런 경우에는 조회이지만 POST를 사용해야 한다.\n\t- 애매하면 POST\n\n\u003cbr\u003e\n\n\u003e \u003ca href='/brain/Lecture/kim-spring/http/section04/#http-api-제작'\u003e위에서\u003c/a\u003e는, URI는 리소스만 식별하여 명사를 사용하라고 했는데, POST의 예시로 만든 URI는 동사의 형태가 있다. 이는, 실무에서는 이상적으로 리소스인 명사만 구별할 수 없는 상황도 있기 때문이다. \u003cbr\u003e\u003cbr\u003e\n\u003e 이렇게 동사 URI가 나올 수 있고, 이를 **컨트롤 URI**라고 한다. 기본적으로, 리소스를 가지고 최대한 URI를 설계하되, 어쩔 수 없는 경우에 컨트롤 URI를 사용한다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**POST는 사실 만능이다. BUT**==\n- 사실 POST는 메시지를 담아서 보내는 모든 것을 할 수 있다.\n- 하지만, 조회할 때는 GET을 사용하는게 유리하다.\n\t- 서버끼리는 GET으로 오면 캐싱하자는 약속을 하는 경우가 많기 때문\n\t- POST로 오면 캐싱하기는 사실 어렵다.\n- 조회 데이터는 최대한 GET\n- 변경 데이터, 프로세스 처리, 진짜 어쩔 수 없는 경우에는 POST\n\n\u003cbr\u003e\u003chr\u003e\n\n### PUT, PATCH, DELETE\n\n\u003cbr\u003e\n\n==**PUT**==\n\n```http\nPUT /members/100 HTTP/1.1\nContent-Type: application/json\n\n{  \n\t\"username\": \"hello\", \n\t\"age\": 20\n}\n```\n\n- **리소스를 ==완전히== 대체**\n\t- 리소스가 있으면 대체\n\t- 리소스가 없으면 생성\n\t- 쉽게 이야기하여, 덮어버림\n\t- 기존 리소스를 갈아치우는 것이라서, 사실 수정에 PUT을 사용하기에는 어려움\n\t\t- 수정은 PATCH를 사용하자\n\t\t- 요새는 PATCH가 다 되지만, 지원 안되는 서버도 있다. 그런 경우에는 무적의 **POST** 사용하자\n- **중요! 클라이언트가 리소스를 식별**\n\t- 클라이언트가 구체적인 리소스 위치를 알고 URI 지정\n\t- POST와 차이점\n\n\u003cbr\u003e\n\n**리소스가 있는 경우**\n\n![](brain/image/section04-7.png)\n\n![](brain/image/section04-8.png)\n\n\u003cbr\u003e\n\n**리소스가 없는 경우**\n\n![](brain/image/section04-9.png)\n\n![](brain/image/section04-10.png)\n\n\u003cbr\u003e\n\n**주의 : 리소스를 ==완전히== 대체한다**\n- 기존 리소스를 삭제하고 완전 덮어버림!!!\n\n![](brain/image/section04-11.png)\n\n![](brain/image/section04-12.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**PATCH**==\n\n```http\nPATCH /members/100 HTTP/1.1\nContent-Type: application/json\n\n{  \n\t\"age\": 50\n}\n```\n\n- 리소스를 **부분적으로** 변경\n\n\u003cbr\u003e\n\n**리소스 부분 변경** \n\n![](brain/image/section04-13.png)\n\n![](brain/image/section04-14.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**DELETE**==\n\n```http\nDELETE /members/100 HTTP/1.1\nHost: localhost:8080\n```\n\n- 리소스 제거\n\n\u003cbr\u003e\n\n**리소스 제거**\n\n![](brain/image/section04-15.png)\n\n![](brain/image/section04-16.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### HTTP 메서드 속성\n\n==**HTTP 메서드의 속성**==\n- 안전 (Safe Methods)\n- 멱등 (Idempotent Methods)\n- 캐시가능 (Cacheable Methods)\n\n![](brain/image/section04-17.png)\n\n\u003cbr\u003e\n\n==**안전 (Safe Methods)**==\n- **호출해도 대상 리소스를 변경하지 않는다.**\n\t- ex) GET 메서드는 안전할까?\n\t\t- 안전하다. 단순히 조회만 하니까\n\t- ex) POST, DELETE, PUT, PATCH 메서드는?\n\t\t- 당연히 안전하지 않다. 어떠한 변경이 발생하니까\n- Q. 그런데 계속 호출해서, 로그 같은게 쌓여서 장애가 발생하면 어떻게하나?\n- ==**A. 안전은 해당 리소스만 고려하고 그런 부분까지 고려 ❌. 말 그대로 해당 리소스가 안전하냐 안전하지 않냐 그것만 고려한다.**==\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**멱등 (Idempotent Methods)**==\n- $f(f(x)) = f(x)$\n- 한 번 호출하든, 두 번 호출하든, 100번 호출하든, **결과가 똑같다**\n- 멱등 메서드\n\t- **GET** : 한 번 조회하든, 두 번 조회하든 같은 결과가 조회됨\n\t- **PUT** : 결과를 대체한다. 따라서 같은 요청을 여러 번 해도 최종 결과는 동일\n\t- **DELETE** : 결과를 삭제한다. 같은 요청을 여러 번 해도 삭제된 결과는 동일\n\t- ==**POST**== : 멱등 ❌!! 두 번 호출하면 같은 결제가 중복해서 발생할 수 있음\n\n\u003cbr\u003e\n\n\u003e **PUT이 왜 멱등일까?** 예를 들어서, 리소스가 없는 상태에서 이미지 파일 image1을 업로드 했다고 하자. 다음으로 똑같은 image1 파일을 또 업로드하면, 기존걸 날리고 결과가 대체되고 또 image1이 남아있다. 즉, image1 파일을 몇 번을 PUT을 해도 결과는 image1로 동일하다. 첫번째에 한 행위랑 몇번을 했던 마지막 행위랑 결과가 동일하다. 이는 **DELETE도 동일, 한번 호출하든 백번 호출하든 최종적으로 결과는 삭제되니까**\n\n\u003cbr\u003e\n\n==**멱등 활용처**==\n- **자동 복구 메커니즘**\n\t- **ex)** DELETE 메서드를 호출했는데, 뭔가 서버에서 응답이 없다. 이때 클라이언트가 잘 됐는지 안됐는지 모르니까 서버에다가 다시 DELETE 메서드를 호출해도 될까?\n\t\t- ㅇㅇ 된다. 왜냐하면 멱등하니까. 요청을 몇 번 하든 결과는 동일하니까.\n- 서버가 TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가?를 의미하는 것\n\n\u003cbr\u003e\n\n==**멱등 추가 예시**==\n- **Q. 재요청 중간에 다른 곳에서 리소스를 변경해버리면 어떻게 되나?**\n\t- 사용자1 : `GET -\u003e username: A, age: 20`\n\t- 사용자2 : `PUT -\u003e username: A, age: 30`\n\t- 사용자1 : `GET -\u003e username: A, age: 30`\n\t\t- 사용자2의 영향으로 바뀐 데이터를 조회하게 됨\n- ==**A. 멱등은 외부 요인으로 중간에 리소스가 변경되는 것까지 고려 ❌**==\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**캐시가능 (Cacheable Methods)**==\n- 응답 결과 리소스를 캐시해서 사용할 수 있는가?\n\t- ex) 웹 브라우저가 되게 큰 이미지를 요청했을 때, 또 이를 받아올 필요가 있나?\n- **GET, HEAD, POST, PATCH** 캐시 가능\n- 실제로는 ==**GET, HEAD**== 정도만 캐시로 사용\n\t- 캐시를 하려면 이 똑같은 리소스랑 키가 맞아야 한다. **GET은 URL만 키로 잡고 캐시하면 되니까 되게 심플하다.**\n\t- POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않다.\n","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/backend/kim-spring/http/section05":{"title":"HTTP 메서드 활용","content":"\n인프런 김영한님의 \u003ca href='https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC' target='_blank'\u003e모든 개발자를 위한 HTTP 웹 기본 지식\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n### 클라이언트에서 서버로 데이터 전송\n\n\u003cbr\u003e\u003cbr\u003e\n\n**클라이언트에서 서버로 데이터를 전송할 때, 전달 방식은 크게 2가지이다.**\n- ==**쿼리 파라미터를 통한 데이터 전송**==\n\t- GET\n\t- 주로 정렬 필터 (검색어)\n- ==**메시지 바디를 통한 데이터 전송**==\n\t- POST, PUT, PATCH\n\t- 회원 가입, 상품 주문, 리소스 등록, 리소스 변경\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 클라이언트에서 서버로 데이터 전송하는 4가지 상황**\n\n- **정적 데이터 조회**\n\t- 이미지, 정적 텍스트 문서 \n- **동적 데이터 조회**\n\t- 주로 검색, 게시판 목록에서 정렬 필터(검색어) \n- **HTML Form을 통한 데이터 전송**\n\t- 회원 가입, 상품 주문, 데이터 변경 \n- **HTTP API를 통한 데이터 전송**\n\t- 회원 가입, 상품 주문, 데이터 변경  \n\t- 서버 to 서버, 앱 클라이언트, 웹 클라이언트 (Ajax)\n\n\u003cbr\u003e\u003chr\u003e\n\n### HTTP API 설계 예시","lastmodified":"2024-12-05T16:13:38.254758394Z","tags":null},"/brain/Lecture/backend/kim-spring/http/section06":{"title":"HTTP 상태코드","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/backend/kim-spring/http/section07":{"title":"HTTP 헤더 - 일반","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/backend/kim-spring/http/section08":{"title":"HTTP 헤더 - 캐시","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/backend/kim-spring/spring-intro/":{"title":"스프링 입문","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/backend/kim-spring/spring-intro/spring-basic":{"title":"스프링 입문 - 목차","content":"\n\u003cbr\u003e\n\n\u003e [!note] 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2023.02.16 ~ 진행중\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e 기본적인 Spring 프레임워크에 대한 파악\n\n## 목차\n\n- [스프링 입문 : 섹션0 - 섹션3](brain/Lecture/backend/kim-spring/spring-intro/spring-basic-01.md)\n- [스프링 입문 : 섹션4 - 섹션8](brain/Lecture/backend/kim-spring/spring-intro/spring-basic-02.md)","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/backend/kim-spring/spring-intro/spring-basic-01":{"title":"섹션0 - 섹션3","content":"\n\u003e 해당 게시글은 김영한님 \u003ca href='https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8' target='_blank'\u003e스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술\u003c/a\u003e강좌의 섹션0부터 섹션3까지 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 프로젝트 환경설정\n\n\u003cbr\u003e\n\n### 프로젝트 생성\n\n1. https://start.spring.io/ 스프링 프로젝트 생성\n\t- 프로젝트 생성\n\t- Project : Gradle\n\t\t- Spring Boot : (SNAPSHOT), (M~)는 정식 버전 아니니까 아무 것도 없고 숫자만 써진 버전으로 설정\n\t\t- Language : Java\n\t\t- Packaging : Jar\n\t\t- Java : 11\n\t- Project Metadata\n\t\t- Group : 보통 기업 도메인명 적어줌. 임의로 hello 적음\n\t\t- Artifact : 프로젝트명\n\t- Dependencies\n\t\t- 어떤 라이브러리를 당겨와서 사용할 것이냐\n\t\t- Spring Web 추가\n\t\t- Thymeleaf 추가 (프리마커 쓰는 회사도 있음)\n\n\u003cbr\u003e\n\n2. 인텔리제이로 프로젝트 오픈\n\n- 자바11로 프로젝트 생성했으니, 인텔리제이도 세팅 변경\n\t- 프로젝트 JDK 설정\n\t\t- File - Project Structure - Project Settings - Project\n\t\t- SDK : 11 Oracle OpenJDK version 11.0.16\n\t\t\t- Language level : SDK default\n\t\t- Platform Settings - SDKs - 1.8이 아닌 11로 설정\n- Gradle JDK 설정\n\t- File - Build, Execution, Deployment - Build Tools - Gradle\n\t\t- Build and run using : Gradle -\u003e IntelliJ (속도향상)\n\t\t- Run tests using : Gradle -\u003e IntelliJ (속도향상)\n\t\t- Gradle JVM : 11 Oracle OpenJDK\n\n\u003cbr\u003e\n\n3. 프로젝트 내용물 설명\n\n- gradle/wrapper : gradle 관련하여 사용하는 폴더\n- src : 기본적으로 main/test 두 갈래 생성\n- src/test : 최근 트렌드인 test 코드 관련, Junit5 기반\n- src/main/resources : 실제 java 코드 제외한 xml, properties, html 등 나머지 전부\n- gitignore : github에 올릴 때 제외할 파일들\n- gradlew, bradlew.bat, settings.gradle : 그래들 설정 관련\n- build.gradle : 예전에는 실제로 타이핑하고 코드 짰으나, 최근에는 start.spring.io와 같은 스프링부트 덕에 설정 파일이 제공됨\n\n\n```java\nplugins {\n\t// 선택한 스프링부트 버전과 자바 언어 등\n\tid 'org.springframework.boot' version '2.7.4'\n\tid 'io.spring.dependency-management' version '1.0.14.RELEASE'\n\tid 'java'\n} \n\ngroup = 'hello'\nversion = '0.0.1-SNAPSHOT'\n// 자바 11버전을 의미\nsourceCompatibility = '11'\n\nrepositories {\n\t// mavenCentral이라는 공개된 사이트에서 라이브러리 다운 받아오기\n\tmavenCentral()\n}\n\ndependencies {\n\t// start.spring.io에서 설정했던 의존관계\n\timplementation 'org.springframework.boot:spring-boot-starter-thymeleaf'\n\timplementation 'org.springframework.boot:spring-boot-starter-web'\n\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ntasks.named('test') {\n\tuseJUnitPlatform()\n}\n```\n\n\u003cbr\u003e\n  \n4. 생성한 프로젝트 실행\n\n\t- src/main/java/hello/hellospring/HelloSpringApplication.java 메인 메서드 그냥 실행\n\t- `@SpringBootApplication` 애노테이션이 있는 것이 스프링부트 실행 파일\n\t- `localhost:8080` 들어가서 Whitelabel Error Page 뜨면 성공\n\n  \n\n```java\npackage hello.hellospring;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloSpringApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(HelloSpringApplication.class, args);\n\t}\n}\n```\n\n\u003cbr\u003e\n\n5. 스프링부트 실행 오류\n\n\t- 8080포트 이미 열려있어서 안되는 경우\n\t- cmd 관리자 권한으로 실행\n\t- `netstat -ano | findstr 8080`으로 열려있는 포트 확인\n\t- `taskkill /F /pid [process_id]`로 8080포트 닫기\n\n\u003cbr\u003e\n\n### 라이브러리 살펴보기\n\n- Maven, Gradle 같은 빌드 툴은 의존관계를 관리해준다. 실제 우리가 추가한 의존관계는 `Spring Web, Thymeleaf`인데, 외부 라이브러리를 확인해보면 수많은 라이브러리가 다운받아져있다. **의존관계에 따라 자기가 필요한 라이브러리들을 알아서 당겨온다.**\n\n- 인텔리제이 우측에 작은 Gradle 클릭해보면, 여러 의존관계 살펴볼 수 있음\n\n\u003cbr\u003e\u003cbr\u003e\n\n**compileClassPath : 스프링 부트 라이브러리**\n\n- spring-boot-starter-web\n\t- spring-boot-starter-tomcat : 웹서버\n\t- spring-webmvc : 웹 MVC\n- spring-boot-starter-thymeleaf : 타임리프 템플릿 엔진 (View)\n\t- spring-boot-starter\n\t\t- spring-boot\n\t\t\t- spring-boog-core\n\t\t- spring-boot-starter-logging\n\t\t\t- logback\n\t\t\t- slf4j\n\n\u003cbr\u003e\n\n- 톰캣은 WAS(Web-Application-Server)이다.\n\n\t- 예전에는 서버에 톰캣같은 웹서버를 설치해놓고 거기에 자바 코드를 밀어놓는 식으로 개발했음. 웹서버와 개발 라이브러리가 완전히 분리되어 있었음\n\n\t- 최근에는 소스 라이브러리에서 이런 웹서버를 알아서 들고있음(임베디드, 내장) 그래서 자바 메인 메서드만 실행해도 따로 설정 필요없이 웹서버가 뜬다. 8080포트로 들어갈 수도 있음\n\n- 실무에서, `system.out.println()` 방식으로 출력하지 않고 log를 사용한다.\n\n\t- 심각한 로그를 따로 관리하거나, 로그 파일이 관리가 됨\n\n\t- slf4j는 인터페이스이고 logback은 실제 로그를 어떤 구현체로 출력할 지\n\n\t- 최근에는 slf4j + logback 조합을 보통 사용한다. 성능도 빠르고 지원하는 기능 많음\n\n\u003cbr\u003e\u003cbr\u003e\n\n**testCompileClasspath : 테스트 라이브러리**\n\n- spring-boot-starter-test\n\t- junit : 테스트 프레임워크 (최근에는 junit 5버전 사용, 핵심)\n\t- mockito : 목 라이브러리\n\t- assertj : 테스트 코드 작성을 더 쉽게 해주는 라이브러리\n\t- spring-test : 스프링 통합 테스트 지원\n\n\u003cbr\u003e\u003cbr\u003e\n\n### View 환경설정\n\n**Welcome Page 만들기** \u003cbr\u003e\n\n`resources/static/` 경로에 `index.html` 파일을 추가하면, welcome page의 기능을 한다. 이는 단순한 정적 페이지이다.\n\n```html\n// resources/static/index.html\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\t\u003chead\u003e\n\t\t\u003ctitle\u003eHello\u003c/title\u003e\n\t\t\u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /\u003e\n\t\u003c/head\u003e\n\t\u003cbody\u003e\n\t\tHello\n\t\t\u003ca href=\"/hello\"\u003ehello\u003c/a\u003e\n\t\u003c/body\u003e\n\u003c/html\u003e\n```\n\n- \u003ca href='https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.welcome-page' target='_blank'\u003espring boot docs - welcomepage\u003c/a\u003e\n\n- \u003ca href='https://spring.io/guides/gs/serving-web-content/' target='_blank'\u003e스프링 공식 튜토리얼\u003c/a\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n**thymeleaf 템플릿 엔진** \u003cbr\u003e\n\n템플릿 엔진을 사용하여, 동적인 페이지를 구현할 수 있다.\n\n- \u003ca href='https://www.thymeleaf.org/index.html' target='_blank'\u003ethymeleaf official hompage\u003c/a\u003e\n\n- \u003ca href='https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.template-engines' target='_blank'\u003e스프링부트 템플릿 엔진 메뉴얼\u003c/a\u003e\n\n\u003cbr\u003e\u003cbr\u003e\n\n웹 어플리케이션에서 첫 번째 진입점이 바로 **Controller, 컨트롤러**이다.\n\n1. `hello/hellospring/controller` 패키지 생성\n\n2. 패키지에 `HelloController.java` 생성\n\n3. `resources/templates/hello.html` 생성\n\n\n```java\n// src/main/java/hello/hellospring/controller/HelloController.java\npackage hello.hellospring.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Controller\npublic class HelloController {\n\n\t@GetMapping(\"hello\")\n\tpublic String hello(Model model) {\n\t\tmodel.addAttribute(\"data\", \"hello!!\");\n\t\treturn \"hello\";\n\t}\n}\n\n```\n\n- `@GetMapping(\"hello\")` : get/post 방식 말할 때 그 get이다. `localhost:8080/hello`와 mapping\n\n- model의 속성으로 키 : data, 값 : hello!!를 넘긴다.\n\n- `return \"hello\"`로 `/resources/templates/hello`를 찾아서 렌더링 함\n\n\u003cbr\u003e\n\n```html\n// resources/templates/hello.html\n\u003c!DOCTYPE html\u003e\n\u003chtml xmlns:th=\"http://www.thymeleaf.org\"\u003e\n\t\u003chead\u003e\n\t\t\u003ctitle\u003eHello\u003c/title\u003e\n\t\t\u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /\u003e\n\t\u003c/head\u003e\n\t\u003cbody\u003e\n\t\t\u003cp th:text=\"'안녕하세요. ' + ${data}\"\u003e안녕하세요. 손님\u003c/p\u003e\n\t\u003c/body\u003e\n\u003c/html\u003e\n```\n\n- `http://www.thymeleaf.org`를 추가함으로써 타임리프 문법 사용 가능\n\n![](brain/image/spring-basic-01-1.png)\n\n1. 웹 브라우저에서 `localhost:8080/hello`로 get 요청\n2. 내장된 톰캣이 웹서버의 역할을 하여 받아서 controller로 전달\n3. 스프링이 컨트롤러에 맵핑된 `hello`가 있나 찾아봄.\n4. controller인 helloController의 메서드가 실행된다. 이때 스프링이 Model을 만들어서 model을 controller에 넣어준다.\n5. controller는 이 model에다가 키 : data, 값 : hello!!를 넣는다.\n6. `/resources/templeates/hello`를 찾고 model을 화면에 넘기면서 화면을 렌더링해라\n\t- 즉, 컨트롤러에서 리턴 값으로 문자를 반환하면 뷰 리졸버( viewResolver )가 화면을 찾아서 처리하게 된다.\n\t- 뷰 리졸버는 View를 찾아주고 템플릿 엔진 연결시켜주는 녀석\n\t- 찾을 때, 스프링 부트 템플릿 엔진 기본 viewName에 매핑\n\t- `resources:templates/` + {ViewName} + `.html`\n\n\u003cbr\u003e\u003cbr\u003e\n\n**서버 재시작 없이 View 파일 리로드**\n\n1. `build.gradle`에 의존성 추가 (spring-boot-devtools 라이브러리 설치해준 것)\n\t- `developmentOnly 'org.springframework.boot:spring-boot-devtools'`\n2. `/resources/application.properties`에 아래 코드 추가 (필수는 아님)\n\n```java\nspring.devtools.livereload.enabled=true\nspring.devtools.restart.enabled=true\n```\n\n3. File - Settings - Advanced Settings - Compiler에서 `Allow auto-make to start~` 체크\n\n4. File - Settings - Build, Execution~ - Compiler에서 `Build project automatically` 체크\n\n이제 View 파일 수정하면 한 5초 뒤에 서버가 알아서 리로드 되면서 크롬 가서 새로고침 해보면 확인 가능하다. 만약, 새로고침 없이 보고 싶으면 크롬 확장 프로그램 Livereload 설치하셈\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 빌드하고 실행하기\n\n빌드하고자 하는 프로젝트 폴더로 이동하고 거기서 마우스 우클릭으로 `Git Bash Here` 혹은 `터미널에서 열기` 클릭! WSL2 java 관련 설정은 [Java Settings](brain/Java/java-settings) 참고\n\n1. `./gradlew build`\n2. `cd build/libs`\n3. `java -jar hello-spring-0.0.1-SNAPSHOT.jar`\n\n이러면 서버 실행 완료된 것! 종료 하려면 `Ctrl + C`\n\n- 빌드 폴더 깔끔하게 지우기 `./gradlew clean`\n\n\u003chr\u003e\n\n## 스프링 웹 개발 기초\n\n웹을 개발한다는 것은 크게 3가지 방법이 있다.\n\n- 정적 컨텐츠 : welcomepage처럼 서버에서 하는 것 없이 파일을 그대로 웹 브라우저에게 내리는 것\n\n- MVC와 템플릿 엔진 : jsp, php가 흔히 말하는 템플릿 엔진인데 html을 그냥 주는 것이 아니라 서버에서 프로그래밍 해서 html을 동적으로 바꿔서 내리는 것. 이 작업을 하기 위하여 Model, View, Controller 패턴으로 개발\n\n- API : JSON 형식으로 데이터를 전달해주는 방식\n\n\u003cbr\u003e\n\n사실 정적 컨텐츠 방식을 제외하면, 이렇게 생각하면 된다.\n\n- MVC 방식처럼 View를 찾아서 템플릿 엔진을 통해 화면을 렌더링해서 HTML을 변환하여 HTML 파일을 웹 브라우저에 넘겨주는 방식, **HTML을 내리냐**\n\n- API를 사용하여 **데이터를 바로 내리냐**\n\n\u003cbr\u003e\n\n### 정적 컨텐츠\n\n스프링 부트는 정적 컨텐츠를 \u003ca href='https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.static-content' target='_blank'\u003e제공\u003c/a\u003e하고 있다. `/resources/static` 폴더에 아무 html 파일을 만들면 그대로 반환해준다. 만약 `hello-static.html` 파일을 만들었다면, `localhost:8080/hello-static.html`로 들어가면 나온다.\n\n![](brain/image/spring-basic-01-2.png)\n\n  \n\n1. 웹브라우저에서 `localhost:8080/hello-static.html`로 get 요청\n\n2. 내장 톰캣 서버가 요청을 받고 스프링에게 넘김\n\n3. 스프링은 컨트롤러 쪽에서 `hello-static`과 맵핑된 컨트롤러 있나 찾아봄\n\n4. 없으면 `resources: statc/hello-static.html`을 찾고 있으면 반환해줌\n\n\u003cbr\u003e\n\n### MVC와 템플릿 엔진\n\nMVC : Model, View, Controller\n\n과거에는 컨트롤러와 뷰를 따로 분리하지 않고 JSP 같은걸로 뷰에 모든 걸 다했다. 이것이 **Model 1 방식**이다. 하지만, 지금은 MVC 패턴으로 많이 한다. 그 이유는 **관심사의 분리, 역할과 책임** 때문이다.\n\nView는 화면을 그리는 것에 모든 역량을 집중해야 하고, Controller나 Model과 관련된 부분은 비즈니스 로직과 관련있거나 내부적인 걸 처리하는 것에 집중해야 한다.\n\n\u003cbr\u003e\n\n`HelloController.java`에 내용 추가\n\n```java\n@GetMapping(\"hello-mvc\")\npublic String helloMvc(@RequestParam(\"name\") String name, Model model) {\n\tmodel.addAttribute(\"name\", name);\n\treturn \"hello-template\";\n}\n```\n\n- `hello-mvc` get 요청에 맵핑\n\n- 외부, 웹에서 파라미터를 받기 위하여 `@RequestParam()`을 사용\n\n- 당연히 Model은 넘겨줘야지\n\n- `addAttribute`에서 파라미터로 넘어온 name을 넘긴다.\n\n\u003cbr\u003e\n\n`resources/templates/hello-static.html`\n\n```html\n\u003chtml xmlns:th=\"http://www.thymeleaf.org\"\u003e\n\t\u003cbody\u003e\n\t\t\u003cp th:text=\"'hello ' + ${name}\"\u003ehello! empty\u003c/p\u003e\n\t\u003c/body\u003e\n\u003c/html\u003e\n```\n\n- 템플릿 엔진으로써 잘 동작하면 th:text의 값인 `'hello ' + ${name}`로 우측의 내용(hello! empty)이 치환이 된다.\n\n\u003cbr\u003e\n\n타임리프 템플릿의 장점은 html을 쓰고 서버 없이 파일을 열어서 껍데기를 볼 수 있는 것이다. `템플릿 파일명 우클릭 - Copy Path/References.. - Absolute Path 복사`하고 웹 브라우저 링크에 치면 볼 수 있다.\n\n\u003cbr\u003e\n\n여기까지 하고 `localhost:8080/hello-mvc`를 입력하면!? `Required request parameter 'name' for method parameter type String is not present]`라는 오류가 콘솔창에 뜬다. 파라미터를 입력해주지 않았기 때문이다. 인텔리제이에서 필요한 파라미터가 무엇인지 볼 때 `Ctrl + P`를 누르면 뜬다.\n\n![](brain/image/spring-basic-01-3.png)\n\n`boolean required() default true`인 것으로 보아 반드시 값이 필요한게 디폴트 설정이다. 따라서, 웹 브라우저 창에 `localhost:8080/hello-mvc?name=name에 들어갈 문자열`을 넣어주면 된다. 그러면 결과로 `'hello ' + ${name}`이니까 `hello name에 들어갈 문자열`이라는 모습이 보일 것이다.\n\n![](brain/image/spring-basic-01-4.png)\n  \n다시 한번, **달러($) 사인에 들어가는 것은 Model에서 뽑아온 key에 해당하는 value이다.** `model.addAttribute(\"name\", name);`이라고 했으니까 `name`이라는 key에서 `name`이라는 value를 가져오는 것!\n\n\u003cbr\u003e\n\n![](brain/image/spring-basic-01-5.png)\n\n1. 웹브라우저에서 `localhost:8080/hello-mvc`로 get 요청\n\n2. 내장 톰캣 서버가 요청을 받고 스프링에게 넘김\n\n3. 스프링은 컨트롤러 쪽에서 `hello-mvc`와 맵핑된 컨트롤러 있나 찾아봄\n\n4. 있으니까 `hello-template`으로 넘기고 `model(name:문자열)`을 넘김.\n\n5. 뷰 리졸버 (viewResolver)가 return의 `hello-template`와 같은`templates/hello-template.html`를 찾아서 타임리프 템플릿 엔진에 처리해달라고 넘김\n\n6. 템플릿 엔진이 렌더링해서 변환한 HTML 파일을 웹 브라우저에 반환\n\n\u003cbr\u003e\n\n### API\n\nMVC 방식과는 다르게 (HTML 파일을 내리는 방식과는 다르게) API는 데이터를 바로 내리는 방식이다. \n\n\u003cbr\u003e\n\n`HelloController.java`에 내용 추가\n\n```java\n@GetMapping(\"hello-string\")\n@ResponseBody\npublic String helloString(@RequestParam(\"name\") String name) {\n\treturn \"hello \" + name;\n}\n```\n\n- `hello-string` get 요청에 맵핑\n\n- `@ResponseBody`의 body는 html의 `\u003cbody\u003e\u003c/body\u003e`를 의미하는 것이 아니라 HTTP의 `헤더부와 바디부`를 의미하는 것이다. HTTP의 응답 body에 이 내용을 직접 넣어주겠다는 의미이다.\n\n- 템플릿 엔진과는 다르게 view 이런게 없어서 저 return 문자가 그대로 내려간다.\n\n![](brain/image/spring-basic-01-6.png)\n\n이렇게 페이지 소스보기 해보면 html 태그 같은거 안뜨고 **문자 데이터 자체**가 그대로 왔다. 그러면, 본격적으로 api를 사용해보도록 하자. 객체를 만들어서 JSON 형식(`key : value`)으로 데이터를 보내보자.\n\n\u003cbr\u003e\n\n`HelloController.java`에 내용 추가\n\n```java\n@GetMapping(\"hello-api\")\n@ResponseBody\npublic Hello helloApi(@RequestParam(\"name\") String name) {\n\tHello hello = new Hello();\n\thello.setName(name);\n\treturn hello;\n}\n\nstatic class Hello {\n\tprivate String name;\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t  \n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n```\n\n- static은 기억나지? 힙에 올리는게 아니라 그냥 클래스 변수로 만들어서 올리고 아무데서나 사용할 수 있게 만들었던거\n\n- private으로 해놨으니까 getter, setter 만들어준거고.\n\n- helloApi에서 hello 객체 만들고 setName으로 들어온 리퀘스트 파라미터인 name 넣어준거고!\n\n- 마지막으로 hello 객체를 반환해줌\n\n![](brain/image/spring-basic-01-7.png)\n\n![](brain/image/spring-basic-01-8.png)\n\n1. 웹브라우저에서 `localhost:8080/hello-api`로 get 요청\n2. 내장 톰캣 서버가 요청을 받고 스프링에게 넘김\n3. 스프링은 컨트롤러 쪽에서 `hello-api`와 맵핑된 컨트롤러 있나 찾아봄\n4. 있네. 근데 `@ResponseBody` 애노테이션이 붙어있네?\n\t- 저게 없으면, viewResolver에게 던져서 view에 맞는 템플릿 엔진 연결해줬잖아\n\t- 얘는 HTTP body 응답에 이걸 그대로 넘겨야겠구나 라고 생각\n\t- 근데, 문자였으면 바로 넣어서 주면 끝인데, 객체일 경우는 어떻게 해야할까?\n\t- 객체가 오면, 기본 default가 json 방식으로 데이터를 만들어서 HTTP 응답에 반환하겠다가 기본 정책!\n5. `viewResolver`가 아닌, `HttpMessageConverter`가 동작\n6. 단순 문자면 `StringConverter`가 동작. 객체이면 `JsonConverter`가 동작\n7. 이것을 응답으로 웹 브라우저에 \n\n\u003cbr\u003e\n\n- 기본 문자처리 : `StringHttpMessageConverter`\n- 기본 객체처리 : `MappingJackson2HttpMessageConverter`\n\t- 객체를 json으로 변환해주는 유명한 라이브러리 대표적인 2개\n\t\t- Jackson version 2\n\t\t- Gson (구글에서 만든거)\n\t- 스프링은 기본적으로 잭슨 라이브러리를 채택!\n- 참고 : 클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보를 조합해서 `HttpMessageConverter`가 선택된다. 예를 들어, 클라이언트 쪽에서 XML을 요청하면 서버 쪽에서 XML 라이브러리를 끼워넣고 XML로 보낼 수 있다는 말이다. 근데 그냥 마음 편하게 json으로 하자 ^^ 다 json으로 한다.\n\n\u003chr\u003e\n\n## 회원 관리 예제\n\n\u003cbr\u003e\n\n### 비즈니스 요구사항\n\n- 굉장히 단순한 비즈니스 요구사항만 정하자.\n- 아직 데이터 저장소(DB)가 선장되지 않은 상황, 가상의 시나리오\n\t- 데이터 : 회원ID, 이름\n\t- 기능 : 회원 등록, 조회\n\n![](brain/image/spring-basic-01-9.png)\n\n- 컨트롤러 : 웹 MVC의 컨트롤러 역할\n\t- API 만드는 것\n- 서비스 : 핵심 비즈니스 로직 구현\n\t- 비즈니스 도메인 객체를 가지고 핵심 비즈니스 로직이 동작하도록 구현한 객체\n\t- 예) 회원은 중복가입 안된다는 것\n- 도메인 : 비즈니스 도메인 객체\n\t- 예) 회원, 주문, 쿠폰 등등 주로 데이터베이스에 저장하고 관리되는 객체\n- 리포지토리 : 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리 \n\n\u003cbr\u003e\n\n![](brain/image/spring-basic-01-10.png)\n\n- 회원 비즈니스 로직에는 MemberService\n- 회원을 저장하는 것은 MemberRepository\n\t- 아직 데이터 저장소가 선정되지 않아서, 우선 인터페이스로 구현 클래스를 변경할 수 있도록 설계 (나중에 선정하고 바꿔끼우기 쉽게)\n\t- 데이터 저장소는 RDB, NoSQL 등등 다양한 저장소를 고민중인 상황으로 가정\n\t- 개발을 진행하기 위해서 초기 개발 단계에서는 구현체로 가벼운 메모리 기반의 데이터 저장소 사용\n\n\u003cbr\u003e\n\n### 도메인, 리포지토리\n\n![](brain/image/spring-basic-01-11.png)\n\n- 회원 **도메인**과 회원 도메인 객체를 저장하고 불러올 수 있는 저장소라고 하는 **리포지토리** 객체를 만들어보자.\n\n\u003cbr\u003e\n\n```java {title=\"domain/Member.java\"}\npublic class Member {  \n    // 시스템이 저장하는 임의의 id (데이터 구분 위해서)  \n    private Long id;  \n    private String name;  \n  \n    public Long getId() {  \n        return id;  \n    }  \n  \n    public void setId(Long id) {  \n        this.id = id;  \n    }  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"repository/MemberRepository.java\"}\npublic interface MemberRepository {  \n    Member save(Member Member);  \n    Optional\u003cMember\u003e findById(Long id);  \n    Optional\u003cMember\u003e findByName(String name);  \n    List\u003cMember\u003e findAll();  \n}\n```\n\n-   Optional은 Java8에 들어간 기능으로 findById나 findByName이 없으면 null이 반환될 수 있는데, 최근에는 Optional로 감싸서 반환하는 것을 선호  \n\n\u003cbr\u003e\n\n```java {title=\"repository/MemoryMemberRepository.java\"}\npublic class MemoryMemberRepository implements MemberRepository {  \n    private static Map\u003cLong, Member\u003e store = new HashMap\u003c\u003e();  \n    private static long sequence = 0L;  \n    \n    @Override  \n    public Member save(Member member) {  \n        member.setId(++sequence);  \n        store.put(member.getId(), member);  \n        return member;  \n    }  \n  \n    @Override  \n    public Optional\u003cMember\u003e findById(Long id) {    \n        return Optional.ofNullable(store.get(id));  \n    }  \n  \n    @Override  \n    public Optional\u003cMember\u003e findByName(String name) {  \n        return store.values().stream()  \n                .filter(member -\u003e member.getName().equals(name))  \n                .findAny();  \n    }  \n  \n    @Override  \n    public List\u003cMember\u003e findAll() {  \n        return new ArrayList\u003c\u003e(store.values());  \n    }  \n}\n```\n\n-  Key는 회원의 아이디 타입인 Long, Value는 Mamber. 실무에서는 동시성 문제가 발생할 수 있어서, 공유되는 변수일 때는 **ConcurrentHashMap**을 써야하는데, 예제니까 일단 단순하게 쓰자  \n-  sequence는 단순하게 0, 1, 2 키값 생성해주는 녀석이다. 얘도 동시성 고려할거면 **AtomicLong** 써야함\n- null이 될 가능성이 있다면 Optional.ofNullable()로 감싸서 반환\n\n\u003cbr\u003e\n\n### 리포지토리 테스트 케이스\n\n![](brain/image/spring-basic-01-12.png)\n\n- 회원 리포지토리가 제대로 동작하는지 테스트 케이스를 만들어보자.\n- 개발한 기능을 실행해서 테스트 할 때 자바의 main 메서드를 통해서 실행하거나, 웹 애플리케이션의 컨트롤러를 통해서 해당 기능을 실행한다. \n- 이러한 방법은 준비하고 실행하는데 오래 걸리고, 반복 실행하기 어렵고 여러 테스트를 한번에 실행하기 어렵다는 단점이 있다. 자바는 ==**JUnit이라는 프레임워크로 테스트를 실행해서 이러한 문제를 해결**==한다.\n\n\u003cbr\u003e\n\n```java {title=\"MemoryMemberRepositoryTest.java\"}\nimport static org.assertj.core.api.Assertions.*;  \n  \nclass MemoryMemberRepositoryTest {  \n    MemoryMemberRepository repository = new MemoryMemberRepository();  \n  \n    @AfterEach  \n    public void afterEach() {  \n        repository.clearStore();  \n    }  \n  \n    @Test  \n    public void save() {  \n        Member member = new Member();  \n        member.setName(\"spring\");  \n  \n        repository.save(member);  \n        Member result = repository.findById(member.getId()).get();  \n\t\t// Assertions.assertEquals(member, result);  \n\t\tassertThat(member).isEqualTo(result);\n    }  \n  \n    @Test  \n    public void findByName() {  \n        Member member1 = new Member();  \n        member1.setName(\"spring1\");  \n        repository.save(member1);  \n          \n        Member member2 = new Member();  \n        member2.setName(\"spring2\");  \n        repository.save(member2);  \n  \n        Member result = repository.findByName(\"spring1\").get();  \n        assertThat(result).isEqualTo(member1);  \n    }  \n  \n    @Test  \n    public void findAll() {  \n        Member member1 = new Member();  \n        member1.setName(\"spring1\");  \n        repository.save(member1);  \n  \n        Member member2 = new Member();  \n        member2.setName(\"spring2\");  \n        repository.save(member2);  \n  \n        List\u003cMember\u003e result = repository.findAll();  \n        assertThat(result.size()).isEqualTo(2);  \n    }  \n}\n```\n\n![](brain/image/spring-basic-01-13.png)\n\n- 어차피 테스트코드는 여기서만 쓰니까 `public class` 말고 그냥 `class`로 하자\n- `@Test` 애노테이션 붙이면 Junit이 테스트코드로 알아차림\n- Assertions을 사용하여 테스트 할 수 있는데 두 버전이 있음\n\t- junit : `Assertions.assertEquals(member, result);`\n\t\t- 테스트하고자 하는 값과 기대하는 값이 좀 헷갈림\n\t- assertj : `Assertions.assertThat(member).isEqualTo(result);`\n\t\t- 테스트하고자 하는 값과 기대하는 값이 직관적\n\t\t- 위에 `import static org.assertj.core.api.Assertions.*;`로 static으로 import하면 그냥 `assertThat()`으로 바로 사용 가능\n\t\t\t- `option + enter` 해서 만들면 됨\n- 한 번에 여러 테스트를 실행하면 메모리 DB에 직전 테스트의 결과가 남아있을 수도 있어서 이전 테스트 때문에 다음 테스트가 실패할 가능성이 있음. 이때 `@AfterEach`를 사용하면 각 테스트가 종료될 때마다 이 기능을 실행하는데, 여기에 메모리 DB에 저장된 데이터를 삭제하도록 할 수 있음\n- ==**테스트는 각각 독립적으로 실행되어야 한다. 테스트 순서에 의존관계가 있는 것은 좋은 테스트가 아니다.**==\n\n\u003cbr\u003e\n\n### 서비스 개발\n\n- 실제 비즈니스 로직이 있는 회원 서비스를 만들어보자.\n\n```java {title=\"service/MemberService.java\"}\npublic class MemberService {  \n    private final MemberRepository memberRepository = new MemoryMemberRepository();  \n  \n    /**  \n     * 회원가입  \n     */  \n    public Long join(Member member) {  \n        // 같은 이름이 있는 중복 회원 X, 중복 회원 검증  \n        validateDuplicateMember(member);  \n        memberRepository.save(member);  \n        return member.getId();  \n    }  \n  \n    private void validateDuplicateMember(Member member) {  \n        memberRepository.findByName(member.getName())  \n                // null이 아니라 만약 값이 있으면 동작하는 로직  \n                .ifPresent(m -\u003e {  \n                    throw new IllegalStateException(\"이미 존재하는 회원입니다.\");  \n                });  \n    }  \n  \n    /**  \n     * 전체 회원 조회  \n     */  \n    public List\u003cMember\u003e findMembers() {  \n        return memberRepository.findAll();  \n    }  \n  \n    public Optional\u003cMember\u003e findOne(Long memberId) {  \n        return memberRepository.findById(memberId);  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### 서비스 테스트\n\n- 비즈니스 로직이 있는 서비스가 잘 동작하는지 테스트 해보자.\n- 실제로 동작하는 코드는 한글로 적기 애매하지만, 솔직히 테스트 코드는 보기 편하기 위함이니까 한글로 `회원가입()` 이렇게 직관적으로 적어도 됨\n\n\u003cbr\u003e\n\n```java\npublic class MemberService {  \n    private final MemberRepository memberRepository = new MemoryMemberRepository();\n}\n```\n\n- 기존에는 회원 서비스가 메모리 회원 리포지토리를 직접 생성하게 했음\n- 그러나, 이렇게 하면 테스트 코드에서 생성하는 메모리 회원 리포지토리와 서비스의 메모리 회원 리포지토리는 같은 것이 아님\n- 그래서 회원 서비스에 의존성 주입(DI)을 하기로 함\n\n\u003cbr\u003e\n\n```java\npublic class MemberService {  \n  \n    private final MemberRepository memberRepository;  \n  \n    public MemberService(MemberRepository memberRepository) {  \n        this.memberRepository = memberRepository;  \n    }\n}\n```\n\n\u003cbr\u003e\n\n```java\nclass MemberServiceTest {  \n  \n    MemberService memberService;  \n    MemoryMemberRepository memberRepository;  \n    \n    @BeforeEach  \n    void beforeEach() {  \n        memberRepository = new MemoryMemberRepository();  \n        memberService = new MemberService(memberRepository);  \n    }  \n  \n    @AfterEach  \n    void afterEach() {  \n        memberRepository.clearStore();  \n    }  \n  \n    @Test  \n    void 회원가입() {  \n        // given  \n        Member member = new Member();  \n        member.setName(\"hello\");  \n  \n        // when  \n        Long saveId = memberService.join(member);  \n  \n        // then  \n        Member findMember = memberService.findOne(saveId).get();  \n        assertThat(member.getName()).isEqualTo(findMember.getName());  \n    }  \n  \n    @Test  \n    void 중복_회원_예외() {  \n        // given  \n        Member member1 = new Member();  \n        member1.setName(\"spring\");  \n  \n        Member member2 = new Member();  \n        member2.setName(\"spring\");  \n  \n        // when  \n        memberService.join(member1);    \n        // 이 예외가 터져야한다.  \n        IllegalStateException e = assertThrows(IllegalStateException.class, () -\u003e memberService.join(member2));  \n        assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다.\");  \n    }  \n  \n    @Test  \n    void findMembers() {  \n    }  \n    @Test  \n    void findOne() {  \n    }\n}\n```\n\n- `@BeforeEach`를 이용하여 테스트 전에 의존성 주입을 시켜줌\n\t- 각 테스트 실행 전에 호출되며, 테스트가 서로 영향이 없도록 항상 새로운 객체를 생성하고 의존관계도 새로 맺어준다.\n- 테스트 코드 작성할 때 ==**given -\u003e when -\u003e then**==으로 짜보자.\n\t- 좀 더 직관적으로 알 수 있다.","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/backend/kim-spring/spring-intro/spring-basic-02":{"title":"섹션4 - 섹션8","content":"\n\u003e 해당 게시글은 김영한님 \u003ca href='https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8' target='_blank'\u003e스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술\u003c/a\u003e강좌의 섹션4부터 섹션8까지 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 스프링 빈과 의존관계\n\n스프링 빈을 등록하는 방법은 2가지가 있다.\n- 컴포넌트 스캔과 자동 의존관계 설정\n- 자바 코드로 직접 스프링 빈 등록하기\n\n### 컴포넌트 스캔, 자동 의존관계\n\n- 지금까지 회원 서비스, 회원 리포지토리, 회원 객체를 만들었다.\n- 이제 회원 컨트롤러가 회원 서비스를 통해 회원가입하고 회원 서비스를 통해 데이터를 조회할 수 있도록 ==**의존관계를 만들어야한다.**==\n\n```java\n@Controller  \npublic class MemberController {  \n    \n}\n```\n\n- 이렇게 `@Controller` 애노테이션 붙여놓으면, 기능은 없지만 스프링 컨테이너라는 스프링 통에 `@Controller` 애노테이션이 있는 MemberController를 객체로 만들어서 스프링이 통에 넣어둔다. 그리고 스프링이 관리를 한다. \n\n\u003cbr\u003e\n\n![](brain/image/spring-basic-01-5.png)\n\n- 이를 ==**스프링 컨테이너에서 스프링 빈이 관리된다고 한다.**==\n- 녹색이 생성된 객체, Bean 이다.\n\n\u003cbr\u003e\n\n```java\n@Controller  \npublic class MemberController {  \n    private final MemberService memberService = new MemberService();  \n}\n```\n\n- 이렇게 새로 만들어 쓸 수도 있지만, 사실 memberService의 기능들은 한 번만 인스턴스를 만들어놓고 기능을 돌려쓰면 된다.\n- 그래서 이를 스프링 빈에 등록 해놓으면 싱글턴으로 딱 하나만 생성하니까 빈에 등록하도록 해보자.\n\n\u003cbr\u003e\n\n```java\n@Controller  \npublic class MemberController {  \n  \n    private final MemberService memberService;  \n  \n    @Autowired  \n    public MemberController(MemberService memberService) {  \n        this.memberService = memberService;  \n    }  \n}\n```\n\n- 생성자에 `@Autowired `가 있으면 ==**스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어준다.**== 이렇게 ==**객체 의존관계를 외부에서 넣어주는 것을 DI (Dependency Injection), 의존성 주입**==이라 한다.\n- 이전 테스트에서는 개발자가 직접 주입했고, 여기서는 `@Autowired`에 의해 스프링이 주입해준다.\n\n\u003cbr\u003e\n\n\u003e **`@Autowired` 생략** : 생성자에 @Autowired를 사용하면 객체 생성 시점에 스프링 컨테이너에서 해당 스프링 빈을 찾아서 주입한다. 생성자가 1개만 있으면 @Autowired 생략 가능하다. \u003cbr\u003e\u003cbr\u003e\n\u003e 의존성 주입 위치는 \u003ca href='/brain/Interview/dog-study/dog-week03' target='_blank'\u003e3주차 스터디\u003c/a\u003e에서 **Spring DI** 참고\n\n\u003cbr\u003e\u003cbr\u003e\n\n![](brain/image/spring-basic-02-1.png)\n\n- 그러나, MemberService를 찾을 수 없다는 오류가 발생!\n\n\u003cbr\u003e\n\n![](brain/image/spring-basic-02-2.png)\n\n- MemberService는 순수한 자바 코드라서 스프링 빈에 등록되어있지 않음!\n- `@Controller`는 애노테이션을 붙여놔서 스프링 빈으로 자동 등록됨\n\n\u003cbr\u003e\n\n**한 번 컴포넌트 스캔 방식으로 등록해보자.**\n\n\u003cbr\u003e\n\n```java {title=\"controller/MemberController.java\"}\n@Controller  \npublic class MemberController {  \n  \n    private final MemberService memberService;  \n  \n    @Autowired  \n    public MemberController(MemberService memberService) {  \n        this.memberService = memberService;  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"service/MemberService.java\"}\n@Service  \npublic class MemberService {  \n  \n    private final MemberRepository memberRepository;  \n  \n    @Autowired  \n    public MemberService(MemberRepository memberRepository) {  \n        this.memberRepository = memberRepository;  \n    }\n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"repository/MemoryMemberRepository.java\"}\n@Repository  \npublic class MemoryMemberRepository implements MemberRepository { \n}\n```\n\n- `@Component` 애노테이션이 있으면 스프링 빈으로 자동 등록\n- `@Component`를 포함하는 애노테이션을 스프링 빈으로 자동 등록 (들어가서 확인해보면 `@Componet`가 포함되어있음)\n\t- `@Controller`\n\t- `@Service`\n\t- `@Repository`\n- `@SpringBootApplication`을 확인해보면 `@ComponentScan`이 있어서 컴포넌트 스캔되는 이유를 확인할 수 있음. 이때, 상위 패키지는 스캔하지 않음\n\n\u003cbr\u003e\n\n실행 순서를 보면\n1. Controller의 생성자에 `@Autowired`를 붙여서 연관된 객체인 MemberService를 스프링 컨테이너에서 자동으로 넣어줘야함\n2. MemberService는 기본 자바코드라서 빈에 등록되어있지 않는 상태. `@Service`를 붙여서 컴포넌트 달아줌\n3. MemberService의 생성자에 `@Autowired`를 붙여서 연관된 객체인 MemberRepository를 스프링 컨테이너에서 자동으로 넣어줘야함\n4. 그런데 현재 MemberRespository는 인터페이스이고 실제로 구현체인 MemoryMemberRepository로 가서 `@Repository` 달아줌\n\n![](brain/image/spring-basic-02-3.png)\n\n- 최종적으로 이러한 의존관계가 형성되면서 스프링 빈 등록 완료!\n\n\u003e **참고** : 스프링은 스프링 컨테이너에 스프링 빈을 등록할 때, 기본으로 싱글톤으로 등록한다(유일하게 하나만 등록해서 공유한다) 따라서 같은 스프링 빈이면 모두 같은 인스턴스다. 설정으로 싱글톤이 아니게 설정할 수 있지만, 특별한 경우를 제외하면 대부분 싱글톤을 사용한다. \u003cbr\u003e\u003cbr\u003e\n\u003e 관련 내용은 \u003ca href='/brain/Interview/dog-study/dog-week05' target='_blank'\u003e5주차 스터디\u003c/a\u003e에서 **Bean 스코프** 참고\n\n\u003cbr\u003e\n\n### 자바 코드로 직접 스프링 빈 등록\n\n- Controller 클래스는 그대로 놔두고 나머지 클래스에서 작성된 `@Component`, `@Autowired` 모두 지우고 실습 진행\n\n```java {title=\"SpringConfig.java\"}\n@Configuration  \npublic class SpringConfig {  \n  \n    @Bean  \n    public MemberService memberService() {  \n        return new MemberService(memberRepository());  \n    }  \n  \n    @Bean  \n    public MemberRepository memberRepository() {  \n        return new MemoryMemberRepository();  \n    }  \n}\n```\n\n- 향후 메모리 리포지토리를 다른 리포지토리로 변경할 예정이므로, 컴포넌트 스캔 방식 대신에 자바 코드로 스프링 빈을 설정하겠다.\n\t- 다형성 때문에 코드 하~나도 안바꾸고 return만 바꾸면 된다.\n\n\u003e  **참고** : XML로 설정하는 방식도 있지만 최근에는 잘 사용하지 않으므로 생략한다.\n    \n\u003e  **참고** : DI에는 필드 주입, setter 주입, 생성자 주입 이렇게 3가지 방법이 있다. 의존관계가 실행중에 동적으로 변하는 경우는 거의 없으므로 생성자 주입을 권장한다.\n    \n\u003e  **참고** : 실무에서는 주로 정형화된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔을 사용한다. 그리고 정형화 되지 않거나, 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록한다.\n    \n\u003e  **주의** : @Autowired 를 통한 DI는 helloController , memberService 등과 같이 스프링이 관리하는 객체에서만 동작한다. 스프링 빈으로 등록하지 않고 내가 직접 생성한 객체에서는 동작하지 않는다.\n\n\n\u003chr\u003e\n\n## 회원 관리 예제 - MVC\n\n### 웹 기능 - 홈 화면 추가\n\n\u003cbr\u003e\n\n```java {title=\"controller/HomeController.java\"}\n@Controller  \npublic class HomeController {  \n  \n    @GetMapping(\"/\")  \n    public String home() {  \n        return \"home\";  \n    }  \n}\n```\n\n- HomeController를 만들고 `templates/home.html`을 만들어서 매핑되게 한다.\n\n![](brain/image/spring-basic-01-2.png)\n\n- 저번에 `static/index.html`에 만들었던 것이 실행되지 않고 `templates/home.html`이 실행되는 이유는 바로 이것 때문이다. \n- 먼저 관련 컨트롤러와 매핑된 html 파일을 찾고 없으면 정적 컨텐츠를 찾는 것!\n\n\u003cbr\u003e\n\n### 웹 기능 - 등록\n\n\u003cbr\u003e\n\n```java {title=\"controller/MemberForm.java\"}\npublic class MemberForm {  \n    private String name;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n}\n```\n\n- 웹 등록 화면에서 데이터를 전달받을 폼 객체\n\n\u003cbr\u003e\n\n```java {title=\"controller/MemberController.java\"}\n@Controller  \npublic class MemberController {  \n  \n    private final MemberService memberService;  \n  \n    @Autowired  \n    public MemberController(MemberService memberService) {  \n        this.memberService = memberService;  \n    }  \n  \n    @GetMapping(\"/members/new\")  \n    public String createForm() {  \n        return \"members/createMemberForm\";  \n    }  \n  \n    @PostMapping(\"/members/new\")  \n    public String create(MemberForm form) {  \n        Member member = new Member();  \n        member.setName(form.getName());  \n  \n        memberService.join(member);  \n  \n        return \"redirect:/\";  \n    }  \n}\n```\n\n- 회원 컨트롤러에서 회원을 실제로 등록하는 것은 `@PostMapping` 부분\n\n\u003cbr\u003e\n\n### 웹 기능 - 조회\n\n- 대충 타임리프 써서 조회는 했지만, 메모리에 저장되는거라 서버 내렸다가 다시 올리면 데이터 다날라감\n- 이건 본격적으로 DB 연결해야겠지 ~\n\n\n\u003chr\u003e\n\n## 스프링 DB 접근 기술\n\n### H2 DB 설치\n\n- 개발이나 테스토 용도로 가볍고 편리한 DB이다. 웹 화면 제공해준다.\n\n**H2 설치, 사용법**\n\n1. \u003ca href='https://www.h2database.com/html/download-archive.html' target='_blank'\u003eh2 archive\u003c/a\u003e에서 1.4.200 버전을 다운받고 압축 풀자.\n2. 최초에 권한을 `chmod 755 h2.sh`로 줘야한다. \n\t- `h2.sh`는 `h2폴더/bin/`에 위치한다.\n3. 실행은 해당 폴더로 이동한 다음 `./h2.sh`로 실행하자\n4. 데이터베이스 파일 생성 방법\n\t- 최초 한번만 `jdbc:he:~/test`\n\t- `~/test.mv.db` 파일 생성 확인\n\t- 확인했으면 `jdbc:h2:tcp://localhost/~/test`로 바꾸고 여기로 접속 (이는 소켓으로 연결한다는 의미)\n\t- 만약 원활하지 않으면 `~/test.mv.db` 지우고 재설치\n\t- 원활하게 접속 안되면 주소창 확인해보자. `ip:8082/login~` 이렇게 ip가 나와있으면 ip를 지우고 `localhost` 붙이면 됨\n1. `build.gradle`에 아래 코드 추가\n\n```java\nimplementation 'org.springframework.boot:spring-boot-starter-jdbc'\nruntimeOnly 'com.h2database:h2'\n```\n\n\u003cbr\u003e\n\n**더 편하게 쓰기 위한 alias**\n\n1. `code ~/.zshrc`에서 `alias h2start=\"/Users/jaeyun/Desktop/Coding/h2/bin/h2.sh\"` 추가\n2. `source ~/.zshrc`로 적용\n3. 이제 터미널에 `h2start`만 치면 됨!\n\n\u003cbr\u003e\n\n**SQL문 관리**\n\n- SQL문을 프로젝트 루트 경로에 `sql` 폴더 하나 만들고 `ddl.sql` 파일 하나 만들자\n- 내부에 SQL문 적어놓으면 나중에 github 관리할 때도 편하고 좋다.\n\n\u003cbr\u003e\n\n### 순수 JDBC\n\n- 옛날 개발자들이 어떻게 Java와 DB를 연결했는지 봐보자.\n- 지금은 전혀 쓰지않으니 가볍게 보도록하자!\n\n\u003cbr\u003e\n\n**`build.gradle` 파일에 jdbc, h2 데이터베이스 관련 라이브러리 추가**\n\n```java\nimplementation 'org.springframework.boot:spring-boot-starter-jdbc'\nruntimeOnly 'com.h2database:h2'\n```\n\n\u003cbr\u003e\n\n**`resources/application.properties`에 스프링부트 DB 연결 설정 추가**\n\n\u003cbr\u003e\n\n```java\nspring.datasource.url=jdbc:h2:tcp://localhost/~/test  \nspring.datasource.driver-class-name=org.h2.Driver  \nspring.datasource.username=sa\n```\n\n- Spring Boot 2.4부터는 `spring.datasource.username=sa`를 꼭 추가해야함\n\t- 추가안하면 `Wrong user name or password` 오류 발생\n\t- 마지막에 공백 붙어도 오류 발생\n\n\u003cbr\u003e\n\n순수 JDBC 코드는 적어놓진 않겠음.\n\n\u003cbr\u003e\n\n```java\n@Configuration  \npublic class SpringConfig {  \n  \n    private DataSource dataSource;  \n  \n    @Autowired  \n    public SpringConfig(DataSource dataSource) {  \n        this.dataSource = dataSource;  \n    }  \n  \n    @Bean  \n    public MemberService memberService() {  \n        return new MemberService(memberRepository());  \n    }  \n  \n    @Bean  \n    public MemberRepository memberRepository() {  \n        return new JdbcMemberRepository(dataSource);  \n    }  \n}\n```\n\n- ==**DataSource는 데이터베이스 커넥션을 획득할 때 사용하는 객체이다.**==\n- ==**스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 DataSource를 생성하고 스프링 빈으로 만들어둔다. 그래서 DI를 받을 수 있다.**==\n\n\u003cbr\u003e\n\n![](brain/image/spring-basic-02-4.png)\n\n![](brain/image/spring-basic-02-5.png)\n\n- ==**개방-폐쇄 원칙 (OCP, Open-Closed Principle)**==\n\t- 확장에는 열려있고, 수정, 변경에는 닫혀있다.\n\t- 자바 객체지향원리의 다형성을 잘 활용한 예시\n- 스프링의 DI(Dependency Injection)을 사용하면 **기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경**할 수 있다.\n\n\u003cbr\u003e\n\n### 스프링 통합테스트\n\n- 스프링 컨테이너와 DB까지 연결한 통합 테스트를 진행해보자.\n- ==**근데 사실 최소한의 단위로 하는 순수한 단위 테스트가 훨씬 좋은 테스트일 확률이 크다. 스프링 컨테이너 없이 테스트 할 수 있도록 훈련하자.**==\n\n```java {title=\"MemberServiceIntegrationTest.java\"}\n@SpringBootTest  \n@Transactional  \nclass MemberServiceIntegrationTest {  \n  \n    @Autowired MemberService memberService;  \n    @Autowired MemberRepository memberRepository;  \n  \n    @Test  \n    void 회원가입() {  \n        // given  \n        Member member = new Member();  \n        member.setName(\"spring\");  \n  \n        // when  \n        Long saveId = memberService.join(member);  \n  \n        // then  \n        Member findMember = memberService.findOne(saveId).get();  \n        assertThat(member.getName()).isEqualTo(findMember.getName());  \n    }\n}\n```\n\n- 어차피 테스트 코드니까 간단하고 빠른게 짱이라서 그냥 `@Autowired` 필드 주입 했음\n- `@SpringBootTest` : 스프링 컨테이너와 테스트를 함께 살펴본다.\n- ==**데이터베이스는 기본적으로 트랜잭션이란 개념이 있는데, insert 쿼리로 데이터를 넣은 이후 commit을 해야 반영이 된다. 보통 기본적으로 auto-commit한다. 그래서 insert 쿼리는 커밋하기 이전에는 DB에 반영이 안된다는 의미**==이다.\n- ==**`@Transactional` : DB에 쿼리를 다 날리고 커밋하기 이전에 롤백(Rollback)해서 DB에 반영되지 않게 하는 것이다.**== 테스트 케이스에 이 애노테이션이 있으면, 테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 항상 롤백한다. 이렇게하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않는다.\n\t- 테스트 케이스의 테스트 메서드 각각 하나 하나마다 적용된다.\n\t- 트랜잭션 시작 - 테스트하고 - 끝나면 롤백, 다시 트랜잭션 시작 - 테스트하고 - 끝나면 롤백\n\n\u003cbr\u003e\n\n### 스프링 JdbcTemplate\n\n- 순수 Jdbc와 동일한 환경설정\n- 스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해준다. 하지만, SQL은 직접 작성해야한다.\n\n```java {title=\"JdbcTemplateMemberRepository.java\"}\npublic class JdbcTemplateMemberRepository implements MemberRepository {  \n  \n    private final JdbcTemplate jdbcTemplate;  \n  \n    // @Autowired, 생성자가 딱 1개라 생략 가능  \n    public JdbcTemplateMemberRepository(DataSource dataSource) {  \n        this.jdbcTemplate = new JdbcTemplate(dataSource);  \n    }\n}\n```\n\n- JdbcTemplate은 **DataSource를 의존성 주입**해줘야 한다.\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eJdbcTemplateMemberRepository 코드보기\u003c/strong\u003e\u003c/summary\u003e\n\n```java\npublic class JdbcTemplateMemberRepository implements MemberRepository {  \n  \n    private final JdbcTemplate jdbcTemplate;  \n  \n    // @Autowired, 생성자가 딱 1개라 생략 가능  \n    public JdbcTemplateMemberRepository(DataSource dataSource) {  \n        this.jdbcTemplate = new JdbcTemplate(dataSource);  \n    }  \n  \n    @Override  \n    public Member save(Member member) {  \n        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);  \n        jdbcInsert.withTableName(\"member\").usingGeneratedKeyColumns(\"id\");  \n  \n        Map\u003cString, Object\u003e parameters = new HashMap\u003c\u003e();  \n        parameters.put(\"name\", member.getName());  \n  \n        Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));  \n        member.setId(key.longValue());  \n        return member;  \n    }  \n  \n    @Override  \n    public Optional\u003cMember\u003e findById(Long id) {  \n        List\u003cMember\u003e result = jdbcTemplate.query(\"select * from member where id = ?\", memberRowMapper(), id);  \n        return result.stream().findAny();  \n    }  \n  \n    @Override  \n    public Optional\u003cMember\u003e findByName(String name) {  \n        List\u003cMember\u003e result = jdbcTemplate.query(\"select * from member where name = ?\", memberRowMapper(), name);  \n        return result.stream().findAny();  \n    }  \n  \n    @Override  \n    public List\u003cMember\u003e findAll() {  \n        return jdbcTemplate.query(\"select * from member where id = ?\", memberRowMapper());  \n    }  \n  \n    private RowMapper\u003cMember\u003e memberRowMapper() {  \n        return (rs, rowNum) -\u003e {  \n            Member member = new Member();  \n            member.setId(rs.getLong(\"id\"));  \n            member.setName(rs.getString(\"name\"));  \n            return member;  \n        };  \n    }  \n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eSpringConfig 코드보기\u003c/strong\u003e\u003c/summary\u003e\n\n```java\n@Configuration  \npublic class SpringConfig {  \n  \n    private DataSource dataSource;  \n  \n    @Autowired  \n    public SpringConfig(DataSource dataSource) {  \n        this.dataSource = dataSource;  \n    }  \n  \n    @Bean  \n    public MemberService memberService() {  \n        return new MemberService(memberRepository());  \n    }  \n  \n    @Bean  \n    public MemberRepository memberRepository() {  \n//        return new MemoryMemberRepository();  \n//        return new JdbcMemberRepository(dataSource);  \n        return new JdbcTemplateMemberRepository(dataSource);  \n    }  \n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### JPA\n\n\u003cbr\u003e\n\n### 스프링 데이터 JPA\n\n\u003chr\u003e\n\n## AOP\n\n### AOP가 필요한 상황\n\n### AOP 적용","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/dataStructure/":{"title":"Data Structure","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/dataStructure/easy-ds/":{"title":"쉬운코드 자료구조","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/dataStructure/easy-ds/lecture00":{"title":"강의소개","content":"\n유튜버 쉬운코드님의 강의 플레이리스트 중  \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터 구조\u003c/a\u003e를 정리한 노트\n\n1. [01. 스택과 큐](brain/Lecture/easycode/ds/lecture01)\n2. [02. 우선순위 큐, 힙](brain/Lecture/easycode/ds/lecture02)\n3. [03. 배열, 동적배열, 연관배열](brain/Lecture/easycode/ds/lecture03)\n4. [04. 리스트, 배열리스트, 연결리스트](brain/Lecture/easycode/ds/lecture04)\n5. [05. map, 해시 테이블](brain/Lecture/easycode/ds/lecture05)\n6. [06. set, hash set](brain/Lecture/easycode/ds/lecture06)\n7. [07. 트리, 이진트리](brain/Lecture/dataStructure/easy-ds/lecture07.md)\n8. [08. 이진탐색트리 BST](brain/Lecture/dataStructure/easy-ds/lecture08.md)\n9. [09. AVL 트리](brain/Lecture/dataStructure/easy-ds/lecture09.md)\n10. [10. 레드블랙트리 기본개념](brain/Lecture/easycode/ds/lecture10)\n11. [11. 레드블랙트리 삭제](brain/Lecture/easycode/ds/lecture11)","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/dataStructure/easy-ds/lecture07":{"title":"07. 트리, 이진트리","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터 구조\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 트리\n\n==**트리(tree)**==\n\n- 노드(node)들의 집합\n- 각 노드는 값(value)과 다른 노드들을 가리키는 레퍼런스들로 구성\n\n\u003e 노드는 엄밀히 말하면 값 뿐만이 아니라 레퍼런스를 포함해서 생각하자\n\n\u003cbr\u003e\n\n### 주요 용어\n\u0003\n\u003cbr\u003e\n\n![](brain/image/lecture07-12.png)\n\n\u003cbr\u003e\n\n==**간선(edge)**==\n- 노드와 노드를 연결하는 선\n- 구현 관점에서는 **레퍼런스**를 의미\n\t- link, branch 라고도 불림\n- ex) 흰색 선들\n\n==**루트(root) 노드**==\n- 트리의 최상단에 있는 노드\n- 트리의 시작점\n- ex) 2번 노드\n\n==**자녀(child) 노드**==\n- 모든 노드는 0개 이상의 자녀 노드를 가짐\n- ex) 9의 자식 노드는 11, 11의 자식 노드는 8, 1, 4 등등\n\n==**부모(parent) 노드**==\n- 자녀 노드를 가지는 노드\n- ex) 2, 5, 9, 6, 11번 노드\n\n==**형제(sibling) 노드**==\n- 같은 부모를 가지는 노드들\n- ex) {8, 1, 4}, {6, 7}, {5, 9}\n\n==**조상(ancestor) 노드**==\n- 부모 노드를 따라 루트 노드까지 올라가며 만나는 모든 노드\n- ex) 8의 조상 노드 : 11, 9, 2\n\n==**자손(descendant) 노드**==\n- 자녀 노드를 따라 내려가며 만날 수 있는 모든 노드\n- ex) 9의 자손 노드 : 11, 8, 1, 4\n\n==**내부(internal) 노드**==\n- 자녀 노드를 가지는 노드, 리프 노드가 아닌 노드\n\t- branch node, inner node 라고도 불림\n- ex) 2, 5, 9, 6, 11번 노드\n\n==**외부(external) 노드**==\n- 자녀 노드가 없는 노드\n\t- leaf node, outer node, terminal node 라고도 불림\n\t- 리프 노드, 외부 노드, 단말 노드\n- ex) 3, 7, 8, 1, 4번 노드\n\n==**경로(path)**==\n- 한 노드에서 다른 노드 사이의 노드들의 시퀀스(sequence)\n- ex) 2에서 7로의 경로 : 2 - 5 - 7\n- ex) 2에서 4로의 경로 : 2 - 9 - 11 - 4\n\n==**경로 길이(length of path)**==\n- 경로에 있는 노드들의 수\n- ex) 2에서 7로의 경로 길이 : 3\n- ex) 2에서 3으로의 경로 길이 : 4\n\n==**노드의 높이(height)**==\n- 노드에서 자기 자손의 리프(leaf) 노드까지의 가장 긴 경로의 간선(edge) 수\n\t- 간선 수가 아니라 노드의 수로 카운트하는 경우도 있어서, 그때는 + 1 해주기\n- ex) 5의 높이 : 2\n\t- 5번 노드에서 갈 수 있는 리프 노드는 3, 7\n\t- 이 중에서 3으로 가는게 가장 김. 따라서 2\n- ex) 리프 노드의 높이 : 0\n\n==**트리의 높이(height)**==\n- 루트 노드의 높이\n- ex) 트리의 높이 : 3\n\n==**노드의 깊이(depth)**==\n- 루트 노드에서 해당 노드까지 경로의 간선(edge) 수\n- ex) 11의 깊이 : 2\n\t- 2에서 9, 9에서 11 총 2\n- ex) 3의 깊이 : 3\n- ex) 루트 노드의 깊이 : 0\n\n==**트리의 깊이(depth)**==\n- 트리에 있는 노드들의 깊이 중 가장 긴 깊이\n- **트리 높이 = 트리 깊이**\n- ex) 트리 깊이 : 3\n\n==**노드의 차수(degree)**==\n- 노드의 자녀 노드 수\n- ex) 11의 차수 : 3\n- ex) 3의 차수 : 0\n\n==**트리의 차수(degree)**==\n- 트리에 있는 노드들의 차수 중 가장 큰 차수\n- 트리 차수 : 3\n\n==**두 노드 사이의 거리(distance)**==\n- 두 노드의 최단 경로의 간선 수\n- ex) distance(9, 8) : 2\n- ex) distance(3, 8) : 6\n\n==**노드의 레벨(level)**==\n\n![](brain/image/lecture07-13.png)\n\n- 노드와 루트 노드 사이의 경로에서 간선(edge)의 수\n- ex) 루트 노드의 레벨 : 0\n\t- 이것 또한 어떤 문서에서는 노드의 수라고 할 수도 있음. 그때는 + 1\n\n==**width**==\n- 임의의 레벨에서 노드의 수\n- ex) level 2의 width : 3\n- ex) level 3의 width : 4\n\n==**노드의 크기(size)**==\n- 자신을 포함한 자손 노드의 수\n- ex) 9의 크기 : 5\n- ex) 5의 크기 : 4\n\n==**트리의 크기(size)**==\n- 트리의 모든 노드의 수\n- ex) 트리의 크기 : 10\n\n==**서브 트리(subtree)**==\n\n![](brain/image/lecture07-14.png)\n\n- 각 노드의 자녀 노드들을 재귀적으로 서브 트리를 구성\n- 모든 노드들은 자신의 자녀 노드들이 재귀적으로 서브트리를 가진다고 이해하자\n\n\u003cbr\u003e\u003chr\u003e\n\n### 주요 특징\n\n- 루트 노드는 하나만 존재\n- 사이클(cycle)은 존재 ❌\n- 자녀 노드는 하나의 부모 노드만 존재\n- 데이터를 순차적으로 저장하지 않는 비선형(nonlinear) 구조\n- 트리에 서브 트리가 있는 재귀적 구조\n- 계층적 구조\n\n\u003cbr\u003e\n\n**트리 자료구조에서 루트 노드는 하나만 존재**\n\n![](brain/image/lecture07-15.png)\n\n\u003cbr\u003e\n\n**트리 자료구조에서 사이클(cycle)은 존재하지 않음**\n\n![](brain/image/lecture07-16.png)\n\n\u003cbr\u003e\n\n**트리 자료구조에서 자녀 노드는 하나의 부모 노드만 존재**\n\n![](brain/image/lecture07-17.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### 이진 트리\n\n==**이진 트리 (binary tree)**==\n\n![](brain/image/lecture07-18.png)\n\n- 각 노드의 자녀 노드 수가 **최대 2개**인 트리\n- ==left child | right child==\n- ==왼쪽 자녀 노드 | 오른쪽 자녀 노드==\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**정 이진 트리 (full binary tree)**==\n\n![](brain/image/lecture07-19.png)\n\n- 모든 노드는 자녀 노드가 없거나 2개인 트리\n\t- 즉, 자녀 노드가 1개인 노드는 없음\n\u001f\n\u003cbr\u003e\u003cbr\u003e\n\n==**완전 이진 트리 (complete binary tree)**==\n\n![](brain/image/lecture07-21.png)\n\n- 마지막 레벨을 제외한 모든 레벨에서 노드가 빠짐 없이 채워져 있음\n- 마지막 레벨은 왼쪽부터 빠짐없이 노드가 채워져 있는 트리\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**포화 이진 트리 (perfect binary tree)**==\n\n![](brain/image/lecture07-22.png)\n\n- 모든 레벨에서 노드가 빠짐없이 채워져 있는 트리\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**변질 이진 트리 (degenerate binary tree)**==\n\n![](brain/image/lecture07-23.png)\n\n- 모든 부모 노드는 하나의 자녀 노드만 가지는 트리\n- pathological binary tree 라고도 불림\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**Left skewed binary tree**==\n\n![](brain/image/lecture07-24.png)\n\n- 모든 부모 노드는 왼쪽 자녀 노드만 가지는 트리\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**Right skewed binary tree**==\n\n![](brain/image/lecture07-25.png)\n\n- 모든 부모 노드는 오른쪽 자녀 노드만 가지는 트리\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**균형 이진 트리 (balanced binary tree)**==\n- 모든 노드에서 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 최대 1인 트리\n\n![](brain/image/lecture07-27.png)\n\n![](brain/image/lecture07-28.png)\n\n![](brain/image/lecture07-29.png)\n\n![](brain/image/lecture07-30.png)\n","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/dataStructure/easy-ds/lecture08":{"title":"08. 이진탐색트리 BST","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터 구조\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 이진탐색트리\n\n==**이진 탐색 트리 (binary search tree)**==\n\n![](brain/image/lecture08-26.png)\n\n- **모든 노드의 왼쪽 서브 트리는 해당 노드의 값보다 작은 값들만 가짐**\n- **모든 노드의 오른쪽 서브 트리는 해당 노드의 값보다 큰 값들만 가짐**\n- ==**이진 탐색 트리의 최소값**== : 트리의 가장 왼쪽에 존재\n\t- 왼쪽 → 왼쪽 하니까 최소값 3\n- ==**이진 탐색 트리의 최대값**== : 트리의 가장 오른쪽에 존재\n\t- 오른쪽 1번밖에 안됨. 최대값 50\n\n\u003cbr\u003e\u003chr\u003e\n\n### 중위순회\n\n==**중위 순회 (inorder traversal)**==\n\n![](brain/image/lecture08-33.png)\n\n- 재귀적으로 왼쪽 서브 트리 순회\n- 현재 노드 방문 (ex. 값 출력)\n- 재귀적으로 오른쪽 서브 트리 순회\n- 결과적으로 출력은 크기 순서로 나열됨\n\n\u003cbr\u003e\u003chr\u003e\n\n### 중위순회 예제\n\n**1. 출발은 항상 루트노드, 재귀적으로 왼쪽 서브트리 순회**\n\n**2. 더이상 갈 왼쪽이 없으니까 현재 노드 방문 (여기서는 3번 노드)**\n\n**3. 오른쪽으로 가려고 하니까 현재 노드의 오른쪽이 없음, 3번 노드의 할일은 끝**\n\n![](brain/image/lecture08-28.png)\n\n\u003cbr\u003e\n\n**4. 5번 노드로 가면 왼쪽 서브트리 순회는 이미 끝난 상태**\n\n**5. 현재 노드 방문하여 5번 노드 출력**\n\n**6. 오른쪽 서브트리 순회, 15번은 다시 왼쪽으로**\n\n**7. 10번 노드는 더이상 없음. 그러니까 다시 10번 출력**\n\n![](brain/image/lecture08-29.png)\n\n**결국 반복하면 아래와 같이 결과가 나옴**\n\n![](brain/image/lecture08-30.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### 전위순회\n\n==**전위 순회 (preorder traversal)**==\n\n![](brain/image/lecture08-32.png)\n\n- 현재 노드 방문 (ex. 값 출력)\n- 재귀적으로 왼쪽 서브 트리 순회\n- 재귀적으로 오른쪽 서브 트리 순회\n\n\u003cbr\u003e\u003chr\u003e\n\n### 후위순회\n\n==**후위 순회 (postorder traversal)**==\n\n![](brain/image/lecture08-34.png)\n\n- 재귀적으로 왼쪽 서브 트리 순회\n- 재귀적으로 오른쪽 서브 트리 순회\n- 현재 노드 방문 (ex. 값 출력)\n\n\u003cbr\u003e\u003chr\u003e\n\n### 후임자 / 선임자\n\n==**노드의 후임자 (successor)**==\n\n![](brain/image/lecture08-35.png)\n\n- 해당 노드보다 값이 큰 노드들 중에서 가장 값이 작은 노드\n- ex) 20의 successor : 30\n- ex) 17의 successor : 20\n- ex) 10의 successor: 15\n\n\u003cbr\u003e\n\n==**노드의 선임자 (predecessor)**==\n\n![](brain/image/lecture08-36.png)\n\n- 해당 노드보다 값이 작은 노드들 중에서 가장 값이 큰 노드\n- ex) 20의 predecessor : 17\n- ex) 10의 predecessor : 5\n- ex) 40의 predecessor : 30\n\n\u003cbr\u003e\u003chr\u003e\n\n### 삽입/삭제/검색\n\n\u003cbr\u003e\n\n**삽입**\n- 그냥 값이 크면 오른쪽, 작으면 왼쪽 이거만 기억하고 넣으면 됨\n\n![](brain/image/lecture08-37.png)\n\n\u003cbr\u003e\n\n**삭제**\n- 삭제하려는 노드가 있는지 먼저 검색\n- 있으면 삭제\n- 즉, 삭제는 검색이라는 작업이 동반됨\n\n**자녀가 없는 노드 삭제**\n- 삭제될 노드를 가리키던 레퍼런스를 가리키는 것이 없도록 처리\n\n**자녀가 하나인 노드 삭제**\n- 삭제될 노드를 가리키던 레퍼런스를 삭제될 노드의 자녀를 가리키게 변경\n\n**자녀가 둘인 노드 삭제**\n- 삭제될 노드의 오른쪽 서브트리에서 제일 값이 작은 노드가 삭제될 노드를 대체\n- 만약, 왼쪽 서브트리로 정했다면 제일 값이 큰 노드가 삭제될 노드를 대체하면 됨\n\n\u003cbr\u003e\n\n**ex) 20 삭제**\n\n![](brain/image/lecture08-39.png)\n\n![](brain/image/lecture08-40.png)\n\n\u003cbr\u003e\n\n**ex) 30 삭제**\n\n![](brain/image/lecture08-41.png)\n\n\u003cbr\u003e\n\n**ex) 50 삭제**\n\n![](brain/image/lecture08-42.png)\n\n\u003cbr\u003e\n\n**ex) 기타**\n\n![](brain/image/lecture08-44.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### 시간복잡도\n\n![](brain/image/lecture08-49.png)\n\n\u003cbr\u003e\n\n**best case**\n- insert : $\\Theta (1)$\n- delete : $\\Theta (1)$\n- search : $\\Theta (1)$\n\n![](brain/image/lecture08-45.png)\n\n\u003cbr\u003e\n\n**average case**\n- insert : $O (\\log N)$\n- delete : $O (\\log N)$\n- search : $O (\\log N)$\n- 왼쪽이던 오른쪽이던 선택한 쪽만 집중하면 점근적으로 사이즈를 절반씩 줄여나갈 수 있음\n\n![](brain/image/lecture08-46.png)\n\n\u003cbr\u003e\n\n**worst case**\n- insert : $\\Theta (N)$\n- delete : $\\Theta (N)$\n- search : $\\Theta (N)$\n- ex) 1을 넣어야 한다면 모든 노드 확인해야함\n\n![](brain/image/lecture08-48.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### 장단점\n\n\u003cbr\u003e\n\n**이진탐색트리 장점**\n- 삽입 / 삭제가 유연 (레퍼런스만 재조정하면 되니까)\n- 값의 크기에 따라 좌우 서브트리가 나눠지기 때문에 삽입/삭제/검색이 (보통은) 빠르다\n- 값의 순서대로 순회 가능 (정렬된 형태로 접근 가능하다는 말)\n\n**이진탐색트리 단점**\n- 트리가 구조적으로 한쪽으로 편향되면 삽입/삭제/검색 등등 수행시간이 악화됨\n- 이 문제를 해결하기 위해 스스로 균형을 잡는 이진탐색트리가 사용됨\n\t- ex) AVL 트리, Red-Black 트리\n\t- 얘네는 worst case 에서도 $O(\\log N)$으로 처리됨","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/dataStructure/easy-ds/lecture09":{"title":"09. AVL 트리","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터 구조\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## AVL 트리\n\n==**AVL 트리**==\n- 이진탐색트리 (BST)의 한 종류\n- 스스로 균형(balancing)을 잡는 트리\n- balance factor를 통해 균형 유지\n","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/":{"title":"Database","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/":{"title":"쉬운코드 DB","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture00":{"title":"강의소개","content":"\n유튜버 쉬운코드님의 강의 플레이리스트 중  \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e를 정리한 노트\n\n1. [01. 데이터베이스 개론](brain/Lecture/db/easy-db/lecture01.md)\n2. [02. RDBMS 기초](brain/Lecture/db/easy-db/lecture02.md)\n3. [03. SQL DB생성, 테이블 생성](brain/Lecture/db/easy-db/lecture03.md)\n4. [04. 데이터 추가/수정/삭제](brain/Lecture/db/easy-db/lecture04.md)\n5. [05. 데이터 조회](brain/Lecture/db/easy-db/lecture05.md)\n6. [06. 서브쿼리](brain/Lecture/db/easy-db/lecture06.md)\n7. [07. three-valued logic](brain/Lecture/db/easy-db/lecture07.md)\n8. [08. Join](brain/Lecture/db/easy-db/lecture08.md)\n9. [09. 통계함수](brain/Lecture/db/easy-db/lecture09.md)\n10. [10. stored function](brain/Lecture/db/easy-db/lecture10.md)\n11. [11. stored procedure](brain/Lecture/db/easy-db/lecture11.md)\n12. [12. 실무에서 프로시저](brain/Lecture/db/easy-db/lecture12.md)\n13. [13. trigger](brain/Lecture/db/easy-db/lecture13.md)\n14. [14. transaction](brain/Lecture/db/easy-db/lecture14.md)\n15. [15. concurrency control](brain/Lecture/db/easy-db/lecture15.md)\n\n\u003cbr\u003e\n\n==**SELECT 조회 요약**==\n\n```sql\nSELECT 속성(들) 혹은 집계함수(들)\nFROM 테이블(들)\n[WHERE 조건(들)]\n[GROUP BY 그룹속성(들)]\n[HAVING 그룹속성(들)]\n[ORDER BY 속성(들)];\n```\n\n==**SELECT 개념적인 실행 순서**==\n- select 쿼리에서 각 절(phase)의 실행 순서는 **개념적인 순서**이다.\n- select 쿼리의 실제 실행 순서는 각 RDBMS에서 어떻게 구현했는지에 따라 다름\n\n1. **FROM** : 어떤 테이블로부터 조회할 것인지 혹은 join이 된 테이블들\n2. **WHERE** : 가지고 오는 튜플들에 대해서 조건을 통해 필터링 해야한다면\n3. **GROUP BY** : 그룹핑을 하고싶다면\n4. **HAVING** : 그룹핑 이후 특정 그룹만 필터링 해서 가지고 오고싶다면\n5. **ORDER BY** : 최종적인 select로 가져오기 직전에 정렬해서 가져오고싶다면\n6. **SELECT** : 관심있는 속성이나 통계에 관하여 최종적인 조회\n\n\u003cbr\u003e\n\n==**DB 생성, 테이블 생성 SQL 한 눈에 보기**==\n\n\u003cbr\u003e\n\n```sql\n// DB 목록 확인\nSHOW DATABASES;\n\n// DB 생성\nCREATE DATABASE db명;\n\n// 선택된 DB 확인\nSELECT database();\n\n// 사용할 DB 지정\nUSE db명;\n\n// DB 삭제\nDROP DATABASE db명;\n\n// 테이블 생성\nCREATE TABLE (속성명 속성타입 등등);\n\n// 테이블 스키마 변경 - 속성 추가\nALTER TABLE 테이블명 ADD 속성명 타입;\n\n// 테이블 스키마 변경 - 속성 이름 변경\nALTER TABLE 테이블명 RENAME COLUMN 지금속성명 TO 바뀔속성명;\n\n// 테이블 스키마 변경 - 속성 타입 변경\nALTER TABLE 테이블명 MODIFY COLUMN 속성명 타입;\n\n// 테이블 스키마 변경 - 테이블 이름 변경\nALTER TABLE 테이블명 RENAME TO 바뀔테이블명;\n\n// 테이블 스키마 변경 - 기본키 추가\nALTER TABLE 테이블명 ADD PRIMARY KEY(id);\n\n// 테이블 삭제\nDROP TABLE 테이블명;\n```\n\n\u003cbr\u003e\n\n==**데이터 추가/수정/삭제**==\n\n\u003cbr\u003e\n\n```sql\n// 데이터 추가 - 1개\nINSERT INTO 테이블명 VALUES (값1, 값2, 값3, ...);\n\nINSERT INTO 테이블명 \nVALUES (속성이름1, 속성이름2, ...) \nINTO ('값1', '값2', ... );\n\n// 데이터 추가 - 여러개\nINSERT INTO 테이블명 VALUES (값1, 값2, 값3, ...), (값1, 값2, 값3, ...), ...;\n\n// 데이터 수정\nUPDATE 테이블명 \nSET 속성1 = 값1 \n[WHERE 조건];\n\n// 데이터 삭제\nDELETE FROM 테이블명\n[WHERE 조건];\n```\n\n\u003cbr\u003e\n\n==**데이터 조회**==\n\n```sql\n// 데이터 조회\nSELECT 속성 FROM 테이블명 [WHERE 조건];\n\n// AS 별칭 짓기\nSELECT 속성 AS 별명 FROM 테이블명 AS 별명;\n\n// DISTINCT 중복제거\nSELECT DISTINCT 속성명 FROM 테이블;\n\n// LIKE 문자열 맞는 조건 - A 시작\nSELECT 속성명 FROM 테이블명\nWHERE 속성 LIKE 'A%';\n\n// LIKE 문자열 맞는 조건 - A로 끝\nSELECT 속성명 FROM 테이블명\nWHERE 속성 LIKE '%A';\n\n// LIKE 문자열 맞는 조건 - A 포함\nSELECT 속성명 FROM 테이블명\nWHERE 속성 LIKE '%A%';\n\n// LIKE 문자열 맞는 조건 - A 포함 2글자\n// _ 하나당 한칸\nSELECT 속성명 FROM 테이블명\nWHERE 속성 LIKE 'A_';\n```","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture01":{"title":"01. DB 개론","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## DB 기본\n\n\u003cbr\u003e\n\n### DB\n\n==**DB(Database) : 전자적으로 (electronically) 저장되고 사용되는 관련있는 (related) 데이터들의 조직화된 집합 (organized collection)**==\n\n- **관련있는 데이터들을** : 같은 출처, 같은 목적, 같은 서비스 안에서 생성되는 데이터들을 관련있는 데이터라고 함\n- **조직화된 집합으로** : 잘 조직화된 데이터들을 내가 찾으려는 데이터를 조금더 빨리 찾을 수 있게 해주고, 불필요한 데이터를 중복되서 생성되지 않게 해주고, 데이터의 불일치 문제도 해결해줌\n- **전자적으로 저장하고 사용** : 데이터가 컴퓨터에 저장되고 사용되는 것\n\n\u003cbr\u003e\n\n### DBMS\n\n==**DBMS(Database Management System) : 사용자에게 DB를 정의하고 만들고 관리하는 기능을 제공하는 소프트웨어 시스템**==\n\n- 대표적인 DBMS로는 PostgreSQL, MySQL, Oracle DB, MS-SQL 등등\n- DB를 정의하다 보면 부가적인 데이터가 발생할 수 있다. -\u003e **metadata**\n\n\u003cbr\u003e\n\n==**metadata : DB를 정의하거나 기술하는(descriptive) data**==\n\n- 즉, 데이터를 설명하기 위한 데이터를 metadata라고 함\n- catalog라고도 부른다.\n\t- DB의 metadata가 저장되는 곳을 catalog라고도 함\n- ex) 데이터 유형, 구조, 제약 조건, 보안, 저장, 인덱스, 사용자 그룹 등등\n- metadata 또한 DBMS를 통해 저장/관리 됨\n\n\u003cbr\u003e\n\n### DB System\n\n==**Database System : DB + DBMS + 연관된 applications**==\n\n- 줄여서 DB라고도 부름\n- 즉, DB라고 하면 순수하게 data 자체를 의미하는 DB일 수도 있지만, DB system을 의미하는 DB일 수도 있다.\n\n\u003cbr\u003e\n\n![](brain/image/lecture01-1.png)\n\n- query : 쿼리는 DB에 접근해서 원하는 데이터를 가져오거나 수정하는 요청을 의미\n- 이것이 전체적인 Database System이 동작하는 방식\n\t1. 애플리케이션 프로그램이 쿼리를 이용해 DBMS에게 요청\n\t2. 받은 쿼리를 분석하고 완료되면 요청에 대한 처리\n\t3. 요청된 데이터가 어떤 형태인지 부가적인 정보인 metadata를 먼저 파악\n\t4. metadata를 바탕으로 요청받은 data를 찾아서 애플리케이션에 반환\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Data models\n\n==**Data Models : DB의 구조를 원하는 형태로, 원하는 추상화 수준으로 모델링 하기 위해 필요한 것이 데이터 모델**==\n\n- **DB의 구조(structure)를 기술하는데 사용될 수 있는 개념들이 모인 집합**\n\t- DB 구조를 **추상화**해서 표현할 수 있는 수단 제공\n- data model은 여러 종류가 있으며, 추상화 수준과 DB 구조화 방식이 조금씩 다름\n- DB에서 읽고 쓰기 위한 기본적인 동작들(operations)도 포함\n\n\u003e DB 구조 : 데이터 유형, 데이터 관계(relationship), 제약 사항(constraints) 등등\n\n\u003cbr\u003e\n\n==**Data models 분류**==\n- 개념적 데이터 모델, conceptual (or high-level) data models\n- 논리적 데이터 모델, logical (or representational) data models\n- 물리적 데이터 모델, physical (or low-level) data models\n\n\u003cbr\u003e\n\n### Conceptual\n\n- 데이터베이스의 추상화 수준을 높게 하여, 누가봐도 쉽게 이해할 수 있는 개념들로 이뤄진 모델\n- ==**추상화 수준이 가장 높음**==\n- 비즈니스 요구사항을 추상화하여 기술할 때 사용\n- 대표적인 Conceptual Data models은 ==**entity-relationship model**==\n\t- **ER diagram**\n\t- DB 구조를 **entity**와 **entity들의 관계**로 나타내는 것\n\n\u003cbr\u003e\n\n![](brain/image/lecture01-2.png)\n\n예를 들어, 대학교의 도서관 시스템을 구현하는 상황에 학생들 정보와 책의 정보를 나타내는 경우\n- Entity : Student, Book\n\t- 각각의 Entity마다 Attribute(속성)이 있음\n- Relation : reads\n\n\u003cbr\u003e\n\n### Logical\n\n- 이해하기 어렵지 않으면서도 ==**디테일하게 DB를 구조화**== 할 수 있는 개념들을 제공하는 모델\n- 데이터가 컴퓨터에 저장될 때의 구조와 크게 다르지 않게 DB 구조화를 가능하게 함\n- 특정 DBMS나 특정 storage에 종속되지 않는 수준에서 DB를 구조화 할 수 있는 모델\n- 대표적인 Logical Data models은 ==**관계형 데이터 모델 (relational data model)**==\n\t- **객체 데이터 모델 (object-data model)**도 있음\n\t- **객체-관계형 데이터 모델 (object-relational data model)**도 있음 (relational + object)\n\t- MySQL, Oracle, MS-SQL은 relational data model\n\t- PostgreSQL은 object-relational data model\n\n\u003cbr\u003e\n\n![](brain/image/lecture01-3.png)\n\n- relation은 테이블을 의미하는 것\n\t- row : 데이터 각각\n\t- column : 데이터의 속성, attribute\n\n\u003cbr\u003e\n\n### Physical\n\n- 컴퓨터에 데이터가 어떻게 파일 형태로 저장되는지를 기술할 수 있는 수단 제공\n- data format, data orderings, access path 등등\n- access path : 데이터 검색을 빠르게 하기 위한 구조체\n\t- ex) index\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Schema \u0026 State\n\n\u003cbr\u003e\n\n### DB Schema\n\n- ==**Data model을 바탕으로 DB의 구조를 기술(description)한 것**==\n- schema는 DB를 설계할 때 정해지며, 한 번 정해진 후에 자주 바뀌지 않음\n\n![](brain/image/lecture01-4.png)\n\n- 이렇게 데이터베이스의 스키마를 보면 구조가 어떤식으로 되어있는 지 큰그림 이해하기 쉬움\n\n\u003cbr\u003e\n\n### DB state(snapshot)\n\n![](brain/image/lecture01-5.png)\n\n- DB에 있는 실제 데이터는 꽤 자주 바뀔 수 있음\n- ==**특정 시점에 DB에 있는 데이터**==를 ==**Database State**== 혹은 ==**Database snapshot**==이라고 함\n- 혹은 DB에 있는 현재 instances의 집합이라고도 함\n\n\u003cbr\u003e\n\n### three-schema\n\n- three-schema architecure는 ==**Database system을 구축하는 architecure 중의 하나**==\n- user application으로부터 물리적인(physical) 데이터베이스를 분리시키는 목적\n\t- 물리적인 DB의 구조가 조금씩 바뀔 수 있는데, 이 DB를 사용하는 user application에 영향을 끼치지 않도록 하려고 three-schema 구조를 사용하는 것\n- 세가지 Level이 존재하며, 각각의 Level 마다 schema가 정의되어 있음\n\n\u003cbr\u003e\n\n==**three-schema architecture 3가지 Level**==\n- 외부 스키마, external schemas (or user view) at external (or view) level\n- 개념적 스키마, conceptual schemas at conceptual level\n- 내부 스키마, internal schemas at internal level\n\n\u003cbr\u003e\n\n![](brain/image/lecture01-6.png)\n\n\u003cbr\u003e\n\n==**내부 스키마 (Internal Schema)**== : 물리적인 저장 장치에 가장 가깝게 위치\n- 물리적으로 데이터가 어떻게 저장되는지 **physical data model**을 통해 표현\n- data storage, data structure, access path (index) 등등 실체가 있는 내용 기술\n\n\u003cbr\u003e\n\n==**외부 스키마 (External Schema)**== : 실제 사용자가 바라보는 곳\n- external views, user views 라고도 불림\n- **특정 유저들이 필요로 하는 데이터만 표현**\n- 그 외 알려줄 필요가 없는 데이터는 숨김\n- **logical data model**을 통해 표현\n\n\u003cbr\u003e\n\nDatabase System의 초창기 아키텍처는 Internal schema, External schema 2개 밖에 없었다. 이렇게 하다보니 **각각의 유저마다 필요로 하는 데이터들이 달라지다 보니까 Internal Level에서 점점 더 중복되는 데이터가 생겼다. 점점 관리하기가 힘들어지고 데이터 불일치가 발생!** 이래서 나온게 Conceptual Schema!\n\n\u003cbr\u003e\n\n==**개념적 스키마 (Conceptual Schema)**== : 내부 스키마를 한 번 추상화해서 표현한 것\n- 전체 DB에 대한 구조 기술\n- 물리적인 저장 구조에 관한 내용은 숨김\n- entities, data types, relationships, user operations, constraints에 집중\n- **logical data model**을 통해 표현\n\n\u003cbr\u003e\n\n==**three-schema architecture**==\n- 각 레벨을 독립시켜서 어느 레벨에서의 변화가 상위 레벨에 영향을 주지 않기 위함\n\t- 예를 들어, 내부 스키마에 문제가 생겼다고 해도 개념적 스키마는 바꿀 필요 없이 매핑만 바꿔주면 된다는 의미. 따라서, 안정적인 운영 가능\n\t- 근데, 개념적 스키마에 문제가 생겼을 때 외부 스키마에 문제가 없게 하는 것은 상대적으로 까다로운 편\n- 대부분의 DBMS가 세가지 수준을 완벽하게 혹은 명시적으로 나누지는 않음\n- 각각의 스키마는 DB 구조를 표현하는 것이지, 실제로 데이터가 존재하는 곳은 **internal level**\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## DB Language\n\n\u003cbr\u003e\n\n### DDL\n\n- DDL (Data Definition Language)\n- ==**Conceptual Schema를 정의하기 위해 사용되는 언어**==\n- Internal schema까지 정의할 수 있는 경우도 있음\n\n\u003cbr\u003e\n\n### SDL\n\n- SDL (Storage Definition Language)\n- Internal schema를 정의하는 용도로 사용되는 언어\n- 요즘은 특히 Relational DBMS에서는 SDL이 거의 없고 파라미터 등의 설정으로 대체됨\n\n\u003cbr\u003e\n\n### VDL\n\n- VDL (View Definition Language)\n- External schemas를 정의하기 위해 사용되는 언어\n- 대부분의 DBMS에서는 DDL이 VDL 역할까지 수행\n\n\u003cbr\u003e\n\n### DML\n\n- DML (Data Manipulation Language)\n- ==**DB에 있는 실제 data를 활용하기 위한 언어**==\n- data 추가, 삭제, 수정, 검색 등등의 기능을 제공하는 언어\n\n\u003cbr\u003e\n\n### 통합된 언어\n\n- 오늘날의 DBMS는 DML, VDL, DDL이 따로 존재하기 보다 통합된 언어로 존재\n- 대표적인 예가 ==**Relational Database Language : SQL**==\n\t- SQL이 DML, VDL, DDL 역할 모두 수행","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture02":{"title":"02. RDBMS","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## RDBMS\n\n\u003cbr\u003e\n\n### relation in mathematics\n\n- relation이라는 개념 자체가, 수학에서 나온 개념이라서 그것부터 보겠다.\n\n\u003cbr\u003e\n\n**set**\n\n- 서로 다른 요소(elements)를 가지는 collection\n\t- 즉, 중복된 요소를 가지고 있지 않다.\n- 하나의 set에서 elements의 순서는 중요하지 않다.\n\t- ex) `{1, 3, 11, 4, 7}`\n\n\u003cbr\u003e\n\n**relation in mathematics**\n- 카테시안 곱의 부분집합\n- 튜플들의 집합\n\n![](brain/image/lecture02-1.png)\n\n- set A에서 요소를 하나 고르고, set B에서 요소를 하나 골라서 두 개의 요소로 쌍(pair)을 만들어보자.\n- 이렇게 ==**가능한 모든 쌍(pair)**==을 수학에서는 `A X B`와 같이 나타낼 수 있음\n- 이렇게 표현하는 것을 ==**카테시안 곱(Cartesian product)**==라고 한다.\n\t- 집합 A에서 a를 하나 고르고, 집합 B에서 b를 하나 골라서 가능한 모든 쌍(pair)\n\n\u003cbr\u003e\n\n![](brain/image/lecture02-2.png)\n\n- set이 2개 밖에 없는 경우 ==**binary relation**==이라고 한다.\n- ==**A와 B의 카테시안 곱의 부분집합을 의미**==\n\n\u003cbr\u003e\n\n![](brain/image/lecture02-4.png)\n\n- 총 n개의 set이 있다고 하자.\n- 위에서는 집합이 2개라서 binary relation이었지만, 지금은 n개니까 ==**n-ary relation**==이라고 한다.\n- ==**n개의 집합에 대한 카테시안 곱의 부분집합을 의미**==\n- 이때 `[1, p, a]`와 같이 각각의 리스트를 ==**튜플(Tuple)**== 이라고 부를 수 있음\n- ==**몇 개의 element 들로 이루어진 리스트라는 의미**==\n- n개의 집합에 대한 튜플이기 때문이 이런 경우에 ==**n-튜플**==이라고 함\n\n\u003cbr\u003e\n\n## relational data model\n\n수학에서의 relation이 어떤 의미인지는 봤고, **관계형 데이터 모델(relational data model)** 에서 이 개념이 어떻게 적용될까? \n=\u003e 데이터 모델 복습은 [1강](brain/Lecture/db/easy-db/lecture01.md)에서\n\n![](brain/image/lecture02-5.png)\n\n- relational data model에서 set은 ==**domain을 의미**==\n- ==**element 혹은 value 들의 집합이 domain!**==\n\n이제부터, 학생 데이터를 저장하는 student를 어떻게 relational data model에서 relation으로 표현하는지 살펴보자.\n\n\u003cbr\u003e\n\n### domain\n\n==**도메인 (domain) : 더이상 나눌 수 없는 값들로 이루어진 집합**==\n\n**domain 정의하기**\n\n![](brain/image/lecture02-6.png)\n\n- `students_ids` : 학번 집합, 7자리 integer 정수\n- `human_names`: 사람 이름 집합, 문자열\n- `university_grades` : 대학교 학년 집합, `{1, 2, 3, 4}`\n- `major_names` : 대학교에서 배우는 전공 이름 집합\n- `phone_numbers` : 핸드폰 번호 집합\n\t- phone_numbers가 두 개인 경우는 혹시 모를 상황에 대비해 비상 연락망도 넣은거임\n\n\u003cbr\u003e\n\n### attribute\n\n==**속성 (attribute) : domain이 relation에서 맡은 역할의 이름**==\n\n동일한 domain이 같은 relation에서 여러 번 사용되는 것은 사용되는 목적(역할)이 다르다. 그래서 이 역할이 다름을 표시해주기 위해 relational data model에서는 **속성(attributes)이라는 개념이 등장**한다. \n\n\u003cbr\u003e\n\n**attribute 추가하기**\n\n![](brain/image/lecture02-7.png)\n\n- 속성(attribute)은 각각의 도메인들이 릴레이션에서 어떤 역할을 수행하는 지, 수행하는 역할에 이름을 붙여주는 것이다.\n\n\u003cbr\u003e\n\n### tuple\n\n==**튜플 (tuple) : 각 attribute의 값으로 이루어진 리스트**==\n\n**tuple 표시하기**\n\n![](brain/image/lecture02-8.png)\n\n- domain은 어떤 값들로 이루어진 집합이라고 했으니까 각각의 domain마다 값들이 있을 것\n- 이 값 중에서 실제로 data가 존재하는 튜플(tuple)들이 있을 것\n\n\u003cbr\u003e\n\n### relation, 요약\n\n근데, 사실 relational data model에서 relation을 표현할 때 이렇게 그림으로 잘 표현하지 않고 테이블로 표현하는 것이 익숙할 것이다. 그래서 그냥 ==**relation을 추상적으로, 전체적으로 table이라고 생각하자.**==\n\n**student relation in relational data model**\n\n![](brain/image/lecture02-9.png)\n\n![](brain/image/lecture02-10.png)\n\n- set of atomic values는 집합이 더 이상 나눌 수 없는 값들로 이루어져야 한다는 제약사항을 의미\n\n\u003cbr\u003e\n\n### relation schema\n\n- relation의 구조를 나타냄\n- relation 이름 + attributes 리스트로 표시\n- ex) `STUDENT(id, name, grade, major, phone_num, emer_phone_num)`\n- attributes와 관련된 constraints도 포함\n\n\u003cbr\u003e\n\n### degree of relation\n\n- ==**relation schema에서 attributes의 수**==\n- ex) `STUDENT(id, name, grade, major, phone_num, emer_phone_num)`\n\t- 속성이 총 6개니까 degree는 6\n\t- 차원의 수는 6이라고도 함\n\n\u003cbr\u003e\n\n### relation state\n\n위에서는 relation을 추상적으로 전체적으로 테이블 자체를 릴레이션이라고 생각하라고 했는데, ==**relation을 relation state라고 생각할 수도 있다. 이것은 튜플들의 집합을 의미한다.**==\n\n![](brain/image/lecture02-11.png)\n\n- 즉, 추상적이고 전체적인 테이블 자체를 relation이라고 하는 것이 아니라 실제 존재하는 데이터에 한정해서 relation이라고 할 수도 있다는 의미\n- 도큐먼트를 보면서 ==**추상적인, 개념적인 의미의 relation을 의미하는 것인지,**== 혹은 ==**튜플들의 집합으로써의 relation을 의미하는 것인지**== 잘 파악하도록 하자.\n\n\u003cbr\u003e\n\n### relational database\n\n**관계형 DB (relational database)**\n- relational data model에 기반하여 구조화된 database\n- relational database는 여러 개의 relations으로 구성된다.\n\n**관계형 DB 스키마 (relational database schema)**\n- 릴레이션 스키마들의 집합 + 무결성 제약조건들의 집합 \n- (relation schemas set + integrity constraints set)\n\n\u003cbr\u003e\n\n### relation 특징\n\n- 중복된 튜플을 가질 수 없다.\n- 속성의 부분집합을 key로 가진다.\n- 튜플의 순서는 중요하지 않다.\n- 하나의 릴레이션에서 속성 이름 중복 불가능\n- 하나의 튜플에서 속성 순서 중요하지 않음\n- 속성은 아토믹 해야함\n\n\u003chr\u003e\n\n1. ==**중복 튜플 불가 : relation은 중복된 tuple을 가질 수 없음 (relation is set of tuples)**==\n\n- relation의 개념 자체가 튜플들의 집합이니까\n- 집합은 중복을 허용하지 않으니까 !!\n\n![](brain/image/lecture02-12.png)\n\n\u003cbr\u003e\n\n2. ==**속성의 부분집합 key : relation의 tuple을 식별하기 위해 attribute의 부분 집합을 key로 설정함**==\n\n- 속성 중 id라는 것을 통해서 튜플을 유니크하게 구분할 수 있음\n\n![](brain/image/lecture02-13.png)\n\n\n\u003cbr\u003e\n\n3. ==**튜플 순서 상관 X : relation에서 tuple의 순서는 중요하지 않음**==\n\n- 튜플 간에 순서가 바뀌어도 릴레이션의 의미가 바뀌지 않음\n- 즉, 튜플을 표시할 때 순서를 정하는 방법에 여러가지가 있을 수 있다.\n\t- ex) id 기준, name 기준, 등등\n\n![](brain/image/lecture02-14.png)\n\n\n\u003cbr\u003e\n\n4. ==**속성 이름 중복 불가 : 하나의 relation(table)에서 attribute의 이름은 중복되면 안됨**==\n\n![](brain/image/lecture02-15.png)\n\n\u003cbr\u003e\n\n5. ==**속성 순서 중요 X : 하나의 tuple에서 attribute의 순서는 중요하지 않음**==\n\n![](brain/image/lecture02-16.png)\n\n\u003cbr\u003e\n\n6. ==**속성 atomic 해야함 : attribute는 atomic 해야 한다. (composite or multivalued attribute 허용 안됨)**==\n\n![](brain/image/lecture02-17.png)\n\n- atomic은 더이상 나눌 수 없는, 원자적인 이라는 의미\n- 현재 address라는 속성은 `서울특별시 / 강남구 / 청담동` 세 가지로 쪼갤 수 있는 속성이다.\n\t- 이렇게 여러 가지 속성이 묶인 것을 복합 속성(composite attribtue)이라고 함.\n\t- 따라서, atomic 하지 않으니까 쪼개야 한다.\n- 현재 major라는 속성은 `컴공, 디자인` 이라는 2가지 값을 동시에 가진다.\n\t- 이런 것을 다중값 속성(multivalued attribute)이라고 함.\n\t- 따라서, atomic 하지 않으니까 쪼개야 한다.\n\n\u003cbr\u003e\n\n## NULL, 키, 제약조건\n\n\u003cbr\u003e\n\n### NULL\n\n==**NULL의 의미는 여러 가지가 있다. 따라서 최대한 NULL을 사용하지 않는 것이 좋다.**==\n\n- 값이 존재하지 않음\n- 값이 존재하지만 아직 그 값이 무엇인지 알지 못함\n- 해당 사항과 관련 없음\n\n![](brain/image/lecture02-19.png)\n\n- toeic_score (토익점수)\n\t- 아직 토익을 치지 않아서 값이 NULL 일 수 있음\n\t- 시험을 쳤지만 제출 안했을수도\n\t- 제출했는데 누락돼서 업데이트 안됐을 수도\n- transfer_from (편입정보)\n\t- 아예 편입하지 않았을 수도, 해당사항 없음\n\t- 편입 했는데 아직 업데이트 안됐을 수도\n\n\u003cbr\u003e\n\n### Keys\n\n==**슈퍼키 (super key) : relation에서 tuples를 unique 하게 식별할 수 있는 attributes set**==\n- ex) `PLAYER(id, name, team_id, back_number, birth_date)` 릴레이션에서 **슈퍼키**\n- **`{id, name, team_id, back_number, birth_date}`**\n\t- 릴레이션의 정의 자체가 튜플들로 이루어진 집합이니까 중복자체를 허용하지 않아서 전체 attributes set 자체로 superkey가 될 수 있음\n- **`{id, name}` , `{name, team_id, back_number}` .. 기타 등등**\n\n\u003cbr\u003e\n\n==**후보키 (candidate key) : 어느 한 attribute라도 제거하면 unique하게 tuples를 식별할 수 없는 슈퍼키(super key)**==\n- 편하게 key라고 부르기도 하고 minimal superkey라고 부르기도 함\n- ex) `PLAYER(id, name, team_id, back_number, birth_date)` 릴레이션 에서 **후보키**\n- **`{id}`**\n\t- id는 이미 attribute가 1개니까 제거할 수 없음, 후보키\n- **`{team_id, back_numer}`**\n\t- 이 둘 중 하나라도 없애면 각각 하나하나는 유니크하게 튜플들을 식별할 수 없음, 후보키\n\n\u003cbr\u003e\n\n==**개인키 (primary key) : relation에서 tuples를 unique하게 식별하기 위해 선택된 후보키(candidate key)**==\n- ex) `PLAYER(id, name, team_id, back_number, birth_date)` 릴레이션 에서 개인키\n- `{id}` 혹은 `{team_id, back_number}` 둘 중 하나를 **개인키**로 선택\n- 보통 attributes 수가 적은 경우를 pk로 선택 많이함. 여기서는 **`{id}`** 선택\n- pk는 보통 밑줄 그어서 표시\n\n\u003cbr\u003e\n\n==**유일키 (unique key) : 개인키(primary key)가 아닌 후보키(candidate keys)**==\n- **대체키(alternate key)** 라고도 부름\n- ex) `PLAYER(id, name, team_id, back_number, birth_date)` 릴레이션 에서 유일키\n- id가 pk로 선택된 경우에 **유일키(=대체키)** 는 **`{team_id, back_number}`**\n\n\u003cbr\u003e\n\n==**외래키 (foreign key) : 다른 relation의 개인키(primary key)를 참조하는 attributes set**==\n- ex) `PLAYER(id, name, team_id, back_number, birth_date)`\n- ex) `TEAM(id, name, manger)`\n- 여기서 **외래키**(foreign key)는 PLAYER의 **`{team_id}`**\n\n\u003cbr\u003e\n\n### 제약조건\n\n==**제약(constraints)은 관계형 데이터베이스(relational database)의 relations들이 언제나 항상 지켜줘야 하는 제약 사항을 의미한다.**==\n- 제약조건을 두는 이유는 데이터베이스가 일치된 형태로, 데이터의 일관성을 보장하기 위해 사용하는 개념이다.\n\n\u003cbr\u003e\n\n==**묵시적 제약조건 (Implicit constraints) : 관계형 데이터 모델 자체가 가지는 제약조건**==\n- relation은 중복되는 tuple을 가질 수 없음\n- relation 내에서는 같은 이름의 attribute를 가질 수 없음\n\n\u003cbr\u003e\n\n==**스키마-기반 제약조건 (schema-based constraints) : 주로 DDL을 통해 스키마에 직접 명시할 수 있는 제약조건**==\n- 명시적 제약조건(explicit constraints)라고도 부름\n- schema-based constraints는 아래와 같이 여러 종류가 있다.\n\t- domain constraints\n\t- key constraints\n\t- NULL value constraint\n\t- entity integrity constraint\n\t- referential integrity constraint\n\n\u003cbr\u003e\n\n**도메인 제약조건 (domain constraints)**\n- attribute의 value는 해당 attribute의 domain에 속한 value여야 한다.\n- 100학년이라는건 말이 안되니까\n\n![](brain/image/lecture02-20.png)\n\n\u003cbr\u003e\n\n**키 제약조건 (key constraints)**\n- 서로 다른 tuples는 같은 value의 key를 가질 수 없다.\n\n![](brain/image/lecture02-21.png)\n\n\u003cbr\u003e\n\n**널 값 제약조건 (NULL value constraint)**\n- attribute가 NOT NULL로 명시됐다면 NULL을 값으로 가질 수 없다.\n\n![](brain/image/lecture02-22.png)\n\n\u003cbr\u003e\n\n**엔티티 무결성 제약조건 (entity integrity constraint)**\n- primary key는 value에 NULL을 가질 수 없다.\n\n![](brain/image/lecture02-23.png)\n\n\u003cbr\u003e\n\n**참조 무결성 제약조건 (referential integrity constraint)**\n- FK와 PK와 도메인이 같아야 하고 PK에 없는 values를 FK가 값으로 가질 수 없다.\n\n![](brain/image/lecture02-24.png)","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture03":{"title":"03. DB/table 생성","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## SQL\n\n==**SQL (Structured Query Language)** ==\n- 현업에서 쓰이는 relational DBMS의 표준 언어\n- 종합적인 database 언어 : DDL + DML + VDL\n\n\u003cbr\u003e\n\n==**Database 구조를 정의할 때 중요한 점**==\n\n- 만드려는 서비스의 스펙과 데이터 일관성, 편의성, 확장성 등등을 종합적으로 고려하여 DB 스키마를 적절하게 정의하는 것이 중요\n\n\u003cbr\u003e\n\n### 기본 용어\n\n\u003cbr\u003e\n\n==**주요 용어**==\n\n| relational data model |  SQL   |\n|:---------------------:|:------:|\n|       relation        | table  |\n|       attribute       | column |\n|         tuble         |  row   |\n|        domain         | domain |\n\n\u003cbr\u003e\n\n==**SQL에서 relation이란?**==\n\n- **multiset** (= bag) of tuples @ SQL\n\t- 중복된 tuple을 허용한다는 의미\n\t- SQL에서는 각 tuple이 중복될 수 있다\n\n\u003cbr\u003e\n\n==**SQL \u0026 RDBMS**==\n\n- SQL은 RDBMS의 표준 언어이지만 실제 구현에 강제가 없음\n- 따라서, RDBMS마다 제공하는 SQL의 스펙이 조금씩 다름\n\n\u003cbr\u003e\n\n\n\u003cbr\u003e\n\n### 기본 명령어\n\n- 데이터베이스 목록 확인\n\n```sql\nSHOW DATABASES;\n\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n```\n\n\u003cbr\u003e\n\n- 데이터베이스 생성\n\n```sql\nCREATE DATABASE db이름;\n\n+--------------------+\n| Database           |\n+--------------------+\n| company            |\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n```\n\n\u003cbr\u003e\n\n- 지금 선택된 데이터베이스가 무엇인지\n\n```sql\nSELECT database();\n\n+------------+\n| database() |\n+------------+\n| NULL       |\n+------------+\n```\n\n\u003cbr\u003e\n\n- 사용할 데이터베이스 지정\n\n```sql\nUSE db이름;\n\nDatabase changed\n\n다시 선택된 데이터베이스 확인해보면\n\nSELECT database();\n+------------+\n| database() |\n+------------+\n| company    |\n+------------+\n```\n\n\u003cbr\u003e\n\n- 데이터베이스 삭제\n\n```sql\nDROP DATABASE db이름;\n```\n\n\u003cbr\u003e\n\n### DB vs 스키마\n\n- MySQL 에서는 `DATABASE`와 `SCHEMA`가 같은 뜻을 의미\n\t- `CREATE DATABASE company = CREATE SCHEMA company`\n- 그러나, 다른 RDBMS에서는 의미가 다르게 쓰임\n\t- ex) PostgreSQL에서는 `SCHEMA`가 `DATABASE의 namespace`를 의미\n\t- 그래서 PostgreSQL에서는 하나의 DATABASE가 여러 개의 SCHEMA를 가질 수 있음\n\t- 데이터베이스 안에서 스키마가 정의, 스키마 안에서 테이블이 정의\n\n\u003cbr\u003e\n\n### 속성 데이터 타입 (정수)\n\n![](brain/image/lecture03-2.png)\n\n- **PostgreSQL에서는 SMALLINT, INT or INTEGER, BIGINT 3종류만 있음**\n\t- TINYINT, MEDIUMINT가 없음\n- 고정 소수점 방식\n\t- `DECIMAL(precision, scale)`\n\t- precision : 자릿수, scale : 소숫점 이하 몇 째 자리까지\n\t- `DECIMAL(5, 2) =\u003e [-999.99 ~ 999.99]`\n\n\u003cbr\u003e\n\n\u003e SQL 표준 스펙에서는 DECIMAL은 유연한 처리, NUMERIC은 엄격한 처리 \u003cbr\u003e\n\u003e 하지만 MySQL에서는 DECIMAL, NUMERIC 둘 다 엄격하게 처리함 \u003cbr\u003e\n\u003e 엄격한 처리는 (5, 2)에서 5자리를 넘어가도 5자리까지만 딱 저장한다는거 \u003cbr\u003e\n\u003e 유연한 처리는 넘어가도 저장해주는거임\n\n\u003cbr\u003e\n\n### 속성 데이터 타입 (문자열)\n\n![](brain/image/lecture03-3.png)\n\n- VARCHAR가 CHAR보다 좋은 것 아니냐? 할 수 있지만, **VARCHAR와 CHAR를 어떻게 구현했는지에 따라 조금씩 다르다.** -\u003e RDBMS마다 다르다.\n\t- PostgreSQL\n\t\t- VARCHAR 권장\n\t- MySQL : VARCHAR가 storage 상 이점은 있겠지만, 시간적 성능이 CHAR에 비해 안좋을 수 있음\n\t\t- Form Number같이 문자열 크기가 고정적 -\u003e CHAR 권장\n\t\t- 문자열 크기가 고정적이지 않은 속성인 경우 -\u003e VARCHAR 권장\n- PostgreSQL 에서는 TEXT만 있음\n- MySQL 에서는 TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT 있음\n\t- VARCHAR보다 긴건 MEDIUMTEXT, LONGTEXT\n\t- TINYTEXT, TEXT는 VARCHAR와 동일하거나 그보다 작은 길이를 저장\n\n\u003cbr\u003e\n\n### 속성 데이터 타입 (날짜와 시간)\n\n![](brain/image/lecture03-4.png)\n\n- 시간을 3자리 까지 표시할 수 있다는 것은(hhh) 일이 경과된 시간을 표시하기 위함임\n- DATETIME과 TIMESTAMP의 차이\n\t- 범위의 차이\n\t- time-zone 반영 차이\n- TIMESTAMP는 표준시간대 UTC를 반영하는데, MySQL이 설치되어있는 서버의 timezone이나  MySQL 내부적으로 설정된 timezone의 시간 대비 표준 시간대로 변환해서 표준 시간대로 저장하고 읽어 올때도 변환해서 읽어옴\n\t- ==**즉, MySQL의 TIMESTAMP는 time-zone에 영향을 받는다!!**==\n\n\u003cbr\u003e\n\n### 속성 데이터 타입 (etc)\n\n![](brain/image/lecture03-5.png)\n\n- byte-string은 보안 관련해서 암호화하고 싶을 때 암호화 키를 byte-string으로 저장함\n- boolean\n\t- PostgreSQL은 있음\n\t- MySQL은 따로 없음\n\t\t- TINYINT로 대체해서 사용 (0과 1)\n\n\u003cbr\u003e\n\n### 속성 DEFAULT\n\n==**attribute DEFAULT**==\n- attribute의 default 값을 정의할 때 사용\n- 새로운 tuple을 저장할 때 해당 attribute에 대한 값이 없다면 default 값으로 저장\n\n![](brain/image/lecture03-14.png)\n\n**DEFAULT 선언방법**\n\n![](brain/image/lecture03-15.png)\n\n\u003cbr\u003e\n\n### 테이블 스키마 변경\n\n==**ALTER TABLE**==\n- table의 schema를 변경하고 싶을 때 사용\n\n![](brain/image/lecture03-28.png)\n\n\u003e 이미 서비스 중인 table의 schema를 변경하는 것이라면 \u003cbr\u003e\n\u003e 변경 작업 때문에 서비스의 백엔드에 영향이 없을 지 검토한 후에 변경하는 것이 중요!!!\n\n\u003cbr\u003e\n\n==**DROP TABLE**==\n- table을 삭제할 때 사용\n- `DROP TABLE 테이블명;`\n\n\u003cbr\u003e\n\n### 제약조건\n\n==**Key Constraints : PRIMARY KEY**==\n- primary key : table의 tuple을 식별하기 위해 사용, 하나 이상의 attribute(s)로 구성\n- primary key는 중복된 값을 가질 수 없으며, NULL도 값으로 가질 수 없음\n\n![](brain/image/lecture03-6.png)\n\n\u003cbr\u003e\n\n**Primary key 선언방법**\n\n![](brain/image/lecture03-7.png)\n\n- attribute가 여러 개라면 반드시 오른쪽처럼 적어야함\n- 그러나, attribute가 한개라면 `PRIMARY KEY(id)`처럼 해도 됨\n\n\u003cbr\u003e\n\n==**Key Constraints : UNIQUE**==\n- UNIQUE로 지정된 attribute(s)는 중복된 값을 가질 수 없음\n- 단, NULL은 중복을 허용할 수도 있음 (RDBMS 마다 다름)\n\t- MySQL, PostgreSQL에서는 NULL 중복 허용해줌\n\n![](brain/image/lecture03-8.png)\n\n\u003cbr\u003e\n\n**UNIQUE 선언방법**\n\n![](brain/image/lecture03-9.png)\n\n\u003cbr\u003e\n\n==**NOT NULL constraint**==\n- attribute가 NOT NULL로 지정되면 해당 attribute는 NULL을 값으로 가질 수 없음\n- 보통 `NOT NULL`과 `UNIQUE`는 같이 많이 선언함\n\t- \u0003왜냐하면, UNIQUE가 NULL의 경우에는 중복을 허용할 수 있기 때문에, attribute가 NULL을 허용하지 않아도 되는 조건이라면 이렇게 많이 씀\n\n![](brain/image/lecture03-10.png)\n\n\u003cbr\u003e\n\n**NOT NULL 선언방법**\n\n![](brain/image/lecture03-11.png)\n\n\u003cbr\u003e\n\n==**CHECK constraint**==\n- attribute의 값을 제한하고 싶을 때 사용\n\n![](brain/image/lecture03-16.png)\n\n\u003cbr\u003e\n\n**CHECK 선언방법**\n\n![](brain/image/lecture03-17.png)\n\n\u003cbr\u003e\n\n==**Referential integrity constraint : FOREIGN KEY**==\n- 참조 무결성 제약조건\n- attribute(s)가 다른 table의 primary key나 unique key를 참조할 때 사용\n\n![](brain/image/lecture03-18.png)\n\n\u003cbr\u003e\n\n**FOREIGN KEY 선언방법**\n\n![](brain/image/lecture03-19.png)\n\n1. FOREIGN KEY로 설정할 attribute 이름\n2. 어떤 테이블을 참조하는지, 테이블의 어떤 attribute 참조하는지\n3. 참조하고 있는 값이 삭제되거나 업데이트 될 때 FOREIGN KEY value를 어떻게 할 지 옵션\n\t- MySQL에서는 **CASCADE, SET NULL, RESTRICT** 3개가 있다고 이해하자\n\t- PostgreSQL에서는 5가지 전부 제대로 지원함\n\n\u003cbr\u003e\n\n- **CASCADE**\n\n![](brain/image/lecture03-20.png)\n\n- **SET NULL**\n\n![](brain/image/lecture03-21.png)\n\n- **RESTRICT** : 참조하고 있는애 있느면 수정 불가\n\n![](brain/image/lecture03-22.png)\n\n- **NO ACTION**\n\t- MySQL에서는 RESTRICT와 NO ACTION이 동일\n\t- SQL 표준 스펙에서는 거의 유사\n\t\t- SQL에서 NO ACTION은 한 트랜잭션 내의 여러 SQL이 실행되는 동안에는 참조값이 변경/삭제 되는 것은 허용하지만, 트랜잭션이 끝났을 때도 여전히 \u0008참조 무결성 제약을 위반하고 있다면 이것은 금지한다는 의미\n\n- **SET DEFAULT**\n\t- MySQL은 SET DEFAULT를 잘 지원하지 않음\n\n![](brain/image/lecture03-23.png)\n\n\u003cbr\u003e\n\n### 제약조건 이름 명시\n\n==**constraint 이름 명시하기**==\n- 이름을 붙이면 어떤 constraint를 위반했는지 쉽게 파악할 수 있음\n- constraint를 삭제하고 싶을 때 해당 이름으로 삭제 가능\n\n![](brain/image/lecture03-24.png)\n\n- `test_chk_1`이 무엇을 의미하는지 알고싶으면 MySQL에서는 `show create table 테이블명;`라고 하면 결과로 나오는 화면에서 알 수 있다.\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 예제\n\nIT 회사 관련 RDB를 만들어보자.\n- 부서, 사원, 프로젝트 관련 정보들을 저장할 수 있는 관계형 데이터베이스를 만들자\n- 사용할 RDBMS는 MySQL (InnoDB)\n\t- MySQL은 여러 DB 엔진을 제공하는데, 가장 많이 사용하는 InnoDB를 기준으로 설명\n\n### 실습\n\n![](brain/image/lecture03-1.png)\n\n- Data model을 바탕으로 DB의 구조를 기술했음 -\u003e 스키마 만들었다는 거\n\n\u003cbr\u003e\n\n![](brain/image/lecture03-12.png)\n\n![](brain/image/lecture03-13.png)\n\n![](brain/image/lecture03-25.png)\n\n![](brain/image/lecture03-26.png)\n\nDEPARTMENT 테이블 만들 당시에는 `leader_id`에 대한 FOREIGN KEY 지정을 못했었는데, 이제 생겼으니 한번 수정해보자.\n\n![](brain/image/lecture03-27.png)","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture04":{"title":"04. Data 추가/수정/삭제","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 데이터 다루기\n\n[이전 강의](brain/Lecture/db/easy-db/lecture03.md)에서 DB를 만들었으니 이제 다뤄보자.\n\n\u003cbr\u003e\n\n### 데이터 추가\n\n\u003cbr\u003e\n\n![](brain/image/lecture04-6.png)\n\n\u003cbr\u003e\n\n```sql\nINSERT INTO 테이블명 VALUES (값1, 값2, 값3, ...);\n```\n\n- 테이블을 정의할 때 attribute의 순서대로 데이터를 넣어줘야 함\n- 테이블에 정의된 모든 attribute에 값을 넣어야 함\n\t- null이 허용되어있으면 임시로 null이라도 넣어야 함\n\n\u003cbr\u003e\n\n```sql\nINSERT INTO 테이블명 VALUES (속성이름1, 속성이름2, ...) INTO ('값1', '값2', ... );\n```\n\n- 테이블에 값을 넣는 attribute의 순서에 자유도가 생겼음\n- 넣고 싶은 attribute에만 값을 넣을 수 있음\n\t- 빈 곳에는 DEFAULT값이 있으면 DEFAULT, 없으면 NULL이 들어감\n\n\u003cbr\u003e\n\n```sql\nINSERT INTO 테이블명 VALUES (값1, 값2, 값3, ...), (값1, 값2, 값3, ...), ...;\n```\n\n- 위 두개는 한 번에 하나의 데이터(튜플)을 넣는 것인데 이거는 한 번에 여러 데이터를 넣는것\n\n![](brain/image/lecture04-7.png)\n\n\u003cbr\u003e\n\n**데이터 조회 맛보기**\n\n```sql\nSELECT 속성 FROM 테이블명;\nSELECT * FROM 테이블명;\n테이블명에 있는거 전부 가져오기\n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 데이터 수정\n\n\u003cbr\u003e\n\n```sql\nUPDATE 테이블명 \nSET 속성1 = 값1 \n[WHERE 조건];\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 개발팀 (dept_id가 1003)의 연봉을 2배 인상하려고 한다면?**\n\n```sql\nUPDATE employee\nSET salary = salary * 2\nWHERE dept_id = 1003;\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 프로젝트 ID 2003에 참여한 임직원의 연봉을 2배 인상하려고 한다면?**\n\n![](brain/image/lecture04-8.png)\n\n```sql\nUPDATE employee, works_on\nSET salary = salary * 2;\nWHERE id = empl_id and proj_id = 2003;\n```\n\n- `id = empl_id` 부분이 두 `employee`와 `works_on` 테이블을 연결시키는 부분\n\n\u003cbr\u003e\n\n```sql\nUPDATE employee, works_on\nSET salary = salary * 2;\nWHERE employee.id = works_on.empl_id and works_on.proj_id = 2003;\n```\n\n- 근데 직관적이지 않아서 `테이블명.속성`의 형태로 바꿔줬음\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 데이터 삭제\n\n\u003cbr\u003e\n\n```sql\nDELETE FROM 테이블명\n[WHERE 조건];\n```\n\n- WHERE 절이 없으면 테이블의 모~든 튜플이 사라지는거라서 주의하자.\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) John이 퇴사해서 employee 테이블에서 John 정보 삭제해야함**\n- John의 employee ID = 8, 현재 John은 project 2001에 참여 중\n\n\u003cbr\u003e\n\n![](brain/image/lecture04-9.png)\n\n```sql\nDELETE FROM employee WHERE id = 8;\n```\n\n- 그렇다면 `WORKS_ON` 테이블에서도 따로 지워야할까?\n\n\u003cbr\u003e\n\n![](brain/image/lecture04-10.png)\n\n- `WORKS_ON` 테이블의 설정이 CASCADE로 되어있어서 `employee` 테이블만 지워도 반영됨\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) Dingyo가 두 개의 프로젝트 참여 중인데 하나에서 빠지기로 했으면?**\n\n```sql\nDELETE FROM works_on WHERE impl_id = 5 and proj_id = 2002;\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) Dingyo가 2001 프로젝트만 집중하고 나머지는 다 빠지려면?**\n\n```sql\nDELETE FROM works_on WHERE impl_id = 5 and proj_id \u003c\u003e 2001;\n```\n\n- `\u003c\u003e` 이것은 제외한다는 의미!! , `!=` 이거랑 동일한 표현\n\n\u003chr\u003e\n\n## 예제\n\n### 데이터 추가 오류\n\n![](brain/image/lecture04-2.png)\n\n- PK 중복되니까 에러\u0003발생\n\n![](brain/image/lecture04-3.png)\n\n- CHECK 조건에서 연봉이 5천만원 이상이라고 했었으니까 에러 발생\n\n![](brain/image/lecture04-4.png)\n\n- `SHOW CREATE TABLE 테이블명;`으로 테이블 만들어진거 확인 가능\n\n![](brain/image/lecture04-5.png)\n\n- 아직 FOREIGN KEY가 없는데 `111`로 추가해버렸으니까\n- \u0003`a foreign key constraint falis`는 참조 무결성 제약조건 위배를 의미\n\t- 참조하는 값이 **실제로 그 테이블에 있을 때에만 값을 지정**할 수 있음\n\n","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture05":{"title":"05. Data 조회","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 데이터 조회\n\n### SELECT\n\n\u003cbr\u003e\n\n```sql\nSELECT 속성 FROM 테이블명 [WHERE 조건];\n```\n\n\u003cbr\u003e\n\n```sql\nSELECT name, position FROM employee WHERE id = 9;\n```\n\n- **selection condition : 조건을 명시해주는 것**\n\t- `WHERE id = 9;`\n- **projection condition : 관심있어 하는 속성 리스트**\n\t- `SELECT name, position`\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) project 2002를 리딩(leading)하고 있는 임직원의 ID와 이름과 직군 조회**\n\n![](brain/image/lecture05-1.png)\n\n```sql\nSELECT employee.id, employee.name, position\nFROM project, employee\nWHERE project.id = 2002 and project.leader_id = employee.id;\n```\n\n- **selection condition : 조건을 명시해주는 것**\n\t- `WHERE project.id = 2002 and project.leader_id = employee.id;`\n- **join condition : 테이블을 연결시켜주는 조건**\n\t- `project.leader_id = employee.id;`\n- **projection condition : 관심있어 하는 속성 리스트**\n\t- `SELECT employee.id, employee.name, position`\n\n\u003cbr\u003e\n\n![](brain/image/lecture05-2.png)\n\n- 테이블 이름을 같이 명시해두지 않은 id와 name은 어떤 테이블의 것인지 알 수 없음\n- 그래서 테이블 이름을 반드시 명시해줘야함.\n\n![](brain/image/lecture05-3.png)\n\n- 모호하다는 오류 뜨는거 보이지!?\n\n\u003cbr\u003e\n\n### AS 별칭짓기\n\n==**AS는 테이블이나 attribute에 별칭(alias)을 붙일 때 사용**==\n- AS는 생략 가능\n\n![](brain/image/lecture05-4.png)\n\n![](brain/image/lecture05-5.png)\n\n- 근데, 이렇게 불러오면 SELECT 결과가 `id, name, position` 이렇게 뜰거임\n- 리더의 아이디, 리더의 이름으로 명시해주고 싶다면? AS 사용!\n\n![](brain/image/lecture05-7.png)\n\n![](brain/image/lecture05-8.png)\n\n- AS는 생략 가능!!\n\n\u003cbr\u003e\n\n### DISTINCT\n\n==**DISTINCT는 SELECT 결과에서 중복되는 tuples은 제외하고 싶을 때 사용**==\n\n```sql\nSELECT DISTINCT 속성명 FROM 테이블\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 디자이너들이 참여하고 있는 프로젝트들의 ID와 이름을 알고싶음**\n\n![](brain/image/lecture05-9.png)\n\n- `WORKS_ON` 테이블이 나머지 두 테이블을 연결해주는 연결고리 역할\n\n![](brain/image/lecture05-11.png)\n\n- 근데 결과를 보면 중복이 발생. 이때 DISTINCT 사용!\n\n![](brain/image/lecture05-12.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### LIKE\n\n\u003cbr\u003e\n\n![](brain/image/lecture05-16.png)\n\n==**LIKE는 문자열에 맞는 pattern matching 할 때 사용**==\n- `%`는 0개 이상의 임의의 개수를 가지는 문자를 의미\n\n```sql\n// 속성이 N 문자로 시작\nSELECT 속성명 FROM 테이블명\nWHERE 속성 LIKE 'N%';\n\n// 속성이 N 문자로 끝나는\nSELECT 속성명 FROM 테이블명\nWHERE 속성 LIKE '%N';\n\n// 속성에 N이 들어가는\nSELECT 속성명 FROM 테이블명\nWHERE 속성 LIKE '%N%';\n\n// 속성에 N이 들어가면서 4글자\nSELECT 속성명 FROM 테이블명\nWHERE 속성 LIKE 'N _ _ _';\n```\n\n\u003cbr\u003e\n\n==**escape 문자와 함께 LIKE 쓰고싶으면?**==\n\n- `%`로 시작하거나 `_`로 끝나는 프로젝트 이름을 찾고싶다면?\n- `SELECT name FROM project WHERE name LIKE '\\%%' or name LIKE '%\\_';`\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 이름이 N으로 시작하거나 N으로 끝나는 임직원들의 이름 알고싶음**\n\n![](brain/image/lecture05-13.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 이름에 NG가 들어가는 임직원들의 이름을 알고싶음**\n\n![](brain/image/lecture05-14.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 이름이 J로 시작하는, 총 네 글자의 이름을 가지는 임직원들의 이름 알고싶음**\n\n![](brain/image/lecture05-15.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### asterisk\n\n==**Asterisk(`*`, 애스터리스크)는 선택된 tuples의 모든 attributes를 의미**==\n\n![](brain/image/lecture05-18.png)\n\n\u003cbr\u003e\n\n### 주의사항\n\n1. SELECT로 조회할 때 조건들을 포함해서 조회한다면 ==**이 조건들과 관련된 attributes에 index가 걸려있어야 함**==\n\t- 그렇지 않다면 데이터가 많아질수록 조회 속도가 느려짐\n\t- ex) `SELECT * FROM employee WHERE position = 'dev_back';`\n\t\t- positon에 대해 index가 걸려 있어야 employee 테이블에 데이터가 아무리 많이 있다고 해도 쿼리문의 실행 속도가 느려지지 않고 여전히 빠르게 유지될 것\n2. MySQL 기준으로 작성된거라 다른 RDBMS와 SQL 문법이 조금씩 다를 수 있음","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture06":{"title":"06. 서브쿼리","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## Subquery\n\n### Subquery 기본\n\n- ==**subquery**==(nested query / inner query) : [SELECT](brain/Lecture/db/easy-db/lecture05.md), INSERT, UPDATE, DELETE에 포함된 쿼리\n\t- subquery는 `()`안에 기술됨\n- ==**outer query**==(main query) : subquery를 포함하는 쿼리\n- 서브쿼리는 WHERE 절에 있을 수도, FROM 절에 있을 수도 있다\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) ID가 14인 임직원보다 생일이 빠른 임직원의 ID, 이름, 생일 알고싶음**\n\n![](brain/image/lecture06-1.png)\n\n- 이렇게 쿼리 두번 써서 나타내지말고 한 번에 나타낼 수 없나?\n\n![](brain/image/lecture06-2.png)\n\n- 이렇게 쏙 넣어버렸음\n- subquery\n\t- `()` 안에 있는 `(SELECT birth_date FROM employee WHERE id = 14)`\n- outer query\n\t- `SELECT id, name, birth_date FROM employee WHERE birth_date`\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) ID가 1인 임직원과 같은 부서 성별인 임직원들의 ID와 이름과 직군**\n\n![](brain/image/lecture06-3.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) ID가 5인 임직원과 같은 프로젝트에 참여한 임직원들의 ID**\n\n- 서브쿼리가 안떠오르면 일단 두 파트로 나눠서 생각!\n\t- ID가 5인 임직원과 같은 프로젝트\n\t- 참여한 임직원 ID\n\n![](brain/image/lecture06-4.png)\n- ID가 5인 임직원 본인 자체는 제외한 것\n- DISTINCT는 두 프로젝트에 모두 참가했을 수도 있으니까 제거해준 것\n- 근데 OR라고 이렇게 써주면 귀찮잖아?\n\n![](brain/image/lecture06-5.png)\n- `IN` 이라는 키워드를 사용했음\n\n![](brain/image/lecture06-6.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### IN - OR 같은 녀석\n\n- ==**v IN (v1, v2, v3, ...)**== : v가 (v1, v2, v3, ...) 중에 하나와 같이 같다면 TRUE를 return\n\t- (v1, v2, v3, ...)는 명시적인 값들의 집합일 수 있음\n\t- (v1, v2, v3, ...)는 subquery의 결과(set or multiset)일 수 있음\n\t\t- set은 중복 허용 O, multiset은 중복 허용 X\n- ==**v NOT IN (v1, v2, v3, ...)**== : v가 (v1, v2, v3, ..)의 모든 값과 값이 다르다믄 TRUE를 return\n- IN은 EXISTS와 서로 바꿔가며 사용 가능\n\n\u003cbr\u003e\n\n==**unqualified attribute가 참조하는 table**==\n- 해당 attribute가 사용된 query를 포함하여 그 query의 바깥 쪽으로 존재하는 모든 queries 중에 해당 attribute 이름을 가지는 **가장 가까이에 있는 table을 참조**\n\n![](brain/image/lecture06-7.png)\n\n![](brain/image/lecture06-8.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) ID가 5인 임직원과 같은 프로젝트에 참여한 임직원들의 ID와 이름**\n\n![](brain/image/lecture06-10.png)\n\n- `works_on` 테이블에는 이름이 없으니까 이것만으로는 불가능\n- `employee` 테이블을 참조해야함\n- `WHERE` 절에 서브쿼리를 넣은 것\n\n![](brain/image/lecture06-11.png)\n\n- `FROM` 절에 서브쿼리를 넣은 것\n- 그래서 `employee` 실제 테이블 , `DSTNCT_E` 가상 테이블 2개의 테이블이 있는 것\n- WHERE 절은 `employee 테이블의 id`와 `DSTNCT_E 가상 테이블의 empl_id`를 join condition으로 엮어준 것\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### EXISTS 존재여부\n\n- ==**correlated query**== : subquery가 바깥쪽 query의 attribute를 참조할 때, correlated subquery라 부름\n- ==**EXISTS**== : subquery의 결과가 최소 하나의 row라도 있다면 TRUE 반환\n- ==**NOT EXISTS**== : subquery의 결과가 단 하나의 row도 없다면 TRUE 반환\n- EXISTS는 IN과 서로 바꿔가며 사용 가능\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) ID가 7 혹은 12인 임직원이 참여한 프로젝트 ID와 이름**\n\n![](brain/image/lecture06-12.png)\n\n- `SELECT P.id, P.name FROM project P`\n\t- project 테이블의 row에 대해서 하나하나씩 확인\n\n![](brain/image/lecture06-13.png)\n\n```sql\nWHERE EXISTS (\n\tSELECT * \n\tFROM works_on W\n\tWHERE W.proj_id = P.id AND W.empl_id IN (7, 12)\n\t);\n```\n\n- `works_on` 테이블의 id와 바깥에 있는 `project` 테이블의 id인 `P.id`와 같은지 확인\n\t- 바깥쪽 쿼리의 속성을 참조하니까 이것이 **correlated subquery**\n- 동시에 그 `works_on` 테이블의 `empl_id`가 7 혹은 12인 것을 찾는 것\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) EXISTS를 IN으로 바꿔보면?**\n\n![](brain/image/lecture06-14.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 2000년대생이 없는 부서의 ID와 이름**\n\n![](brain/image/lecture06-15.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) NOT EXISTS를 NOT IN으로 바꿔보면?**\n\n![](brain/image/lecture06-16.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**성능 비교 : IN vs EXISTS**==\n- RDBMS의 종류와 버전에 따라 다르며, 최근 버전은 많은 개선이 이루어져서 IN과 EXISTS의 성능 차이가 거의 없는 것으로 알려짐\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### ANY 서브쿼리 단 하나라도\n\n- ==**v comparison_operator ANY (subquery)**== : subquery가 반환한 결과들 중에 단 하나라도 v와의 비교 연산이 TRUE라면 TRUE를 반환\n- ==**SOME**==도 ==**ANY**==와 같은 역할\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 리더보다 높은 연봉을 받는 부서원을 가진 리더의 ID와 이름과 연봉**\n\n![](brain/image/lecture06-18.png)\n\n- 부서의 리더인지 아닌지 여부는 `department` 테이블을 참조해야만 알 수 있음\n- 서브쿼리\n\t- 리더와 같은 부서에 있는 임직원 찾아야함 `dept_id = E.dept_id`\n\t\t- 바깥쪽 쿼리의 조건에 의해 `E.dept_id`가 리더의 id임\n\t- `id \u003c\u003e D.leader_id`\n\t\t- 리더 외의 부서원이라는 뜻, `!=`로 해도 무방\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 리더보다 높은 연봉을 받는 부서원을 가진 리더의 ID와 이름과 연봉과 해당 부서 최고 연봉**\n\n![](brain/image/lecture06-19.png)\n\n![](brain/image/lecture06-20.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### ALL 모두\n\n- ==**v comparison_operator ALL (subquery)**== : subquery가 반환한 결과들과 v와의 비교 연산이 모두 TRUE라면 TRUE 반환\n\n\u003cbr\u003e\n\n**ex) ID가 13인 임직원과 한 번도 같은 프로젝트에 참여하지 못한 임직원들의 ID, 이름, 직군**\n\n![](brain/image/lecture06-21.png)\n\n\u003cbr\u003e","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture07":{"title":"07. three-valued logic","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## three-valued logic\n\n### NULL의 의미\n\n==**SQL에서 NULL의 의미**== : SQL [조회](brain/Lecture/db/easy-db/lecture05.md)에서는 다양한 의미를 하나의 NULL로 표시\n\n- unknown\n\t- 알려지지 않음\n\t- ex) 누군가의 생일이 NULL이라고 하면 생일은 무조건 있을테니 아직 알려지지 않음을 의미\n- unavailable or withheld\n\t- 공개하지 않음, 이용 불가능함\n\t- ex) 민감한 개인 정보라서 공개하지 않아서 이용 못함\n- not applicable\n\t- 해당사항 없음\n\t- ex) 집전화가 없는 경우\n\n![](brain/image/lecture07-1.png)\n\n![](brain/image/lecture07-2.png)\n\n- id가 14와 15인 아이의 생일이 같다고 할 수 있을까?\n\t- NULL은 여러 의미가 있어서 같은지 다른지 단정할 수 없다.\n\t- 그래서 아무것도 가지고 오지 않는다.\n\t- 생일이 NULL인게 아무것도 없다는 말이 아니다!!\n- 따라서, NULL과 비교하기를 원할 때는 동등 연산자를 사용하면 안된다.\n\n\u003cbr\u003e\n\n### IS\n\n==**IS**==\n- NULL인지 비교할 때 사용하는 비교 연산자\n- NULL이 아닌 녀석을 찾으려면 ==**IS NOT**== 사용\n\n![](brain/image/lecture07-3.png)\n\n\u003cbr\u003e\n\n### NULL과 three-valued\n\n- NULL과 비교했을 때 결과가 어떻게 될까?\n- 어느 한쪽에 NULL이 있다면 결과는 무조건 UNKNOWN\n\t- 이건 \u003ca href=/brain/Lecture/easycode/db/lecture07/#unknown-연산결과\u003e아래\u003c/a\u003e에서 확인\n\n\u003cbr\u003e\n\n==**NULL과 SQL three-valued logic**==\n\n![](brain/image/lecture07-5.png)\n\n- SQL에서 NULL과 비교 연산을 하게 되면 그 결과는 ==**UNKNOWN**==이다.\n- ==**UNKNOWN**==은 \"TRUE 일 수도 있고 FALSE 일 수도 있다\"는 의미\n- ==**three-valued logic**== : 비교/논리 연산의 결과로 ==**TRUE, FALSE, UNKNOWN**==을 가짐\n\n\u003cbr\u003e\n\n![](brain/image/lecture07-4.png)\n\n- NULL이 1990년 3월 9일과 같은지 아닌지는 모르는 상태이다.\n- 그래서 id가 14, 15인 녀석의 결과는 UNKNOWN이다.\n\n\u003cbr\u003e\n\n### UNKNOWN 연산결과\n\n==**AND, OR, NOT은 어떻게 되나?**==\n\n![](brain/image/lecture07-6.png)\n\n- AND\n\t- TRUE + UNKNOWN = UNKNOWN (TRUE 일 수도, FALSE 일 수도 있으니까)\n\t- FALSE + UNKNOWN = FALSE (무조건 FALSE 이니까)\n\t- UNKNOWN + UNKNOWN = UNKNOWN (UNKNOWN 일 수도, FALSE 일 수도 있으니까)\u0004\n- OR\n\t- TRUE + UNKNOWN = TRUE\n\t- FALSE + UNKNOWN = UNKNOWN\n\t- UNKNOWN + UNKNOWN = UNKNOWN\n- NOT\n\t- UNKNOWN의 NOT은 TRUE 일 수도 FALSE 일 수도 = UNKNOWN\n\n\u003cbr\u003e\n\n==**왜 이 결과가 중요할까?**==\n- **WHERE 절에 있는 condition(s)의 결과가 TRUE인 tuple(s)만 선택**된다.\n- 즉, **결과가 FALSE거나 UNKNOWN이면 tuple은 선택되지 않는다.**\n\n\u003cbr\u003e\n\n### NOT IN 주의사항\n\n==**NOT IN 사용 시 주의사항**==\n- ==**v NOT IN (v1, v2, v3)**==는 아래와 같은 의미이다.\n\t- `v != v1 AND v != v2 AND v != v3`\n- 그렇다면, 만약 v1, v2, v3 중 하나가 NULL이라면?\n\n\u003cbr\u003e\n\n![](brain/image/lecture07-7.png)\n- 마지막을 살펴보자.\n- `3 != 1 AND 3 != 2 AND 3 != NULL`\n- `TRUE and TRUE and UNKNOWN = UNKNOWN`\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 2000년대 생이 없는 부서의 ID와 이름**\n\n![](brain/image/lecture07-9.png)\n\n- 공교롭게도 아직 부서를 배치받지 않아 부서의 id에 NULL이 있다면?\n- `D.id`가 어떤 값이라고 할지라도 무조건 FALSE 아니면 UNKNOWN이다.\n- WHERE 절은 TRUE인 경우에만 tuple을 선택한다고 했는데 어떤 경우에도 TRUE가 절대로 나올 수 없으니까 SELECT 문이 반환하는 결과는 아무것도 없음.\n\n\u003cbr\u003e\n\n==**이 문제를 해결하는 방법**==\n\n1. 애초에 `employee` 테이블에서 `dept_id`가 NULL을 가지지 못하게 NOT NULL 처리\n\n2. 서브쿼리에서 `dept_id`가 NOT NULL인 경우 체크\n\n![](brain/image/lecture07-10.png)\n\n3. `NOT IN`을 `NOT EXISTS`로 바꿔서 처리\n\n![](brain/image/lecture07-11.png)\n\n","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture08":{"title":"08. Join","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## Join\n\n\u003cbr\u003e\n\n==**SQL에게 JOIN이란?**==\n- 두 개 이상의 table들에 있는 데이터를 한 번에 [조회](brain/Lecture/db/easy-db/lecture05.md)하는 것\n- 여러 종류의 JOIN 존재\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) ID가 1인 임직원이 속한 부서 이름은?**\n\n![](brain/image/lecture08-1.png)\n\n- `employee` 테이블 만으로는 알 수 없어서 `department` 테이블와 연결해야함\n- 이걸 join이라고 함\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### Implict vs Explicit\n\n\u003cbr\u003e\n\n==**Implicit join (암시적 조인)**==\n\n```sql\nSELECT D.name\nFROM employee AS E, department AS D\nWHERE E.id = 1 and E.dept_id = D.id;\n```\n\n- **from 절에는 table 들만 나열하고 where 절에 join condition을 명시하는 방식**\n- old-style join syntax\n- where 절에 select condition과 join condition이 같이 있기 때문에 가독성 떨어짐\n- 복잡한 join 쿼리를 작성하다 보면 실수로 잘못된 쿼리를 작성할 가능성이 큼\n\n\u003cbr\u003e\u003cbr\u003e\n\n==**Explicit join (명시적 조인)**==\n\n```sql\nSELECT D.name\nFROM employee AS E JOIN department AS D ON E.dept_id = D.id;\nWHERE E.id = 1;\n```\n\n- from 절에 ==**JOIN**== 키워드와 함께 joined table 들을 명시하는 방식\n- from 절에 ==**ON**== 뒤에 join condition이 명시\n\t- `employee` 테이블이 `department` 테이블에 조인한다.\n\t- 어떤 조건으로? `E.dept_id = D.id`인 조건으로!\n- 가독성이 좋음\n- 복잡한 join 쿼리 작성 중에도 실수할 가능성이 적음\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### Inner join\n\n\u003cbr\u003e\n\n==**Inner join (내부 조인)**== : **두 table에서 join condition을 만족하는 tuple 들로 result table을 만드는 join**\n\n![](brain/image/lecture08-4.png)\n\n```sql\n// INNER 생략 가능, 그냥 join이라고 하면 inner join임\n// ON 없으면 cross join이다. 주의하자\n\nFROM table1 [INNER] JOIN table2 ON join_condition\n```\n\n- join condition에 사용 가능한 연산자(operator) : `=, \u003c, \u003e, !=` 등등 여러 비교 연산자 가능\n- join condition에서 **null 값을 가지는 tuple은 result table에 포함되지 못함**\n\n\u003cbr\u003e\n\n**ex) INNER JOIN**\n\n![](brain/image/lecture08-2.png)\n\n![](brain/image/lecture08-3.png)\n\n- 매칭이 안된 `employee` 테이블의 SIMON과 `department` 테이블의 1002는 매칭이 안돼서 `join 된 테이블`의 결과에 없음\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### Outer join\n\n==**Outer join (외부 조인)**== : **두 table에서 join condition을 만족하지 않는 tuple 들도 result table에 포함하는 join**\n\n![](brain/image/lecture08-5.png)\n\n```sql\n// OUTER 생략 가능\nFROM table1 LEFT [OUTER] JOIN table2 ON join_condition\nFROM table1 RIGHT [OUTER] JOIN table2 ON join_condition\nFROM table1 FULL [OUTER] JOIN table2 ON join_condition\n```\n\n- join condition에 사용 가능한 연산자(operator) : `=, \u003c, \u003e, !=` 등등 여러 비교 연산자 가능\n- MySQL은 FULL OUTER JOIN 지원 x\n\t- LEFT JOIN과 RIGHT JOIN을 UNION해서 사용해야함\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) LEFT OUTER JOIN**\n\n![](brain/image/lecture08-6.png)\n\n![](brain/image/lecture08-7.png)\n\n- LEFT인 `employee` 테이블에서 join condition을 만족하지 않는 튜플들도 함께 포함시킴\n\t- 그래서 `joined table`에 SIMON이 포함되어있음\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) RIGHT OUTER JOIN**\n\n![](brain/image/lecture08-8.png)\n\n![](brain/image/lecture08-9.png)\n\n- RIGHT인 `department` 테이블에서 join condition을 만족시키지 않는 튜플들도 함께 포함시킴\n\t- 그래서 `joined table`에 HR이 포함되어있음\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) FULL OUTER JOIN**\n- MySQL이 FULL OUTER JOIN 지원 안해서 PostgreSQL로 했음\n\n![](brain/image/lecture08-10.png)\n\n![](brain/image/lecture08-11.png)\n\n- `joined table`에 SIMON, HR 다 있음\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### equi join\n\n- join condition에서 `=` (equality comparator)를 사용하는 join\n\n![](brain/image/lecture08-12.png)\n\n- 1번째는 INNER JOIN 이면서도 equi join\n- 2~4번째는 OUTER JOIN 이면서도 equi join\n\n\u003cbr\u003e\n\n==**equi join에 대한 두 가지 시각**==\n- inner join, outer join 상관없이 `=`를 사용한 join이라면 equi join으로 보는 경우\n- inner join으로 한정해서 `=`를 사용한 경우에 equi join으로 보는 경우\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### using\n\n\u003cbr\u003e\n\n==**USING**== : **두 table이 equi join 할 때 join 하는 attribute의 이름이 같다면, USING으로 간단하게 작성 가능** \n\n```sql\nFROM table1 [INNER] JOIN table2 USING (attributes)\nFROM table1 LEFT [OUTER] JOIN table2 USING (attributes)\nFROM table1 RIGHT [OUTER] JOIN table2 USING (attributes)\nFROM table1 FULL [OUTER] JOIN table2 USING (attributes)\n```\n\n- 같은 이름의 attribute는 result table에서 한 번만 표시됨\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) JOIN 하는 테이블끼리 속성명이 동일한 경우 - USING 사용 X**\n\n![](brain/image/lecture08-13.png)\n\n- 속성명도 동일, 결과값도 동일한데 이렇게 적을 필요가 있나? -\u003e USING 써보자\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) JOIN 하는 테이블끼리 속성명이 동일한 경우 - USING 사용 O**\n\n![](brain/image/lecture08-14.png)\n\n- USING으로 묶은건 맨 앞으로 빠진다.\n\t- 아마 둘 중 어느 테이블에도 속해있지 않은 속성이라고 구분하는 느낌같음\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### natural join\n\n\u003cbr\u003e\n\n==**NATURAL JOIN (자연 조인)**== : **두 table에서 같은 이름을 가지는 모든 attribute pair에 대해서 equi join을 수행**\n\n```sql\nFROM table1 NATURAL [INNER] JOIN table2\nFROM table1 NATURAL LEFT [OUTER] JOIN table2\nFROM table1 NATURAL RIGHT [OUTER] JOIN table2\nFROM table1 NATURAL FULL [OUTER] JOIN table2\n```\n\n- join condition을 따로 명시하지 않음\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) NATURAL INNER JOIN - 같은 속성 1개**\n\n![](brain/image/lecture08-15.png)\n\n![](brain/image/lecture08-16.png)\n\n- 두 테이블에서 같은 attribute인 `dept_id`가 equi join 되었음\n- INNER JOIN이니까 SIMON이나 HR이 보이지 않음\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) NATURAL INNER JOIN - 같은 속성 여러개**\n\n![](brain/image/lecture08-17.png)\n\n![](brain/image/lecture08-18.png)\n\n- NATURAL INNER JOIN -\u003e USING -\u003e ON 이렇게 바꿔도 모두 동일한 표현\n- 근데, 결과가 Empty set이다. 왜 그런지 한번 보도록 하자.\n\n```sql\n// 자연 내부 조인\nSELECT * FROM employee E\nNATURAL INNER JOIN department D;\n\n// 내부조인 + USING 사용\nSELECT * FROM employee E\nINNER JOIN department D\nUSING (dept_id, name);\n\n// 내부조인 + ON 사용 (기본)\nSELECT * FROM employee E\nINNER JOIN department D\nON E.dept_id = D.dept_id\nAND E.name = D.name;\n```\n\n- `E.dept_id = D.dept_id` 부서 이름은 같을 수 있음\n- `E.name = D.name` 사람 이름과 부서 이름이 같을 일은 거~의 없겠네\n\t- \u0003그래서 아무런 결과를 반환하지 못할 것\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### cross join\n\n==**CROSS JOIN (상호 조인)**== : **두 table의 tuple pair로 만들 수 있는 모든 조합( = 카테시안 곱, Cartesian product)을 result table로 반환**\n\n![](brain/image/lecture08-19.png)\n\n```sql\n// implicit cross join\nFROM table1, table2\n\n// explicit cross join\nFROM table1 CROSS JOIN table2\n```\n\n- join condition이 따로 없음\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) explicit CROSS JOIN**\n\n![](brain/image/lecture08-20.png)\n\n![](brain/image/lecture08-21.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) implicit CROSS JOIN**\n\n![](brain/image/lecture08-22.png)\n\n- explicit와 동일한 결과 나옴\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### MySQL Join\n\n1. MySQL에서는 ==**FULL OUTER JOIN**==을 지원하지 않는다.\n\t- LEFT JOIN과 RIGHT JOIN을 UNION해서 사용해야함\n\n2. MySQL에서는 **`cross join = inner join = join`** 이다.\n\t- 원래는 **cross join**에 join condition이 따로 없으니까 `ON or USING`을 쓰면 안되는데 MySQL에서는 된다.\n\t- **cross join**에 `ON or USING`을 같이 쓰면 **inner join**으로 동작함\n\t- **inner join (or join)** 이 `ON or USING` 없이 사용된다면 **cross join**으로 동작함\n\n\u003cbr\u003e\n\n\u003e 정리하자면, \u003cbr\u003e\n\u003e ON (or USING) 같이 쓰면 -\u003e **INNER JOIN ( = JOIN)** \u003cbr\u003e\n\u003e ON (or USING) 안쓰면 -\u003e **CROSS JOIN**\n\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### self join\n\n==**SELF JOIN (자체 조인)**== : **table이 자기 자신에게 join 하는 경우**\n\n![](brain/image/lecture08-23.png)\n\n```sql\nFROM table1 INNER JOIN table1\n```\n\n- 별도의 문법이 있는 것은 아니고 1개로 조인하면 자체 조인이 됨\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 예제\n\n**ex) ID가 1003인 부서에 속하는 임직원 중 리더를 제외한 부서원의 ID, 이름, 연봉**\n\n![](brain/image/lecture08-24.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) ID가 2001인 프로젝트에 참여한 임직원들의 이름과 직군과 소속 부서 이름**\n\n![](brain/image/lecture08-25.png)\n\n- FROM 절\n\t- `works_on` 테이블을 `employee` 테이블에 **내부 조인** 걸었음\n\t\t- \u0003어떤 프로젝트에 어떤 임직원이 참여했는지 정보 + 임직원의 정보\n\t- `result` 테이블에서 `department` 테이블로 **왼쪽 외부 조인** 걸었음\n\t\t- 소속부서의 이름을 알아내야 하기 때문에 !\n\t\t- left join인 이유는 `E.dept_id = D.id` join condition 때문에 그럼\n\t\t\t- 혹시나 임직원이 부서 배정 전이라 null 일 경우를 대비\n- WHERE 절\n\t- id가 2001인 프로젝트니까 !","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture09":{"title":"09. 통계함수","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 정렬\n\n### ORDER BY\n\n==**ORDER BY : 조회 결과를 특정 attribute(s) 기준으로 정렬하여 가져올 때 사용**==\n- default 정렬 방식은 오름차순\n- 오름차순 정렬은 **ASC**\n- 내림차순 정렬은 **DESC**\n\n\u003cbr\u003e\n\n**ex) 임직원들의 정보를 연봉 순서대로 정렬해서 알고싶음 - 오름차순**\n\n![](brain/image/lecture09-1.png)\n\n\u003cbr\u003e\n\n**ex) 임직원들의 정보를 연봉 순서대로 정렬해서 알고싶음 - 내림차순**\n\n![](brain/image/lecture09-2.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 임직원들의 정보를 같은 부서 안에서 연봉 순서대로 정렬해서 알고싶음**\n\n![](brain/image/lecture09-4.png)\n\n- 앞에 적힌 `dept_id`로 먼저 정렬\n\t- MySQL에서는 NULL을 가장 작게 인식해서 먼저 나옴\n- 부서 내에서 연봉 순서대로 정렬됨\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 집계\n\n==**집계 함수 (Aggregate function) : 여러 tuple 들의 정보를 요약해서 하나의 값으로 추출하는 함수**==\n\n- 대표적으로 **COUNT, SUM, MAX, MIN, AVG** 함수\n- (주로) 관심있는 attribute에 사용\n\t- ex) `AVG(salary)` , `MAX(birth_date)`\n- **NULL 값들을 제외하고 요약 값 추출**\n\n\u003cbr\u003e\u003cbr\u003e\n\n### COUNT\n\n==**COUNT로 수를 셀 때는 애스터리스크(`*`)를 사용하는 것을 추천**==\n\n\u003cbr\u003e\n\n**ex) 임직원의 수를 알고싶음**\n\n![](brain/image/lecture09-5.png)\n\n- 애스터리스크(`*`)는 튜플의 수를 의미\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 포지션을 가지는 임직원의 수를 알고싶음**\n\n![](brain/image/lecture09-6.png)\n\n- 결과가 위와 동일한 것을 볼 수 있음\n- attribute의 값에 중복이 있다고 하더라도 **중복을 포함해서 COUNT함**\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 부서를 가지는 임직원의 수를 알고싶음**\n\n![](brain/image/lecture09-7.png)\n\n- NULL을 제외하고 중복을 포함하여 나머지 COUNT\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 프로젝트 2002에 참여한 임직원의 수와 최대 연봉과 최소 연봉과 평균 연봉을 알고싶음**\n\n![](brain/image/lecture09-8.png)\n\n- `works_on` 테이블은 누가 어떤 프로젝트에 참여했는지에 대한 정보가 있으니까 참조해야함\n- `employee` 테이블은 연봉 정보가 있으니까 참조해야함\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 그룹\n\n### GROUP BY\n\n==**GROUP BY : 관심있는 attribute(s) 기준으로 그룹을 나눠서 그룹별로 aggregate function을 적용하고 싶을 때 사용**==\n- grouping attribute(s) : 그룹을 나누는 기준이 되는 attribute(s)\n- grouping attribute(s)에 **NULL 값이 있을 때는 NULL 값을 가지는 tuple끼리 묶임**\n- 그룹을 기준으로 했으면 SELECT에 그 그룹 가져와야지 !\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 각 프로젝트에 참여한 임직원의 수와 최대 연봉과 최소 연봉과 평균 연봉을 알고싶음**\n\n![](brain/image/lecture09-9.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n### HAVING\n\n==**HAVING : aggregate function의 결과값을 바탕으로 그룹을 필터링하고 싶을 때 사용**==\n- GROUP BY와 함께 사용\n- HAVING 절에 명시된 조건을 만족하는 그룹만 결과에 포함됨\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 프로젝트 참여 인원이 7명 이상인 프로젝트들에 대하여 각 프로젝트에 참여한 임직원의 수와 최대 연봉과 최소 연봉과 평균 연봉을 알고싶음**\u0004\n\n![](brain/image/lecture09-10.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 예제\n\n**ex) 각 부서별 인원 수를 인원 수가 많은 순서대로 정렬해서 알고싶음**\n\n![](brain/image/lecture09-11.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 각 부서별 - 성별 인원 수를 인원 수가 많은 순서대로 정렬해서 알고싶음**\n\n![](brain/image/lecture09-12.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 회사 전체 평균 연봉보다 평균 연봉이 적은 부서들의 평균 연봉을 알고싶음**\u0004\n\n![](brain/image/lecture09-13.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 각 프로젝트 별로 프로젝트에 참여한 90년대생들의 수와 이들의 평균 연봉을 알고싶음**\n\n![](brain/image/lecture09-14.png)\n- `ROUND()`는 소숫점 이하 반올림\n\n![](brain/image/lecture09-15.png)\n- 이 결과를 `proj_id` 기준으로 정렬한 것\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 프로젝트 참여 인원이 7명 이상인 프로젝트에 한정해서 각 프로젝트 별로 프로젝트에 참여한 90년대생들의 수와 이들의 평균을 알고싶음**\n\n- 내가 걸어주려는 조건이 어떤 조건인지에 따라 WHERE 절에 명시할건지, HAVING절에 조건을 명시할 건지 파악해야함\n\n![](brain/image/lecture09-16.png)\n\n![](brain/image/lecture09-17.png)\n\n\u003cbr\u003e\n\n**만약 위 예제에서 HAVING절에 조건을 걸었다면?**\n\n![](brain/image/lecture09-19.png)\n\n- HAVING절에 사용된 COUNT는 그룹핑을 한 뒤에 그 그룹에 대해 카운트를 한 값이다.\n\t- 이 COUNT의 의미는 각 부서별로 90년대생에 대한 카운트이다.\n\t- 각 부서별 90년대 생에 대한 참여를 카운트 한 것\n\n\u003cbr\u003e\u003cbr\u003e\n\n### SELECT 최종 정리\n\n==**SELECT 조회 요약**==\n\n```sql\nSELECT 속성(들) 혹은 집계함수(들)\nFROM 테이블(들)\n[WHERE 조건(들)]\n[GROUP BY 그룹속성(들)]\n[HAVING 그룹속성(들)]\n[ORDER BY 속성(들)];\n```\n\n\u003cbr\u003e\n\n==**SELECT 개념적인 실행 순서**==\n- [select](brain/Lecture/db/easy-db/lecture05.md) 쿼리에서 각 절(phase)의 실행 순서는 **개념적인 순서**이다.\n- select 쿼리의 실제 실행 순서는 각 RDBMS에서 어떻게 구현했는지에 따라 다름\n\n1. **FROM** : 어떤 테이블로부터 조회할 것인지 혹은 join이 된 테이블들\n2. **WHERE** : 가지고 오는 튜플들에 대해서 조건을 통해 필터링 해야한다면\n3. **GROUP BY** : 그룹핑을 하고싶다면\n4. **HAVING** : 그룹핑 이후 특정 그룹만 필터링 해서 가지고 오고싶다면\n5. **ORDER BY** : 최종적인 select로 가져오기 직전에 정렬해서 가져오고싶다면\n6. **SELECT** : 관심있는 속성이나 통계에 관하여 최종적인 조회","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture10":{"title":"10. stored function","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## Stored function\n\n==**Stored function : 사용자가 정의한 함수**==\n- DBMS에 저장되고 사용되는 함수\n- SQL의 **select, insert, update, delete statement**에서 사용 가능\n- 자주 사용되는 일반적인 쿼리를 모듈화시켜서 편리하게 사용하기 위함\n- [stored procedure](brain/Lecture/db/easy-db/lecture11.md)과는 다른 것\n\n\u003cbr\u003e\n\n**stored function 특징**\n- 이외에도 loop를 돌면서 반복적인 작업 수행 가능\n- case 키워드를 사용하여 값에 따라 분기 처리 가능\n- 에러를 핸들링하거나 에러를 일으키는 등의 다양한 동작 정의 가능\n\n\u003cbr\u003e\n\n==**delimiter \\$$**==\n- 딜리미터는 기본적으로 `;`의 역할\n- 함수가 시작하는 부분의 `;`와 함수 내부의 여러 쿼리에 대한 `;`와 혼동이 생기지 않게 하려고 임시적으로 사용하기 위함\n\n\u003cbr\u003e\n\n```sql\n\u003e DELIMITER $$\n\n\u003e CREATE FUNCTION 이름(파라미터) \n\u003e RETURNS 리턴타입\n\u003e OPTION\n\u003e BEGIN\n\u003e \t수행할 것\n\u003e END\n\u003e $$\n\n\u003e DELIMITER ;\n```\n\n- Option 자리는 MySQL의 옵션이 들어감\n\t- `CONTAINS SQL`\n\t\t- 데이터를 읽거나 쓰는 명령이 포함되어있지 않음\n\t\t- ex) 실행되지만 데이터를 읽거나 쓰는것을 하지 않는 `@SET @x = 1`\n\t- `NO SQL`\n\t\t- 루틴에 SQL 문이 없음을 의미\n\t- `READS SQL DATA`\n\t\t- 루틴에 데이터를 읽는 쿼리 (ex. `SELECT`)이 포함되어 있지만 쓰는 것은 없음\n\t- `MODIFIES SQL DATA`\n\t\t- 루틴에 데이터를 쓸 수 있는 쿼리 (ex. `INSERT`, `DELETE`)가 포함되어 있음\n- `DB.이름`이라고 하지 않으면 현재 설정되어 있는 DB에 함수가 생성됨\n\t- 혹시 까먹었니!? DB 목록은 `SHOW DATABASES;`로 확인 가능해!\n\n\u003cbr\u003e\n\n**stored function 삭제하기**\n\n```sql\nDROP FUNCTION 함수이름;\n```\n\n\u003cbr\u003e\n\n### 예제\n\n**ex) 임직원의 ID를 열 자리 정수로 랜덤하게 발급하고 싶음. ID의 맨 앞자리는 1로 고정됨**\n\n![](brain/image/lecture10-2.png)\n- 10자리 정수니까 10억\n- MySQL 내장 함수 `rand()`는 0과 1 사이의 값을 가져오는 것\n- `rand() * 10억`을 하면 9자리 정수부를 가지는 값이 나올 것\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 위에서 정의한 `id_generator()`를 이용하여 Employee 테이블에 임직원 정보 추가해보자**\n\n![](brain/image/lecture10-3.png)\n\n![](brain/image/lecture10-5.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 부서의 ID를 파라미터로 받으면, 해당 부서의 평균 연봉을 알려주는 함수 작성해보자**\n\n![](brain/image/lecture10-6.png)\n\n![](brain/image/lecture10-7.png)\n\n- `DECLARE`로 변수를 선언하지 않고 사용할 수 있음\n\t- `@`를 붙이면 변수로 인식함\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 위에서 정의한 `dept_avg_salary(int)` 함수로 부서 정보와 부서 평균 연봉을 함께 가져와보자**\n\n![](brain/image/lecture10-9.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 졸업 요건 중 하나인 토익 800 이상을 충족했는지를 알려주는 함수를 작성해보자**\n\n![](brain/image/lecture10-10.png)\n\n![](brain/image/lecture10-11.png)\n\n- `DECLARE`로 변수를 선언하지 않고 사용할 수 있음\n\t- `@`를 붙이면 변수로 인식함\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 위에서 정의한 `toeic_pass_fail(int)` 함수로 학생 정보와 함께 토익 점수 조건을 충족했는지 여부를 같이 가져와보자**\n\n![](brain/image/lecture10-12.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 파악하기\n\n- 회사에 입사했는데, 등록된 stored function이 많이 있다고 하자.\n- 이걸 파악하는 방법\n\n```sql\n// 해당 DB에 있는 함수 목록\nSHOW FUNCTION STATUS where DB = '이름';\n\n// 함수의 코드 보고 싶으면\nSHOW CREATE FUNCTION 함수이름;\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 예를 들어, 위에서 정의한 함수들을 확인해보려면?**\n\n![](brain/image/lecture10-13.png)\n\n![](brain/image/lecture10-14.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 언제 쓰면 좋을까?\n\nStored function은 언제 사용하면 좋을까?\n- 내부적으로 개발팀에서 결정한 것이 있을 것.\n- 지금부터는 쉬운코드님의 개인적인 생각\n\n### three-tier architecture\n\n==**Three-tier architecture**==\n\n보통, 클라이언트-서버 모델은 three-tier architecture를 따른다.\n\n![](brain/image/lecture11-14.png)\n\n**Presentation tier**\n- 사용자에게 보여지는 부분을 담당하는 tier\n- HTML, javascript, CSS, native app, desktop app\n\n**Logic tier**\n- 서비스와 관련된 기능, 정책 등등 비즈니스 로직을 담당하는 tier\n- application tier, middle tier라고도 불림\n- Java + Spring, Python + Django, etc..\n\n**Data tier**\n- 데이터를 저장하고 관리하고 제공하는 역할을 하는 tier\n- MySQL, Oracle, SQL Server, PostgreSQL, MongoDB\n\n\n\u003cbr\u003e\n\n### 그래서 언제 사용?\n\n- util 함수로 쓰기에는 좋을 것 같음\n- 비즈니스 로직을 stored function에 두는 것은 좋지 않을 것 같다.\n\t- 비즈니스 로직은 Logic tier에서 담당하는 것인데, 비즈니스 로직 일부를 stored function에서 담당하게 되면, 비즈니스 로직의 일부가 Data tier에 위치하게 됨\n\t- 서비스가 커질수록 관리 비용이 늘어남.\n\t\t- Logic tier 봤다가~ Data tier 봤다가~\n\n\u003cbr\u003e\n\n### 위에서 구현한 함수 예시\n\n![](brain/image/lecture10-18.png)","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture11":{"title":"11. stored procedure","content":"\n유튜버 인코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## Stored procedure\n\n==**Stored procedure : 사용자가 정의한 프로시저**==\n- RDBMS에 저장되고 사용되는 프로시저\n- 구체적인 하나의 태스크(task)를 수행한다.\n- [stored function](brain/Lecture/db/easy-db/lecture10.md)과는 다르다.\n\n```sql\n\u003e DELIMITER $$\n\n\u003e CREATE PROCEDURE 이름(IN 파라미터 타입, OUT 파라미터 타입, INOUT 파라미터 타입) \n\u003e BEGIN\n\u003e \t수행할 것\n\u003e END\n\u003e $$\n\n\u003e DELIMITER ;\n```\n\n- ==**IN**== : 값을 파라미터로 전달받을 수 있지만, 값을 바꿀 수 없음\n- ==**OUT**== : 호출 당시 값을 전달받을 필요는 없고, 최종적으로 값을 반환할 때 사용\n- ==**INOUT**== : 값을 전달받을 수 있으면서도, 동시에 값을 반환하는 역할도 가능\n\t- 파라미터는 default로 IN으로 동작함\n\t- 따라서, **IN** 키워드는 생략해도 되지만, **OUT** 키워드는 반드시 작성해야함\n\n\u003cbr\u003e\n\n**stored procedure 특징**\n- 이외에도 조건문을 통해 분기처리 가능\n- 반복문 수행 가능\n- 에러를 핸들링하거나 예외를 일으키는 등의 다양한 로직 정의 가능\n\n\u003cbr\u003e\n\n### 예제\n\n**ex) 두 정수의 곱셈 결과를 가져오는 프로시저를 작성해보자**\n\n![](brain/image/lecture11-1.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 두 정수를 맞바꾸는 프로시저를 작성해보자**\n\n![](brain/image/lecture11-2.png)\n\n![](brain/image/lecture11-3.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 각 부서별 평균 연봉을 가져오는 프로시저를 작성해보자**\n\n![](brain/image/lecture11-4.png)\n\n![](brain/image/lecture11-5.png)\n\n\u003cbr\u003e\u003cbr\u003e\n\n**ex) 사용자가 프로필 닉네임을 바꾸면 이전 닉네임을 로그에 저장하고 새 닉네임으로 업데이트하는 프로시저를 작성해보자**\n\n![](brain/image/lecture11-6.png)\n\n![](brain/image/lecture11-8.png)\n\n- `now()`는 현재시간, 업데이트 되는 시간을 위해서 가져왔음\n\n![](brain/image/lecture11-9.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### function과의 차이\n\n==**stored procedure**== vs ==**stored function**==\n\n![](brain/image/lecture11-10.png)\n\n- 이외에도 ...\n\t- 내부적으로 다른 function/procedure를 호출할 수 있는지\n\t- resultset( = table)을 반환할 수 있는지\n\t- precompiled execution plan을 만드는지\n\t\t- 조금더 효율적으로 실행될 수 있도록 미리 컴파일할 수 있는지를 말하는거\n\t- try-catch를 사용할 수 있는지\n\t- 등등 ...\n\n\u003cbr\u003e\u003cbr\u003e\n\n**와닿지 않느다면 예시를 봐보자.**\n\n**stored procedure**\n\n ![](brain/image/lecture11-11.png)\n- 반드시 OUTPUT 파라미터를 통해서 결과값 반환해야함\n\n**stored function**\n\n![](brain/image/lecture11-12.png)\n- 반드시 RETURN 키워드를 통해서 반환해야함\n\n ![](brain/image/lecture11-13.png)\n- function이면 이렇게 SQL문에 사용 가능\n\n\u003cbr\u003e\n\n그러나, 실무에서 stored procedure를 사용하는 일은 잘 없다. 이는 [다음](brain/Lecture/db/easy-db/lecture12.md)에서 확인하자.","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture12":{"title":"12. 실무에서 프로시저","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 실무에서 프로시저\n\n실무에서 프로시저를 사용한다는 것은 권장되지 않는다. 왜 그럴까?\n\n### 3-tier architecture\n\n==**최근 실무**==에서는 client-server architecture의 한 종류인 ==**3-tier architecture 모델로 서비스를 개발함**==\n\n![](brain/image/lecture11-14.png)\n\n\u003cbr\u003e\n\n**Logic tier**\n- ==**비즈니스 로직이란?**==\n\t- ex) 당근마켓의 비즈니스 로직\n\t- 회원 가입 / 탈퇴\n\t- 상품 리스트업 알고리즘\n\t- 상품 정보 업로드 기능\n\t- 상품 검색 기능\n\t- 메시지 기능\n\t- etc ...\n\n\u003cbr\u003e\n\n**Data tier**\n- ==**데이터?**==\n\t- ex) 당근마켓의 데이터\n\t- 회원 정보\n\t- 상품 정보\n\t- 판매 / 구매 내역\n\t- 지역 정보\n\t- etc ...\n\n\u003cbr\u003e\n\n![](brain/image/lecture11-15.png)\n\n- 즉, stored procedure를 사용한다는 것은 data tier에 비즈니스 로직이 생기게 된다는 의미이다.\n- data tier에 비즈니스 로직이 생기게 된다는 것은 어떤 장/단점이 있을까 ??\n\n\u003cbr\u003e\u003chr\u003e\n\n## 프로시저 장점\n\n**stored procedure 장점**\n- Application에 투명(transparent)하게 동작할 수 있다.\n- Network traffic을 줄여서 응답 속도를 향상시킬 수 있다.\n- 여러 서비스에서 재사용 가능하다.\n- 민감항 정보에 대한 접근을 제한할 수 있다.\n\n\u003cbr\u003e\u003chr\u003e\n\n### transparent\n\n**ex) stored procedure를 사용하지 않고 Logic tier에서만 비즈니스 로직을 관리한다고 생각해보자.**\n\n![](brain/image/lecture11-16.png)\n\n- 비즈니스 로직을 수정할 일이 생겼고, 현재 서버는 트래픽을 받고 있는 상황이다.\n- 이제 배포해야하니까 컴파일시키고 배포파일 만든 이후에 기존의 인스턴스는 내리고 새로운 인스턴스를 띄워야 한다.\n\t- 하지만, 동시에 모두 서버 애플리케이션을 껐다 키면 안된다. 트래픽을 받고 있는 상황이라 바꿔주는 동안 트래픽을 처리할 수 없다.\n\t- 따라서, 나눠서 처리해야한다.\n- 하나 바꾸고 재가동, 하나 바꾸고 재가동... **비즈니스 로직을 수정할 일이 있을 때마다, 컴파일 새로하고, 빌드해서 배포 파일 만들고, 한대 한대씩 재가동 하는 것은 귀찮아 보인다.**\n\n\u003cbr\u003e\n\n**ex) 하지만, 이 비즈니스 로직이 stored procedure를 이용하여 관리된다면 어떻게 될까?**\n\n![](brain/image/lecture11-17.png)\n\n- Logic tier에서는 프로시저를 호출만 하고 있으니까, 서버 애플리케이션 쪽은 바꿀 필요 없음\n- Data tier에 프로시저만 쏙 바꾸면 되는거다.\n\n\u003cbr\u003e\n\ntransparent 하다는 의미는, 뭔가를 바꿔도 바뀌기 전에 사용하고 있던 부분들은 바꾸지 않고도 내용을 바꿀 수 있다는 의미이다. ==**따라서, stored procedure는 application에 대해서 transparent 할 수 있다는 장점이 있는 것이다.**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 응답속도 감소\n\n**ex) stored procedure를 사용하지 않고 Logic tier에서만 비즈니스 로직을 관리한다고 생각해보자.**\n\n![](brain/image/lecture11-18.png)\n\n- 스프링 서버와 DB 서버는 다른 서버이기 때문에 쿼리문마다 호출해야 한다.\n- 요청을 보내는 순간 **네트워크 트래픽이 발생**\n\n\u003cbr\u003e\n\n**ex) 하지만, 이 비즈니스 로직이 stored procedure를 이용하여 관리된다면 어떻게 될까?**\n\n![](brain/image/lecture11-19.png)\n\n- 어차피 비즈니스 로직이 DB 서버에서 처리되기 때문에 프로시저를 호출만 하면 된다.\n- 네트워크 트래픽이 한 번만 왔다갔다 하면 된다.\n- ==**따라서, Network traffic을 줄여서 응답 속도를 향상시킬 수 있다는 장점이 있다.**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 재사용 가능\n\n**ex) DB에 저장되어있는 data를 이용하는 서비스가 3개 있다고 하자.**\n\n![](brain/image/lecture11-21.png)\n\n- 각 서비스는 Java, Python, Javascript 각각으로 비즈니스 로직을 구현해야함\n\n![](brain/image/lecture11-22.png)\n\n- ==**stored procedure를 쓰면 여러 서비스에서 재사용 가능하다는 장점이 있다.**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 정보 제한\n\n**ex) 회사 내의 개발자나 임직원이 DB에 접근하는 것을 막는 경우**\n- 예를 들어, 사용자의 주민등록번호, 신용카드 정보 등등 민감한 정보에 접근을 막는 경우\n- 하지만, 개발자가 개발은 해야하는 상황\n\n![](brain/image/lecture11-23.png)\n- 개발자가 프로시저에 접근하는 것은 허용함으로써, ==**직접적인 접근은 막고 비즈니스 로직은 구현할 수 있도록 해주는 것이 stored procedure의 장점!!**==\n\n\u003cbr\u003e\u003chr\u003e\n\n## 프로시저 단점\n\n**stored procedure 단점**\n\n- 유지 관리 보수 비용이 커진다.\n- DB 서버를 추가하는 것은 간단한 작업이 아님\n\t-  DB 서버의 CPU 사용량이나 메모리 사용량이 늘어나게 되고, 트래픽이 폭발적으로 증가한 유사시에 긴급하게 대응이 힘듦\n- stored procedure가 언제나 transparent 인 것은 아님\n- stored procedure가 transparent 하다고 무조건 좋은 것도 아님\n- 재사용이 가능하다는 것은 양날의 검이 될 수도 있다.\n- stored procedure가 민감한 정보에 대하여 접근을 완벽히 제한할 수 없음\n\t- 또, DB 혹은 테이블 접근을 막으면 개발 및 CS 업무의 신속함이 떨어짐\n\t- CS 업무는 Customer Service를 뜻함\n\n\u003cbr\u003e\u003chr\u003e\n\n### 유지보수 힘듦\n\n**ex) Logic tier에도 비즈니스 로직, Data tier에도 비즈니스 로직이 있는 경우**\n\n![](brain/image/lecture11-24.png)\n\n- **Logic tier 봤다가~ Data tier 봤다가~** 왔다갔다 힘듦\n- **소스 코드의 버전 관리도 해야하고, 프로시저의 버전 관리**도 해야함\n- 원래는 소스코드만 관리하면 되니까, 여기에서는 Java만 알면 되는데, **프로시저의 문법도 알아야함**\n- 만약, 신규 기능 개발시 이에 대한 비즈니스 로직을 프로시저로 개발한다고 하자.\n\t- 프로시저쪽 코드도 수정\n\t- 애플리케이션쪽에 호출하는 소스코드도 수정\n\t- 컴파일, 배포 등 다시 다해야함\n- 따라서, ==**유지 관리 보수 비용이 커진다는 단점 발생**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### DB서버 추가\n\n**ex) Presentation tier에서 온 트래픽 증가 시 DB 서버 추가하는 경우**\n\n![](brain/image/lecture11-26.png)\n\n- Logic tier 서버의 CPU 사용량보다 Data tier의 DB 서버 CPU 사용량이 훨씬 많을 것\n\n![](brain/image/lecture11-27.png)\n\n- 이런 상황에서 Traffic이 갑자기 폭발적으로 증가하면?\n- 프로시저를 통해 비즈니스 로직을 다 가지고 있으니까 DB 서버 하나로 감당하기 힘들 것\n\n![](brain/image/lecture11-28.png)\n\n- RDBMS에 부하가 몰려서 신규 DB 서버를 추가했다고 하자.\n- 추가해봤자, 바로 해결이 안된다. 데이터는 기존 서버에만 있고 새로운 서버에는 똑같이 데이터를 복제해줘야 하는데... 언제 데이터를 전부 복사하겠나?\n- ==**비즈니스 로직을 프로시저를 통해서 RDBMS에 두게 된다면, DB 서버의 CPU 사용량이나 메모리 사용량이 늘어나게 되고, 트래픽이 폭발적으로 증가한 유사시에 긴급하게 대응이 불가능**==하게 된다. DB 서버를 추가하는 것은 간단하지 않다.\n\n\u003cbr\u003e\n\n### transparent 보장X\n\n**ex) stored procedure의 이름을 바꾸는 상황이라고 하자**\n\n![](brain/image/lecture11-32.png)\n\n- 이렇게 바로 이름을 바꿔버리면? 기존에 애플리케이션 서버에서 호출하던 프로시저의 이름과 다르기 때문에 바로 서비스에 문제가 생긴다.\n\n![](brain/image/lecture11-33.png)\n\n- 이렇게 이름 바꿀 프로시저를 새로 만들고 기존에 애플리케이션 서버에서 호출하던 프로시저의 이름을 하나 바꾸고 재가동, 하나 바꾸고 재가동, ... 이 짓을 반복한다.\n- 마지막으로 기존의 프로시저를 삭제하는 것이다.\n- ==**오히려, transparent 하기는 커녕, 소스 코드에 로직이 있는 경우보다 더 손이 많이 갈 수 있는 단점이 있다.**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### transparent 항상좋음?\n\n**ex) stored procedure의 body 부분만 바꾸는 상황이라고 하자**\n\n![](brain/image/lecture11-34.png)\n\n- body 부분만 바꿔서 번거롭게 애플리케이션 서버의 프로시저 호출 부분을 바꾸지 않고 transparent하게 변경할 수 있다.\n- 그런데, 바뀐 부분에 예상치 못한 버그가 생겨서 난리가 나게 되었다.\n- ==**다시 이전으로 롤백한다고 하더라도, 버그가 있는 프로시저가 동작하고 있었던 동안에 이와 관련된 모든 트래픽들은 안좋은 영향을 받았을 것이다.**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 양날의 검 재사용\n\n**ex) 하나의 서비스에서 요청하는 트래픽이 폭발적으로 증가한다고 하자.**\n\n![](brain/image/lecture11-39.png)\n\n- 스프링 쪽 서비스 A에서 폭발적으로 요청한다면 나머지 다른 서비스도 영향을 받게 됨\n- 이렇게, 여러 서비스가 동시에 DBMS의 프로시저를 사용하게 되면, ==**통제되지 않는 사용으로 모두에게 문제가 발생할 수 있게 된다. stored procedure를 재사용 가능하다는 것은 양날의 검이 되는 것이다.**==\n\n![](brain/image/lecture11-40.png)\n\n- 그래서 이런 식으로 아키텍처를 가져가는 것이 좋다.\n- DB의 앞단에 **데이터를 관리하는 서비스를 하나 만든다.**\n\t- 실제 서비스들은 Data Service를 통해 원하는 로직을 사용할 수 있도록 한다.\n\t- Data Service는 **Restful API** 같은 것을 통하여 인터페이스를 제공해야 한다.\n\t- 각각의 서비스들은 API를 호출하는 형태로 사용하는 것이다.\n- 이런 상황에서 Service A의 트래픽이 폭발적으로 증가하면, Data Service 쪽에서 Service A에 해당하는 호출만 막으면 된다.\n\t- 이렇게 하면 Service B와 Service C는 문제가 없게 된다.\n\n\u003cbr\u003e\n\n**그런데, 이렇게 하면 Data Service 쪽에서는 고민이 된다.**\n\n- 프로시저를 서비스 A, B, C에서 재사용하면서 사용하는 것이 아니라 Data Service에서만 사용하기 때문이다.\n\n![](brain/image/lecture11-41.png)\n\n- 그래서 Data Service 쪽을 관리하는 사람은 그냥 프로시저를 쓰지 말고 소스코드로 관리하자는 쪽으로 가게 되는 것이다.\n\n\u003cbr\u003e\u003chr\u003e\n\n### 완벽한 정보제한 불가\n\u0003\n사실 위에서는 간접적으로 정보에 접근하도록 하여 민감한 정보를 감췄다고는 하지만..\n\n![](brain/image/lecture12-7.png)\n\n- 이렇게 return 값을 받아버리면 적어도, 개발자들은 민감한 정보에 대한 접근이 가능해진다.\n\n![](brain/image/lecture12-8.png)\n\n- 또, 이렇게 DB 혹은 테이블 접근을 막으면 개발 및 CS (Customer Service) 업무의 신속함이 떨어진다.\n\n\u003cbr\u003e\n\n\u003e [!note] 그래서, 사실 보안과 관련된 부분은 아래와 같이 하는 것이 좋다. \u003cbr\u003e\n\u003e - 담당자나 개발자에게만 DB 혹은 테이블 권한을 부여하자\n\u003e - 민감한 정보는 암호화해서 저장하자\n\u003e - 보안서약서 등을 통해 정책적으로 보안을 강화하자\n\n\u003cbr\u003e\u003chr\u003e\n\n### 이외의 단점\n\n- procedure로는 복잡하고 유연한 코드를 작성하기 어렵다.\n- 오늘날의 프로그래밍 언어는 훨씬 다양하고 강력한 기능들을 제공한다.\n\t- 굳이 프로시저를??\n- procedure는 가독성이 떨어진다.\n- procedure는 디버깅이 어렵다.\n\n\u003cbr\u003e\u003chr\u003e\n\n## Logic tier 장점\n\n그렇다면, 프로시저를 쓰지 않고 Logic tier에서 비즈니스 로직을 관리하는 방식은 어떤 면에서 좋다는 말일까? ==**사실 프로시저의 장점에서 언급했던 것을 로직 티어에서 관리하면 더 좋게 해결할 수도 있다.**==\n\n- 트래픽이 증가했을 때, 서버 추가가 쉽다.\n- 하나씩 재가동하는 불편한 방법이, 버그 발생에 관한 이점을 가져온다.\n- 응답속도 향상은 사실 가능하다.\n\n\u003cbr\u003e\u003chr\u003e\n\n### 서버추가 쉬움\n\n프로시저의 단점에서 \u003ca href='/brain/Lecture/easycode/db/lecture12/#db서버-추가'\u003eDB서버 추가가 힘들다\u003c/a\u003e는 것이 있었는데, Logic tier에서는 애플리케이션 서버 투입이 간단하다.\n\n![](brain/image/lecture11-29.png)\n\n- 애초에 트래픽을 분산받아서 사용하기 떄문에 좀 더 좋은 상황\n\n![](brain/image/lecture11-31.png)\n\n- 최근은 클라우드가 잘 되어있어서 오토 스케일링(auto scaling) 같은거 이용하면 애플리케이션 서버 추가하는 것은 매우 쉽다.\n- ==**Logic tier에 애플리케이션 서버를 투입하는 것은 간단하다. 데이터를 가지고 있지 않기에 그냥 추가하면 된다. 따라서, CPU 혹은 메모리 부하를 쉽게 분산시킬 수 있다.**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 버그 피해 최소화\n\n프로시저의 단점에서 \u003ca href='/brain/Lecture/easycode/db/lecture12/#transparent-항상좋음'\u003etransparent가 항상 좋은 것이냐\u003c/a\u003e는 것이 있었는데, Logic tier에서의 하나하나 재가동 하는 부분 덕에 오히려 좋은 점도 있다.\n\n![](brain/image/lecture11-35.png)\n\n- 하나 하나 재가동 해야하니까, 하나 바꾸고 모니터링 하고 있는다.\n\n![](brain/image/lecture11-36.png)\n\n- 이렇게 버그가 발생한걸 발견하면, 간헐적으로 문제가 발생했다는 것을 확인하니까 빠르게 이전 버전으로 롤백할 수 있다.\n- 물론, 이 순간에 이 서버로 들어온 트래픽은 안좋은 영향을 받았을 것이다.\n\t- 하지만 stored procedure 때는 온전히 모든 서버가 안좋은 영향을 받았다면,\n\t- 이번에는 4분의 1에 해당하는 서버만 안좋은 영향을 받았을 것이다. 그나마 훨씬 낫다.\n- ==**이렇게 애플리케이션 서버를 통해 배포를 매번 하는 것은 번거롭기는 해도 예상치 못한 버그의 영향을 최소화 할 수 있다.**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 응답 속도 감소\n\n프로시저의 장점에서 \u003ca href='/brain/Lecture/easycode/db/lecture12/#응답속도-감소'\u003e응답속도 감소\u003c/a\u003e를 말할 때, Logic tier에 비즈니스 로직을 둔다면 응답속도가 느리다고 했는데, ==**사실 Logic tier에 비즈니스 로직을 두고도 응답 속도를 향상시킬 수 있다.**==\n\n![](brain/image/lecture12-1.png)\n\n- 각각의 쿼리문 (`select`, `insert`, `update`)이 매번 요청을 보내서 응답속도에 문제가 있다고 했었다.\n- 그렇다면 만약에, **insert와 update를 동시에 한다면?**\n\n![](brain/image/lecture12-2.png)\n\n- ==**스레드 풀(Thread Pool)을 사용하던 Non-blocking IO를 사용하던 동시에 DB서버로 요청을 보낸다.**==\n- 순차적으로 요청할 필요가 없는 경우라면, ( 동시에 진행이 가능한 경우라면 ) 동시에 호출하여 응답속도를 향상시킬 수 있다.\n\n\u003cbr\u003e\n\n**ex) 그런데, 예를 들어 순차적으로 요청해야 하는 경우라면 어떻게 응답 속도를 향상시킬까?**\n\n![](brain/image/lecture12-3.png)\n\n- select문 A와 B는 반드시 순차적으로 실행되어야 하는 상황이라고 하자.\n- 이 경우에는 어떻게 응답 속도를 향상시킬까?\n\n![](brain/image/lecture12-5.png)\n\n- 이렇게 ==**캐시(cache)를 사용한다. 여기서 사용된 캐시는 redis이다.**==\n\t- 소스코드에 캐시 관련 로직도 추가한다.\n\t- 캐시가 추가되면서 타임라인에도 변화가 생긴다.\n- `getPoint(int id)`라는 로직은 id를 받으면 그 id의 포인트를 가져오는 로직이다.\n\t1. `getFromCache(id)`는 id에 대한 포인트가 캐시에 있는지 먼저 확인\n\t2. 초기에는 당연히 캐시에 아무것도 없기 때문에 `return point if not null` 수행하지 않고 밑으로 코드 실행\n\t3. \u00032번의 select문 수행 이후 계산하여 얻은 포인트를 캐시에 넣는다.\n\t\t- redis는 key-value 형태로 데이터를 저장함\n\t\t- 얼마동안 캐시에 저장할 것인지 life time도 저장함. 여기서는 60초라고 해놨음\n\t4. 이후 계산한 포인트를 반환\n- 당장은 네트워크를 좀 더 타게 되어서 복잡해진 것처럼 보임. 하지만..?\n\n![](brain/image/lecture12-6.png)\n\n- 같은 id에 대해서는 캐시에 있는 동안 한 번만 왔다갔다 하니까 ==**응답 속도가 향상됨!!**==\n- 이런식으로 ==**비즈니스 로직을 소스코드에 두고도, 캐시를 사용하면 응답 속도를 향상시키면서 DB 부하까지고 줄이는 엄청난 효과를 가져온다. 실무에서 정말 많이 사용하는 패턴**==\n\n\n\n","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture13":{"title":"13. trigger","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## Trigger\n\nTrigger의 사전적 의미\n- (총의) 방아쇠\n- (반응사건을 유발한) 계기, 도화선\n- 촉발시키다 ( = set off)\n- 작동시키다 ( = set off)\n\n==**SQL에서 Trigger**==\n- 데이터베이스에서 어떤 이벤트가 발생했을 때 자동적으로 실행되는 [프로시저(procedure)](brain/Lecture/db/easy-db/lecture11.md)\n- ==**데이터에 변경이 생겼을 때, 즉 DB에 insert, update, delete가 발생했을 때 이것이 계기가 되어 자동적으로 실행되는 프로시저(procedure)를 의미**==\n\t- 트리거는 데이터의 변경 이력, 히스토리 같은 곳에 사용되면 좋을듯!\n\t- 트리거는 테이블에서 변화가 일어날 때마다 통계를 계산하고 싶을 때 쓰면 좋을 듯!\n\t- 근데 개인적으로.. 트리거는 유지보수가 너무 힘드니 최후의 보루로 남겨두도록...\n\n```sql\n\u003e DELIMITER $$\n\n\u003e CREATE TRIGGER 트리거이름\n\u003e 언제 업데이트\n\u003e 어떤 테이블\n\u003e BEGIN\n\u003e \t수행할 것\n\u003e END\n\u003e $$\n\n\u003e DELIMITER ;\n```\n\n\u003cbr\u003e\n\n### 예시 - OLD 키워드\n\n**ex) 사용자의 닉네임 변경 이력을 저장하는 트리거를 작성해보자**\n\n![](brain/image/lecture13-1.png)\n\n- 업데이트라는 이벤트가 발생하게 되면, 무언가를 트리거 시킨다.\n- 뭘 트리거 시키냐? 뭘 촉발시키냐?\n\t- 기존의 닉네임을 `USERS_LOG` 테이블에 저장하는 그 액션을 촉발시킴\n\n![](brain/image/lecture13-2.png)\n\n\u003cbr\u003e\n\n![](brain/image/lecture13-3.png)\n\n- 어떤 이벤트에 대해서 트리거 발생? -\u003e 사용자의 닉네임에 `UPDATE`가 발생할 때마다\n- 업데이트 이전에 액션을 취하게 할거라서 `BEFORE`\n- `ON users` : 어떤 테이블? users 테이블~\n- `FOR EACH ROW` : 업데이트가 되는 각 ROW 마다 이 트리거를 실행\n- `BEGIN ~ END` 사이의 BODY 부분이 **트리거가 취하는 액션**\n- ==**OLD 키워드**==\n\t- 시점이 `BEFORE UPDATE`라면\n\t\t- update 되기 이전의 tuple을 가리킴\n\t- 시점이 `BEFORE DELETE`라면\n\t\t- delete 된 tuple을 가리킴\n\n![](brain/image/lecture13-5.png)\n\n- 과연 트리거가 잘 동작했을까 ?\n\n![](brain/image/lecture13-6.png)\n\n- 잘 됐네~\n- 트리거는 ==**데이터의 변경 이력, 히스토리 같은 곳에 사용되면 좋을듯!**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 예시 - NEW 키워드\n\n**ex) 사용자가 마트에서 상품을 구매할 때마다 지금까지 누적된 구매 비용을 구하는 트리거를 작성해보자**\n\n![](brain/image/lecture13-7.png)\n\n- 2000원 + 5000원의 결과가 최종적으로 업데이트되는 트리거를 만들어보자는 의미\n\n\u003cbr\u003e\n\n![](brain/image/lecture13-8.png)\n\n- 어떤 이벤트에 대해서 트리거 발생? -\u003e `INSERT` 이벤트 할 때마다\n- insert 이후에 액션을 취하게 할거라서 `AFTER`\n- `ON buy` : 어떤 테이블? buy 테이블~\n- `FOR EACH ROW` : INSERT 되는 각 ROW 마다 이 트리거를 실행\n- ==**NEW 키워드**==\n\t- 시점이 `AFTER INSERT`라면\n\t\t- insert된 tuple을 가리킴\n\t- 시점이 `AFTER INSERT`라면\n\t\t- update된 후의 tuple을 가리킴\n\n![](brain/image/lecture13-9.png)\n\n![](brain/image/lecture13-10.png)\n\n오키 하나 더 사보자\n\n![](brain/image/lecture13-11.png)\n\n![](brain/image/lecture13-12.png)\n\n- 트리거는 ==**테이블에서 변화가 일어날 때마다 통계를 계산하고 싶을 때 쓰면 좋을 듯!**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 예제 - 한 번에 감지\n\n- update, insert, delete 등을 한 번에 감지하도록 설정 가능\n- MySQL은 불가능, 실습은 PostgreSQL로 진행\n\n**ex) 임직원의 평균 연봉을 구하는 트리거 만들어보자.**\n- 임직원이 새로 들어오든, 나가든, 연봉이 업데이트되든 등등\n\n\u003cbr\u003e\n\n![](brain/image/lecture13-13.png)\n\n- 그런데 여기서 `FOR EACH ROW`는 문제가 있다.\n\n![](brain/image/lecture13-14.png)\n\n- 이는 employee 테이블에서 부서 id가 1003인 임직원들의 연봉을 모두 1.5배 올려주는 것\n- 만약, 임직원이 5명이라면 `FOR EACH ROW`로 트리거를 작성했기 때문에 **트리거가 총 다섯 번 실행하게 된다.**\n- 이렇게 트리거가 tuple마다 발생하는 것은 굉장히 비효율적 동작\n- update문이 실행됐을 때 트리거가 한 번만 실행되게 하려면 어떻게 바꾸지?\n\n![](brain/image/lecture13-15.png)\n\n- ==**FOR EACH STATEMENT**==\n- ==**row 단위가 아니라 statement 단위로 trigger가 실행될 수 있도록 한다.**==\n\t- 단, MySQL은 `FOR EACH STATEMENT` 사용 불가능\n\n\u003cbr\u003e\u003chr\u003e\n\n### 예제 - 조건 WHEN\n\n- trigger를 발생시킬 디테일한 조건을 지정할 수 있다.\n\t- 단, MySQL은 불가능\n\n\u003cbr\u003e\n\n**ex) 사용자가 닉네임을 변경할 때마다 닉네임의 히스토리를 저장하는 트리거**\n\n![](brain/image/lecture13-16.png)\n\n- `WHEN` 키워드를 이용하여 디테일한 조건을 걸어서 트리거가 실행되도록 할 수 있음\n\n\u003cbr\u003e\u003chr\u003e\n\n## Trigger 주의사항\n\n- 트리거는 가시적이지 않아서, 개발도, 관리도, 문제 파악도 힘들어짐\n- 지나치게 많이 사용하면 파악하기 힘들어짐\n- 과도한 트리거 사용은 DB에 부담을 주고 응답을 느리게 만듦\n- 디버깅이 어려움\n- 문서 정리가 특히나 중요함\n\n\n\u003cbr\u003e\u003chr\u003e\n\n### 가시적이지 않음\n\n==**트리거는 소스 코드로는 발견할 수 없는 로직이기 때문에, 어떤 동작이 일어나는지 파악하기 어렵고 문제가 생겼을 때 대응하기 어렵다.**==\n\n![](brain/image/lecture13-19.png)\n\n- 웹 애플리케이션 서버에서는 트리거의 존재를 파악하기 힘들다.\n- 웹 애플리케이션 서버는 소스 코드를 기반으로 동작하는 것인데 트리거는 RDBMS에서 바로 등록되어서 사용되는 것이고, DB에 어떤 이벤트가 발생했을 때 그 이벤트가 트리거가 되어 실행되는 로직이기 때문이다.\n\t- 소스 코드 상에서 직접 호출하는 로직이 아니다.\n- 프로시저는 소스 코드 상에 호출하는 부분이라도 있지... 트리거는 아니다.\n\n\u003cbr\u003e\u003chr\u003e\n\n### 지나친 사용\n\n![](brain/image/lecture13-20.png)\n\n==**지나치게 많은 트리거를 사용하게 되면, 트리거가 또 다른 트리거를 발생하고 또 다른 트리거를 발생시켜 연속적인 트리거가 발생하여 파악하기 힘들게 된다.**==","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture14":{"title":"14. transaction","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 트랜잭션\n\n==**트랜잭션(Transaction)**==\n- **단일한 논리적인 작업 단위 (a single logical unit of work)**\n- 논리적인 이유로 여러 SQL문 들을 단일 작업으로 묶어서 나눠질 수 없게 만든 것\n- 트랜잭션의 SQL문 들 중에 일부만 성공해서 DB에 반영되는 일은 일어나지 ❌\n\n==**커밋(Commit)**==\n- 지금까지 작업한 내용을 DB에 ==**영구적으로(permanently) 저장**==하라\n- transaction을 종료한다\n\n==**롤백(Rollback)**==\n- 지금까지 ==**작업들을 모두 취소**==하고 트랜잭션 이전 상태로 되돌려라\n- transaction을 종료한다\n\n\u003cbr\u003e\n\n```sql\n-- 트랜잭션 시작을 알림\nSTART TRANSACTION;\n-- 작업 수행 후 COMMIT으로 DB에 반영 + 트랜잭션 종료\nCOMMIT;\n-- 작업 수행하다가 작업 모두 취소하고 되돌리기 + 트랜잭션 종료\nROLLBACK;\n```\n\n\u003cbr\u003e\n\n### 트랜잭션 예제\n\n**예제 상황**\n\n![](brain/image/lecture14-1.png)\n\n![](brain/image/lecture14-2.png)\n\n![](brain/image/lecture14-3.png)\n\n- 두 sql문이 모두 성공해야 **이체**라는 작업이 성공하는 것\n- 이체라는 작업은 ==둘 다 정상 처리되어야만 성공하는 **단일 작업**==\n\n\u003cbr\u003e\n\n**MySQL로 표현**\n\n![](brain/image/lecture14-4.png)\n\n![](brain/image/lecture14-6.png)\n\n![](brain/image/lecture14-7.png)\n\n![](brain/image/lecture14-8.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### AUTOCOMMIT\n\n==**AUTOCOMMIT**==\n- 각각의 SQL문을 자동으로 transaction 처리 해주는 개념\n- **SQL문이 성공적으로 실행**하면 자동으로 **COMMIT**\n- **실행 중 문제**가 있었다면 알아서 **ROLLBACK**\n- MySQL에서는 default로 autocommit이 enabled 되어있음\n- 다른 DBMS에서도 대부분 같은 기능 제공\n\n```sql\n-- 현재 AUTOCOMMIT의 활성화 여부 확인 쿼리\nselect @@autocommit;\n\n-- AUTOCOMMIT 끄려면\nSET autocommit=0;\n```\n\n\u003cbr\u003e\n\n==**MySQL에서 트랜잭션 시작 시 autocommit**==\n- `START TRANSACTION` 실행과 동시에 autocommit은 off 됨\n- `COMMIT` / `ROLLBACK`과 함께 transaction이 종료되면 원래 autocommit 상태로 되돌아감\n\n\u003cbr\u003e\n\n**ex) autocommit 활성화 상태에 insert문 해보기**\n\n![](brain/image/lecture14-9.png)\n\n![](brain/image/lecture14-10.png)\n\n\u003cbr\u003e\n\n**ex) autocommit 비활성화 상태에 delete문 해보기**\n\n![](brain/image/lecture14-12.png)\n\n![](brain/image/lecture14-13.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### 트랜잭션 사용패턴\n\n==**일반적인 transaction 사용 패턴**==\n1. transaction을 시작(==**begin**==)한다.\n2. 데이터를 읽거나 쓰는 등의 SQL문들을 포함해서 로직 수행\n3. 일련의 과정들이 문제없이 동작했다면 transaction을 ==**commit**==\n4. 중간에 문제가 발생했다면 transaction을 ==**rollback**==\n\n\u003cbr\u003e\n\n==**자바 코드에서의 예시**==\n\n![](brain/image/lecture14-14.png)\n\n- `connection.setAutoCommit(false);`\n\t- 이것이 autocommit을 끄면서, 동시에 **트랜잭션을 시작하겠다는 의미를 포함**\n- `connection.setAutoCommit(true);`\n\t- 보통 DB connection은 한 번 쓰고 버리는 것이 아니기 때문에 autocommit 설정을 원래로 바꿔야 함 \n- 이체와 관련된 비즈니스 로직 코드와, 트랜잭션 코드가 같이 있으면 보기 불편하니까 이를 숨기고 싶음\n\n\u003cbr\u003e\n\n![](brain/image/lecture14-15.png)\n\n- `@Transactional` 애노테이션을 통해 트랜잭션 관련 코드는 숨기고 이체에 관련된 비즈니스 로직만 남겨서 보기 수월하게 만들었음\n\n\u003cbr\u003e\u003chr\u003e\n\n## ACID\n\n### Atomicity\n\n==**원자성(Atomicity)**==\n- 모두 성공하거나, 모두 실패하거나를 보장하기 위한 특징\n- ALL or Nothing\n- transaction은 논리적으로 쪼개질 수 없는 작업 단위이기 때문에 내부의 SQL문들은 모두 성공해야함\n- 중간에 SQL 문이 실패하면 지금까지의 작업을 모두 취소하여 아무 일도 없었던 것처럼 rollback 함\n\n\u003cbr\u003e\n\n![](brain/image/lecture14-16.png)\n\n- ==**commit**== 실행 시 DB에 ==**영구적으로 저장하는 것**==은 DBMS가 담당하는 부분\n- ==**rollback**== 실행 시 ==**이전 상태로 되돌리는 것**==도 DBMS가 담당하는 부분\n- 개발자는 언제 commit 하거나 rollback 할 지를 챙겨야 함\n\t- 트랜잭션 단위를 어떻게 결정할 지\n\t- 어떤 문제가 발생했을 때 롤백할\u001c 지\n\n\u003cbr\u003e\u003chr\u003e\n\n### Consistency\n\n==**일관성(Consistency)**==\n- transaction은 DB 상태를 consistent(일관된) 상태에서 또 다른 consistent 상태로 바꿔줘야 함\n- constraints, trigger 등을 통해 DB에 정의된 rules을 transaction이 위반했다면 rollback 해야 함\n- transaction이 DB에 정의된 rule을 위반했는지는 DBMS가 commit 전에 확인하고 알려줌\n- 그 외 application 관점에서 transaction이 consistent하게 동작하는지는 개발자가 챙겨야 함\n\t- 왜냐하면, DBMS는 DB에 정의된 룰만 확인하니까\n\n\u003cbr\u003e\n\n![](brain/image/lecture14-17.png)\n- 테이블을 생성할 때 정한 제약조건에서 이미 위배\n- 더이상 트랜잭션을 진행할 필요가 없음. rollback\n- 이렇게 DB의 일관성을 유지시켜주는 것이 consistency\n\n\u003cbr\u003e\u003chr\u003e\n\n### Isolation\n\n==**격리성(Isolation)**==\n- 여러 transaction들이 동시에 실행될 때도 혼자 실행되는 것처럼 동작하게 만듦\n- DBMS는 여러 종류의 isolation level을 제공\n- 개발자는 isolation level 중 어떤 level로 transaction을 동작시킬지 설정할 수 있음\n- [concurrency control(동시성 제어)](brain/Lecture/db/easy-db/lecture15.md) 의 주된 목표가 **isolation**\n\n\u003cbr\u003e\n\n==**여러 종류의 isolation level을 제공하는 이유?**==\n- 엄격하게 구현하면 DB 서버의 performance(성능)가 떨어지기 때문에\n- ==Isolation level이 높으면 높을수록== 보다 엄격하게 격리시켜 다른 트랜잭션으로부터 영향을 받을 경우가 줄어듦\n\t- 대신, 그만큼 동시에 실행될 수 있는 동시성이 떨어지게 되어 DB 서버의 퍼포먼스가 떨어지게 됨\n- ==Isolation level이 낮으면 낮을수록== 여러 트랜잭션이 실행될 수 있는 동시성이 높아져서 DB 서버의 퍼포먼스가 좋아짐\n\t- 대신, 다른 트랜잭션으로부터 영향받을 가능성이 커지기 때문에 잘못된 결과를 초래할 확률이 커짐\n\n\u003cbr\u003e\n\n**ex) J가 H에게 20만원을 이체할 때, 하필 그 타이밍에, H도 ATM에서 본인 계좌에 30만원을 입금한다면?**\n\n![](brain/image/lecture14-18.png)\n\n- 이런 문제 발생 시 중요한 특성이 Isolation\n\n\u003cbr\u003e\u003chr\u003e\n\n### Durability\n\n==**지속성, 영존성 (Durability)**==\n- commit된 transaction은 DB에 **영구적으로** 저장\n- DB system에 문제(power fail / DB crash)가 생겨도 commit된 transaction은 DB에 남아있어야 함\n- 영구적으로 저장한다라고 할 때는 일반적으로 ==**비휘발성 메모리(HDD, SDD, ...)**에 저장한다는 것을 의미==\n- 기본적으로 transaction의 durability는 DBMS가 보장\n\n\u003cbr\u003e\n\n![](brain/image/lecture14-19.png)\n\n- commit 이후에 트랜잭션이 DB에 영구적으로 저장되는 것을 Durability라고 함","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/easy-db/lecture15":{"title":"15. 동시성 제어 1부","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e데이터베이스\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## Concurrency Control\n\n### 예제\n\n**ex) J가 H에게 20만원을 이체할 때, 하필 그 타이밍에, H도 ATM에서 본인 계좌에 30만원을 입금한다면?**\n\n**case 1**\n\n![](brain/image/lecture15-1.png)\n\n\u003cbr\u003e\n\n**case 2**\n\n![](brain/image/lecture15-2.png)\n\n\u003cbr\u003e\n\n**case 3**\n\n![](brain/image/lecture15-3.png)\n\n\u003cbr\u003e\n\n**case 4**\n\n![](brain/image/lecture15-4.png)\n\n- 이렇게 update 된 데이터가 사라지는 현상을 ==**Lost update**==라고 함\n\n\u003cbr\u003e\n\n**용어정리**\n\n![](brain/image/lecture15-5.png)\n\n![](brain/image/lecture15-6.png)\n\n- 위와 같이 간소화 시켜보겠다.\n- 이렇게 하나 하나의 과정을 ==**operation**==이라고 부름\n- `r1(K)`를 보면 r은 읽기, 1은 트랜잭션 숫자, K는 읽으려는 데이터이다.\n\n\u003cbr\u003e\n\n**최종 간소화**\n\n![](brain/image/lecture15-7.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### Schedule\n\n==**Schedule (스케쥴)**==\n- 여러 transaction들이 동시에 실행될 때 각 transaction에 속한 operation 들의 실행 순서를 의미\n- 각 transaction 내의 operations들의 순서는 바뀌지 ❌\n\n\u003cbr\u003e\n\n==**Serial schedule (순차적 스케쥴)**==\n- transaction들이 **겹치지 않고 한 번에 하나씩 실행**되는 schedule\n\n![](brain/image/lecture15-8.png)\n\n\u003cbr\u003e\n\n==**nonserial schedule (비순차적 스케쥴)**==\n- transaction들이 **겹쳐서(interleaving) 실행**되는 schedule\n\n![](brain/image/lecture15-9.png)\n\n\u003cbr\u003e\n\n==**Serial schedule 성능**==\n- Serial schedule은 순차적으로 트랜잭션이 실행되니까 이상한 결과를 만들지는 않음\n- 하지만, IO 작업을 하는 동안 CPU는 가만히 놀고 있음\n- **한 번에 하나의 transaction만 실행되기 때문에 좋은 성능을 낼 수 없고 현실적으로 사용할 수 없는 방식**\n\n\n\u003cbr\u003e\n\n==**nonserial schedule 성능**==\n\n![](brain/image/lecture15-10.png)\n\n- transaction들이 겹쳐서 실행되기 때문에 동시성이 높아져서 같은 시간동안 더 많은 transaction 들을 처리할 수 있음\n- 하지만, transaction 들이 어떤 형태로 겹쳐서 실행되는지에 따라 이상한 결과가 나올 수 있음\n\n\u003cbr\u003e\n\n**고민거리**\n- 성능 때문에 여러 transaction 들을 겹쳐서 실행할 수 있으면 좋다. (nonserial schedule)\n- 하지만, 이상한 결과가 나오는 것은 원하지 않는다.\n\n\u003cbr\u003e\n\n**아이디어**\n- nonserial schedule로 실행해도 이상한 결과가 나오지 않는 방법이 뭘까?\n\t- **serial schedul과 동일한(equivalent) nonserial schedule을 실행해보자!**\n\t- schedule이 동일하다의 의미를 정의해야겠네\n\n\u003cbr\u003e\u003chr\u003e\n\n### Conflict\n\n\u003cbr\u003e\n\n==**Conflict**==\n- 두 개의 operations에 대하여 사용하는 개념\n- conflict가 중요한 이유는, **conflict operation의 순서가 바뀌면 결과도 바뀌기 때문**\n- 아래의 세 가지 조건을 모두 만족하면 conflict\n\t1. ==**서로 다른 transaction 소속**==\n\t2. ==**같은 데이터에 접근**==\n\t3. ==**최소 하나는 write operation**==\n\n\u003cbr\u003e\n\n**ex) conflict 예시**\n\n![](brain/image/lecture15-11.png)\n\n![](brain/image/lecture15-13.png)\n\n\u003cbr\u003e\n\n==**Conflict equivalent, 충돌되는 연산 순서가 동일하다**==\n- conflict 개념을 사용하여 **schedule이 동일하다는 의미**를 정의하기 위함\n- 아래의 두 조건을 모두 만족하면 conflict equivalent\n\t1. ==**두 schedule은 같은 transaction들을 가짐**==\n\t2. ==**어떤(any) conflicting operations의 순서도 양쪽 schedule 모두 동일**==\n\n![](brain/image/lecture15-14.png)\n- 3개의 conflicting operations들의 순서가 양쪽 모두 동일\n\t- sched.3 : `r2(H) -\u003e w1(H)`, sched.4 : `r2(H) -\u003e w1(H)`\n\t- sched.3 : `w2(H) -\u003e r1(H)`, sched.4 : `w2(H) -\u003e r1(H)`\n\t- sched.3 : `w2(H) -\u003e w1(H)`, sched.4 : `w2(H) -\u003e w1(H)`\n- 이 두 개의 스케쥴은 최종적으로 conflict equivalent 하다고 할 수 있음\n- 그런데, schedule2를 보면 순차적인 스케쥴(serial schedule)이다.\n\n\u003cbr\u003e\u003chr\u003e\n\n### Serializable\n\n==**Conflict Serializable**==\n\n![](brain/image/lecture15-14.png)\n\n- 위의 예시처럼 serial schedule과 conflict equivalent 할 때 conflict serializable이라고 한다.\n- nonserial schedule 이었던 schedule3은 **conflict serializable**이다.\n\n\u003cbr\u003e\n\n**ex) 다른 예제, sched.4는 conflict serializable일까?**\n\n![](brain/image/lecture15-15.png)\n- 두 스케쥴은 같은 트랜잭션에 대하여 실행하는 것이기에 Conflict equivalent 첫 번째 조건 🟢\n- conflicting operations 확인\n\t- sched.4 : `r1(H) -\u003e w2(H)`, sched.2 : `w2(H) \u003c- r1(H)`\n\t- 엥! 순서가 역전되어있네. conflict equivalent 하지 않네 !!\n- sched.4는 serial schedule인 sched.2와는 conflict equivalent 하지 않은 것 확인\n\n\u003cbr\u003e\n\n![](brain/image/lecture15-16.png)\n- 두 스케쥴은 같은 트랜잭션에 대하여 실행하는 것이기에 Conflict equivalent 첫 번째 조건 🟢\n- conflicting operations 확인\n\t- sched.4 : `r1(H) -\u003e w2(H)`, sched.1 : `r1(H) -\u003e w2(H)`\n\t- sched.4 : `r2(H) -\u003e w1(H)`, sched.1 : `w1(H) \u003c- r2(H)`\n\t- 엥! 순서가 역전되어있네. conflict equivalent 하지 않네 !!\n- sched.4는 serial schedule인 sched.1와는 conflict equivalent 하지 않은 것 확인\n\n\u003cbr\u003e\n\n결과적으로, sched.4는 serial schedule인 sched.1과 sched.2 둘 중 그 **어떤 serial schedule과도 conflict equivalent 하지 않는다.** ==**그래서 sched.4가 이상한 결과가 나온 것이다. 그 어떤 serial schedule과도 conflict equivalent 하지 않았으니까.**==\n\n![](brain/image/lecture15-17.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### Serializable 구현\n\n==**Conflict Serializable 구현**==\n- 여러 transaction을 동시에 실행해도 schedule이 conflict serializable 하도록 보장하는 **프로토콜**을 적용\n\t- 일단 실행하고나서 conflict serializable 한 지 확인하는 것이 아니라, **아예 conflict serializable한 schedule만 실행될 수 있도록 보장하는 프로토콜을 적용한다는 의미**\n\n\u003cbr\u003e\n\n**ex) 여러 트랜잭션이 실행될 때마다 해당 schedule이 conflict serializable인지 확인하면 안됨?**\n- 요청이 많이 몰려오면, 동시에 실행될 수 있는 트랜잭션 수가 너무 많음\n- 이 많은 트랜잭션이 실행될 때 그 스케쥴이 conflict serializable 한 지 확인하려면 비용이 굉장히 많이 들 것이니까\n- 따라서, 이러한 방법은 사용하지 않음\n\n\u003cbr\u003e\n\n### 최종정리\n\n어떤 ==schedule==이 어떤 임의의 ==serial schedule==과 ==동일(equivalent)== 하다면 이 schedule은 ==serializable하다 혹은 serializability 속성을 가진다==라고 말함\n\n어떤 ==schedule==이 어떤 임의의 ==serial schedule==과 ==충돌되는 연산 순서가 동일(conflict equivalent)== 하다면 이 schedule은 ==conflict serializable하다 혹은 conflict serializability 속성을 가진다==라고 말함\n\n어떤 ==schedule==이 어떤 임의의 ==serial schedule==과 ==view equivalent== 하다면 이 schedule은 ==view serializable하다 혹은 view serializability 속성을 가진다==라고 말함\n\n\u003cbr\u003e\n\n==**concurrency control**== makes any schedule serializable\n- 어떤 스케쥴도 serializable 하게 만드는 역할을 수행하는 것이 바로 **동시성 제어**이다.\n- 이것과 밀접하게 연관된 트랜잭션의 속성이 바로 **Isolation** 이다.\n\t- isolation을 너무 엄격하게 지켜서 serializability를 완벽하게 추구하면, 그만큼 동시성이 줄어들어서 성능은 떨어지게 된다.\n\t- 그래서 이 isolation을 좀 완화시켜서 개발자의 필요에 따라 유연하게 선택할 수 있도록 한 개념이 바로 **isolation level**이다.","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/hussein-db/":{"title":"Hussein DB","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/hussein-db/lecture00":{"title":"강의소개","content":"\n유데미 Hussein Nasser님의 \u003ca href='https://www.udemy.com/course/database-engineering-korean' target='_blank'\u003e데이터베이스 엔지니어링 마스터 강의\u003c/a\u003e를 정리한 노트\n\n\u003chr\u003e\n\n강의 노트 요약\n- 워크로드\n\t- 컴퓨팅 리소스가 작업 완료 또는 결과 도출을 위해 수행하는 처리 작업의 유형과 양을 의미\n\t- 컴퓨터에서 실행하는 모든 애플리케이션이나 프로그램은 워크로드로 간주할 수 있으므로 워크로드는 실행하는 작업의 유형과 수에 따라 크게 달라질 수 있음\n\n- NoSQL은 특정 데이터베이스의 워크로드를 나타내는 이름일뿐\n\t- DB라는 본질은 변하지 않음\n\t- 효율적으로 데이터를 저장할 계획, 검색할 계획을 세워야함\n\n\u003chr\u003e\u003cbr\u003e\n\n1. [01. ACID](brain/Lecture/db/hussein-db/lecture01.md)","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/db/hussein-db/lecture01":{"title":"01. ACID","content":"\n유데미 Hussein Nasser님의 \u003ca href='https://www.udemy.com/course/database-engineering-korean' target='_blank'\u003e데이터베이스 엔지니어링 마스터 강의\u003c/a\u003e를 정리한 노트\n\n\u003chr\u003e\n\n## ACID 소개\n\n==**ACID**==\n- 관계형 데이터베이스 시스템(RDB)의 중요한 속성\n\n\u003cbr\u003e\n\n==**Agenda**==\n- What is a Transaction?\n- Atomicity (원자성)\n\t- 왜 일관성을 보장하는데 원자성이 가장 중요할까?\n- Isolation (고립성)\n\t- 트랜잭션이 고립되어있다는 것은 무슨 의미일까?\n\t- 여러 트랜잭션을 동시에 시작하면 이 모든 것들이 내 데이터에 접근하고 변경을 하려하면?\n\t- 그들이 무엇을 볼 수 있는지, 보아서는 안되는 지?\n\t- 이 모든 것들이 일관성에 영향을 끼침\n\t- 일관성 이야기에 앞서서 원자성과 고립성을 먼저 이야기하는 것이 중요하다 생각하여 순서를 배치함\n- Consistency (일관성)\n- Durability (지속성, 영속성)\n\t- 트랜잭션을 커밋하거나 저장할 때 실제로 데이터가 비휘발성 저장소에 지속적으로 저장되어 내 데이터에 접근할 수 있어야 한다.\n\t- DB가 충돌하거나 전원이 꺼져도 내 데이터에 여전히 접근할 수 있어야 한다.\n\n\u003cbr\u003e\u003chr\u003e\n\n## 트랜잭션이란?\n\n==**Transaction**==\n- 하나의 작업 단위\n- 하나의 작업 단위로 취급되는 SQL 쿼리들의 모음\n- 트랜잭션은 데이터를 변경할 수도, 읽기 전용일 수도 있음\n- 트랜잭션은 항상 시작됨\n\t- 만약, 우리가 트랜잭션을 시작하지 않으면 DB 쪽에서 우리 대신 시작함\n\t- 사용자가 정의한 트랜잭션일 수도, 시스템에 의해 암시적으로 정의한 트랜잭션일 수도 있음\n\n데이터는 구조화되어있고, 여러 테이블을 가지고 있기에 하나의 쿼리로 원하는 모든 작업을 수행하기에 어려움\n\n\u003cbr\u003e\n\n### 트랜잭션의 수명\n\n- Transaction **BEGIN**\n- Transaction **COMMIT**\n- Transaction **ROLLBACK**\n- Transaction **unexpected ending = ROLLBACK (ex. crash)**\n\n\u003cbr\u003e\n\n트랜잭션은 항상 여러 쿼리가 포함된 새로운 트랜잭션을 시작하겠다는 것을 DB에 알리는 **BEGIN**으로 시작\n- 작성한 쿼리를 모두 만족하는 트랜잭션이 지속성을 갖는 것은 아님\n- 트랜잭션의 수명 동안 내가 진행한 모든 변경사항을 커밋하여 디스크에 영구적으로 저장하라고 알려줘야함\n\n\u003cbr\u003e\n\n**1000개의 쿼리를 실행하고 1000개의 변경을 커밋한다고 하자. 어떻게 DB를 구축할래?**\n1. 모든 변경을 실제로 디스크에 모두 쓰는 경우\n2. 기다렸다가 메모리에 모은 다음, 커밋할 때 한꺼번에 디스크에 쓰는 경우\n\n첫 번째 방법은 커밋을 빠르게 할 것이고, 두 번째 방법은 커밋을 느리게 할 것이지만 디스크 I/O가 줄어들겠지. 모든 것에는 장단점이 있음\n\n\u003cbr\u003e\n\n**예를 들어, 권장되지는 않지만 50,000개의 쿼리를 실행하다가 문제가 생겼다고 하자. 롤백해야겠지?**\n- 중간에 진행되었던 변경사항을 커밋하지말고 모든 변경사항을 되돌려\n- 위의 1000개 쿼리 문제도 다시 생각해보자. 이 모든 시간동안 쿼리를 실행할 때 실제로 디스크에 영구적으로 저장되어있는지 확인하나요?\n\t- 만약, 그러한 작업을 한다면 모든 작업을 되돌려야 하는데 그것 또한 엄청나게 많은 작업...\n- 두 번째 방법처럼 메모리에 모으는 경우라면 실제 디스크에는 아무것도 쓰지 않았기에 롤백이 더 빨라질 것 → 그냥 메모리 비우면 되잖아 ~\n- 롤백을 위한 undo, redo 공간이 있으며 모든 변경사항에 대해 작동함\n\n\u003cbr\u003e\n\n**예를 들어, 권장되지는 않지만 20,000개의 쿼리를 실행하다가 시스템이 다운되었다고 하자.**\n- 롤백해야하는데 데이터베이스 시스템이 다운됐어. 어떻게 할래?\n- 데이터베이스가 다시 시작할 때, 이를 롤백해야함\n\n\u003cbr\u003e\n\n**이러한 방법들을 실제 구현하는 것은 MySQL, Postgres, Oracle 등 각각 다르게 구현됨**\n- 시스템 다운에 최적화 할 지, 커밋에 최적화 할 지 등등\n- Postgres는 커밋을 가장 빠르게 처리함\n\t- 트랜잭션 중에 실행된 모든 쿼리 변경사항을 영구적으로 저장하도록 시도하기 때문\n\t- Postgres는 많은 I/O를 수행하지만 커밋은 아주 빠름\n\t- 커밋 자체가 빠르기에 커밋 중에 시스템이 다운되는 상황이 발생할 가능성이 낮아짐\n\n\u003cbr\u003e\n\n### 트랜잭션의 본질\n\n- 트랜잭션은 데이터를 변경하고 수정하는데 사용됨\n- 하지만, 실제로는 **읽기 전용 트랜잭션을 가지는 것도 좋음**\n\t- DB에게 읽기 전용 트랜잭션이라고 알려주는 것\n\t- 읽기만 하려면 트랜잭션 없이 각 쿼리를 자체 트랜잭션으로 처리하면 안되나?\n\t\t- Consistency(일관성)을 위해 읽기만 하더라도 트랜잭션이 필요함\n\n\u003cbr\u003e\n\n**예를 들어, 보고서를 생성하고 거래시간을 기준으로 일관된 스냅샷을 얻고자 하는 상황**\n- 트랜잭션에서 제공하는 것은 작업해야할 이 그룹뿐만 아니라 트랜잭션이 시작한 시간의 스냅샷까지 얻어야함\n- 내가 읽는 모든것은 처음 시간을 기준으로 하기를 원함\n- 이것이 읽기 전용 트랜잭션의 힘인데, 무엇이든지 읽을 때 무언가가 동시 트랜잭션 때문에 바뀐다고 하더라도 우리는 신경쓸 필요가 없어짐 → Isoloation 파트에서 더 알아보자\n\n\u003cbr\u003e\n\n**예시**\n\n![](brain/image/lecture01-23.png)\n\n- 계좌의 잔액이 음수가 되는 것은 마이너스 통장과 같은 특별한 상황이 아니라면 의미 X\n- 즉, 음수인 데이터가 발생하면 **일관성이 없는 데이터를 의미**\n\u001f\n\n\u003cbr\u003e\u003chr\u003e\n\n## 원자성 (Atomicity)\n\n- 트랜잭션 내의 모든 쿼리는 성공해야함, 나눌 수 없는 원자처럼 취급함\n- 만약, 하나의 쿼리가 실패하면?\n\t- 잔고가 마이너스로 가거나, 중복된 키 항목이 생기거나, 잘못된 SQL 구문이 있거나 등\n\t- 같은 트랜잭션 내에 성공한 쿼리가 100개가 있다고 하더라도 하나의 실패한 트랜잭션으로 인해 즉시 롤백되어야함\n- 만약, 트랜잭션 실행 중에 데이터베이스가 다운된다면?\n\t- 커밋 이전에 다운된다면 실제로 트랜잭션을 커밋하지 않았음\n\t- 모든 성공한 쿼리와 트랜잭션은 롤백되어야함\n\t- 그런데, 데이터베이스가 다운되어 롤백을 못하잖아\n\t\t- → **데이터베이스가 다시 시작되었을 때 데이터베이스는 실패가 있었다고 감지해야함**\n\n\u003cbr\u003e\n\n**결국, 데이터베이스마다 실제 구현이 달라서 트레이드오프를 고려하여 선택해야 함**\n- 어떤 DB는 모든 트랜잭션을 커밋하기도 전에 모든 변경사항을 디스크에 기록함\n\t- 사용자가 커밋할 것이라고 낙관적으로 가정하는 것\n\t- 실제로, 커밋 당시에 어떤 작업도 추가적으로 진행하지 않고 그냥 \"이 트랜잭션이 커밋되었다\" 정도만 작성함\n\t- 쿼리의 속도는 느리지만 커밋의 속도는 빠름\n- 어떤 DB는 디스크에 기록하지 않고 메모리에 모아놨다가 한 방에 flush\n\t- 쿼리의 속도는 빠르지만 커밋의 속도는 느림\n\t- 롤백은 상대적으로 빠름\n\t\t- 디스크에 기록하지 않았고, 메모리만 비워버리면 되니까\n\n\n\n\u003cbr\u003e\u003chr\u003e\n\n## 고립성 (Isolation)\n\n\u003cbr\u003e\u003chr\u003e\n\n## 일관성 (Consistency)\n\n\u003cbr\u003e\u003chr\u003e\n\n## 지속성 (Durability)\n\n\u003cbr\u003e\u003chr\u003e\n\n## ACID 실전 예제\n\n\u003cbr\u003e\u003chr\u003e\n\n## Phantom Reads\n\n\u003cbr\u003e\u003chr\u003e\n\n## 읽기 방식 비교\n\n\u003cbr\u003e\u003chr\u003e\n\n## 궁극적 일관성","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/etc/":{"title":"ETC","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/etc/apple-git/":{"title":"코딩애플 - Git","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/etc/apple-git/apple-git":{"title":"코딩애플 git","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/git-and-github/' target='_blank'\u003e코딩애플의 git/github 강좌\u003c/a\u003e의 필기와 제가 알던 지식을 정리한 글 입니다. \n\n\u003chr\u003e\n\n## git 세팅\n\n\u003cbr\u003e\n\n**Windows**\n\n1. 구글에 git windows 검색 후 다운\n2. 설치 과정에서 `Use Visual Studio Code as Git's default editor` 체크\n3. 설치 과정에서 `Override the default branch` 체크하고 원하는 branch 명 \u003cbr\u003e 현재, 깃과 깃허브 기본 브랜치를 **master**로 설정해놨음\n4. 설치 과정에서 기본 에디터 체크 안했다면 `git config --global core.editor \"code --wait\"`\n5. 기본 브랜치 바꾸는 명령어는 `git branch -M 브랜치명`\n\n\u003cbr\u003e\n\n**mac**  \n\n1. 구글에 Homebrew 검색 후 설치\n2. 터미널에 `brew install git` 입력 후 깃 설치\n3. `git config --global init.defaultBranch master` 기본 브랜치 master 설정\n4. `git config --global core.editor \"code --wait\"` 기본 에디터 vscode 설정\n5. 만약, 기본 브랜치 바꾸는 명령어는 `git branch -M 브랜치명`\n\n\u003cbr\u003e  \n\n```bash\ngit config --global init.defaultBranch master\ngit config --global core.editor \"code --wait\"\ngit config --global user.email \"github 아이디\"\ngit config --global user.name \"이름\"\ngit config --global core.autocrlf true # windows\ngit config --global core.autocrlf input # mac\n```\n\n\u003cbr\u003e\n\n### 현재 세팅\n\n```bash\n[user]\n    name = jae_yoon(mac)\n    email = wlwhsvkdlxh@gmail.com\n\n[init]\n    defaultBranch = master\n\n[core]\n    editor = code --wait\n    autocrlf = input\n\n[push]\n    default = current\n\n[pull]\n    rebase = true\n\n[diff]\n    tool = vscode\n\n[difftool \"vscode\"]\n    cmd = code --wait --diff $LOCAL $REMOTE\n\n[alias]\n    hist = log --graph --all --pretty=format:'%C(yellow)[%ad]%C(reset) %C(green)[%h]%C(reset) | %C(white)%s %C(bold red)[[%an]]%C(reset) %C(blue)%d%C(reset)' --date=short\n\n[merge]\n    tool = vscode\n\n[mergetool \"vscode\"]\n    cmd = code --wait $MERGED\n\n[mergetool]\n    keepBackup = false\n```\n\n\u003chr\u003e\n\n## git 명령어\n\n### 기본 명령어\n\n![[brain/image/apple-git-1.png]]\n\n  \n\n```bash\ngit init # 초기 폴더를 git 사용할 수 있게\ngit add file_name # 작업 폴더 -\u003e staging area\ngit commit -m \"memo\" # staging area -\u003e repository\ngit status # staging area 목록 확인\ngit log --all --oneline # commit 내역 한 줄로 조회\ngit commit --amend -m \"메모\" # 가장 최근 commit 내용 변경\n```\n\n작업 폴더에서 staging area로 올릴 파일을 고르는 행위를 **스테이징 한다** 라고 함\n\ngit add는 파일을 새로 추적할 때도 사용하고\n\n수정한 파일을 staged 상태로 만들 때도 사용한다.\n\n\u003cbr\u003e\n\n### git diff\n\n- `git diff` : 최근 commit과 현재 파일의 차이점 보여줌\n\n- j, k로 스크롤바 조작 / q로 종료\n\n- diff가 엔터키 하나, 스페이스바 하나만 했다고 해도 차이점으로 보여주기 때문에 좀 쓰레기 같음\n\n- `git difftool` : vi 에디터 형태로 비교해서 편하게 보여줌\n\n- vi에디터 기본 동작키 h, j, k, l, `:q` 이런거 사용\n\n- `git difftool 커밋아이디` : 현재 파일과 특정커밋 비교 가능\n\n- 사실 difftool도 쓰레기라... 그냥 vscode로 설정하고 보자\n\n- vscode extensions에서 git graph 다운받으면\n\n\u003cbr\u003e\n\n```bash\ngit config --global diff.tool vscode\ngit config --global difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE'\ngit difftool\n```\n\n\u003cbr\u003e\n\n### vscode git\n\n![](brain/image/apple-git-2.png)\n\n1. 1번 버튼 누르면 사용 가능\n\n2. 플러스 모양 눌러서 `작업폴더 -\u003e staging area`\n\n3. 마이너스 모양 눌러서 `staging area -\u003e 작업폴더`\n\n4. 체크 모양 눌러서 `staging area -\u003e repository`\n\n5. 그래프 모양 눌러서 브랜치 별 커밋 내용들, 각 파일 눌러서 diff 모두 확인 가능\n\n\u003cbr\u003e  \n\n### git branch\n\n![](brain/image/apple-git-3.png)\n\n```bash\ngit branch 브랜치명 # 브랜치 생성\ngit switch 브랜치명 # 브랜치로 이동\ngit log --all --oneline --graph # branch 그래프 모양도 같이 보기\ngit merge 브랜치명 # 현재 위치(HEAD)에 브랜치명을 병합\n```\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-4.png)\n\n- 충돌이 났을 때, 어떤 것을 적용할 지 선택하고 꼭 git add, git commit 해주자.\n\n- merge는 현재 위치(HEAD)에 브랜치를 병합하는 과정이다. 따라서 switch로 브랜치 이동을 꼭 해주고 병합하자.\n\n- 과거에는 checkout을 주로 썼는데, checkout은 만능인 반면 switch는 정말 브랜치 이동만 한다. 무지성 checkout 하는걸 염려해서 브랜치 이동은 `switch`, 스테이징 취소는 `git restore --staged \u003cfile\u003e` 명확하게 나눠서 사용하는 추세인 듯 하다.\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-5.png)\n\n![](brain/image/apple-git-6.png)\n\n- git graph로 보면 시간 순서가 완벽하게 되어있는데, git log는 그래보이진 않음\n\n\u003cbr\u003e\n\n```bash\ngit branch # 브랜치 목록 확인 (로컬)\ngit branch -r # 브랜치 목록 확인 (원격 ex.github)\ngit branch -a # 브랜치 목록 확인 (전체)\ngit branch -d 브랜치명 # 브랜치 삭제 (로컬저장소)\ngit push origin --delete 브랜치명 # 브랜치 삭제 (원격저장소)\n```\n\n\u003cbr\u003e\n\n```bash\ngit branch -d 브랜치명 # merge 완료된 브랜치 삭제\ngit branch -D 브랜치명 # merge 안한 브랜치 삭제\n# 깔끔하게 그 브랜치에서 작업한거 싹 날라감\n\ngit branch -m 변경전 변경후 # 브랜치명 변경\ngit branch -M 브랜치명 # 기본 브랜치 변경\n```\n  \n\u003cbr\u003e\n\n### git hist\n  \n\u003cbr\u003e\n\n`git hist`는 실제로는 없는 명령어이다. 매번 `git log --all --oneline --graph` 이런식으로 작성하기 귀찮으니까 `alias` 기능으로 만든 것이다. 일종의 커스텀 기능이다. 원래 oneline만 하면 날짜나 누가 커밋했는지는 안나와서, 내가 커스텀 한 것은 아래와 같다.\n\n```bash\ngit config --global alias.hist \"log --graph --all --pretty=format:'%C(yellow)[%ad]%C(reset) %C(green)[%h]%C(reset) | %C(white)%s %C(bold red)[[%an]]%C(reset) %C(blue)%d%C(reset)' --date=short\"\n```\n\n![](brain/image/apple-git-7.png)\n\n- 날짜, 커밋명 간단히, 커밋내용, 커밋작성자, 브랜치 다 보인다.\n\n- 보면 git config user name을 수정했었는데, `origin/master`, `orign/HEAD` 저기까지가 깃허브에 git push로 올렸던 커밋들이다. 그 이후 user name을 저렇게 수정했었다. 아직은 push 하지 않은 상태라 브랜치가 coupon, HEAD -\u003e master 이렇게 되어있는 모습이다.\n\n- vim 환경이기 때문에 j가 아래 방향키, k가 위 방향키로 잘먹는다.  \n\n\u003chr\u003e\n\n## 방법론\n  \n\u003cbr\u003e\n\n### 3-way merge\n\n![](brain/image/apple-git-8.png)\n\n- 신규 브랜치, merge 하고자 하는 중심 브랜치 각각에 새로운 commit이 있을 때 merge하면 두 브랜치의 코드를 합쳐서 새로운 commit을 자동으로 생성\n\n- 3-way merge 방식은 merge 했다는 흔적이 남게 된다.\n\n- 3-way 방식이 싫은 경우 강제로 \u003ca href='/brain/Lecture/apple/apple-git/apple-git/#rebase-and-merge'\u003erebase하여 fast-forward 방식\u003c/a\u003e을 사용하거나 \u003ca href='/brain/Lecture/apple/apple-git/apple-git/#squash-and-merge'\u003esquash and merge 방식\u003c/a\u003e을 사용한다.\n\n\u003cbr\u003e  \n\n모든 브랜치를 3-way merge 해버리면 나중에 참사가 일어날 수 있다.\n\n![](brain/image/apple-git-9.png)\n\n- 3-way merge 되면, 흔적이 남아서 매우 복잡하게 보인다.\n\n![](brain/image/apple-git-10.png)\n  \n- master branch의 git log를 출력해보면 3-way merge 된 branch들의 commit 내역도 다 같이 출력되어서 보기 더럽다. (ex. 깃허브에서 커밋 내역 볼 때)\n\n이러한 참사를 해결하기 위하여 **squash and merge 방식**을 사용하곤 한다.\n\n\u003cbr\u003e\n\n### fast-forward merge\n\n![](brain/image/apple-git-11.png)\n  \n- 신규 브랜치에만 새로운 commit이 있고 merge 하고자 하는 브랜치에는 새로운 commit이 없는 경우 사용하는 merge 방식\n\n- 그냥 신규 브랜치보고 지금부터 너의 이름은 master 브랜치야! 라고 한다.\n\n- 그래서 merge한 흔적이 남지 않는다.\n\n- fast-forward merge가 싫은 경우 강제로 `git merge --no --ff 브랜치명`으로 강제로 3-way merge 할 수 있다.\n\n\u003cbr\u003e\n\n### rebase and merge\n\n![](brain/image/apple-git-12.png)\n\n- rebase는 브랜치의 시작점을 다른 commit으로 옮겨주는 것\n\n- 신규 브랜치, merge 하고자 하는 중심 브랜치 각각에 새로운 commit이 있을 때 신규 브랜치의 시작점을 merge 하고자 하는 중심 브랜치의 가장 최근 commit으로 옮기고 fast-forward 방식으로 merge 한다.\n\n- 3-way merge가 싫을 때 사용할 수 있다.\n\n- 역시나 merge한 흔적이 남지 않는다.\n\n- 단, rebase를 사용했기 때문에 master branch의 새로운 커밋과 **conflict 할 가능성이 매우 높아진다.**\n\n\u003cbr\u003e\n\n**rebase and merge 사용법**\n\n1. rebase 할, 시작점 바꾸고 싶은 브랜치로 이동\n\n2. `git rebase merge할 브랜치명`\n\n3. 그 다음 이동하여 fast-forward merge\n\n```bash\ngit switch sub\ngit rebase master\ngit switch master\ngit merge sub\n```\n\n\u003cbr\u003e\n\n### squash and merge\n\n![](brain/image/apple-git-13.png)\n\n- 3-way merge가 너무 많아서 git log 보기 힘들까봐 주로 사용\n\n- merge 흔적이 남지 않음\n\n- 브랜치에서 만들어놨던 많은 commit을 모두 합쳐서 하나의 commit으로 master 브랜치에 생성해줌  \n\n\u003cbr\u003e\n\n**squash and merge 사용법**\n\n```bash\ngit switch master\ngit merge --squash 브랜치명\ngit commit -m \"메세지\"\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 그래서 어떤 방식?\n\n\u003cbr\u003e  \n\n- 프로젝트 마다, 팀마다 branching/merge 가이드가 존재\n\n- 예를 들어, 안중요한 잔챙이 브랜치는 **squash**하세요.\n\n- feature/develop 브랜치는 **3-way merge**하세요.\n\n- 혼자서 할 때는 대충 쓰세요.\n\n\u003chr\u003e\n\n## git merge 실습\n\n실습과정에서, branch를 만드는 시점은 중요하다. 예를 들어, commit2에서 git branch를 이용하며 브랜치를 생성하면 commit2가 시작지점이 되는 것이니까. 이를 잘 이해하며 실습을 시작한다.\n\n### 3-way merge 실습\n\n![](brain/image/apple-git-14.png)\n\n- 분기되었던 모습, 즉, merge된 흔적이 남아있다.\n\n- `git branch -d 3-way`로 브랜치를 지워도 그래프 모양으로 나타난다.\n\n- 3-way merge는 각각의 브랜치가 합쳐져서 새로운걸 만들어내는 형태라 mergetool이 따로 열렸다. 그래서 Merge branch 'commit4'와 같이 커밋을 남겼다.\n\n\u003cbr\u003e\n\n### fast-forward 실습\n\n![](brain/image/apple-git-15.png)\n\n- fast-forward 방식은 master 브랜치에 새로운 commit이 없으니까 master 브랜치의 HEAD만 fastforward 브랜치로 바뀐 모습이다.\n\n- 따라서, merge 흔적이 남아있지 않다.\n\n- HEAD만 바뀌는 형태라 mergetool이 따로 열리지 않았다.\n\n- HEAD가 `(HEAD -\u003e master, fast)` 이런식으로 나타났다.\n\n\u003cbr\u003e\n\n### rebase and fast-forward 실습  \n\n![](brain/image/apple-git-16.png)\n\n- rebase 하기 전 모습\n\n![](brain/image/apple-git-17.png)\n\n- rebase 이후 모습\n\n- 그래프에서 분기가 사라짐을 확인 가능하다.\n\n![](brain/image/apple-git-18.png)\n\n- rebase 이후 fast-forward 한 모습\n\n- fast-forward 방식과 동일하게 HEAD만 바뀐 모습이다.\n\n\u003cbr\u003e\n\n### squash and merge 실습\n\n![](brain/image/apple-git-19.png)\n\n- squash 하기 이전 모습\n  \n![](brain/image/apple-git-20.png)\n\n- squash를 하고 나서 squash는 되었지만, HEAD는 업데이트가 되지 않았다고 한다. commit을 추가적으로 하고 log를 확인해보면\n\n![](brain/image/apple-git-21.png)\n\n- commit4가 정상적으로 생성된 모습이다. 하지만 squash 브랜치는 남아있다. 그래서 `git branch -D squash`로 브랜치를 삭제해보면\n\n![](brain/image/apple-git-22.png)\n  \n- 이와 같이 깔끔하게 merge 흔적이 사라진 모습이다.\n\n- squash로 merge하면 브랜치의 내용이 순간이동하는 개념이라 squash 브랜치는 아직 merge 되지 않았다고 나왔다. 그래서 `git branch -d squash`가 아닌 `git branch -D squash`로 삭제했다.\n\n\u003chr\u003e\n\n## git 되돌리기\n\n\u003cbr\u003e\n\n### git restore  \n\n- 파일 하나를 수정하고 싶은데 ctrl + z로 수정하기에 수정사항이 너무 많다면 사용\n\n- 해당하는 commit 시점으로 파일 내용 되돌림\n\n```bash\ngit restore 파일명\ngit restore --source 커밋아이디 파일명\ngit restore --staged 파일명\n```\n\n예를 들어, `a.txt` 파일 작업 중, 내용1을 입력하고 커밋1, 내용2를 입력하고 커밋2를 한 상태라고 하자. 내용3을 입력했다가 뭔가 이상해서 파일 내용을 돌리려고 하면 `git restore a.txt`를 사용해서 가장 최신 커밋으로 돌리자.  \n\n만약, 가장 최신 커밋보다 이전의 커밋으로 내용을 돌리고 싶으면 `git restore --source 커밋아이디 파일명`으로 돌아가자.\n\n`git add`로 작업폴더에서 staging area로 올렸다가 staging area에서 다시 작업폴더로 내리고 싶으면, 즉, 스테이징을 취소하고 싶으면 `git restore --staged 파일명`을 사용하도록 하자.\n\n\u003cbr\u003e  \n\n### git revert\n\n- commit을 취소하고 싶은 경우 revert 사용\n\n- commit을 없애는 건 아니고 commit 하나를 취소한 commit을 하나 생성해줌\n\n![](brain/image/apple-git-23.png)\n\n- 예를 들어, b파일을 만든 **244ef15** commit을 취소하고싶음.\n\n- `git revert 244ef15`를 입력하면 에디터가 열림. 그리고 새로운 commit을 하나 추가해줌.\n\n- 결과적으로 244ef15에서 일어난 commit을 취소해줌\n\n- 작업폴더에서 a파일과 c파일만 있고 b파일은 사라져있을 것\n\n- merge로 생성된 commit도 취소 가능\n\n```bash\ngit revert 커밋아이디\ngit revert 커밋아이디1 커밋아이디2\ngit revert HEAD # 가장 최근 commit 취소\n```\n\n\u003cbr\u003e\n\n### git reset\n\n- 특정 commit 시절로 아예 모든 것을 되돌려버림  \n\n```bash\ngit reset --hard 커밋아이디\ngit push -f # 원격저장소에도 업데이트 하기\n```\n\n![](brain/image/apple-git-24.png)\n\n- git revert 예제에서 git reset --hard 한 모습\n\n- 아예 c파일 생성, revert b 커밋 자체가 날라간 모습\n\n- (주의) 따라서, 협업시 사용금지. 갑자기 커밋을 다 날려버릴 수도 있기 때문이다.\n\n\u003cbr\u003e\n\n혼자 작업할 때도 reset을 잘 사용하지는 않는다. 기억 잃고 7살로 되돌아갈래?라고 한다면 안돌아가지 않을까. 미래 기억을 reset은 삭제해버리니까 좀 쫄린다.  \n\n```bash\ngit reset --soft 커밋아이디\n```\n\n- 리셋이긴 한데, 변동사항을 지우지는 않고 staging area에 올려놓는다. 사용하려면 git commit 하면 됨\n\n```bash\ngit reset --mixed 커밋아이디\n```\n\n- 리셋이긴 한데, 변동사항을 지우지는 않고 staging area에도 올려놓지 않는다. 사용하려면 git add, git commit 둘다 해야함\n\n\u003chr\u003e\n\n## git push\n\n- 로컬 repository를 원격 repository로 올리기\n  \n```bash\ngit push -u 원격저장소주소 올릴로컬브랜치명\ngit remote add 변수명 주소\ngit push origin 올릴로컬브랜치명\ngit remote -v # 변수목록 확인\ngit clone 원격저장소주소 # 원격저장소 받아오기\n```\n\n- `git push -u https://github.com/Shin-Jae-Yoon/TIL.git master`라고 하면 로컬의 master 브랜치가 해당하는 원격저장소에 push 된다.\n\n- 매번 주소 치기 귀찮으니까 remote 기능 이용해보자.\n\n- `git remote add origin https://github.com/Shin-Jae-Yoon/TIL.git`이라고 하면 git 주소를 origin 변수에 저장한 것이다.\n\n- `git push -u origin master`이라고 하면 위의 것과 같은 말이다.\n\n- `-u` 옵션은 주소를 기억하라는 옵션이라서 앞으로는 `git push`만 입력해도 될 것 이다.\n\n\u003cbr\u003e  \n\n### .gitignore\n\n원격저장소에 쓸데없는 파일은 commit해서 올리지 않도록 하는 것이 좋은데, `.gitignore` 파일을 만들면 원격저장소에 올리지 않을 파일들을 쉽게 명시 가능하다. 명시된 파일들은 git add 해도 스테이징 되지 않는다.\n  \n예를 들어, `node_modules`는 깃허브에 올리지 않는다. 어차피 `package.json` 파일만 잘 있으면 `npm install` 했을 때 자동으로 `node_modules` 폴더가 생성되니까.\n\n\u003chr\u003e\n\n## github 이용 협업\n\n- 기본적으로 `git clone 원격저장소` 하는 것부터 시작한다.\n\n- 팀원도 push 하고 싶으면 깃허브의 settings -\u003e Access -\u003e Collaborators -\u003e Manage access에서 팀원 깃헙아이디를 등록해놔야 push 가능해진다.  \n\n\u003cbr\u003e\n\n### 다른 팀원이 최근에 git push 한 경우\n\n다른 팀원이 최근에 git push 한 경우에 내가 git push를 하지 못하는 경우가 있을 수 있다. 즉, 원격저장소에 변동사항이 생겨서 새로운게 생기면 git push 하지 못한다. 이런 경우 `git pull`로 먼저 원격저장소의 내용을 가져와서 업데이트 해야 한다.\n  \n\n```bash\ngit pull origin 브랜치명\n# 원격저장소에서 해당하는 branch만 pull 가능\n```\n\ngit pull은 엄밀히 말하면 `git fetch + git merge`이다. 원격 저장소의 신규 commit을 가져오고 내 브랜치에 merge 하는 것이다. 이 말은 merge 과정에서 conflict 발생 가능성이 있다는 말이다. 뭐 conflict 나면 에디터 열고 수정해야지 ...\n\n\u003cbr\u003e\n\n### pull request\n\n- 프로젝트를 할 때 branch를 쪼개서 작업하는 경우가 많아질 것\n\n- 예를 들어, `git push origin feature`로 feature 브랜치를 로컬에서 생성하고 작업하고 있다고 가정하자. (물론, 깃허브에서 브랜치 생성하고 pull 해왔어도 가능)\n\n- feature가 잘 작동해서 master 브랜치에 merge 하려고 한다.\n\n- github에서 merge 하거나\n\n- 로컬에서 merge 한 다음 push 하거나\n\n- 협업할 때는 merge 하기 전에 검토를 하는 경우가 일반적\n\n- github의 pull request 기능을 이용해보자.\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-25.png)\n\n1. 로컬 환경에서 만든 다른 브랜치로 작업하고 `git push origin 만든브랜치` 해서 브랜치에서 작업한 내용을 원격 repository로 push\n\n2. github에서 pull requests 탭 들어가서 pull request 생성\n\n3. 검토해보고 merge 될 것 같으면 3가지 옵션 중 선택해서 merge\n\n4. conflict 발생했다면 github에서 수정 가능하니까 conflict 해결하기\n\n5. 다쓰고 나면 브랜치 삭제해주고 이런건 알아서 하기\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-26.png)\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-27.png)\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-28.png)\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-29.png)\n  \n\u003cbr\u003e\n\n![](brain/image/apple-git-30.png)\n\n\u003cbr\u003e\n\n![](brain/image/apple-git-31.png)\n\nmerge 전략 3가지 역시 깃허브에 반영되어있음.\n\n\u003cbr\u003e\n\n1. create a merge commit\n\n새로운 merge commit 생성해주는 \u003ca href='/brain/Lecture/apple-git/apple-git/#3-way-merge'\u003e3-way-merge\u003c/a\u003e를 실행한다. master 브랜치 조회해보면 합쳐진 브랜치의 commit 내역도 전부 나온다. 역시 git log를 보면 합쳐진 브랜치도 나오기 때문에 commit 내역이 많으면 복잡하고 더러워 보일 수 있다.\n\n\u003cbr\u003e\n\n2. squash and merge\n\n합쳐질 브랜치의 commit 내역을 하나로 합쳐서 master 브랜치에 신규 commit을 생성해준다. git log를 보면 합쳐진 브랜치는 안나온다. commit을 하나로 합쳐서 master 브랜치로 순간이동하는 방식이라 많은 사람이 선호한다.\n\n\u003cbr\u003e\n\n3. rebase and merge\n\n합쳐질 브랜치를 master 브랜치 최신 commit으로 rebase 하고 나서 fast-forward merge 같은 작동을 해준다. 결과는 squash and merge와 비슷한데, 합쳐질 브랜치의 commit 내역이 전부 보존된다. 하지만, git log에는 합쳐진 브랜치가 나오지 않는다.\n\n\u003chr\u003e\n\n## 브랜치 전략\n\n- 프로젝트 커지고 사람 많아져도 branch, merge를 깔끔하게 하려고 사용하는 전략들이 있다. **GitFlow, Github Flow, Trunk-based, Gitlab Flow**\n\n\u003cbr\u003e  \n\n### Git Flow 전략\n\n![](brain/image/apple-git-32.png)\n\n![](brain/image/apple-git-33.png)\n\n![](brain/image/apple-git-34.png)\n\n**GitFlow** 개발 전략은 게임 개발 같이 항상 안정적인 release를 해야하는 경우에 사용하기 적합하다. 크게 5개 브랜치를 운영한다.\n\n- main 브랜치\n\n- develop 브랜치 (개발용, main 브랜치의 복사본)\n\n- feature 브랜치 (develop에 기능 추가용)\n\n- hotfix 브랜치 (main 브랜치 버그 픽스용)\n\n- release 브랜치 (develop 브랜치를 main 브랜치에 merge 하기 전 최종 테스트본, 가끔 사용)\n\n장점은 안정적이지만, 단점은 간단한 개발의 경우 리소스 낭비가 심할 수 있다. 간단한 작업임에도 매번 develop 브랜치~ release 브랜치~ 이런식으로 진행해야하니까. 최근 CI/CD를 도입하는 회사가 많이 늘었는데, 그런 경우에 git flow 전략은 적합하지 않다.\n\n\u003e \u003ca href='https://seosh817.tistory.com/104' target='_blank'\u003eCI/CD\u003c/a\u003e에 관한 것은 해당 링크에 자세히 설명되어있다.\n\n  \n\n\u003cbr\u003e\n\n  \n\n### Trunk-based 전략\n\n![](brain/image/apple-git-35.png)\n\n코드 짠 것을 대충 배포해도 상관없거나 굳이 큰 업데이트가 없는 안정적인 프로그램의 경우, git flow 처럼 많은 브랜치를 만드는 것보다 해당하는 **Trunk-based 전략**이 더 적합할 수 있다. 그냥 main 브랜치와 기능추가용 feature 브랜치만 사용하면 된다. **github flow**도 해당하는 전략과 비슷하다.\n\n1. 기능추가, 버그픽스가 필요하면 main 브랜치에서 새로운 브랜치를 분기하여 코드 작성\n\n2. 기능이 완성되면 main 브랜치에 merge (다 쓴 브랜치 삭제)\n\n3. main 브랜치를 필요할 때마다 배포\n\n\u003cbr\u003e\n\n**장점**은 코드를 한 브랜치에서만 관리하기에 편하다는 점이다. 이때 크게 개발하고 한 번에 merge 하는 것보다 작은 단위로 자주 merge 하는 것이 더 안전하다. **단점**은 역시 main 브랜치의 코드가 뻑이 나면 큰일나서 테스트나 코드 리뷰를 자주해야 한다. 그래서 테스트와 배포를 자동으로 하는 \u003ca href='https://seosh817.tistory.com/104' target='_blank'\u003eCI/CD\u003c/a\u003e를 도입한 곳에서 자주 사용한다.\n\n\u003chr\u003e\n\n## git stash\n\n- 코드를 작성하다가 잠시 보관하고 싶을 때 사용\n\n- 최근 commit과 차이점 있는 부분 전부 보관\n\n- 스테이징 되었든 안되었든 모두 stash 된다\n\n- 하지만, 스테이징 안해놓은 새로운 파일 (untranked file 인듯)은 stash 안될 수도 있다.  \n\n\u003cbr\u003e\n\n\n**stash 되는 파일 목록** \u003cbr\u003e\u003cbr\u003e\n\nstash란 아래에 해당하는 파일들을 보관해두는 장소 이다.\n\n1. Modified이면서 Tracked 상태인 파일\n\n\t- Tracked 상태인 파일을 수정한 경우\n\n\t- Tracked: 과거에 이미 commit하여 스냅샷에 넣어진 관리 대상 상태의 파일\n\n2. Staging Area에 있는 파일(Staged 상태의 파일)\n\n\t- git add 명령을 실행한 경우\n\n\t- staged 상태로 만들려면 git add 명령을 실행해야 한다.\n\n\t- git add는 **파일을 새로 추적할 때도 사용**하고 **수정한 파일을 Staged 상태로 만들 때**도 사용한다.\n\n```bash\ngit stash\ngit stash list # 보관된 코드 목록\ngit stash save \"메모\" # 메모와 함께 보관\ngit stash pop # 코드 다시 불러오기\ngit stash drop 번호 # stash 1개 삭제\ngit stash clear # stash 전부 삭제\n```\n\n- git stash pop은 pop에서 알 수 있다시피 가장 최근 것부터 가져온다. stash는 스택에 새로운 stash가 만들어지면서 저기에 넣고 working directory, 작업공간이 깔끔해지는 효과이다.\n\n\u003cbr\u003e\n\n\u003e [!note] stash가 왜 필요함? 주석처리 하면 어떰?  \n\u003e\n\u003e 주석처리를 한다고 하더라도 commit 하면 그 내역이 같이 올라간다. 따라서 그걸 숨기고 싶을 때 stash 쓰면 유용하다. 혹은 따로 stash 같은 역할을 하는 branch 하나 만들고 거기에 작성해도 된다. 둘 중 마음에 드는 방식 사용하자.","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/":{"title":"Frontend","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-html/":{"title":"코딩애플 - HTML/CSS","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-html/all-in-one":{"title":"All-in-One 강의노트","content":"\n\u003cbr\u003e\n\n\u003e [!note] HTML/CSS All-in-one : 기초부터 Bootstrap, SASS, 고급 animation 까지\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2022.07.02 ~ 2022.07.25\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e 백엔드여도, 웹 개발자이기 때문에 웹의 기초 구조를 파악하는 것에 목적 \u003cbr\u003e\n\u003e 클론코딩 하며 최대한 실습 위주\n\n## 목차\n\n- [코딩애플 All-in-One 기초모듈](brain/Lecture/frontend/apple-html/all-in-one-basic.md)\n- [코딩애플 All-in-One 중급모듈](brain/Lecture/frontend/apple-html/all-in-one-mid.md)\n- [코딩애플 All-in-One 고급모듈](brain/Lecture/frontend/apple-html/all-in-one-last.md)","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-html/all-in-one-basic":{"title":"All-in-One 기초모듈","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/html-basics/' target='_blank'\u003eHTML/CSS All-in-one : 기초부터 Bootstrap, SASS, 고급 animation 까지\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## HTML\n\n\u003cbr\u003e\n\n### HTML 태그\n\n- 띄어쓰기를 하고 원하는 class 붙이면 클래스 2개 이상 가능\n\n```html\n\u003cdiv class=\"container text-center\"\u003e\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n### input 태그 name 속성\n\n- input 태그에 name 속성을 지정하면 서버에 name에 해당하는 변수로 데이터를 전송\n\n\n```html\n\u003cinput type=\"text\" name=\"age\" /\u003e\n\u003c!-- age라는 변수로 서버에 전송 --\u003e\n```\n\n\u003cbr\u003e\n\n- 서버에 데이터 전송할 때 방식 2개\n\n\t1. `\u003cinput type=\"submit\"\u003e`\n\t2. `\u003cbutton type=\"submit\"\u003e전송\u003c/button\u003e`\n\n\u003cbr\u003e\n\n### select 태그\n\n- 드롭다운 구현 가능\n\n```html\n\u003cselect\u003e\n\t\u003coption\u003e자장면\u003c/option\u003e\n\t\u003coption\u003e짬뽕\u003c/option\u003e\n\t\u003coption\u003e탕수육\u003c/option\u003e\n\u003c/select\u003e\n```\n\n\u003cbr\u003e\n\n### label 태그  \n\n- input 태그 체크박스 활용할 때 의미 없는 글자는 span 태그를 사용해도 되지만, label 태그를 이용해보자.\n\n- input태그의 id와 label 태그의 for를 동일하게 맞춰주면 label 태그의 글자를 클릭해도 체크박스가 선택된다.\n\n```html\n\u003cinput id=\"sub\" type=\"checkbox\" /\u003e \u003clabel for=\"sub\"\u003eSubscribe\u003c/label\u003e\n```\n\n\u003cbr\u003e\n\n### table\n\n- table 태그로 감싸며 thead 태그와 tbody 태그를 써주는 것이 보기 좋다.\n\n- 그리고 tr 태그로 행 먼저, 그 이후 td 태그로 열, 아래는 3행 3열 테이블\n\n```html\n\u003ctable\u003e\n\t\u003cthead\u003e\n\t\t\u003ctr\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\u003c/tr\u003e\n\t\u003c/thead\u003e\n\t\u003ctbody\u003e\n\t\t\u003ctr\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\u003c/tr\u003e\n\t\t\u003ctr\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\t\u003ctd\u003e\u003c/td\u003e\n\t\t\u003c/tr\u003e\n\t\u003c/tbody\u003e\n\u003c/table\u003e\n```\n\n- 셀 병합을 할때는 `\u003ctd colspan=\"4\"\u003e\u003c/td\u003e`와 같이 colspan에 합치기 원하는 숫자를 넣기\n\n- 추가로 html 테이블에서 td의 width를 설정하면 전체 열의 width가 변한다.\n\n\u003chr\u003e\n\n## CSS\n\n\u003cbr\u003e\n\n### float 속성\n\n- float는 요소를 **공중에** 붕 띄워서 왼쪽/오른쪽 정렬하는 속성\n\n- 공중에 붕 띄는 속성 때문에 다음에 오는 div 박스가 보이지 않는 경우 발생\n\n- `clear: both`를 이용해서 초기화 해줘야함\n\n```css\n.box_practice .article01 {\n\tfloat: left;\n}\n\n.box_practice .article02 {\n\tfloat: right;\n}\n\n.box_practice .footer {\n\tclear: both;\n}\n```\n\n\u003cbr\u003e\n\n\u003e **참고**\n\u003e \u003cbr\u003e\n\u003e float 속성으로 가로 정렬할 때 float 박스들을 감싸난 하나의 큰 div 박스를 만들고 \u003cbr\u003e\n\u003e 폭을 지정해주는게 좋다. 그래야 모바일에서 흘러넘치지 않는다.\n\n```html\n\u003cdiv\u003e\n\t\u003cdiv class=\"left-box\"\u003e\u003c/div\u003e\n\t\u003cdiv class=\"right-box\"\u003e\u003c/div\u003e\n\t\u003cdiv class=\"footer\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n### Selector 셀렉터\n\n- 셀렉터 사용 시 공백 말고 꺽쇠( `\u003e` )도 가능\n\n- 단, 꺽쇠 사용 시 4~5개 이상 연달아쓰는건 권장X 버그의 원인\n\n```html\n\u003cui class=\"navbar\"\u003e\n\t\u003cli\u003e\u003cspan\u003e안녕\u003c/span\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003c/li\u003e\n\u003c/ui\u003e\n```\n\n```css\n.navbar li \u003e span {\n\tcolor: red;\n}\n```\n\n\u003cbr\u003e\n\n- `nth-child()` 셀렉터는 여러 요소 중 원하는 n번째 요소에 스타일을 주기 위함이다.\n\n```css\n.cart-table td:nth-child(2) {\n\tcolor: red;\n}\n\n.cart-table td:nth-child(n + 2) {\n\tcolor: blue;\n}\n```\n\n- 위의 코드는 2번째에 나오는 td에만 color를 주는 것이고\n\n- 아래의 코드는 2번째 이후에 나오는 td들에 color를 주겠다는 것\n\n\u003cbr\u003e\n\n### background 속성\n\n- 그냥 이미지를 넣어도 되지만, background도 생각\n\n- `background-image: url(./img/img03.png);` 배경 이미지 설정 (이때, url 여러개 넣어서 배경 겹치기 가능)\n\n- `background-size: cover;` 배경 이미지 div 박스에 꽉차게\n\n- `background-size: contain;` 배경 이미지 잘리지 않게\n\n- `background-repeat: no-repeat;` 반복되는거 없애기\n\n- `background-position: center;` center를 기준으로 배경 채움\n\n- `background-attachment: fixed;` 스크롤 될 때 배경 동작 설정 방식\n\n- `filter: brightness(50%)` 배경에 보정 입히기 - 명도 (단, 안에 글씨 있으면 글씨도 필터가 입혀지니까 이는 조심하자.)\n\n\u003cbr\u003e\n\n### 배경에 검은색 틴트 주기\n  \n```css\n.main-background {\n\tbackground-image: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)),\n\turl(이미지경로~~);\n}\n```\n\n\u003cbr\u003e\n\n### margin collapse 현상\n\nmargin collapse 현상은, div 박스 두 개가 겹친 경우에 **박스 2개의 위쪽 테두리가 겹치면, margin도 합쳐지는 현상**을 의미한다.\n\n\u003cbr\u003e\n\n```html\n\u003cdiv class=\"main-background\"\u003e\n\t\u003ch4 class=\"main-title\"\u003eBuy Our Shoes!\u003c/h4\u003e\n\u003c/div\u003e\n```\n\n이 경우에서 박스 2개가 겹쳐지게 되어, main-title에 margin-top을 주면 margin이 합쳐진 현상이라 같이 내려가게 될 것이다. 해결방안으로는, 테두리가 안붙게 하면 된다. 부모 박스에 `padding: 1px`과 같은 조작을 취하면 된다.\n\n\u003cbr\u003e\n\n### 좌표 이동\n\n- `position` 속성 부여하여 좌표이동 가능해짐.\n\n- 특징 01 : 좌표 이동 가능\n\n- 특징 02 : float와 비슷하게 공중에 뜨는 원리\n\n- `position: relative` 내 원래 위치가 기준\n\n```css\n.main-button {\n\tposition: relative;\n\ttop: 100px; // 위쪽에서부터 100px\n\tleft: 100px; // 왼쪽에서부터 100px\n}\n```\n\n- `position: static` 좌표 이동 금지\n\n- `position: fixed` 현재 화면 (viewport) 기준으로 고정\n\n- navbar 같은거 스크롤 해도 상단에 고정시키면 좋으니까, 그럴 때 사용\n\n- `position: absolute` 내 부모 태그 중에 `position: relative` 가진 부모를 기준으로 한다.\n\n- `position: absolute` 요소를 **가운데 정렬**하는 방법\n\n```css\n.main-btn {\n\tposition: absolute;\n\tleft: 0;\n\tright: 0;\n\tmargin: auto;\n\twidth: 30%;\n}\n```\n\n\u003cbr\u003e\n\n### z-index\n\n- div 박스가 겹칠 때 우선순위를 두기\n\n- `z-index: 1`, `z-index: 5` 숫자가 클 수록 (높을 수록) 앞에 온다.\n\n\u003cbr\u003e\n\n### width의 영역에 관한 문제\n\n- width는 div 박스의 너비가 아니라 **width는 내부 content 영역의 너비를 의미한다.** padding이나 border에 width는 영향을 주지 않는다.\n\n- 해결하려면, content 부분만 width로 설정하는 것이 아니라, padding과 border를 모두 포함하라고 시키면 된다.\n\n- `box-sizing: border-box;` - width가 padding, border를 포함한다.\n\n- content-box는 padding과 border를 포함하지 않는 경우이다.\n\n- 아래의 예제로 box-sizing이 있고 없고를 비교해보기\n\n  \n```css\n.explain-box {\n\tposition: relative;\n\tmargin: auto;\n\tpadding: 20px;\n\ttext-align: center;\n\ttop: -80px;\n\tmax-width: 600px;\n\twidth: 80%;\n\theight: 40%;\n\tbackground-color: rgb(238, 237, 239);\n\tbox-sizing: border-box;\n}\n```\n\n\u003cbr\u003e\n\n### css 초기 설정시 편한 것, normalize\n\n```css\n\nbody {\n\tmargin: 0px;\n}\n\ndiv {\n\tbox-sizing: border-box;\n}\n\nhtml {\n\tline-height: 1.15; /* 기본 행간 높이 */\n}\n```\n\n혹은 크롬, 파이어폭스, 사파리와 같이 브라우저 호환성 이슈가 있을 때 css 파일에 추가하고 시작하면 좋은 설정들이 있다. (버튼의 크기나 이미지가 브라우저마다 다르거나 한 경우 때문에)\n\n\u003cbr\u003e\n\n\u003ca href='https://github.com/necolas/normalize.css/blob/master/normalize.css' target='_blank'\u003enormalize.css\u003c/a\u003e를 참고하도록 하자.\n\n\u003cbr\u003e\n\n### input type에 따른 css 셀렉터\n\n- 아래와 같이 지정하면 input type이 text인 아이들만 css 스타일링 가능\n\n```css\ninput[type='text'] {\n\tpadding: 10px;\n\tfont-size: 20px;\n\tborder: 1px solid black;\n}\n```\n\n\u003cbr\u003e\n\n### vertical-align 속성\n\n- inline/inline-block 요소 간의 세로정렬 할 때 vertical-align을 사용한다.\n\n- 테이블 사용 시 수직 정렬에도 사용 가능\n\n- pratice02.html에서 실패했던 이유는 ? div박스와 조작을 시도했기 때문\n\n- 해결책은 하나의 div 박스 내에서 img와 글자를 span태그로 묶어서 그 둘을 vertical-align 했으면 가능했을 듯하다.\n\n```html\n\u003cdiv\u003e\n\t\u003cimg\n\tsrc=\"https://mdn.mozillademos.org/files/12245/frame_image.svg\"\n\twidth=\"32\"\n\theight=\"32\"\n\t/\u003e\n\t\u003cspan style=\"vertical-align : middle;\"\u003e\n\timage with a default alignment.\u003c/span\u003e\n\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n### table 태그 border-radius 오류\n\n- border-collapse 속성을 table 태그에 적용했을 때 border-radius가 안먹는 오류가 있다.\n\n\u003cbr\u003e\n\n- 첫 번째 해결방안\n\n```css\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\n\n(왼쪽위에있는 td) {\n\tborder-top-left-radius: 5px;\n}\n```\n\n\u003cbr\u003e\n\n- 두 번째 해결방안\n\t- box-shadow 속성을 이용하여 테두리를 가짜로 만들어내는 편법\n\n```css\n\ntable {\n\tborder-collapse: collapse;\n\tborder-radius: 7px;\n\tborder-style: hidden;\n\tbox-shadow: 0 0 0 1px #666;\n}\n```\n\n\u003cbr\u003e\n\n### button 태그 같이 hover 할 때 마우스 커서\n\n- `:hover`로 pseudo-class를 하지 않아도 `cursor:pointer`와 같이 작성하면 올렸을 때 마우스 커서 바뀜\n \n```css\nbutton {\n\tpadding: 15px;\n\tfont-size: 20px;\n\tborder: none;\n\tcursor: pointer;\n}\n```\n\n\u003cbr\u003e\n\n### input 태그 focus 스타일 안먹힐 때\n\n- `input:focus`를 해서 border 속성을 지정했는데 색깔이 안먹는 경우가 있다.\n- 그럴때는 크롬 기본속성인 outline을 none으로 설정해주자.\n\n```css\n.cart-footer .input-test:focus {\n\toutline: none;\n\tborder: 2px solid rgb(2, 77, 163);\n}\n```\n\n\u003cbr\u003e\n\n### css의 다양한 pseudo-class\n\n```css\n/* 외우는법 hofa */\n\n:hover /*마우스를 올려놓을 때*/\n:focus /*클릭 후 계속 포커스 상태일 때*/\n:active /*클릭 중일 때*/\n\n:link /* 방문 전 링크 */\n:visited /* 방문 후 링크 */\n:any-link /*방문 전, 방문 후 링크 한번에 선택할 때*/\n\n:playing /*동영상, 음성이 재생중일 때*/\n:paused /*동영상, 음성이 정지시*/\n:autofill /*input의 자동채우기 스타일*/\n:disabled /*disabled된 요소 스타일*/\n:checked /*체크박스나 라디오버튼 체크되었을 때*/\n\n:blank /*input이 비었을 때*/\n:valid /*이메일 input 등에 이메일 형식이 맞을 경우*/\n:invalid /*이메일 input 등에 이메일 형식이 맞지 않을 경우*/\n:required /*필수로 입력해야할 input의 스타일*/\n\n:nth-child(n) /*n번째 자식 선택*/\n:first-child /*첫째 자식 선택*/\n:last-child /*마지막 자식 선택*/\n```\n\n\u003cbr\u003e\n\n### 코드 양이 줄어드는 class 작명법 (OOCSS, BEM)\n\n- **OOCSS (Object Oriented CSS)**\n\n- CSS 양이 줄어들고, 유지보수 편리\n\n- 뼈대용 class, 살점용 class 각각 제작\n\n- 뼈대 디자인을 먼저 분리해놓고 색깔과 같은 살점을 추가하는 방식\n\n```html\n\u003cbutton class=\"main-btn bg-red\"\u003e버튼1\u003c/button\u003e\n\u003cbutton class=\"main-btn bg-blue\"\u003e버튼2\u003c/button\u003e\n```\n\n```css\n.main-btn {\n\tpadding: 15px;\n\tfont-size: 20px;\n\tborder: none;\n\tcursor: pointer;\n}\n\n.bg-red {\n\tbackground: red;\n}\n\n.bg-blue {\n\tbackground: blue;\n}\n```\n\n\u003cbr\u003e\n\n- OOCSS를 극단적으로 여러 **Utility class**를 만들어 놓을 수 있다.\n\n```css\n.f-small {\n\tfont-size: 12px;\n}\n\n.f-mid {\n\tfont-size: 16px;\n}\n\n.f-lg {\n\tfont-size: 20px;\n}\n\n.bg-red {\n\tbackground: red;\n}\n\n.bg-blue {\n\tbackground: blue;\n}\n\n```\n\n```html\n\u003cbutton class=\"main-btn bg-red f-lg\"\u003e버튼\u003c/button\u003e\n```\n\n\u003cbr\u003e\n\n- **BEM (Block\\_\\_Element--Modifier)**\n\n- class 작명할 때 창의력이 부족한 경우 BEM 작명법을 이용할 수 있다.\n\n- `class = \"덩어리이름__역할--세부특징\"`\n\n```html\n\u003cdiv class=\"profile\"\u003e\n\t\u003cimg class=\"profile__img\" /\u003e\n\t\u003ch4 class=\"profile__title\"\u003e\u003c/h4\u003e\n\t\u003cp class=\"profile__content\"\u003e\u003c/p\u003e\n\t  \n\t\u003cbutton class=\"profile__button--red\"\u003e버튼1\u003c/button\u003e\n\t\u003cbutton class=\"profile__button--blue\"\u003e버튼2\u003c/button\u003e\n\u003c/div\u003e\n\n```\n\n- 사람마다 다르다. OOCSS를 쓰면 html이 더러워져서 추천하지 않는 사람도 있음\n\n- BEM도 Modifer는 빼고 Block\\_\\_Element까지만 쓰는 사람도 있음\n\n- 최근, React나 Vue로 HTML 만들면 굳이 OOCSS, BEM 굳이 안쓰는 경우가 많아서 깊게 익힐 필요 X\n\n- React나 Vue에서는 html 페이지 단위가 아닌, 작은 덩어리 (component) 단위로 개발하게 된다. 이때 profile과 같이 class 명이 중복되어도 컴포넌트끼리 스타일이 간섭되지 않게 코드 작성이 가능하다. 대표적으로, React의 styled-components 라이브러리를 사용하면 가능하다.","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-html/all-in-one-last":{"title":"All-in-One 고급모듈","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/html-basics/' target='_blank'\u003eHTML/CSS All-in-one : 기초부터 Bootstrap, SASS, 고급 animation 까지\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## Pseudo-element\n- pseudo-class (다른 상태일 때 스타일 줄 때) `.class:`\n- pseudo-element (내부의 일부분만 스타일 줄 때) `.class::`\n\n\u003cbr\u003e\n\n기초 모듈 수업에서 pseudo-class 가 무엇인지 학습했었다. `:hover`와 같이 특정 요소가 다른 상태일 때 (ex. 마우스 올렸을 때) 스타일 줄 수 있게 해주는 것이었다. pseudo-element는 콜론 2개 `::`를 입력하여 사용한다.\n\n```css\n/* 이러면 pseudo 클래스의 첫 번째 글자만 빨간색으로 바뀜! */\n.pseudo::first-letter {\n\tcolor: red;\n\tfont-size: 2rem;\n}\n```\n\n\u003cbr\u003e\n\n보통 `::after (내부 맨 뒤에 뭔가 추가)`나 `::before (내부 맨 앞에 뭔가 추가)`를 어느정도 자주 사용하는 편이다.  \n\n```css\n/* 이러면 pseudo 클래스 맨 뒤에 '안녕' 글자 생김 */\n.pseudo::after {\n\tcontent: '안녕';\n\tcolor: red;\n\tfont-size: 2rem;\n}\n```\n\n만약, float를 사용해서 `clear: both;`를 하고 싶은 경우에 pseudo-element를 이용해서 빈 div 박스를 추가해줄 수 있다. (즉, 귀찮게 html 맨 밑에 div 박스 추가하고 style 줄 필요 없다는 말이지만, 나는 앞으로 float 안쓰고 flex 같은거 쓸거니깐... 그래도 혹시 모르니 메모 !)\n  \n```css\n.product-container::after {\n\tcontent: ''; /* 그냥 내용 없는거 */\n\tdisplay: block;\n\tclear: both;\n\tfloat: none;\n}\n```\n\n\u003cbr\u003e  \n\n`input 태그의 type이 file`인 경우 화면에 `파일 선택` 버튼 말고 `선택된 파일 없음`이라는 글자가 나온다. 아래에서 설명한 shadow dom인데 이 경우 단순히 input 태그를 조작하여서 버튼 색깔을 변경할 수는 없다.\n\n```css\n/* 이러면 \"선택된 파일 없음\" 여기 배경색이 바뀜 */\n.input_file {\n\tbackground: skyblue;\n}\n\n/* 이렇게 해야 \"파일 선택\" 버튼의 배경색이 바뀜 */\n.input_file::file-selector-button {\n\tbackground: skyblue;\n}\n\n/* pseudo-element에 pseudo-class도 사용 가능 */\n\n.input_file::file-selector-button:hover {\n\tbackground: blue;\n}\n```\n\n\u003cbr\u003e\n\n- Pseudo-element 활용한 쓸데없는 짓들\n\n- CSS 만으로 버튼에 마우스 올리면 배경 어둡게하기 https://codepen.io/css-tricks/pen/dxyfA\n\n- CSS만으로 3D 느낌 리본모양만들기 https://codepen.io/team/css-tricks/pen/mVZGKa\n\n- ol 태그의 숫자 스타일링하기 https://www.456bereastreet.com/archive/201105/ styling_ordered_list_numbers/\n\n- table 반응형으로 만드는 여러가지 방법 https://css-tricks.com/responsive-data-tables/\n\n- CSS만으로 영문 폰트 만들기 https://yusugomori.com/projects/css-sans/fonts\n\n\u003chr\u003e  \n\n## Shadow DOM\n\n```html\n\u003cinput type=\"file\" /\u003e\n```\n\n이와 같은 코드 입력 시, 화면에 `파일 선택` 버튼 말고 `선택된 파일 없음`이라는 글자가 나온다. 분명 태그 하나만 사용했는데 2개를 사용한 것처럼 보인다. 이것은 **Shadow DOM**이라는 숨겨진 요소 때문이다.  \n\n\u003cbr\u003e\n\n크롬 개발자 도구 설정에서 Elements의 `Show user agent shadow DOM`을 체크한 이후 input 태그의 내부를 살펴보면 shadow-root가 있고 그 안에 보면 `pseudo=\"-webkit-file-upload-button\"`이 있을 것이다. 이것이 shadow DOM이다. input 태그 하나만 입력해도 span 태그인 선택된 파일 없음이 한 번에 입력되도록 개발자에게 편하려고 생긴 것이다.\n\n\u003cbr\u003e  \n\n그래서 결국, 버튼에 배경색을 주려면 위에서 했던 `.input_file::file-selector-button` 말고 어떻게 하지?\n\n\u003cbr\u003e\n\n**input [type=file]**\n\n```css\ninput[type='file']::-webkit-file-upload-button {\n\tbackground: black;\n\tcolor: white;\n}\n```\n\n크롬 개발자 도구 열어서 pseudo 부분을 pseudo-element 부분에다가 넣고 스타일링 하면 된다. 왜냐면 pseudo-element 역할 자체가 **내부의 일부분만 스타일 줄 때** 사용하는 것이니까 내부의 버튼에만 스타일을 주고싶은 거니까 이렇게 사용하는 것이다.\n\n\u003cbr\u003e\n\n추가로, `-webkit-`은 크롬, 사파리, Edge에서만 적용되는 스타일이다. Firefox는 `-moz`를 작성해야하고 Explorer는 `-ms-`를 사용한다. 즉, 브라우저마다 shadow DOM 까보면 살짝씩 다르다.\n\n\u003cbr\u003e\n\n\u003e [!note]  실제 파일 업로드 버튼 만드는 것\n\u003e\n\u003e 글자를 눌러도 버튼이 선택되게 스타일링한다.\n그리고 input태그는 display를 none 줘버린다.\n\n\n```html\n\u003clabel for=\"sub\"\u003e\n\t파일 업로드\n\t\u003cinput id=\"sub\" type=\"file\" style=\"display: none\" /\u003e\n\u003c/label\u003e\n```\n\n\u003cbr\u003e  \n\n**input placeholder**\n\ninput 태그의 `placeholder`도 div 박스 두 개의 형태 같지 않는가? shadow DOM인가? 까보면 역시 그렇다.\n\n```css\n/* 이러면 placeholder 안에 글자 색깔 빨간색으로 바뀜 */\ninput::-webkit-input-placeholder {\n\tcolor: red;\n}\n```\n\n\u003cbr\u003e\n  \n**input [type=range]**\n\nrange 또한 마찬가지이다. range는 id가 track과 thumb 두 개가 있음을 확인 가능하다. 그런데 아마 손잡이 thumb는 pseudo 어쩌구가 없어서 선택 어떻게 해야하나 의문이 들 것이다. 눌러서 밑에 보면 `user agent stylesheet`가 보일 것인데 **브라우저 기본 CSS**를 의미한다. 우리가 스타일 주지 않아도 기본적으로 보이는 스타일이다. 따라서, 여기 `input[type='range']::-webkit-slider-thumb` 부분을 복사해오고 조작하면 된다. 따옴표나 i 이런건 지우고 사용한다. 이때, apperance가 기본 값이 auto라서 none으로 바꾸고 사용해야 한다. 손잡이 thumb의 apperance만 바꾸면 안되고 range 자체의 apperance를 바꿔야 적용될 것이다.\n\n\u003cbr\u003e\n\n```css\ninput[type='range'] {\n\tappearance: none;\n\tbackground-color: lightgray;\n\tborder-radius: 1rem;\n}\n\ninput[type='range']::-webkit-slider-thumb {\n\tappearance: none;\n\tbackground-color: green;\n\twidth: 1rem;\n\theight: 1rem;\n\tborder-radius: 1rem;\n}\n```\n\n\u003cbr\u003e\n\n**progress**\n\n```css\nprogress {\n\t/*기본 배경은 없애주는게 좋습니다*/\n\t-webkit-appearance: none;\n\t-moz-appearance: none;\n\tappearance: none;\n\tbackground: white;\n\t\n\t/* IE10 호환성용 */\n\tcolor: red;\n}\n\nprogress::-webkit-progress-bar {\n\tbackground-color: lightgray;\n\tborder-radius: 1rem;\n}\n\nprogress::-webkit-progress-value {\n\tbackground-color: red;\n\tborder-radius: 1rem;\n}\n\n/*파이어폭스 호환성을 위해*/\nprogress::-moz-progress-bar {\n\tbackground-color: red;\n\tborder-radius: 2px;\n}\n```\n\n\u003chr\u003e\n\n## Sass\n\n- CSS를 개선한 CSS 전처리언어 (Preprocessor) = SASS\n\n- Sass에는 조건문, 반복문, 변수, 함수 존재\n\n- 즉, 문법이 존재한다는 의미 =\u003e 반복적인 부분 쉽게 처리 가능\n\n- SASS 파일은 `파일명.scss`\n\n- 웹 브라우저는 sass파일을 읽지 못하니까 css로 변환 작업이 필요하다. vscode extension에서 `Live Sass Compiler version 5 이상`을 설치한다. 그러면 vscode 하단에 `Watch Sass`가 보인다. 이를 누르면 scss에서 css로 변환이 된다.\n\n- 같이 생성되는 `.map`파일은 크롬 개발자도구 디버깅 용도이다. 크롬에서는 scss 파일을 읽는 것이 아니라 css 파일을 읽을 것이다. `.map` 파일이 있으면 크롬에서 css가 아닌 scss 파일로 분석해준다.\n\n\u003cbr\u003e\n\n1. 코드를 scss에 작성\n2. html에 파일 넣는건 css 파일 넣기\n\n\u003cbr\u003e\n\n\u003e [!note] 하단에 바가 안보여서 watch sass를 찾을 수 없다면?\n\u003e\n\u003e View - Appearance - Status bar 켜기\n\n\u003cbr\u003e\n\n파일 확장명에 따른 차이\n\n- sass 문법을 작성해서 만든 파일명은 2개가 있음\n- `.scss` : 중괄호 써야 하는거 (보통 이거 많이 사용)\n- `.sass` : 중괄호 안써도 되는거\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Sass 문법\n\n\u003cbr\u003e\n\n### 문법01. 값을 저장하고 사용하는 변수\n\n- 어려운 단어 기억해야할 때 변수 문법을 사용한다. `$변수명 : 저장해서 사용할 값;`\n- 규칙적인 스타일 만들 때도 변수를 사용하는 것은 도움이 된다.\n- 사칙연산 바로 가능 (단, %에서 px 빼는 행위는 하지 말고 같은 단위끼리 하자.)\n\n```css\n/* 기존 css 코드 */\n.background {\n\tbackground-color: #2a4cb2;\n}\n\n.box {\n\tcolor: #2a4cb2;\n}\n```\n  \n```scss\n// 변수 사용 scss 코드\n$메인컬러: #2a4cb2;\n\n.background {\n\tbackground-color: $메인컬러;\n}\n```\n\n```scss\n// scss 응용하기 좋은거\n$메인컬러: #2a4cb2;\n$서브컬러: #eeeeee;\n$기본사이즈: 16px;\n\n.background {\n\tbackground-color: $메인컬러;\n\tfont-size: $기본사이즈 - 2px;\n}\n\n.box {\n\tcolor: $서브컬러;\n\tfont-size: $기본사이즈 + 2px;\n}\n```\n\n위 코드는 font-size를 기본사이즈에서 빼고 더함으로써 **상대적인 크기**를 결정했다. 그래서 나중에 수정하기에 용이하다. 즉, 규칙적인 스타일 만들 때도 변수를 사용하는 것은 도움이 된다는 의미이다.\n\n\u003cbr\u003e  \n\n```scss\n// 괄호를 치는 것이 좋은 습관 !\n$기본사이즈: 16px;\n\n.box {\n\tfont-size: $기본사이즈 + 2px;\n\twidth: (100px * 2);\n\theight: (300px / 3);\n}\n```\n\n\u003cbr\u003e\n\n사실 CSS 기본 문법에도 변수 문법 이용 가능하고 사칙연산도 사용 가능하다. 근데 귀찮음\n\n\u003cbr\u003e  \n\n### 문법02. 셀렉터 대신 사용하는 Nesting\n\n- 관련있는 class들을 묶어서 사용할 때 편함\n- nesting 안에다가 또 nesting 가능하지만, 보통 2개 이상 중첩하지는 않음\n\n```css\n/* CSS 문법 */\n.navbar ul {\n\twidth: 100%;\n}\n\n.navbar li {\n\tcolor: black;\n}\n```\n\n```scss\n// sass 문법\n.navbar {\n\tul {\n\t\twidth: 100%;\n\t}\n\n\tli {\n\t\tcolor: black;\n\t}\n}\n```\n\n```scss\n// sass 문법으로 hover 사용법\n.navbar {\n\t:hover {\n\t\tcolor: blue;\n\t}\n}\n\n.navbar {\n\t\u0026:hover {\n\t\tcolor: blue;\n\t}\n}\n```\n\n- 위의 방식은 `.navbar :hover`\n- 밑의 방식은 `.navbar:hover`\n- 즉 `\u0026`기호를 붙히면 셀렉터를 스페이스바 없이 붙힐 수 있음\n\n\u003cbr\u003e\n\n### 문법03. 이미 있는 클래스를 확장하는 @extend\n\n- 반복되는 코드 없애고 싶을 때 사용\n- class 전체를 복사해주는 문법이 `@extend`\n- `%`는 `.` 대신 사용할 수 있는 임시 클래스\n- css에서 클래스로 컴파일하고 싶지 않을 때 사용\n- 컴파일 하고나면 `%` 안에 있는 것들은 모두 사라짐\n\n1. 중복된 스타일이 많으면 클래스로 묶는다\n2. `@extend`로 필요할 때 복사한다.\n\n```scss\n%btn {\n\twidth: 100px;\n\theight: 100px;\n\tpadding: 20px;\n}\n\n.btn-green {\n\t@extend %btn;\n\tcolor: green;\n}\n\n.btn-red {\n\t@extend %btn;\n\tcolor: red;\n}\n```\n\n```css\n/* 위의 scss에서 컴파일된 css 결과 */\n.btn-green,\n.btn-red {\n\twidth: 100px;\n\theight: 100px;\n\tpadding: 20px;\n}\n\n.btn-green {\n\tbackground: green;\n}\n\n.btn-red {\n\tbackground: red;\n}\n```\n\n\u003cbr\u003e\n\n### 문법04. 코드를 한 단어로 축약하는 @mixin\n\n- 약간 함수 같은 느낌\n- `@mixin`으로 선언, `@include`로 불러오기, `$ 변수 사용해서 파라미터`\n- `@extend`와 비슷해보이지만 파라미터 때문에 `@mixin`을 더 많이 사용함\n\n```scss\n@mixin 버튼기본디자인() {\n\tfont-size: 16px;\n\tpadding: 10px;\n}\n\n.btn-green {\n\t@include 버튼기본디자인();\n\tbackground: green;\n}\n```\n\n```scss\n@mixin 버튼기본디자인($구멍1, $구멍2) {\n\tfont-size: 16px;\n\tpadding: 10px;\n\tbackground: $구멍1;\n\tcolor: $구멍2;\n}\n\n.btn-green {\n\t@include 버튼기본디자인(green, black);\n}\n```\n\n```css\n/* 컴파일된 css 파일 */\n.btn-green {\n\tfont-size: 16px;\n\tpadding: 10px;\n\tbackground: green;\n\tcolor: black;\n}\n```\n\n만약, 글자 중간에 `$변수` 혹은 `$파라미터` 넣고 싶으면 `#{ $변수명 }`을 사용한다.\n\n```scss\n@mixin 폰트기본스타일($구멍1, $구멍2) {\n\tfont-size: $구멍1;\n\t#{ $구멍2 }: -1px;\n}\n\nh2 {\n\t@include 폰트기본스타일(40px, letter-spacing);\n}\n```\n\n```css\n/* 컴파일 된 css */\nh2 {\n\tfont-size: 40px;\n\tletter-spacing: -1px;\n}\n```\n\n\u003cbr\u003e\n\n### 문법05. 다른 파일에 있는 내용 가져오는 @use 문법\n  \n- 파이썬의 `@import`같은 느낌이다.\n- 예를 들어, 여러 파일에 공통적으로 사용되는 css 기본 세팅같은거 파일 저장해놓고 불러와서 사용\n- css 기본 문법에도 `@import` 있음 scss에서는 `@use` 쓰는거\n- 컴파일을 원하지 않는 파일은 `_파일명.scss`로 작명한다.\n- `@use '파일명'` 할 때 컴파일 안되게 언더바 붙힌 파일에서 언더바는 빼도 된다\n- 예를 들어, `sass01.scss` 파일에서 `_reset.scss` 파일 `@use`할 때, `@use 'reset'` 이까지만 적어도 되는거\n\n\u003cbr\u003e\n\n\u003e [!note] Memo\n\u003e\n\u003e 뭐 기본세팅 .scss 파일은 종속적인 파일이니까 굳이 매번 .css로 컴파일 할 필요가 없잖아? 그러니까 언더바(_) 붙혀서 컴파일 못하게 하자.\n\n\u003cbr\u003e\n\n파일을 불러오면 거기에 있던 `@mixin`, `$변수` 이런거 다 사용 가능\n\n1. 다른 파일의 `$변수` 사용\n\t- `파일명.$변수`\n\n2. 다른 파일의 `@mixin` 사용\n\t- `@include 파일명.mixin이름`\n\n\u003chr\u003e\n\n## HTML video, audio\n\n- `\u003cvideo src=\"영상.mp4\"\u003e\u003c/video\u003e`의 형태로 넣음\n- `\u003cvideo src=\"영상.mp4\" controls\u003e\u003c/video\u003e` 하면 재생버튼 생김 **controls**\n- 근데 영상 넣을때 `source`를 따로 넣는게 더 나\n\n\u003cbr\u003e\n\n**source 태그**를 이용해서 따로 넣는 방식의 장점은 **호환성을 챙길 수 있다**는 것이다. 비디오의 형식이 mp4, webM, mkv 등 브라우저마다 지원하는 비디오 확장자가 다르다. 따라서, 아래와 같은 코드로 작성하면 위에거 틀어보고 안되면 밑에거 틀어보세요~ 이런 말이다.  \n\n```html\n\u003c!-- 보통 용량이 작은 확장자부터 위에 작성한다. --\u003e\n\u003cvideo controls\u003e\n\t\u003csource src=\"영상-m.webm\" type=\"video/mp4\" /\u003e\n\t\u003csource src=\"영상-m.???\" type=\"video/mp4\" /\u003e\n\t\u003csource src=\"영상.mp4\" type=\"video/mp4\" /\u003e\n\u003c/video\u003e\n```\n\n\u003cbr\u003e\n\n**autoplay**는 크롬 브라우저에서 자동재생 정책상 그냥 `autoplay` 작성하면 안되고 `autoplay muted`해야 된다.\n\n```html\n\u003cvideo controls autoplay muted\u003e\n\t\u003csource src=\"영상.mp4\" type=\"video/mp4\" /\u003e\n\u003c/video\u003e\n```\n\n\u003cbr\u003e\n\n**preload**는 브라우저 로딩 시 영상을 미리 다운받을지, 말지, 적당히 받을지에 관한 속성 `\u003cvideo preload=\"metadata\"\u003e`  \n\n- `preload=\"none\"` : 미리 다운로드 X\n- `preload=\"auto\"` : 미리 다운로드 O\n- `preload=\"metadata\"` : 미리 다운로드 적당히, 초반 썸네일과 영상 초반부 약간 로딩. 제일 추천\n\n\u003cbr\u003e\n\n**poster**는 비디오 썸네일 결정 가능 `\u003cvideo poster=\"이미지.jpg\"\u003e\u003c/video\u003e`\n\n\u003cbr\u003e\n\n**loop**은 비디오 무한 재생 `\u003cvideo loop\u003e\u003c/video\u003e`\n\n\u003cbr\u003e\n\n**audio**도 마찬가지, `\u003caudio src=\"음악.mp3\" controls\u003e\u003c/audio\u003e` 추가로, autoplay 자동재생 기능은 애초에 안된다. 자바스크립트로 조작하면 가능\n\n\u003chr\u003e\n\n## 궁극의 가운데 정렬\n\n어떤 요소를 진짜 극한으로 가운데 정렬할 때 사용하는 방법\n\n```css\n/* 어떤 요소 위 빈 박스 */\n.box {\n\theight: 500px;\n\twidth: 100%;\n\toverflow: hidden;\n\tposition: relative;\n}\n\n.container {\n\tposition: absolute;\n\twidth: 100%;\n\ttop: 50%;\n\tleft: 50%;\n\ttransform: translate(-50%, -50%);\n\tz-index: 0;\n}\n```\n\n\u003chr\u003e\n\n## 애니메이션 만들기 심화 (@keyframes)\n\n[중급 모듈](brain/Lecture/frontend/apple-html/all-in-one-mid.md) 애니메이션 만들기에서 one-way 애니메이션 만드는 방법을 배웠었다. 그때는 a에서 b로만 가능했다. 아래와 같이 복잡한 애니메이션은 `@keyframes`로 구현한다. `transition`은 one-way 밖에 안되서이다.\n\n1. a -\u003e b -\u003e c\n2. a -\u003e b -\u003e a\n3. a -\u003e 1초정지 -\u003e b\n\n\u003cbr\u003e\n\n먼저, **transform**에 관하여 알아야한다.\n\n- `transform: rotate(숫자deg)` : 각도만큼 회전\n\n- `transform: translateX(숫자px)`: 숫자px 만큼 X축 좌표이동 (animation 줄 경우 margin-left 같은걸로 이동하는 것보다 부드럽게 이동함)\n\n- `transform: scale(숫자)` 숫자만큼 크기 변화 줌, 2라고 하면 2배 키워줌\n\n- `transform: skew(숫자deg)` : 각도만큼 비틀기\n\n\u003cbr\u003e\n\n**왜 복잡한 애니메이션을 만드는데 transform을 쓰면 좋다는 것인가?** 간단하다. 성능이 좋아서이다. 애니메이션이 느리고 버벅이면 역효과 일으키기 때문이다. 즉, `@keyframes`안에다가 transform을 안쓰고 margin을 쓰더라도 애니메이션을 만들 수 있겠지만, margin 변경은 transform에 비하여 느리다.\n\n\u003cbr\u003e\n\n**transform의 성능이 좋은 이유가 뭘까?** 웹브라우저는 HTML, CSS 코드를 2D 그래픽으로 바꿔주는 간단한 프로그램인데, 이때 브라우저가 그림 그리는 순서가 있다. 첫번째로 HTML, CSS를 쭉 읽으면서 Render Tree를 만든다. Render tree는 그림 그리기 전 CSS를 쭉 정리한 참고자료 느낌이다. 이걸보고 그림그리기 시작한다. 먼저 박스를 그리며 어디에 위치하는지 Layout을 잡고 다음으로 픽셀 하나하나에 색을 입히는 Paint를 하고 쓸데없는 Composite 단계의 css 속성들을 처리한다.\n\n\u003cbr\u003e\n\n정리하자면 1단계 Rander tree 그리면서 css 속성들 정리 2단계 Layout 잡기에 margin, padding, width, height 같은 속성들을 처리하고 3단계 Paint에서 background-color 같은거 처리하고 4단계 Composite 처리 단계에서 transform, opacity 같은거 처리한다.\n\n\u003cbr\u003e\n\n### 브라우저가 그림 그리는 순서 (렌더링 과정)\n\n1. Render tree\n\n2. Layout 잡기\n\n3. Paint 하기\n\n4. Composite 처리\n\n\u003cbr\u003e\n\n그러면, 만약 margin을 갑자기 변경했다고 하자. 그럼 브라우저는 margin을 변경하기 위하여 2단계 Layout 잡기 단계를 해야한다. 그러면 3단계, 4단계도 다시 해야하는 것이다. 즉, 다시 **렌더링** 된다는 말이다. 그러면 transform을 갑자기 변경하면? **4단계 composite 처리만 다시 하면 되니까 부담이 훨씬 덜하게 되는 것**이다. 결과적으로 transform의 성능이 margin보다 좋은 것이다. 특히, 자바스크립트가 너무 많은 사이트는 애니메이션을 항상 transform으로 줘야한다.\n\n\u003cbr\u003e\n\n추가로, **transform이 더 빠른 두 번째 이유**가 있다. 원래 웹 브라우저는 HTML, CSS 처리건 자바스크립트 실행이건 쓰레드 1개만 사용한다. 그런데, composite 처리 단계에 있는 css 속성들은 **다른 쓰레드에서 처리해준다.** 자바스크립트가 아무리 많아도 애초에 다른 쓰레드에서 처리하기 때문에 transform이 빠른 것이다.  \n\n\u003cbr\u003e\n\n다음으로, **keyframes**는 몇 퍼센트 진행했는지 진행도에 따라 나눠서 코드를 작성하면 된다. 그 이후, 사용하고자 하는 클래스에 `animation-name: 작명;` , `animation-duration: 몇초;`와 같은 식으로 작성하면 된다.\n\n```css\n@keyframes 작명 {\n\t0% {\n\n\t}\n\n\t50% {\n\t\n\t}\n\n\t100% {\n\t\n\t}\n}\n```\n\n\u003cbr\u003e\n\n**animation 관련 속성**\n\n```css\n.box:hover {\n\tanimation-name: 움찔움찔;\n\tanimation-duration: 1s;\n\t/* 베지어 주기 (처음에 실행할 지 나중에 실행할 지) */\n\tanimation-timing-function: linear;\n\t/* 시작 전 딜레이 */\n\tanimation-delay: 1s;\n\t/* 몇회 반복할것인가 */\n\tanimation-iteration-count: 3;\n\t/* 애니메이션을 멈추고 싶은 경우 자바스크립트로 이거 조정 */\n\tanimation-play-state: paused;\n\t/* 애니메이션 끝난 후에 원상복구 하지말고 정지 */\n\tanimation-fill-mode: forwards; \n}\n```\n\n\u003cbr\u003e\n\n### 3D 애니메이션 (사진 뒤집기)\n  \n- 앞면, 뒷면 배치는 `position: absolute` 사용해야함\n\n- inner 자체를 뒤집어버리는게 나음\n\n- `transform: rotate()`를 사용하는 것이라 처음에 뒷면을 미리 뒤집어놔야함\n\n- 뒷면의 모습이 안보이게 `transform-style: preserve-3d;`와 `front의 z-index 우선순위 높이기`, `backface-visibility: hidden;`\n\n- 내용은 \u003ca href='https://github.com/Shin-Jae-Yoon/TILbefore/blob/master/Language/html_css/lecture/codding_apple/%EA%B3%A0%EA%B8%89%EB%AA%A8%EB%93%88/threeD_animation.html' target='_blank'\u003ethreeD_animation.html\u003c/a\u003e 참고\n\n\u003cbr\u003e\n\n### 애니메이션 성능 잡는 방법들\n\n1. `will-change` 사용\n\n```css\n.box {\n\twill-change: transform;\n}\n```\n\n애니메이션을 주는 `.box`가 약간 느리게 동작할 때 `will-change: 애니메이션 줄 속성`을 써놓으면 성능개선이 가능하다. 이는 **바뀔 내용을 미리 렌더링 해주는 속성**이기 때문이다. 애니메이션이 이상하게 버벅이면 사용하고 잘 작동하면 굳이 쓸 필요는 없다. 왜냐하면 많이쓰면 오히려 더 느려질 수 있기 때문이다. 이와 관련된 내용과 will-change에 관한 추가적인 내용은 \u003ca href='https://dev.opera.com/articles/ko/css-will-change-property/' target='_blank'\u003e여기\u003c/a\u003e에 있다.\n\n\u003cbr\u003e\n\n2. 하드웨어 가속\n\n애니메이션이 많아서 CPU만으로 연산이 불가능하면 GPU의 도움을 받으면 된다.\n\n```css\n.box {\n\ttransform: translate3d(0, 0, 0);\n}\n```\n\n이와 같이 쓰면 3D 이동도 가능한데, 이때 GPU를 사용해서 연산한다. 그래서 이걸 이용한 꼼수인데 `translate3d(0, 0, 0)`으로 사용하면 아무곳으로 이동하지 않는 3D 이동 명령을 주고 뒤에 필요한 transform을 적용한다면 GPU를 이용해서 box 클래스가 가진 transform 속성들을 연산하는 원리이다.\n\n\u003chr\u003e\n\n## CSS 스킬 심화\n\n### CSS Grid\n\n- `display: grid`는 격자 모눈종이가 있다면 색칠해나가는 방식으로 생각\n\n- 부모 div에 `display: grid`, `grid-template-columns: `, `grid-template-rows: ` 주면 자식들은 모눈종이가 된다.\n\n- rows는 가로칸 갯수, 사이즈 columns는 세로칸 갯수, 사이즈\n\n- `grid-gap: `은 격자 간격\n\n\u003cbr\u003e  \n\n가로 2칸, 세로 3칸짜리 모눈종이\n\n```html\n\u003cdiv class=\"grid-container\"\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\t\u003cdiv\u003e\u003c/div\u003e\n\u003c/div\u003e\n```\n\n```css\n.grid-container {\n\tdisplay: grid;\n\tgrid-template-columns: 100px 100px 100px;\n\tgrid-template-rows: 100px 100px;\n}\n```\n\n![](brain/image/all-in-one-last-1.png)\n  \n\u003cbr\u003e\n\ngrid 컨테이너에서 사용하기 좋은 단위는 **fr(fraction)** 이다. 그리드 트랙 사이즈로 사용 되는 fr 단위는 유연한 단위로 그리드 컨테이너의 여유 공간을 비율로 나눠 설정한다. 퍼센트(%) 단위와 유사해 보일 수 있으나, 퍼센트 값과 다르게 길이가 아니다. **fr은 몇 배수**로 이해한다.\n\n\u003cbr\u003e\n\n```css\n/* 이러면 전체 가로에 대해 1배, 1배, 1배 */\n/* rows는 높이의 개념이라 height 속성이 있어야 fr 먹을거임 */\n.grid-container {\n\tdisplay: grid;\n\tgrid-template-columns: 1fr 1fr 1fr;\n\tgrid-template-rows: 100px 100px;\n}\n```\n\n\u003cbr\u003e\n\n**grid 이용한 레이아웃 만들 때**\n\n1. 내부 박스 크기 조절\n2. 그냥 부모 건드리기\n\n\u003cbr\u003e  \n\n**1번 방법**. 자식 div 높이와 폭을 조정하는 방법이다. 내부 박스에게 그냥 `grid-column`이나 `grid-row`를 줘본다.\n\n```css\n.grid-nav {\n\tgrid-column: 1 / 4;\n}\n```\n  \n`grid-column`은 세로 선을 의미한다. 이때 `display: grid`의 자식들에만 사용 가능하다. 따라서 여기서는 여러 div 박스를 의미한다. `1 / 4`가 의미하는 바는 세로선 1~4 만큼 차지해달라는 뜻이다.\n\n\u003cbr\u003e\n\n![](brain/image/all-in-one-last-2.png)\n\n```css\n.grid-nav {\n\tgrid-row: 1 / 3;\n}\n```\n\n`grid-row`은 가로 선을 의미한다. 이때 `display: grid`의 자식들에만 사용 가능하다. 따라서 여기서는 여러 div 박스를 의미한다. `1 / 3`가 의미하는 바는 가로선 1~3 만큼 차지해달라는 뜻이다.\n\n![](brain/image/all-in-one-last-3.png)\n\n\u003cbr\u003e\n\n이런식으로 작성하고 최종적으로 나머지 div박스 지운다.\n\n```html\n\u003cdiv class=\"grid-container\"\u003e\n\t\u003cdiv class=\"grid-nav\"\u003e\u003c/div\u003e\n\t\u003cdiv class=\"grid-sidebar\"\u003e\u003c/div\u003e\n\t\u003cdiv class=\"grid-content\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n```\n\n```css\n.grid-container {\n\tdisplay: grid;\n\tgrid-template-columns: 100px 100px 100px 100px;\n\tgrid-template-rows: 100px 100px 100px;\n}\n \n.grid-container div {\n\tborder: 1px solid black;\n}\n\n.grid-nav {\n\tgrid-column: 1 / 5;\n}\n\n.grid-sidebar {\n\tgrid-row: 2 / 4;\n}\n\n.grid-content {\n\tgrid-column: 2 / 5;\n\tgrid-row: 2 / 4;\n}\n```\n\n\u003cbr\u003e  \n\n**2번 방법**. 자식에 이름 쓰고 부모는 색칠하기\n\n```css\n.grid-nav {\n\tgrid-area: 헤더;\n}\n\n.grid-sidebar {\n\tgrid-area: 사이드;\n}\n```\n\n`grid-area: `는 자식에 이름짓는 속성이다. 그리고 이후에 `grid-template-areas: \" \" ` 형태로 배치해주면 된다. 배치할 때 기억자 같이 배치는 안되고 사각형 모양으로만 가능하다.\n\n```css\n.grid-container {\n\tdisplay: grid;\n\tgrid-template-columns: 100px 100px 100px 100px;\n\tgrid-template-rows: 100px 100px 100px;\n\tgrid-template-areas:\n\n\t'헤더 헤더 헤더 헤더'\n\t'사이드 . . .'\n\t'사이드 . . .';\n}\n```\n\n\u003cbr\u003e\n\n**Grid 숙제 관련**\n\n\u003cbr\u003e\n\n이미지 (img) 파일은 기본적으로 글자취급 받기 때문에 글자의 베이스라인처럼 이미지 밑에 하얀색 선이 거슬리게 나올 수 있다. 그때 반드시 `display: block;`을 줘서 없애도록 해보자!\n\n\u003cbr\u003e\n\n### CSS 스킬 sticky\n\n- 스크롤해도 상단에 고정하고자 하는 속성에 `position: sticky;`\n\n- 주고 나서 어느 위치에 고정될 지도 정해준다. ex) top, bottom\n\n- sticky는 마치 fixed와 유사하다.\n\n- fixed는 viewport에다가 div 박스나 이미지를 고정시킬 때 쓰는 속성이었다. 그래서 fixed 해버리면 스크롤 해도 그 화면에 딱 고정된다.\n\n- 즉, sticky는 조건부 fixed이다. 그냥 스크롤 하다가 sticky 부여된 녀석을 만났을 때 조건적으로 fixed 되는 것이다.\n\n- 부모 박스 넘어서면 sticky는 해제된다.\n\n```css\n.image {\n\tfloat: right;\n\twidth: 400px;\n\tposition: sticky;\n\ttop: 100px;\n}\n```\n\n정리하자면, `position: sticky` \n\n1. 스크롤을 할 만한 부모 박스가 있어야 함\n2. top 등 좌표속성과 함께 써야 제대로 보임\n","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-html/all-in-one-mid":{"title":"All-in-One 중급모듈","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/html-basics/' target='_blank'\u003eHTML/CSS All-in-one : 기초부터 Bootstrap, SASS, 고급 animation 까지\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 폰트 설정법\n\n- `font-family : '폰트'` 형식으로 설정한다.\n\n- 버그 없이 사용하려면 폰트의 영문명 사용\n\n- 폰트를 여러개 설정하는 이유는 안정석 확보를 위해서이다. 왼쪽부터 적용된다.\n\n- 아래 예시에서 gulim이 없어서 적용 안된다면 gothic으로 적용한다는 의미\n\n- 웹사이트 이용자의 컴퓨터에 설치가 된 폰트들을 적용할 수 있다.\n\n```css\nbody {\n\tfont-family: 'gulim', 'gothic';\n}\n```\n\n\u003cbr\u003e\n\n**사용자의 컴퓨터에 설치되지 않은 폰트를 사이트에서 이용하는 방법**\n\n- css 최상단에 `@font-face`로 적용할 폰트의 경로와 이름 작성\n\n- 웹 폰트용으로 나온 **woff**파일은 ttf에 비해 용량의 3분의 1 수준\n\n```css\n@font-face {\n\tfont-family: '폰트이름';\n\tsrc: url(폰트 저장 주소);\n}\n```\n\n\u003cbr\u003e\n\n**Google Fonts 사용**\n\n- 폰트 파일 없이, 구글 폰트를 직접 링크하는 방식\n\n- 구글이 호스팅해주는 폰트가 미리 정의된 css 파일을 가져다 사용하는 방식이다.\n\n- **내 사이트의 트래픽 절약 가능**\n\n- 크롬 브라우저가 이미 방문한 사이트는 캐싱해주기 때문에 많은 사람들이 이용할수록 더 빠르게 폰트를 이용 가능\n\n- html 적용 - `\u003clink\u003e` 부분\n\n- css 적용 - `@import` 부분\n\n\u003chr\u003e\n\n## 폰트 Anti-aliasing  \n\n- 폰트 앤티앨리어싱은 폰트를 부드럽게 보여주는 기술\n\n- 픽셀의 각진 부분을 부드럽게 바꾸는 방법\n\n- mac은 자동으로 앤티앨리어싱 해주지만, window는 아님\n\n- 글자에 각도를 주고 살짝 돌리면 됨\n\n```css\np,\nh4,\nh3,\nh2,\nh1,\nspan,\nbutton {\n\ttransform: rotate(0.03deg);\n}\n```\n\n\u003chr\u003e\n\n## flex\n\n- 가로 배치, 혹은 여러 배치에서 자주 사용할 flex 속성이다.\n\n- 부모 태그에 `display : flex;` 설정한다.\n\n- `justify-content: flex-start;` 좌측 정렬\n\n- `justify-content: flex-end;` 우측 정렬\n\n- `justify-content: flex-center;` 가운데 정렬\n\n- `justify-content: space-between;` 사이 사이 떨어뜨리게 꽉차게\n\n- 세로 배치 원하면, `flex-direction: column;`\n\n```css\n.flex-container {\n\tdisplay: flex;\n\tjustify-content: flex-start;\n}\n\n.flex-item {\n\twidth: 100px;\n\theight: 100px;\n\tbackground-color: gray;\n\tmargin: 5px;\n}\n```\n\n\u003cbr\u003e\n\n- flex에서 600px를 줬다고 하면, 실제 크기가 600px 되는 것이 아니라, 최대한 거기까지 키운다는 의미\n\n- width가 커서 밑으로 보내고 싶다면 `flex-wrap: wrap;` 속성 이용\n\n- flex 이용 시 상하 정렬은 `align-item: center;` 속성 이용\n\n```css\n/* 궁극적인 상하좌우 정렬 */\n\n.flex-container {\n\tdisplay: flex;\n\theight: 500px;\n\talign-items: center;\n\tjustify-content: center;\n}\n```\n\n\u003cbr\u003e\n\n- flex에서는 박스 크기를 px 말고 **비율**로 설정 가능하다.\n\n- `flex-grow` 속성은 몇 배수를 의미한다.\n\n- 아래의 예시는 1:2:1이다.\n\n```html\n\u003cdiv class=\"flex-container\"\u003e\n\t\u003cdiv class=\"flex-item\" style=\"flex-grow: 1\"\u003e1\u003c/div\u003e\n\t\u003cdiv class=\"flex-item\" style=\"flex-grow: 2\"\u003e2\u003c/div\u003e\n\t\u003cdiv class=\"flex-item\" style=\"flex-grow: 1\"\u003e3\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n- navbar 디자인 하고싶을 때 가운데를 붕 띄우고 싶으면 가운데만 비율주고 띄운다.\n\n```html\n\u003cdiv class=\"flex-container\"\u003e\n\t\u003cdiv class=\"flex-item\"\u003e1\u003c/div\u003e\n\t\u003cdiv class=\"flex-item\" style=\"flex-grow: 1\"\u003e2\u003c/div\u003e\n\t\u003cdiv class=\"flex-item\"\u003e3\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n![](brain/image/all-in-one-mid-1.png)\n\n- \u003ca href='https://studiomeal.com/archives/197' target='_blank'\u003e1분 코딩 css-flex\u003c/a\u003e\n- \u003ca href='https://studiomeal.com/archives/533' target='_blank'\u003e1분 코딩 css-grid\u003c/a\u003e\n\n\u003chr\u003e\n\n## HTML head 태그\n\n- head 태그에는 사이트 내에서 눈에 보이지 않는 중요한 정보들\n\n\u003cbr\u003e\n\n1. css 파일 첨부\n\t- link 태그 이용\n\t- 상대경로 방식, 절대경로 방식\n\n\u003cbr\u003e\n\n  \n\n2. 스타일 태그\n\t- css 파일과 유사하게 동작\n\t- body 태그 안에 있어도 동작하지만 html 파일 코드는 위에서 아래로 읽어나가는 방식이라서 body 태그에 뒀을 때 사이트 로딩 시 스타일이 깨질 수 있음\n\n\u003cbr\u003e\n\n3. 사이트 제목\n\t- 브라우저 탭에 뜨는 이름\n\n\u003cbr\u003e\n\n4. **meta 태그**\n\n```html\n\u003chead\u003e\n\t\u003cmeta charset=\"UTF-8\" /\u003e\n\t\u003cmeta name=\"description\" content=\"백엔드 마스터 신재윤입니다.\" /\u003e\n\t\u003cmeta name=\"keywords\" content=\"백엔드, backend, 개발자, 신재윤\" /\u003e\n\t\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n\u003c/head\u003e\n```\n\n- 4-1 : 사이트 인코딩 형식 지정 방법\n\n- 4-2 : 사이트 검색 결과 화면에 뜨는 글귀\n\n- 4-3 : 검색에 도움을 주는 키워드\n\n- description은 구글 검색 시 파란 제목으로 뜨는 글귀\n\n- keywords는 검색에 도움을 주는 키워드\n\n- 4-4 : 사이트 초기 줌 레벨이나 폭을 지정해주는 것\n\n- `width=device-width`는 모바일 기기의 실제 폭으로 렌더링 해주는 것\n\n- 실제 접속 시 스마트폰 기기의 실제 가로폭을 보고 렌더링하라는 명령어\n\n- `initial-scale=1`은 접속시의 화면 줌 레벨 설정\n\n\u003cbr\u003e\n\n5. open graph\n\n```html\n\u003chead\u003e\n\t\u003cmeta property=\"og:image\" content=\"/이미지경로.jpg\" /\u003e\n\t\u003cmeta property=\"og:description\" content=\"사이트설명\" /\u003e\n\t\u003cmeta property=\"og:title\" content=\"사이트제목\" /\u003e\n\u003c/head\u003e\n```\n\n- og 메타 태그는 facebook이 만든 태그\n\n- 카카오톡, 페이스북 같은 sns에 링크를 공유했을 때 뜨는 박스\n\n- 그 박스에 보이는 이미지, 사이트 제목, 사이트 설명\n\n![](brain/image/all-in-one-mid-2.png)\n\n\u003cbr\u003e  \n\n6. Favicon\n\n```html\n\u003chead\u003e\n\t\u003clink rel=\"icon\" href=\"아이콘경로.ico\" type=\"image/s-icon\" /\u003e\n\u003c/head\u003e\n```\n\n- 상단 탭 웹사이트 제목 옆에 뜨는 이미지 아이콘\n\n- ico 형식 대신 png도 가능, 하지만 ico가 호환성 best\n\n- 32 x 32 사이즈가 보편적\n\n- 웹 사이트를 바탕화면에 바로가기 추가했을 경우 뜨는 아이콘도 커스터마이징 가능\n\n- `rel=\"apple-touch-icon-precomposed\"` 이렇게 rel 속성을 조정\n\n- OS마다 요구하는 rel 속성이 달라지니까 그때그때 찾아서 적용\n\n- 혹은 favicon generator 검색하면 OS별로 알아서 만들어줌\n\n\u003chr\u003e\n\n## **반응형 웹**\n\n\u003cbr\u003e\n\nvw (viewport width)\n- 브라우저 폭에 비례\n\n\u003cbr\u003e\n\nvh (viewport height)\n- 브라우저 높이에 비례\n\n\u003cbr\u003e  \n\n**rem (기본 폰트사이즈에 비례)**\n\n- 보통 html 태그 폰트 사이즈는 기본 16px로 설정되어있다.\n\n- 10rem이라고 하면 160px이 되는 것이다.\n\n- 버튼이든 패딩이든 마진이든 전부 rem으로 크기지정하면 기본 font-size가 커져도 모든게 같이 커진다는 장점이 있다.\n\n- 요즘은 컨트롤 누르고 마우스휠 올리면... 다 같이 커지기는 한다\n\n\u003cbr\u003e\n\nem (내 폰트 사이즈의 몇배)\n\n- 만약 내 폰트 사이즈가 15px, width가 20em이면 300px이 되는 것이다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n반응형 웹사이트를 만들 때, html head 태그에 meta 태그를 반드시 추가해야한다. 느낌표 emmet 하면 들어가있기는 하다.\n\n```html\n\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n```\n\n\u003cbr\u003e\n\n기본적인 원리는 media query 문법이다. 아래 코드는 현재 브라우저 폭이 1200px 이하인 경우 저 내용을 적용해라는 의미이다.\n\n```css\n@media screen and (max-width: 1200px) {\n\t.main-title {\n\t\tfont-size: 30px;\n\t}\n}\n```\n\n반응형 웹에서 breakpoint 기준은 **1200px, 992px, 768px, 576px** 단위를 많이 사용한다. 보통 1200px 부터 태블릿, 768px부터 모바일 이런식으로 많이 사용한다. breakpoint는 4개 이상으로 넘어가면 복잡해진다.\n\n\u003chr\u003e\n\n## 크롬 개발자 도구 (디버깅)\n\n- css 스타일링을 바꿨는데 바뀌지 않는 오류가 있다면, 파일을 찾기보다 크롬 개발자 도구를 사용하자\n\n- **우선 적용중인 스타일을 맨 위에서 보여준다**\n\n- css의 !important 속성 (10000점)\n\n- html의 style 속성 (1000점)\n\n- css의 id 속성 (100점)\n\n- css의 class 속성 (10점)\n\n- html의 태그를 css에서 셀렉터 이용 (1점)\n\n\u003chr\u003e\n\n## Font Awesome\n\n평소에 자주 사용하던 폰트어썸 사이트, 간단한 아이콘을 폰트 취급하여 사용\n\n\u003cbr\u003e\n\n사용방법\n\n  1. 웹 Kit 방식 : 폰트 어썸 사이트에서 kit 생성하고 html head 파일에 삽입하는 방식. 서버 용량이 많지 않거나 귀찮을때 그냥 사용한다. 간단한 프로젝트에서 보통 많이 사용함.\n\n2. CDN 방식 : Content Delivery Network (콘텐츠 전송 네트워크) 방식으로 폰트 어썸이 호스팅하는 서버에서 아이콘들을 받아와서 사용하는 방식이다.\n\n\u003e [!note] Kit 방식 vs CDN 방식?\n\u003e\n\u003e 사실 kit 방식과 cdn 방식이 어떤 차이인지 모르겠다.\nkit 방식은 회원가입 후 발급받은 킷을 이용했고\ncdn 방식은 구글에 fontawesome cdn 검색해서 나오는\ncdnjs 사이트에서 그 링크를 이용했다.\ncdnjs에서 가져온 링크는 로그인 할 필요도 없이 바로\n사용할 수 있었다.\n\n\u003cbr\u003e\n\n3. css 파일 다운로드 : 위의 두 방식은 폰트어썸 측의 서버가 다운되면 나에게도 영향이 끼친다는 의미이다. 이를 방지하고자 css 파일을 다운로드 받고 사용하는 방식이 있다. 강의에서는 다운받은 zip 파일에서 css 폴더의 `all.css`, `all.min.css`, `webfonts 폴더` 빼고 모두 지웠다. 그리고 웹폰트 폴더에서도 용량이 적은 woff만 사용했다.\n\n\u003cbr\u003e\n\nFont Awesome 사용할 때 css 파일에서 font-size를 조절 혹은 html의 style 속성에서 font-size를 조절하곤 했는데, 간단한 약어로 아이콘 크기 조정, 회전, 애니메이션 효과, 아이콘 끼리 중첩 등이 가능했다. 보통 크기 조절은 간단하게 `\u003ci class=\"fa-solid fa-cart-shopping fa-3x\"\u003e\u003c/i\u003e`와 같이 `fa-1x` 부터 `fa-5x`까지 되는 것 같았다.\n\n\u003cbr\u003e\n\n- \u003ca href='https://nuknukhan.tistory.com/38' target='_blank'\u003eFontAwesome 스타일링 간단 사용법\u003c/a\u003e\n- \u003ca href='https://fontawesome.com/docs/web/style/styling' target='_blank'\u003eFontAwesome DOCS\u003c/a\u003e\n\n\u003chr\u003e\n\n## 애니메이션 만드는 원리\n\n\u003cbr\u003e\n\none-way 애니메이션 만드는 방법 \n\n1. 시작스타일 만들기\n2. 최종스타일 만들기\n3. 언제 최종스타일로 변하는지 (ex. 마우스로 올렸을 때)\n4. transition으로 애니메이션 속성 주기\n\n\u003cbr\u003e\n\ntransition 세부 속성\n\n```css\n.box {\n\ttransition-delay: 1s; /* 시작 전 딜레이 */\n\ttransition-duration: 0.5s; /* transition 작동 속도 */\n\ttransition-property: opacity; /* 어떤 속성에 transition 입힐 지 */\n\ttransition-timing-function: ease-in; /* 동작 속도 그래프 조정 */\n}\n```\n\n- \u003ca href='https://github.com/Shin-Jae-Yoon/TIL/blob/master/Language/html_css/lecture/codding_apple/%EC%A4%91%EA%B8%89%EB%AA%A8%EB%93%88/hw_responsive.css' target='_blank'\u003e애니메이션 실습 예제 -  hw_responsive\u003c/a\u003e\n- \u003ca href='https://github.com/Shin-Jae-Yoon/TIL/blob/master/Language/html_css/lecture/codding_apple/%EC%A4%91%EA%B8%89%EB%AA%A8%EB%93%88/hw2_animation.css' target='_blank'\u003e애니메이션 숙제 예제 hw2_animation\u003c/a\u003e\n\n\u003cbr\u003e\n\n흘러넘치는거 숨겨주는 `overflow: hidden` 속성 까먹지 말자. overflow 속성은 박스의 폭이나 높이를 초과하는 내부요소를 처리하기 위한 속성이다. 만약 `overflow: visible`하면 넘치는 부분 보여주고 `overflow: scroll`하면 넘치는 요소를 보기 위한 스크롤 바가 생성된다.\n\n\u003cbr\u003e\n\n추가로 다른 사이트에서 애니메이션 작동원리 보려면 크롬 개발자 도구에서 마우스로 찍은 후에 점 세개 눌러서 more tools에서 animations 탭을 보면 어떤 속성이 어느 정도의 시간에 거쳐서 변화하는지 보여준다.\n\n\u003chr\u003e\n\n## Bootstrap  \n\n- html, css 개발 속도를 빠르게 해주는 것\n- css와 js cdn을 복사해서 붙혀넣기 하면 사용할 수 있다. css는 head 태그, js는 body 태그\n- 유용한 키워드 : Navbar, Card, Carousel, Modal, Badge, Media Object, Shadow\n\n\u003cbr\u003e\n\n개발시간 단축하는 Utility class가 제공된다.  \n- container 클래스를 사용하면 여백 가진 박스가 생성된다.\n- margin-top 같은 경우 `mt-3`이라고 하면 margin-top이 3정도 들어간다. 1~5까지 있다.\n- padding-left와 right의 경우 `ps-5`, `pe-5`라고 한다. start와 end의 약자이다.\n- 가운데 정렬은 `text-center`하면 된다.\n- 폰트 사이즈는 `fs-3`로 하면된다. 1~6까지 있다.\n- width는 `w-50`으로 하면 된다. %수치라서 100%까지 된다.\n- 부트스트랩 홈페이지에서 Utilities에서 유틸리티 클래스 명을 찾을 수 있다.\n\n```html\n\u003cdiv class=\"container\"\u003e카드 같은거 ~\u003c/div\u003e\n\u003ch5 class=\"card-title mt-3\"\u003eCard title\u003c/h5\u003e\n\u003ch5 class=\"card-title text-center\"\u003eCard title\u003c/h5\u003e\n\u003ch5 class=\"card-title fs-5\"\u003eCard title\u003c/h5\u003e\n```\n\n\u003cbr\u003e  \n\n부트스트랩은 특히 **반응형 레이아웃**에 관한 개발속도를 향상시킨다. container 박스 안에 row와 col을 적절하게 배열하면 된다. 보통 한 행 기준 12칸으로 쪼개는데 `col-4`로 하면 정확하게 3등분 되는 것이다.\n\n```html\n\u003cdiv class=\"container\"\u003e\n\t\u003cdiv class=\"row text-center\"\u003e\n\t\t\u003cdiv class=\"col-4\"\u003e안녕하세요\u003c/div\u003e\n\t\t\u003cdiv class=\"col-4\"\u003e안녕하세요\u003c/div\u003e\n\t\t\u003cdiv class=\"col-4\"\u003e안녕하세요\u003c/div\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n여기서 반응형을 추가하는 방법은 **조건문**을 더하면 된다. 현재, 웹 사이즈에서는 가로로 배열되어있는데 모바일에서는 세로로 배열하고 싶다고 하자. 그때 `-md`를 달아본다. md는 768px 이상에서만 저 조건을 실행해달라는 의미이다. 추가적인 자료는 \u003ca href='https://getbootstrap.com/docs/5.1/layout/grid/' target='_blank'\u003eBootstrap 공식 문서\u003c/a\u003e에서 확인한다.\n\n\u003cbr\u003e\n\n반응형 웹을 디자인 할 때, 모바일 화면을 먼저 설계하는 것이 편하다.\n- \u003ca href='https://github.com/Shin-Jae-Yoon/TIL/blob/master/Language/html_css/lecture/codding_apple/%EC%A4%91%EA%B8%89%EB%AA%A8%EB%93%88/hw4_snsProfile.html' target='_blank'\u003ehw4_snsProfile 실습\u003c/a\u003e은 99% 부트스트랩으로 제작했음\n- 부트스트랩에서 flex의 shrink, grow가 헷갈린다? \u003ca href='https://studiomeal.com/archives/197' target='_blank'\u003e1분 코딩 css-flex\u003c/a\u003e, \u003ca href='https://darrengwon.tistory.com/130' target='_blank'\u003e티스토리 블로그\u003c/a\u003e 참고\n- 부트스트랩의 d-flex 등 다양한 레이아웃은 \u003ca href='https://espania.tistory.com/142' target='_blank'\u003e여기\u003c/a\u003e 참조\n\n\u003cbr\u003e\n\n### Bootstrap 수직정렬\n\n\u003cbr\u003e\n\n\u003ca href='https://github.com/Shin-Jae-Yoon/TIL/blob/master/Language/html_css/lecture/codding_apple/%EC%A4%91%EA%B8%89%EB%AA%A8%EB%93%88/bootstrap2.html' target='_blank'\u003ebootstrap2.html\u003c/a\u003e 예제에서 사진과 글자를 수직정렬할 때의 문제이다. css를 다룰 때 고질적으로 겪었던 오류이다. 부트스트랩의 `align-middle`을 아무리 써봐도 글자가 수직정렬 되지 않았다. 근본적인 해결책을 찾고자 한다.\n\n\u003cbr\u003e\n\n먼저, 글은 p 태그로 작성한 상태이다. \u003ca href='https://programmer-ririhan.tistory.com/83' target='_blank'\u003e티스토리 블로그 글\u003c/a\u003e에서 css를 통한 수직 정렬을 하는 vertical-align 속성은 block 요소가 아닌 inline 혹은 inline-block에서만 사용 가능하다는 점이다. 아차! 싶었다. p 태그는 display 기본 속성이 block 속성이다. 그래서 \u003ca href='https://getbootstrap.com/docs/5.1/utilities/vertical-align/' target='_blank'\u003eBootstrap docs Vertical alignment\u003c/a\u003e도 살펴보면, `To vertically center non-inline content (like \u003cdiv\u003es and more), use our flex box utilities.`라고 떡하니 나와있었다. block 속성은 flex box utilities를 이용하라고..\n\n\u003cbr\u003e\n\n또 vertical-align 속성에 대한 잘못된 지식이 있었음을 알 수 있었다. 하나의 div 박스가 있고 그 박스에 `text-align : middle;`속성을 줬을 때 가운데 정렬이 되었던 경험을 살려 `vertical-align: middle;`하면 되겠지~ 싶었는데 서로 다른 느낌이다. text-align은 말 그대로 박스 안의 가운데 정렬이 맞지만, vertical-align은 간단한 inline 내에서 높낮이 정도 조절하는 것이다. \u003ca href='https://developer.mozilla.org/ko/docs/Web/CSS/text-align' target='_blank'\u003etext-align MDN 공식문서\u003c/a\u003e에서 **블록 요소나 표의 칸 상자의 가로 정렬을 설정한다**고 떡하니 나와있고, \u003ca href='https://developer.mozilla.org/ko/docs/Web/CSS/vertical-align' target='_blank'\u003evertical-align MDN 공식문서\u003c/a\u003e에서 **inline 또는 table-cell box에서의 수직 정렬을 지정한다**고 떡하니 나와있다. 내가 가진 개념은 오개념이었다.\n\n\u003cbr\u003e\n\n\u003ca href='https://getbootstrap.com/docs/5.1/utilities/flex/#align-items' target='_blank'\u003eBootstrap docs align\u003c/a\u003e에서는 정의한다. `align-items-center`를 이용하여 flex 아이템들을 정렬시키든 `align-self-center`를 이용하여 정렬시키는 방법이 떡하니 나와있었다. 예제의 경우 `row` 클래스의 행 속성에 `align-items-center`를 이용하여 아이템들을 가운데 정렬 시키든가 혹은 `col`클래스의 열 속성에 `align-self-center`를 이용하여 가운데 정렬 시키든가 두 방법 중 하나를 선택하면 된다.\n\n\u003cbr\u003e\n\n추가로, flex 박스의 순서를 부여하고자 할 때는 `order`를 이용하도록 한다. 물론 order 클래스 역시 조건문을 달아서 반응형으로 제작 가능하다. `order-lg-3`의 형태로 !\n\n\u003cbr\u003e\n\n### Bootstrap pill badge  \n\n부트스트랩에서 알약 모양 bill badge 썼을 때 알약이 깨지는 경우에는 `box-sizing: border-box;` 확인하자\n\n\u003chr\u003e\n\n## CSS 레거시 코드 수정 방법\n\n원본 CSS 파일을 건들기 애매한 경우 CSS를 덮어쓰는 방법이 있다.\n\n1. 같은 클래스명 하단에 작성\n2. 우선순위 높이기\n3. specificity 높이기\n\n먼저, 1번의 방법을 설명하겠다. HTML 파일에서 main.css를 link하고 있다고 하자. 그러면 그 아래에 main2.css를 한 번 더 link 하는 방식이다.\n\n\n```css\n/* main.css */\n.custom {\n\tcolor: green;\n}\n\n/* main2.css */\n.custom {\n\tcolor: blue;\n}\n```\n\n이렇게 작성하면 결과적으로 색깔이 blue로 바뀔 것이다. **같은 class면 더 밑에 있는게 우선 적용되는 원리이다.** 즉, css 파일이 나뉘어져 있어도 밑에 있으면 더 우선적으로 적용되는 성질이다. media query도 밑에 작성하는 이유도 바로 이것이다.\n\n\u003cbr\u003e\n\n2번의 방법은 우선순위를 높이는 것이다. 위에서 **html의 style 속성 (1000점), css의 id 속성 (100점), css의 class 속성 (10점), html 태그 셀렉터 (1점)** 방법을 이용한다. 사실 10000점 짜리도 있다. `!important`가 붙은것은 무조건 최우선적으로 적용된다.\n\n```css\n.custom {\n\tcolor: red !important;\n}\n```\n\n그러나, 우선순위를 높이는 방식은 근본적인 해결방법이 아니다. 계속 우선순위를 높여갈 수 없지 않은가? 따라서 이 방법은 급할 때 사용하되 가능한 사용하지 않도록 한다.\n\n\u003cbr\u003e\n\n마지막으로 specificity 점수를 높이는 것이다. 클래스 명을 더 세부적으로 적어서 점수를 찔끔찔끔 올리는 방식이다.  \n\n```css\n/* 태그 셀렉터 1점 + class 10점 + class 10점 = 21점 */\ndiv.main-background .custom {\n\tcolor: green;\n}\n\n/* class 10점 = 10점 */\n.custom {\n\tcolor: red;\n}\n```\n\n\n따라서, .custom이 아래에 있다고 해도 위가 최종적으로 점수가 높기 때문에 위의 코드가 적용된다. 그러면 애초에 위처럼 누가 작성해놨다고 하면?\n\n```css\n/* 남이 짜놓은 레거시 코드, 21점 */\ndiv.main-background .custom {\n\tcolor: green;\n}\n\n/* 조금이라도 점수 올리기 위한 발악, 22점 */\ndiv.main-background p.custom {\n\tcolor: red;\n}\n```\n\n그래서, 처음부터 셀렉터를 너무 정확하게 적어놓으면 나중에 덮어쓰기 힘들 수 있다. 그래서 클래스명 하나를 작성하는 방식을 처음에 사용하도록 노력하자.\n\n\u003cbr\u003e\n\n**좋은 코드의 기준**\n\n1. 나중에 수정/관리가 쉬운 코드\n2. 확장성이 좋은 코드\n\n즉, 재활용 가능하고 확장해서 다른 class 만들기 쉽다면 좋은 css 코드라고 할 수 있다.","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-js/":{"title":"코딩애플 - JavaScript","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-js/apple-js":{"title":"Javascript 입문과 웹 UI 개발","content":"\n\u003cbr\u003e\n\n\u003e [!note] Javascript 입문과 웹 UI 개발 필기노트\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2022.07.26 ~ 2022.08.15\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e 자바스크립트의 기본적인 사용법에 대한 파악\n\n## 목차\n\n- [코딩애플 JS 입문과 웹 개발 01](brain/Lecture/frontend/apple-js/apple-js-01.md)\n- [코딩애플 JS 입문과 웹 개발 02](brain/Lecture/frontend/apple-js/apple-js-02.md)\n- [코딩애플 JS 입문과 웹 개발 03](brain/Lecture/frontend/apple-js/apple-js-03.md)\n- [코딩애플 JS 라이브러리](brain/Lecture/frontend/apple-js/js-library.md)","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-js/apple-js-01":{"title":"LEVEL 01","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/javascript-jquery-ui/' target='_blank'\u003eJavaScript 입문과 웹 UI 개발\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 자바스크립트 사용 목적\n\nJavaScript는 html 파일 내부에 숨어서 **html 조작과 변경**을 담당하는 언어이다.\n\n- 탭, 모달 등 웹페이지 UI 제작 가능\n- 유저가 입력한 데이터 검사 가능\n- 유저가 버튼 누르면 서버로 데이터 요청 가능 등\n\nscript 태그 안에 넣어서 작성한다. 물론 js 파일을 따로 만들어서 link 해도 된다. script 태그 안에 적은 코드는 **브라우저 새로고침시 1번 실행된다.**\n\n\u003cbr\u003e\n\n**`document.getElementById('id명').무엇을 = '어떻게';`** \u003cbr\u003e\n\n`document.getElementById('hi').innerHTML = 'JS 고수에요';` \u003cbr\u003e\n\n- document : 문서, html 문서를 의미\n- 마침표 : ~의\n- getElementById('hi') : 아이디가 hi인 html 요소 (element)를 가져와라, 셀렉터\n- innerHTML : HTML 내부에서\n- 그리고 'JS 고수에요'를 대입하라.\n  \n```javascript\n// 글자 색깔 빨간색으로 변경\ndocument.getElementById('id').style.color = 'red';\n\n// img의 src 변경\ndocument.getElementById('id').src = './img/주소';\n```\n\n\u003cbr\u003e\n\n**`document.getElementsByClassName('class명')\\[인덱스].무엇을 = '어떻게';`**\u003cbr\u003e\n\n`document.getElementsByClassName('hi')[0].innerHTML = 'JS 고수에요';`\n\n- class는 여러 개 나올 수 있어서 인덱싱 해줘야함\n\n\u003chr\u003e\n\n## querySelector\n\ngetElementsByClassName, getElementById와 같이 querySelector는 유용하다. css의 셀렉터 기능을 사용할 수 있게 해준다.\n\n```javascript\ndocument.querySelector('.test').innerHTML = '안녕';\ndocument.querySelector('#test').innerHTML = '안녕';\n```\n\n단, 클래스 사용 시 제일 최상단 요소만 선택되므로, 예를 들어, 두번째 요소를 선택하고 싶으면 querySelectorAll을 사용하고 인덱스를 줘야 한다.\n\n```html\n\u003cul class=\"list-group\"\u003e\n\t\u003cli class=\"list-group-item\"\u003eAn item\u003c/li\u003e\n\t\u003cli class=\"list-group-item\"\u003eA second item\u003c/li\u003e\n\t\u003cli class=\"list-group-item\"\u003eA third item\u003c/li\u003e\n\u003c/ul\u003e\n  \n\u003cscript\u003e\n\tdocument.querySelectorAll('list-group-item')[1].innerHTML = '두번째 아이템';\n\u003c/script\u003e\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### getElementById와 비교\n\n\u003ca href='https://www.measurethat.net/Benchmarks/ShowResult/11974' target='_blank'\u003e벤치마크 결과\u003c/a\u003e를 살펴보면, getElement가 querySelector보다 약 1.2배 빠른 것을 확인 가능하다. getElement가 성능이 좋은 것은 확실하다.\n\n\u003cbr\u003e\n\n하지만, id는 getElementById, class는 getElementByClassName 등 요소마다 다른 것을 사용하는 것은 querySelector를 이용하여 셀렉터를 취급하는 것보다 분명 피곤한 일이다. 또, querySelector는 `id, class, [data-*=\"\"], input[name=\"\"]`등 다양한 셀렉터를 사용할 수 있다.\n\n\u003cbr\u003e\n\nquerySelector가 성능이 약간 떨어질 수 있지만 생산성이 높다는 말이다. 실제로 조금 더 느리다고는 하지만, querySelector는 초당 약 7,000,000 건의 작업을 처리할 수 있다. querySelector도 충분히 빠르다는 말이다. 성능 때문에 querySelector를 지양하고 getElement를 사용하라는 건 조금 받아드리기 힘들다. 실제로, querySelector보다 느린 \u003ca href='https://w3techs.com/technologies/history_overview/javascript_library/all/y' target='_blank'\u003ejQuery의 시장 점유율\u003c/a\u003e을 보면 2022년 8월 17일 기준 77.4%이다. 느려서 querySelector를 쓰지 말아야 한다면, jQuery도 사용하지 말아야 하는 것 아닌가?\n\n\u003cbr\u003e\n\n물론, 생산성 측면에서 봤을 때 jQuery가 querySelector보다 훨씬 높으니까 조~금 어불성설일 수 있지만, 말하고자 하는 것은 속도때문에 querySelector를 포기해야 할 이유가 있는가 하는 것이다. 하나의 주장일 뿐이지만 나도 굳이 getElement를 쓰기 보다는 querySelector를 쓰는 것에 한 표 던진다.\n\n\u003chr\u003e\n\n## UI 만드는 법칙\n1. HTML/CSS로 미리 디자인 (필요하면 미리 숨김)\n\t- `display: none;` 이용\n2. 필요할때 보여주기 (자바스크립트 사용)\n\t- `display: block;` 이용\n\n이걸로 모달창, 드롭다운 메뉴 등 구현 가능\n\n\u003chr\u003e\n\n## 자바스크립트 function\n\n- 긴 코드 축약하고 싶을 때 사용\n- 긴 코드 재사용이 잦을 때 사용\n- 함수명 영어 작명 시\n\n1. 소문자 시작\n2. camelCase\n\n`open_alert()` **X**, `openAlert()` **O**\n\n```javascript\nfunction 작명(파라미터) {\n\tdocument.getElementById('alert').style.display = 파라미터;\n}\n```\n\n```html\n\u003cbutton class=\"alert-open\" onclick=\"작명('flex')\"\u003e띄우기\u003c/button\u003e\n```\n\n- 파라미터 내부에 문자는 `' '` 안, 숫자는 바로  \n\n\u003chr\u003e\n\n## 초창기 겪는 문제들, 오류들\n\n\u003cbr\u003e\n\n1. script 태그를 body 내부에서 상단에 작성한 경우\n\nscript 태그를 body 내부에서 상단에 작성하면 잘 안되는 경우가 있다. script 태그를 조작할 html의 하단에 코드를 작성하는 이유는 렌더링 과정에서 위에서 아래로 읽어가기 때문이다. 따라서 상단에 작성하면 렌더링이 늦을 수 있다.\n\n  \u003cbr\u003e\n\n2. 셀렉터 오타 주의\n\n셀렉터 오타로 자바스크립트 실행이 안되는 경우, 크롬 개발자 도구에서 console 탭에서 에러 타입을 보자. **어쩌구 of null**은 대부분 셀렉터 오타이다. \"style을 읽고 싶은데 왼쪽에 있는것이 null이다~\" 라는 형태의 오류가 자주 보일 것이다.\n\n\u003cbr\u003e\n\n3. 기본 문법 오타  \n\n대문자, 소문자 확인 잘하자. `getElementById`를 `getElementByid`로 작성하지 않았는가? 뭐 잘 안보이면 항상 크롬 개발자도구 console 탭을 확인하자.\n\n\u003chr\u003e\n\n## 이벤트리스너\n\nhtml 버튼 태그에 `onclick` 붙히면 좀 더럽지 않음? 그때 `addEventListener()`을 자바스크립트에서 구현하자. 클릭, 키 입력, 스크롤, 드래그 등 웹 페이지에 조작을 가하는 행위가 **이벤트**이다. 이벤트가 일어나길 귀 기울여서 기다리는 친구가 **이벤트 리스너**이다.\n\n- `'click'` : 마우스 클릭\n- '`mouseover`' : 마우스 갖다대는거\n- `'scroll'` : 마우스 스크롤\n- `'keydown'` : 키 입력\n\n\u003ca href='https://developer.mozilla.org/en-US/docs/Web/Events' target='_blank'\u003e그 외 수많은 이벤트 목록 참고\u003c/a\u003e\n\n```javascript\n셀렉터로찾은요소.addEventListener('event명', function () {\n// 실행할 코드\n});\n\ndocument.getElementById('alert2_close').addEventListener('click', function () {\n\tdocument.getElementById('alert2').style.display = 'none';\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 콜백함수  \n\n위에 addEventListener 사용할 때 첫번째 파라미터에는 event 요소가 들어가고, 두번째 파라미터 자리에 들어갔던 function()이 있을거임\n\n```javascript\n셀렉터로찾은요소.addEventListener('event명', function () {\n// 실행할 코드\n});\n```\n\n- 이 function()이 바로 콜백함수\n- 자바스크립트에서 코드를 순차적으로 실행하고 싶을 때 콜백함수를 자주 사용\n- 콜백함수 자리에 만든 함수 넣어도 됨. 단, `함수()`의 형태가 아닌 `함수`로 넣어야 오류 없이 작동할 것\n\n\u003chr\u003e\n\n## classList, toggle\n\nnavbar 같은 곳에서 주로 사용하는 버튼 눌렀을 때 등장하는 서브메뉴를 구현하려고 한다. 해당하는 UI 제작할 때는\n\n1. 미리 htmml/css 디자인 해놓고 `display: none;`으로 숨긴다.\n2. 버튼 누르면 display 속성 바꿔서 보여준다.\n\n이 경우 `document.getElementById('id').style.display = 'none'`과 같이 작성해도 되지만, class 탈부착식으로 만드는 것이 유지보수에 편리하기 때문이다.\n\n\u003cbr\u003e\n\n```css\n.list-group {\n\tdisplay: none;\n}\n\n.show {\n\tdisplay: block;\n}\n```\n\n다음과 같이 show 클래스를 list-group 클래스에 붙혔다 뗐다 하는 방식으로 만들면 될 것 같다. 이때 자바스크립트에서 html에 접근하여 클래스를 붙히는 기능을 해주는 것이 **classList**이다.\n\n```javascript\ndocument\n\t.getElementsByClassName('navbar-toggler')[0]\n\t.addEventListener('click', function () {\n\t\tdocument.getElementsByClassName('list-group')[0].classList.add('show');\n});\n```\n\n만약, 버튼을 한 번 더 누르면 서브메뉴를 숨기고 싶다면 if문, 변수문법을 사용해서 가능하다. 아직 안배웠으니까 쉬운 방법인 **toggle**을 이용한다.\n\n```javascript\ndocument\n\t.getElementsByClassName('navbar-toggler')[0]\n\t.addEventListener('click', function () {\n\tdocument.getElementsByClassName('list-group')[0].classList.toggle('show');\n});\n```\n\n이렇게 코드 작성 시, toggle 기능을 이용하여 show 클래스가 있다면 없애고 없다면 붙히는 방식이다.\n\n\u003chr\u003e\n\n## jQuery 라이브러리\n\n자바스크립트 코드가 길고 더러워서 HTMl 조작을 쉽게하는 라이브러리들이 대표적으로 jQuery, React, Vue이다. React와 Vue는 자바스크립트 숙련도를 요구하기 때문에 간단하게 jQuery를 배워본다. jQuery는 라이브러리일 뿐 새로운 문법이나 이런게 아니라 함수명만 짧아진다. 예를 들어, `document.querySelect`와 같은 셀렉터는 짧게 `$` 하나로 바뀌고 `addEventListener`는 짧게 `on` 하나로 바뀐다.\n\n\u003cbr\u003e\n\njQuery CDN을 이용하여 사용한다.\n\n```javascript\n\u003cscript\nsrc=\"https://code.jquery.com/jquery-3.6.0.min.js\"\nintegrity=\"sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=\"\ncrossorigin=\"anonymous\"\u003e\u003c/script\u003e\n```\n\n거의 모든 자바스크립트 라이브러리는 로딩 속도 때문에 `\u003cbody\u003e` 태그 끝나기 전에 넣는 것을 권장한다. jQuery 설치한 곳 **하단**에서 jQuery 문법을 사용 가능하다. 상단에 코드 짜고 안된다고 울지말고 제발 하단에다가 짜라. 강의에서는 편의상 그냥 head 태그 끝에 jQuery를 설치했다. 로딩속도는 조금 느리겠지만, 코드 보기에 좋으니깐 편의상~\n\n\u003cbr\u003e\n\n- `$` : querySelectorAll의 역할\n\n- `.eq()` : querySelectorAll의 인덱스 역할\n\n- `.html` : jQuery로 html의 내용 변경\n\n- `.css('속성', '값')` : jQuery로 css의 내용 변경\n\n- `.addClass('클래스명')` : jQuery로 클래스 부착\n\n- `.removeClass('클래스명')` : jQuery로 클래스 제거\n\n- `.toggleClass('클래스명')` : jQuery로 클래스 토글\n\n```javascript\ndocument.querySelector('.hello').innerHTML('바보');\n$('.hello').html('바보');\n\ndocument.querySelector('.hello').style.color = 'red';\n$('.hello').css('color', 'red');\n```\n\nquerySelector를 쓰면 인덱스 하나하나 지정하고 바꿔줘야해서 양이 늘어난다. (뭐, 클래스명 같게 하고 querySelectorAll 말고 querySelector 쓰면 되긴 함) 근데 jQuery를 쓰면 그냥 한꺼번에 바꿀 수 있다.\n\n```html\n\u003cp class=\"hello\"\u003e안녕\u003c/p\u003e\n\u003cp class=\"hello\"\u003e안녕\u003c/p\u003e\n\u003cp class=\"hello\"\u003e안녕\u003c/p\u003e\n```\n\n```javascript\ndocument.querySelectorAll('.hello')[0].innerHTML = '바보';\ndocument.querySelectorAll('.hello')[1].innerHTML = '바보';\ndocument.querySelectorAll('.hello')[2].innerHTML = '바보';\n  \n$('.hello').html('바보');\n```\n\n\u003cbr\u003e\n\njQuery 이벤트리스너 사용법\n\n```javascript\n$(\"#test-btn\").on(\"click\", function () {\n\t어쩌구~\n});\n```\n\nstyle의 display 속성을 none으로 바꿔도 되지만 jQuery는 편리한 것들을 제공해줌  \n\n- `.hide()` : 사라지게\n\n- `.fadeOut()` : 서서히 사라지게\n\n- `.slideUp()` : 줄어들며 사라지게\n\n- `.show()` : 보이게\n\n- `.fadeIn()` : 서서히 보이게\n\n- `.slideDown()` : 늘어나며 보이게\n\n- `.fadeToggle()` : 누를때마다 fade\n\n\u003chr\u003e\n\n## 모달(Modal) 창 제작 Tip\n\nModal창은 보통 페이지 맨 앞에, 모든 html 요소 제일 위에 존재하기 때문에 **html 맨 위에 적는 것**이 관습이다.  \n\n```css\n/* 모달창 국룰 세팅 */\n.modal {\n\tposition: fixed;\n\tz-index: 5;\n}\n```\n\n```html\n\u003cdiv class=\"black-bg\"\u003e\n\t\u003cdiv class=\"white-bg\"\u003e\n\t\t\u003ch4\u003e로그인하세요\u003c/h4\u003e\n\t\t\u003cbutton class=\"btn btn-danger\" id=\"close\"\u003e닫기\u003c/button\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cbutton id=\"login\"\u003e로그인\u003c/button\u003e\n\n\u003cscript\u003e\n$('#login').on('click', function () {\n\t$('.black-bg').addClass('show-modal');\n});\n\n$('#close').on('click', function () {\n\t$('.black-bg').removeClass('show-modal');\n});\n\u003c/script\u003e\n```\n\n\u003chr\u003e\n\n## UI에 애니메이션 추가\n  \n위의 예제 코드에서 addClass와 removeClass 대신에 fadeIn과 fadeOut을 넣으면 애니메이션을 넣을 수 있지만, 자바스크립트에 애니메이션을 넣는 것은 성능 때문에 좋은 관습은 아니고 css에 넣는 것이 좋다.\n\n- \u003ca href='/brain/Lecture/apple/apple-html/all-in-one-mid' target='_blank'\u003eone-way-animation\u003c/a\u003e\n\n- \u003ca href='/brain/Lecture/apple/apple-html/all-in-one-last' target='_blank'\u003eanimation 심화\u003c/a\u003e\n\n추가로, 애니메이션 제작 시 `display: none;` 보다 `visibility: hidden;`이 낫다.\n\n\u003cbr\u003e\n\n- 자바스크립트 (jQuery)로 애니메이션 넣은 코드\n\n```html\n\u003cbody\u003e\n\t\u003cdiv class=\"black-bg\"\u003e\n\t\t\u003cdiv class=\"white-bg\"\u003e\n\t\t\t\u003ch4\u003e로그인하세요\u003c/h4\u003e\n\t\t\t\u003cbutton class=\"btn btn-danger\" id=\"close\"\u003e닫기\u003c/button\u003e\n\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\n\t\u003cbutton id=\"login\"\u003e로그인\u003c/button\u003e\n\u003c/body\u003e\n  \n\u003cscript\u003e\n\t$('#login').on('click', function () {\n\t\t// fadeIn() 사용\n\t\t$('.black-bg').fadeIn();\n\t});\n\u003c/script\u003e\n```\n\n```css\n.black-bg {\n\twidth: 100%;\n\theight: 100%;\n\tposition: fixed;\n\tbackground: rgba(0, 0, 0, 0.5);\n\tz-index: 5;\n\tpadding: 30px;\n\t/* display: none 사용 */\n\tdisplay: none;\n}\n\n.show-modal {\n\t/* display: block 사용 */\n\tdisplay: block;\n}\n```\n\n\u003cbr\u003e\n\n- css로 애니메이션 적용한 코드  \n\n```html\n\u003cbody\u003e\n\t\u003cdiv class=\"black-bg\"\u003e\n\t\t\u003cdiv class=\"white-bg\"\u003e\n\t\t\t\u003ch4\u003e로그인하세요\u003c/h4\u003e\n\t\t\t\u003cbutton class=\"btn btn-danger\" id=\"close\"\u003e닫기\u003c/button\u003e\n\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\n\t\u003cbutton id=\"login\"\u003e로그인\u003c/button\u003e\n\u003c/body\u003e\n  \n\u003cscript\u003e\n\t$('#login').on('click', function () {\n\t\t// addClass() 사용\n\t\t$('.black-bg').addClass('show-modal');\n\t});\n\u003c/script\u003e\n```\n\n```css\n.black-bg {\n\twidth: 100%;\n\theight: 100%;\n\tposition: fixed;\n\tbackground: rgba(0, 0, 0, 0.5);\n\tz-index: 5;\n\tpadding: 30px;\n\n\t/* visibility, opacity, transition 사용 */\n\tvisibility: hidden;\n\topacity: 0;\n\ttransition: all 1s;\n}\n\n.show-modal {\n\t/* visibility, opacity 사용 */\n\tvisibility: visible;\n\topacity: 1;\n}\n```\n\n- 자바스크립트 (jQuery)로 애니메이션 넣은 서브메뉴바  \n\n```html\n\u003cscript\u003e\n\t$('.navbar-toggler').on('click', function () {\n\t\t$('.list-group').slideToggle();\n\t});\n\u003c/script\u003e\n```\n\n```css\n.list-group {\n\tdisplay: none;\n}\n```\n\n- css로 애니메이션 적용한 서브메뉴바\n\n```html\n\u003cscript\u003e\n\t$('.navbar-toggler').on('click', function () {\n\t\t$('.list-group').toggleClass('show-menubar');\n\t});\n\u003c/script\u003e\n```\n\n```css\n.list-group {\n\tdisplay: block;\n\theight: 0;\n\toverflow: hidden;\n\ttransition: all 1s;\n}\n\n.show-menubar {\n\theight: 210px;\n}\n```\n\n\u003chr\u003e\n\n## form태그 if/else\n\n- form 태그 다룰 때, 전송 버튼은 반드시 `type=\"submit\"` 해줄 것 명심하자. 일반 버튼은 `type=\"button\"` 이렇게 해야 오류가 없다.\n- form 태그는 서버로 유저정보 전송하려고 쓰는 것이다.\n- `\u003cform action=\"url~~~\"\u003e\u003c/form\u003e` 서버 경로 제대로 설정하자.\n\n\u003cbr\u003e\n\n### 조건문 (if-else)\n\n```javascript\nif (조건) {\n\t조건이 참일 때 실행할 코드\n} else {\n\t조건이 거짓일 때 실행할 코드\n}\n```\n\n- 조건 사용 시 비교연산자 `==, ===, !=, !==, \u003c, \u003c=, \u003e, \u003e=`\n- 조건 사용 시 boolean `true(1), false(0)` 이용\n- 참고로 `elif`는 파이썬임 `else if`가 자바스크립트\n- `else if`는 위의 조건이 참이면 실행 안되는 것임\n\n```javascript\nif (1 == 3) {\n\tconsole.log('맞아요1');\n} else if (1 == 1) {\n\tconsole.log('맞아요2');\n}\n\n// 출력 : 맞아요2\nif (3 == 3) {\n\tconsole.log('맞아요1');\n} else if (1 == 1) {\n\tconsole.log('맞아요2');\n}\n\n// 출력 : 맞아요1\n// 위에가 참이니까 맞아요2는 출력안되고 그냥 끝남\n\nif (1 == 1) {\n\tconsole.log('맞아요1');\n}\n\nif (2 == 2) {\n\tconsole.log('맞아요2');\n}\n\n// 출력 : 맞아요1\n// 출력 : 맞아요2\n```\n\n\u003cbr\u003e\n\n### 비교 연산자\n\n그냥 비교할 때는 `==`, `!=` 타입까지 맞춰서 비교할 때는 `===`, `!==`\n\n- 동등 연산자(`==`) : 두 피연산자의 자료형을 일치시킨 후 비교 수행\n- 부등 연산자(`!=`) : 두 피연산자의 자료형을 일치시킨 후 비교 수행\n- 일치 연산자(`===`) : 자료형 변환 없이 비교 수행\n- 불일치 연산자(`!==`) : 자료형 변환 없이 비교 수행\n\n\u003cbr\u003e\n\n### 논리 연산자\n\n- `\u0026\u0026` : AND\n- `||` : OR\n- `!` : NOT\n\n\u003chr\u003e\n\n## truthy, falsy 자료\n\n| truthy 자료 | falsy 자료 |\n| :---------: | :--------: |\n| 0 제외 숫자 | 0 |\n| '문자' | '' |\n| [] | null |\n| {} | undefined |\n| | NaN |  \n\n\u003chr\u003e\n\n## undefined, null\n\nundefined와 null은 '값이 없다' 라는 점에서 유사하지만 엄밀히 말하면 다른 개념이다. typeof 연산자로 타입을 확인해보면 undefined는 undefined 타입이, null은 object 타입이라고 표시된다.\n\n- undefiend : 변수는 존재하나, 어떠한 값으로도 할당되지 않아 자료형이 정해지지(undefined) 않은 상태\n\n- null : 변수는 존재하나, null 로 (값이) 할당된 상태. 즉 null은 자료형이 정해진(defined) 상태\n\n```javascript\nvar var1;\n//undefined (어떤 값도 할당되지 않아서 자료형을 알 수 없음)\n\nvar var2 = null;\n//null (null로 (값이) 할당되어서 자료형을 알 수 있음 - null의 자료형은 object)\n``` \n\n근데, `undefined == null`을 비교하면 true값이 나온다. 이는 위에서 설명한 비교연산자 때문이다. 엄격한 비교인지 엄격하지 않은 비교인지 때문이다.\n\n```javascript\nundefined == null; //true , 형변환 까지 해줘서 true가 나옴\nundefined === null; //false , 형변환을 하지 않아서 false가 나옴\n```\n\n\u003chr\u003e\n\n## if문 이용한 form 태그 \n\n```javascript\n// 물론 둘다 else if 말고 그냥 if 문들로 해도 됨\n// 근데 else if가 나은듯\n\ndocument\n\t.getElementsByTagName('form')[0]\n\t.addEventListener('submit', function (e) {\n\t\tif (document.getElementById('email').value == '') {\n\t\t\te.preventDefault();\n\t\t\talert('아이디를 입력 해주세요 !');\n\t\t} else if (document.getElementById('pw').value == '') {\n\t\t\te.preventDefault();\n\t\t\talert('비밀번호를 입력 해주세요 !');\n\t\t} else if (document.getElementById('pw').value.length \u003c 6) {\n\t\t\te.preventDefault();\n\t\t\talert('비밀번호를 6자리 이상 입력 해주세요 !');\n\t\t} else {\n\t\t\talert('정상적으로 제출되었습니다.');\n\t\t}\n});\n\n// jQuery 사용\n$('form').on('submit', function (e) {\n\tif (document.getElementById('email').value == '') {\n\t\te.preventDefault();\n\t\talert('아이디를 입력 해주세요 !');\n\t} else if (document.getElementById('pw').value == '') {\n\t\te.preventDefault();\n\t\talert('비밀번호를 입력 해주세요 !');\n\t} else if (document.getElementById('pw').value.length \u003c 6) {\n\t\te.preventDefault();\n\t\talert('비밀번호를 6자리 이상 입력 해주세요 !');\n\t} else {\n\t\talert('정상적으로 제출되었습니다.');\n\t}\n});\n```\n\n- getElementsByTagName 할 때도 인덱스 지정해줘야함\n\n- 제출버튼에 id 지정해줘도 되지만, form 태그의 이벤트를 submit으로 해줘도 됨\n\n- input의 값은 value로 가져옴\n\n- 전송을 원하지 않으면 function의 괄호 안에 `e`를 넣고 `e.preventDefault();` 해주면 됨\n\n\u003chr\u003e\n\n## input 이벤트  \n\n```javascript\ndocument.getElementById('email').addEventListener('input', function () {});\n\ndocument.getElementById('email').addEventListener('change', function () {});\n```\n\n- 불러온 id 태그가 input 태그일 때 addEventListener 이벤트에 input / change 준 경우\n\n- input 태그에 유저가 입력한 값이 변할 때 실행된다는 의미\n\n- 이벤트 input 일 때 : input 태그에 입력한 값이 바뀔 때마다 실행\n\n- 이벤트 change 일 때 : input 태그에 입력한 값이 바뀌고 **포커스를 잃을 때** 실행\n\n- 응용하면 비밀번호 6자리 이상 입력해야할 때 그것보다 작게 입력하고 있으면 계속 ui 띄우는 경우가 있겠네\n\n\u003chr\u003e\n\n## 변수 문법\n  \n\n```javascript\nvar 변수명 = 넣을자료;\n```\n\n변수를 사용하는 이유\n\n- 길고 복잡한 자료들 저장 가능\n- 특정 값을 기억하게 하려고 (count 같은거)\n- **좋은 관습 : 자주쓰는 셀렉터 변수에 넣어쓰기**\n\n\u003cbr\u003e\n\n변수는 **변수의 선언, 할당, 범위** 세 가지만 잘 기억하면 된다.  \n\n- 변수의 선언 : 변수 만들겠습니다.\n- 변수의 할당 : 변수에 자료 넣기\n- 변수의 범위\n- 함수 안에서 변수 만들면 사용가능 범위는 함수 내부 \u003cbr\u003e 함수 안에서 만든 변수를 함수 밖에서 사용하려고 하면 사용 불가능\n  \n```javascript\nvar 이름; // 변수의 선언\n이름 = 'kim'; // 변수의 할당\n\nvar 이름 = 'kim'; // 변수의 선언과 할당\n이름 = 'park'; // 변수의 재할당\n```\n\n```javascript\nfunction 함수() {\n\tvar 이름 = 'kim';\n\tconsole.log(이름);\n}\n// 출력 : kim\n\nfunction 함수() {\n\tvar 이름 = 'kim';\n}\n\nconsole.log(이름);\n// 출력 : Uncaught ReferenceError: 이름 is not defined\n```\n\n\u003cbr\u003e\n\n### var let const 차이\n\n| var | let | const |\n| :--------------------------------: | :-------------------------: | :-------------------------: |\n| 재선언O | 재선언X | 재선언X |\n| 재할당O | 재할당O | 재할당X |\n| 범위 function \u003cbr\u003e Function-scoped | 범위{ } \u003cbr\u003e {Block-scoped} | 범위{ } \u003cbr\u003e {Block-scoped} |\n\n- let 변수 : 재선언 불가\n\n- 코드가 길어지면 사용한 변수를 까먹고 또 만들 수 있다. \u003cbr\u003e let은 이것을 방지 가능\n\n```javascript\nlet 이름 = 'kim';\nlet 이름 = 'park';\n\n// 출력 : Uncaught SyntaxError: Identifier '이름' has already been declared\n```\n\n- const 변수 : 재선언 불가, 재할당 불가\n\n- 변하는 안되는 값을 보관할 때 좋다. 상수\n\n```javascript\nconst 이름 = 'kim';\n이름 = 'park';\n\n// 출력 : Uncaught TypeError: Assignment to constant variable.\n```\n\n- 추가로, let과 const는 function뿐만 아니라 중괄호 `{}` 내부는 모두 범위로 취급한다.\n\n```javascript\nif () {\n\tlet 이름;\n}\n\n// 이것도 밖에서 이름 사용 못함\n```\n\n\u003cbr\u003e\n\n### 문자 중간에 변수 쉽게 넣기\n\n- 백틱 기호를 사용한다.\n\n- 변수는 `${변수}`와 같이 담는다.\n\n```javascript\nlet a = '안녕';\nconsole.log('문자' + a + '문자');\nconsole.log(`문자${a}문자`);\n\n// 문자안녕문자\n```","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-js/apple-js-02":{"title":"LEVEL 02","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/javascript-jquery-ui/' target='_blank'\u003eJavaScript 입문과 웹 UI 개발\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## setTimeout, setInterval\n\n\u003cbr\u003e\n\n### setTimeout\n\n- 몇 초 **후** 코드 실행하기 위한 자바스크립트 기본 내장 함수\n- 1000ms = 1초\n- 콜백함수자리에 만들어둔 함수 당연히 넣을 수 있음\n\n```javascript\nsetTimeout(function () {\n\t실행할코드;\n}, ms);\n\n// 콜백함수에 함수 넣으면?\nsetTimeout(알림창제거, 3000);\n\nfunction 알림창제거() {\n\tdocument.querySelectorAll('.alert')[0].style.display = 'none';\n}\n```\n\n- 대신 만든 함수 넣을 때 `함수()` 말고 `함수`만 넣으셈\n\n```javascript\nsetTimeout(알림창제거(), 3000);\n```\n\nsetTimeout은 함수로의 참조를 받아올 것이라 예상한다. 위의 `알림창제거()`는 함수를 실행시킨다. 그리고 실행의 결과가 setTimeout으로 전달된다. 우리가 코딩했던 것들을 살펴봤을 때, 알림창제거()의 결과는 undefined (아무것도 리턴하지 않는 함수)이다.그러므로 아무것도 스케쥴되지 않으니까 `알림창제거`만 넣어라.\n\n- 타이머를 변수에 담아서 사용 가능!\n\n```javascript\nlet 타이머 = setTimeout(어쩌구);\n```\n\n\u003cbr\u003e\n\n### setInterval\n\n- 몇 초 **마다** 코드 실행하기 위한 자바스크립트 기본 내장 함수\n\n```javascript\nsetInterval(function () {\n\t실행할코드;\n}, ms);\n```\n\n\u003cbr\u003e\n\n### clearTimeout\n\n- 타이머를 삭제하고 싶으면 타이머를 변수에 담고 clearTimeout 하면 된다.\n\n- `clearTimeout()`, `clearInterval()` 상호교환 가능하다. 허나, 명확성을 위하여 그렇게 하지말라고 \u003ca href='https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout' target='_blank'\u003e공식 문서\u003c/a\u003e에서 표기하고 있다.\n\n```javascript\nfunction 콘솔출력() {\n\tconsole.log('안녕');\n}\n\nlet 타이머 = setTimeout(콘솔출력, 1000);\nclearTimeout(타이머);\n```\n\n\u003chr\u003e\n\n## JS 문법 vs 브라우저 사용법\n\n- 자바스크립트 문법 : `if, var, function`\n\n- 브라우저 사용법 : `document.querySelector(), setTimeout(), alert()`\n\n- 자바스크립트 문법은 브라우저 사용할 경우 프로그래밍적인 기능을 더하고 싶을 때 사용하는 것이다. (ex. 조건 분기, 잠깐 보관, 코드가 길때 축약 등)\n\n- 웹 브라우저 사용법은 정확하게 **Web Browser API 사용법** 이라고 한다.  \n\n\u003chr\u003e\n\n## 정규식\n\n- 정규식(Regular Expression)  \n\n- 공백 검사 말고도 유저가 입력한게 이메일 형식인지 맞는지 검사하고 싶다면 정규식을 사용해보도록 하자.\n\n- \u003ca href='https://regexr.com/' target='_blank'\u003eregex test\u003c/a\u003e 사이트를 통해 표현이 맞는지 검사해보자.\n\n\u003cbr\u003e\n\n### includes()\n\n- 문자 검사하는 쉬운 방법이다.\n\n- 한계 : 왼쪽 문자에 한글이 들어있냐, 영어가 들어있냐, A로 끝나냐, 숫자가 1회 출현하냐 이런 것을 검사할 수 없다.\n\n```javascript\n'abc'.includes('a');\n// true\n\n'abc'.includes('d');\n// false\n```\n\n\u003cbr\u003e\n\n### 정규식 파헤치기\n\n- `/ /`안에 문자를 넣고 정규식을 사용한다.  \n\n```javascript\n/a/.test('abcde');\n// true\n```\n\n\u003cbr\u003e\n\n**정규식으로 범위 지정 가능**\n\n`/[a-z]/` : a ~ z 중 아무 글자 1개, 즉 범위 지정 가능\n\n```javascript\n/[a-z]/.test('abcde')\n// true\n\n/[a-z]/.test('바보')\n// false\n\n/[A-Z]/.test('abcde')\n// false\n\n/[A-Z]/.test('abcdA')\n// true\n```\n\n\u003cbr\u003e\n\n- `/[a-zA-z]/` : 아무 알파벳 1개\n\n- `/[ㄱ-ㅎ가-힣ㅏ-ㅣ]/` : 아무 한글문자 1개\n\n- `/[0-9]/` : 아무 숫자 1개\n\n- `/\\S/` : 아무 문자 **1개**, 특수기호까지 포함\n\n```javascript\n/[ㄱ-ㅎ가-힣]/.test('안녕')\n// true\n\n/[ㄱ-ㅎ가-힣]/.test('ㅏㅏㅏ')\n// false\n\n/[ㄱ-ㅎ가-힣ㅏ-ㅣ]/.test('ㅏㅏ')\n// true\n```\n\n\u003cbr\u003e\n\n\u003e [!note] Memo\n\u003e\n\u003e 주의할 게, 지금 문자 1개를 찾는 것이다. /a/는 a 문자 1개\"만\" 찾는 것이다. 여러 개 찾고 싶으면 /a+/ 형태로 +를 사용하자. +는 왼쪽 문자 반복 검색\n\n\u003cbr\u003e\u003cbr\u003e\n\n**정규식으로 시작`(^)`/끝문자`($)` 검사**  \n\n- `/^a/` : a로 문자 시작하냐\n\n- `/a$/` : a로 문자 끝나냐\n\n- `/a|b/` : a 또는(or) b 있냐\n\n- `/(a|b)/` : 괄호 사용 가능, 정규식에서 괄호는 묶어서 계산해줌\n\n\u003cbr\u003e\n\n**정규식으로 이메일형식 검사**\n\n- `.` : 정규식의 특별한 문법, 따로 dot을 사용하고 싶으면 `\\` 써주기\n\n- `+` : 왼쪽 문자 반복 검색\n\n```javascript\n/\\S@\\S\\.\\S/.test('aaa@bbb.ccc')\n// false\n// 모든문자 1개 + 골뱅이 + 모든문자 1개 + . + 모든문자 1개\n\n/\\S@\\S\\.\\S/.test('a@b.c')\n// true\n\n/\\S+@\\S+\\.\\S+/.test('aaa@bbb.ccc')\n// true\n```\n\n\u003chr\u003e\n\n## Carousel (캐러셀)\n\n- carousel, 회전목마라는 뜻인데 간단히 이미지 슬라이드라고 이해하자.\n- one-way 애니메이션 기반 UI 이다.\n\n1. 애니메이션 시작 전 화면 제작\n2. 애니메이션 종료 후 화면 제작\n3. 언제 종료화면으로 변할지 JS 코드짜기\n4. transition 추가\n\n\u003cbr\u003e\n\n1. **시작 전 화면**\n\n\n```css\n.slide-container {\n\twidth: 300vw;\n\tdisplay: flex;\n}\n\n.slide-box {\n\twidth: 100vw;\n} \n\n.slide-box img {\n\twidth: 100%;\n}\n```\n\n- 이런 느낌으로 컨테이너 전체 너비를 `캐러셀 이미지 개수 * 100vw` 정도로 해놓는다.\n- 그리고 박스의 폭 각각을 `100vw`로 설정한다.\n- 이미지 너비를 `100%`로 하고 박스에 꽉차게 설정한다.\n- 현재 슬라이드 컨테이너 너비가 300vw라서 좌우 스크롤이 생길 것이다. 그를 막기 위해 slide-container를 감싸는 div 박스를 하나 만들고 `style=\"overflow: hidden\"` 줘서 흐르는걸 숨겨준다.\n\n\u003cbr\u003e\n\n2. **시작 후 화면**\n\n- margin-left 속성을 줘도 되지만, 성능 때문에 `transform: translateX()` 속성을 사용하자. 현재 상황에서 `-100vw`를 해주면 전체적으로 왼쪽으로 이동하니 두번째 캐러셀 이미지가 보일 것이다.\n\n```css\n.slide-container {\n\twidth: 300vw;\n\tdisplay: flex;\n\ttransform: translateX(-100vw);\n}\n```\n\n\u003cbr\u003e\n\n3. 언제 종료화면으로 변할지 JS 코드 짜기\n\n- 버튼을 클릭했을 때 이미지에 translateX() 속성 주는 방식\n- 해당하는 캐러셀 이미지에 가도록 X축 조절하면 됨\n\n```javascript\ndocument\n\t.querySelector(\".slide-2\")\n\t.addEventListener(\"click\", function () {\n\t\tdocument.querySelector(\".slide-container\").style.transform =\n\t\t\"translateX(-100vw)\";\n});\n```\n\n\u003cbr\u003e\n\n4. **transition**\n\n```css\n.slide-container {\n\twidth: 300vw;\n\tdisplay: flex;\n\ttransition: all 1s;\n}\n```\n\n\u003cbr\u003e\n\n**이전 버튼과 다음 버튼을** 활용할 때는 현재 상테에 대한 변수를 하나 두고 그 변수 값을 조정하며 코드를 짜도록 하자.\n\n\u003chr\u003e\n\n## function() return 문법\n\n\u003ca href='/brain/Lecture/apple-js/apple-js-01' target='_blank'\u003eJS 입문과 웹 개발 01\u003c/a\u003e에서 설명한 자바스크립트 함수는 긴 코드를 축약하는 것과 파라미터를 추가해서 사용하는 것에 장점이 있었다. **return은 함수쓰고 그 자리에 뭔가 뱉고 싶으면 쓰는 것이다.**\n\n```javascript\nfunction 함수() {\n\treturn 123;\n}\n\n함수(); // 이 자리에 123 퉤! 하고 뱉음\n\n// 확인해보자\nvar 변수 = 함수();\nconsole.log(변수);\n```\n\n- 반환할 때 숫자, 문자, 수식 다 가능하다.\n\n- return은 함수종료 기능도 있다. return 밑에는 더이상 실행되지 않는다.\n\n\u003cbr\u003e\n\n\u003e [!note] 그래서 return 용도가 뭔데?\n\u003e\n\u003e  자료를 넣으면 다른 자료가 나오는 변환기를 만들고 싶을 때 사용\n  \n\u003cbr\u003e\n\n쇼핑몰을 만드는 예시에서 가격 밑에 부가세를 표현해주고 싶다고 하자. 그럼 함수를 만들고 가격(자료)을 넣으면 부가세(다른 자료) 나오는 계산기를 만들고 싶은 것이다.\n\n```javascript\nfunction 부가세(가격) {\n\treturn 가격 * 0.1;\n}\n\n부가세(50000); // 5000\n```\n\n`문자 -\u003e 문자 변환기`, `숫자 -\u003e true/false 변환기` 아무렇게나 제작 가능\n\n\u003chr\u003e\n\n## 자바스크립트 소수점 다루기\n\n자바스크립트에서 소수점 있는 숫자연산시 주의해야한다. 약간의 오차가 발생할 수 있다.\n\n\n```javascript\nconsole.log(55555 * 1.1);\n// 61110.50000000001\n\nconsole.log(1.1 + 0.3);\n// 1.4000000000000001\n```\n\n컴퓨터는 2진법으로 설계되어있기 때문에, `10 + 20`이라고 하면 숫자 10과 숫자 20을 더하는 것이 아니라 2진법으로 변환하여 `1010 + 10100`을 계산한다. 이때, 소수점을 2진법으로 변환 시 문제가 발생한다.\n\n\u003cbr\u003e\n\n`1.1 -\u003e 1.00011001100110011001100....` 이렇게 무한히 `1100`이 반복되는 모습을 확인가능하다. 무한한 숫자를 저장하기에 저장공간이 작아서 중간에 자르고 반올림 시켜버린다.\n\n\u003cbr\u003e\n\n매우 작은 오차라서 평소엔 무시해도 되지만, 조금 정확한 연산을 원한다면\n\n\n1. 애초에 소수점을 사용하지 말든가\n\n\t- 소수점을 전부 10곱해서 연산하고 10으로 나누기\n\n2. 소수점 정확하게 계산해주는 라이브러리 쓰든가\n\n3. 연산결과를 반올림해서 쓰든가\n\n\u003cbr\u003e\n\n### 소수점 반올림\n\n- `숫자.toFixed(몇째 자리 까지)`\n- 참고로 toFixed 붙혀주면 **문자로 반환됨**\n- 크롬 콘솔탭에서 색깔이 검은색이면 문자라고 생각하셈, 숫자는 파란색인듯\n\n```javascript\nconsole.log((55555 * 1.1).toFixed(1))\n// 61110.5\n\nconsole.log((55555 * 1.1).toFixed(2))\n// 61110.50\n```\n\n\u003chr\u003e\n\n## +(플러스) 연산자 특징\n\n- `'문자' + 123 =\u003e '문자123'`\n- `'문자' + '문자' =\u003e '문자문자'`\n- 숫자끼리 더하고 싶으면 `parseInt()`, `parseFloat()` 사용\n\n```javascript\nfunction 부가세(가격) {\n\tlet result = (가격 * 1.1).toFixed(1);\n\treturn result + 1;\n}\n\nconsole.log(부가세(55555));\n// 61110.51\n// toFixed 써서 result가 문자니까 문자 + 1 = 문자1이 된 것\n\nfunction 부가세(가격) {\n\tlet result = (가격 * 1.1).toFixed(2);\n\treturn parseFloat(result) + 1;\n}\n\nconsole.log(부가세(55555));\n// 61111.5\n```\n\n\u003chr\u003e\n\n## 부동소수점 부가 설명\n\n\u003ca href='https://youtu.be/-GsrYvZoAdA' target='_blank'\u003e코딩애플 유튜브 영상\u003c/a\u003e을 참조하여 정리했다. 모든 그림의 저작권은 \u003ca href='https://codingapple.com/' target='_blank'\u003e코딩애플\u003c/a\u003e님에게 있습니다. 추가로 참고하기 좋은 \u003ca href='https://codetorial.net/articles/floating_point.html' target='_blank'\u003e링크\u003c/a\u003e입니다.\n\n- 코드를 보면, `1.1 + 0.1`이 `1.2`와 동일하지 않고 약간 크다고 한다.\n\n```javascript\nconsole.log(1.1 + 0.1 == 1.2);\n// false\n\nconsole.log(1.1 + 0.1 \u003e 1.2);\n// true\n```\n\n### 1. RAM\n\n컴퓨터에서 5라는 숫자를 저장하려면 **RAM**에 저장한다. 0과 1의 이진수 형태로 저장하게 된다. 칸은 하나당 bit라고 한다.\n\n![](brain/image/apple-js-02-1.png)\n\n숫자는 보통 8칸 정도를 마련하여 저장한다. 더 큰 수를 저장하고 싶으면 16칸도 할당한다. 16칸은 (-32768 ~ 32767) 까지 저장 가능하다.\n\n\u003cbr\u003e\n\n### 2. 부동소수 표현 저장\n\n소수 저장은 아무렇게나 하는 것이 아니라, 덧셈이나 뺄셈과 같은 연산을 편하게 하기 위하여 \u003ca href='https://docs.microsoft.com/ko-kr/cpp/build/ieee-floating-point-representation?view=msvc-170' target='_blank'\u003eIEEE 표준 표현방식\u003c/a\u003e을 따른다. \u003cbr\u003e\n\n예를 들어, `5.125`라는 수를 저장하기 위하여 메모리에 넉넉히 32칸을 준비한다. 이때, 32비트를 사용하는 방식을 **단정도(single precision)** 라고 한다. **배정도 표현**에서는 64비트를 사용한다.\n\n- 맨 첫번째 칸 : 부호 저장 (양수 = 0, 음수 = 1)\n- 저장할 숫자를 2진법으로 변환 ( **5.125 -\u003e 101.001** )\n- 점을 왼쪽 끝까지 이동 ( **1.01001 * 2\u003csup\u003e2\u003c/sup\u003e** )\n- 01001 부분을 **mantissa**라고 하는데 여기는 맨 뒤 23칸에 밀어넣는다.\n- 지수 부분에 127을 더하고 앞에 8칸에 저장한다. (지수는 2\u003csup\u003e2\u003c/sup\u003e 에서 위에꺼를 의미. 2\u003csup\u003e4\u003c/sup\u003e이면 4가 지수)\n- 여기서 127은 bias이다. bias는 2\u003csup\u003ek-1\u003c/sup\u003e인데 여기서 k는 지수부의 비트 수인 8이다. (8칸)\n\n\u003cbr\u003e  \n\n단정도 표현은 **부호부 (1칸) + 지수부 (8칸) + 가수부 (23칸)** 으로 이루어진다.\n\n\u003cbr\u003e\n\n### 3. 순환소수 문제\n\n이러한 저장 방식에는 순환소수 문제가 있다. 예를 들어, `10진수 0.125`는 `2진수 0.001`로 깔끔하게 나누어떨어진다. 그런데, `10진수 0.1` 같은 숫자는 깔끔하게 떨어지지 않고 `2진수 0.000110011001100110011001100110011001...` 무한히 반복하게 된다. 이러한 경우 32칸에 저장할 수 없어서 뒷부분을 잘라버리고 저장한다. 그렇다면 자른 뒷 부분의 오차가 발생하게 되는 것이다. 한마디로 **정확히 0.1을 저장한 것이 아니라 0.1에 근접한 수를 저장한 것이다.**\n\n\u003cbr\u003e\n\n### 4. 문제 발생\n\n이 사소한 오차가 큰 문제인가? 실제로, 걸프전 당시 미군이 운영하던 패트리어트 (Patriot Missile Defense)라는 미사일 요격 장비가 있었는데, 미사일 요격에 실패하여 28명의 군인이 전사한 사건이 있었다. 패트리어트를 구동하기 위한 프로그램에서 **시간을 0.1초 단위로 측정했다.**\n\n\u003cbr\u003e\n\n여기서 패트리어트는 숫자 1개에 24칸을 사용했다. 그러면 0.1을 표현할 때 오차가 생기는게 단정도 표현 방식보다 더 컸을 것이다. 보통 1시간 마다 0.0034초 오차가 발생했다고 한다. 사소해보이지만, \u003ca href='http://nifty.stanford.edu/2003/pests/2002/lectures/07.1_FloatingPoint/Patriot.html' target='_blank'\u003e사고 report\u003c/a\u003e를 보면 해당 기기를 100시간 가동시키니 **0.34초** 오차가 발생했다. 이렇게 봐도 작아보이는가 ?\n\n\u003cbr\u003e\n\n1500 m/s 속력의 미사일 요격시 이 0.34초 오차 때문에 500m 정도 빗나갔다. 이래서 요격에 실패하여 비극을 일으킨 것이다.\n\n\u003cbr\u003e\n\n### 5. 결론\n\n그래서, 소수는 어디에 사용되는가? \u003cbr\u003e\u003cbr\u003e\n\n- 5-1. 정확히 계산해야하는 자료는 **정수**로 저장 \u003cbr\u003e\n\n돈 같은 경우 5.1 달러를 저장하고 싶으면 float를 사용하여 저장하면 안되고 **정수**의 형태로 저장해야 한다. 즉, 5.1달러가 아닌 5100센트로 저장해야 한다. \u003cbr\u003e\n\n\u003cbr\u003e\n\n- 5-2. 굳이 float 써야할 때는 **반올림 문법** \u003cbr\u003e\n\n```javascript\nprecision = Math.pow(10, precision)\nMath.ceil(num * precision) / precision\n```\n\n\u003cbr\u003e\n\n- 5-3. **double 자료형 사용**하여 더 정확하게 저장 \u003cbr\u003e\n\n숫자 1개당 32칸이 아닌 **64칸을 사용**한다. IEEE 부동소수 표현 설명에서 봤던 **배정도 표현**을 사용하는 것이다. 오차가 매우 작아지기 때문에 괜찮지만, 단점으로는 역시 메모리 용량을 2배 쓰는 것이니까 낭비일 수 있다.\n\n\u003chr\u003e\n\n## scroll 이벤트 활용\n\nwindow 객체를 활용하여 scroll 이벤트를 사용할 수 있다.\n1. 스크롤바 조작할 때마다 코드실행 가능\n2. 박스의 실제 높이 / 보이는 높이 구할 수 있음\n3. 스크롤 얼마나 했는지 스크롤양 구할 수 있음\n\n```javascript\nwindow.addEventListener('scroll', function() {\n\tthis.window.scrollY ~\n})\n```\n\n- 왼쪽이 스크롤 될 때 마다 안에 코드 실행해줌\n\n- 현재 그냥 html 페이지 그 자체를 의미하는건 window, DOM이 있다.\n\n- 스크롤 이벤트를 감지하고 싶으면 보통 window에 이벤트리스너 부착\n\n- 추가로 html에서 임의로 스크롤 만들거면 `overflow-y` 다루셈 혹은 `height 굉장히 큰 div박스` 만들던가\n\n![](brain/image/apple-js-02-2.png)\n\n- `window.scrollY` 하면 스크롤 얼마나 했는지 알려줌. 가로 스크롤은 `window.scrollX`\n- `window.scrollTo(x,y)`는 지정한 위치로 강제로 스크롤함. 원래는 반짝! 순간이동해야하는데 부트스트랩 쓰면 스크롤을 스무스하게 이동시키는게 자동 설정임 이거 해결하려면 css 파일 열어서 아래 코드 작성\n\n```css\n:root {\n\tscroll-behavior: auto;\n}\n```\n\n- `window.scrollBy(x,y)`는 현재 위치부터 강제로 스크롤함.\n\n\u003cbr\u003e\n\n### jQuery로 scroll 이벤트\n\n```javascript\n$(window).on('scroll', function() {\n\t$(window).scrollY ~\n})\n```\n- `$(window).scrollTop()` : jQuery 내장, 현재 스크롤바 위치 출력, scrollY랑 똑같은 기능인데 `scrollTop(숫자)` 하면 scrollTo 기능도 되는거임.\n\n\u003cbr\u003e\n\n### div 박스 스크롤바 내린 높이, 실제 높이\n\n1. div 박스는 scrollY 사용 불가능함. scrollY는 window에만 가능. 박스는 `scrollTop` 사용해야함. 실제 높이는 `셀렉터.scrollHeight` 사용\n\n2. 하지만, 스크롤을 끝까지 내려도 스크롤양과 실제높이가 같지 않을 수 있다. 이는 `scrollTop`의 특징 때문이다. 위에서부터 얼마나 스크롤바를 내렸는지 알려주기는 하지만, 전체를 내린 것은 아니기 때문이다. 현재 위치부터 내린 양을 계산하기 때문에 `눈에 보이는 div 박스 높이 + 스크롤양 = 실제높이`가 되는 것이다.\n\n3. 눈에 보이는 div 박스 높이도 css에 적힌 그 높이가 아니라 정확하게 구해보면 `clientHeight`를 사용하면 된다.\n\n![](brain/image/apple-js-02-3.png)\n\n```javascript\ndocument.querySelector(\".lorem\").addEventListener(\"scroll\", function () {\n\tlet 스크롤양 = document.querySelector(\".lorem\").scrollTop;\n\tlet 실제높이 = document.querySelector(\".lorem\").scrollHeight;\n\tlet 눈높이 = document.querySelector(\".lorem\").clientHeight;\n\n\tconsole.log(스크롤양, 실제높이, 눈높이);\n});\n```\n\n- `188.29 + 100 = 288?` 같이 약간 오차가 생길 수 있고 OS 마다 부정확해서 등호(`==`)를 이용하여 비교하기 보다 (끝까지 스크롤 내렸는지 비교하기 보다) **여유를 가지고 비교하는 것이 좋다.** 맨 밑에서부터 10px 정도 남기고 스크롤 했는지?처럼\n\n\u003cbr\u003e\n\n```javascript\nif (스크롤양 + 눈높이 \u003e 실제높이 - 10) {\n\talert(\"약관을 모두 읽으셨네요!\");\n}\n```\n\n- console을 찍어보면, clientHeight와 scrollHeight는 고정인데 scrollTop의 값이 변하는 것을 확인 가능. 즉, 위에 `눈에 보이는 div 박스 높이 + 스크롤양 = 실제높이`는 끝까지 내렸을 때 성립하는 공식임\n\n\u003cbr\u003e\n\n### div 박스말고 현재페이지 끝까지 스크롤 체크는?\n\n- html 문서의 그냥 html 태그의 높이를 이용하여 구한다.\n\n- 페이지의 scrollHeight는 페이지 로드가 다되고 나서야 정확해서 `\u003cbody\u003e` 끝나기 전에 넣는게 좋은 관습이다.\n\n```javascript\nwindow.addEventListener(\"scroll\", function () {\n\tlet 페이지실제높이 = document.querySelector(\"html\").scrollHeight;\n\tlet 페이지눈높이 = document.querySelector(\"html\").clientHeight;\n\tlet 페이지스크롤양 = document.querySelector(\"html\").scrollTop;\n\n\tif (페이지스크롤양 + 페이지눈높이 \u003e 페이지실제높이 - 10) {\n\t\talert(\"페이지 끝이지롱!\");\n\t}\n});\n```\n\n- `document.documentElement` 이거나 `document.querySelector('html')` 이거나 같음\n\n\u003cbr\u003e\n\n### scroll 내린 만큼 상단에 진행바 (스크롤퍼센트)\n\n- **스크롤퍼센트 = (페이지스크롤양 / (페이지실제높이 - 페이지눈높이)) * 100**\n\n```html\n\u003cdiv class=\"page_progress\"\u003e\u003c/div\u003e\n```\n\n- 고정시켜야해서 `position: fixed` 이런거 필요한데 navbar에 붙히는게 나은듯\n\n- navbar 맨위에 고정시킬 때 `position: fixed; width: 100%; z-index: 5;` 알지?\n\n```css\n.page_progress {\n\tdisplay: block;\n\tbackground-color: black;\n\twidth: 0%;\n\theight: 3px;\n\ttransition: all 0.1s;\n}\n```\n\n```javascript\nwindow.addEventListener(\"scroll\", function () {\n\tlet 페이지실제높이 = document.querySelector(\"html\").scrollHeight;\n\tlet 페이지눈높이 = document.querySelector(\"html\").clientHeight;\n\tlet 페이지스크롤양 = document.querySelector(\"html\").scrollTop;\n\tlet 스크롤퍼센트 = (페이지스크롤양 / (페이지실제높이 - 페이지눈높이)) * 100;\n\n\tthis.document.querySelector(\".page_progress\").style.width = 스크롤퍼센트 + \"%\";\n});\n```\n\n\u003cbr\u003e\n\n### scroll 다룰 때 주의점\n\n1. scroll 이벤트리스너 안의 코드는 1초에 60번 이상 실행됨\n\t- 컴퓨터에 부담을 줄 수 있어서 너무 많이 쓰면 안됨\n\n2. 바닥체크도 여러 번 중복으로 할 것\n\n\u003cbr\u003e\n\n### 결론\n\n- 페이지 스크롤 : `window.scrollY`\n- div 스크롤 : `.scrollTop`\n- div 실제높이 : `.scrollHeight`\n- div 화면높이 : `.clientHeight`\n- jQuery 페이지 스크롤 : `$(window).scrollTop()`\n\n\u003chr\u003e\n\n## for 반복문, 탭기능 만들기\n\n\u003cbr\u003e\n\n### 탭기능\n\n- 탭은 위에 버튼 누르면 그에 걸맞는 div 박스 내용 보이게 하는거\n\n- 역시 탭을 만들 때도 하나하나 display: none~ block~ 하는것보다 `show`라는 클래스 하나 만들어서 탈부착하는 방식으로 만들기\n\n```html\n\u003cdiv class=\"container mt-5\"\u003e\n\t\u003cul class=\"list\"\u003e\n\t\t\u003cli class=\"tab-button\"\u003eProducts\u003c/li\u003e\n\t\t\u003cli class=\"tab-button orange\"\u003eInformation\u003c/li\u003e\n\t\t\u003cli class=\"tab-button\"\u003eShipping\u003c/li\u003e\n\t\u003c/ul\u003e\n\n\t\u003cdiv class=\"tab-content\"\u003e\n\t\t\u003cp\u003e상품설명입니다. Product\u003c/p\u003e\n\t\u003c/div\u003e\n\n\t\u003cdiv class=\"tab-content show\"\u003e\n\t\t\u003cp\u003e스펙설명입니다. Information\u003c/p\u003e\n\t\u003c/div\u003e\n\n\t\u003cdiv class=\"tab-content\"\u003e\n\t\t\u003cp\u003e배송정보입니다. Shipping\u003c/p\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\n```\n\n```css\nul.list {\n\tlist-style-type: none;\n\tmargin: 0;\n\tpadding: 0;\n\tborder-bottom: 1px solid #ccc;\n\tdisplay: flex;\n}\n\n.tab-button {\n\tpadding: 10px 20px 10px 20px;\n\tmargin-right: -1px;\n\tmargin-bottom: -1px;\n\tcolor: grey;\n\ttext-decoration: none;\n\tcursor: pointer;\n}\n\n.orange {\n\tborder-top: 2px solid orange;\n\tborder-right: 1px solid #ccc;\n\tborder-bottom: 1px solid white;\n\tborder-left: 1px solid #ccc;\n\tcolor: black;\n\tmargin-top: -2px;\n}\n\n.tab-content {\n\tdisplay: none;\n\tpadding: 10px;\n}\n\n.show {\n\tdisplay: block;\n}\n```\n\n1. tab-button 누르면 모든 버튼에서 orange 클래스 제거\n2. 누른 버튼에 orange 클래스 부착\n3. 모든 tab-content에서 show 클래스 제거\n4. 누른 버튼의 tab-content에 show 클래스 부착\n\n- 해당하는 기능을 바닐라js로 짜든, jQuery로 짜든, 반복되는 부분이 굉장히 많이 나올 것이다. 이때, **자주쓰는 셀렉터는 변수에 넣어쓰자. 셀렉터 문법은 느리다.** 그리고 여기서 필요한 것이 반복문이다.\n\n\u003cbr\u003e  \n\n### for 반복문\n\n```javascript\nfor (let i = 0; i \u003c 3; i++\u003e) {\n\t반복할 코드 ~\n}\n```\n\n\u003cbr\u003e\n\n- 탭만들기를 예제로, 반복문 이용하여 코드 짜보면\n\n```javascript\nvar 탭버튼 = $(\".tab-button\");\nvar 탭내용 = $(\".tab-content\");\n\nfor (var i = 0; i \u003c 탭버튼.length; i++) {\n\t탭버튼.eq(i).on(\"click\", function () {\n\t탭버튼.removeClass(\"orange\");\n\t탭버튼.eq(i).addClass(\"orange\");\n\t탭내용.removeClass(\"show\");\n\t탭내용.eq(i).addClass(\"show\");\n\t});\n}\n```\n\n이러면, 코드가 잘 돌아가지 않을 것이다. **var가 아닌 let을 사용하면 잘 될 것이다.**\n\n\u003cbr\u003e\n\n### var가 제대로 작동 안한 이유\n\n1. 코드를 위에서부터 한줄한줄 차례로 해석함\n\n2. for문을 만나서 내부 코드를 반복실행 하려고함\n\n3. 이벤트리스너 만남. 이벤트리스너 내부의 코드는 바로 실행되는 코드가 아니고 이벤트가 발생해야 실행되는 코드임\n\n4. **이벤트리스너 내부 코드 실행되지 않고 넘어감**\n\n5. 이 상태로 반복문 3번 실행\n\n6. 한참 뒤 사용자가 버튼 클릭 (현재 `var i = 3`인 상태)\n\n7. `var i = 3`인 상태지만, var 범위는 for문 밖에도 적용이 됨\n\n8. 그래서 `eq(i)`에 3을 대입하려고 함. 하지만, 4번 버튼은 없으니까 에러\n\n\u003cbr\u003e\n\n![](brain/image/apple-js-02-4.png)\n\n\u003ca href='/brain/Lecture/apple-js/apple-js-01' target='_blank'\u003eJS 입문과 웹 개발 01\u003c/a\u003e에서에서 var와 let의 범위를 보면, **let은 block-scoped 범위**이다. 따라서, 반복문 안에서 선언한 var i는 반복문이 끝났음에도 i의 값에 영향을 끼치는 상태이지만, let은 반복문 안에서만 영향을 끼치고 밖에서는 영향을 끼치지 못해서 괜찮은 것이다. c언어에서 배웠던 상식적인 반복문 내부 변수 선언의 범위가 let인 것으로 생각하자.\n\n\u003cbr\u003e\n\n### 탭기능 함수 이용 축약\n\n- 아래의 코드를 함수로 축약해보자.\n\n```javascript\nlet 탭버튼 = $(\".tab-button\");\nlet 탭내용 = $(\".tab-content\");\n  \nfor (let i = 0; i \u003c 탭버튼.length; i++) {\n\t탭버튼.eq(i).on(\"click\", function () {\n\t\t탭버튼.removeClass(\"orange\");\n\t\t탭버튼.eq(i).addClass(\"orange\");\n\t\t탭내용.removeClass(\"show\");\n\t\t탭내용.eq(i).addClass(\"show\");\n\t});\n}\n```\n\n- 축약한 코드\n\n```javascript\nlet 탭버튼 = $(\".tab-button\");\nlet 탭내용 = $(\".tab-content\");\n\nfor (let i = 0; i \u003c 탭버튼.length; i++) {\n\t탭버튼.eq(i).on(\"click\", function () {\n\t\t탭열기();\n\t});\n} \n\nfunction 탭열기() {\n\t탭버튼.removeClass(\"orange\");\n\t탭버튼.eq(i).addClass(\"orange\");\n\t탭내용.removeClass(\"show\");\n\t탭내용.eq(i).addClass(\"show\");\n}\n```\n\n하지만, 이렇게 작성하면 함수 탭열기에 변수 i를 따로 선언한 적이 없기 때문에 코드가 제대로 돌아가지 않을 것이다. **축약할 코드에 변수가 있으면 변수를 파라미터로 바꿔야 잘 작동한다.**\n\n\u003cbr\u003e\n\n- 파라미터 넣은 코드\n\n```javascript\nlet 탭버튼 = $(\".tab-button\");\nlet 탭내용 = $(\".tab-content\");\n\nfor (let i = 0; i \u003c 탭버튼.length; i++) {\n\t탭버튼.eq(i).on(\"click\", function () {\n\t\t탭열기(i);\n\t});\n}\n\nfunction 탭열기(구멍) {\n\t탭버튼.removeClass(\"orange\");\n\t탭버튼.eq(구멍).addClass(\"orange\");\n\t탭내용.removeClass(\"show\");\n\t탭내용.eq(구멍).addClass(\"show\");\n}\n```\n\n\u003chr\u003e\n\n## 이벤트 버블링\n\nlesson.html의 로그인 모달창에서 검은 배경을 눌러도 닫히도록 코드를 짜보자.\n  \n```javascript\n// 검은배경 누르면 모달창 닫기 버튼\ndocument.querySelector(\".black-bg\").addEventListener(\"click\", function () {\ndocument.querySelector(\".black-bg\").classList.remove(\"show-modal\");\n});\n```\n\n이때, 검은 배경이 아닌 그냥 모달창 아무데나 눌러도 모달창이 닫히는 것을 확인할 수 있다. 이는 이벤트 버블링 때문이다. **모든 브라우저는 이벤트 버블링이 일어난다.**\n\n- 이벤트 버블링(event bubbling) : 이벤트가 **상위 html로 퍼지는** 현상  \n\n```html\n\u003cdiv class=\"black-bg\"\u003e\n\t\u003cdiv class=\"white-bg\"\u003e\n\t\t\u003ch4\u003e로그인하세요\u003c/h4\u003e\n\t\t\u003cform action=\"./success.html\"\u003e\n\t\t\t\u003cdiv class=\"my-3\"\u003e\n\t\t\t\t\u003cinput type=\"text\" class=\"form-control\" id=\"email\" /\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\n\t\t\t\u003cdiv class=\"my-3\"\u003e\n\t\t\t\t\u003cinput type=\"password\" class=\"form-control\" id=\"pw\" /\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\n\t\t\t\u003cbutton type=\"submit\" class=\"btn btn-primary\" id=\"send\"\u003e\n\t\t\t\t전송\n\t\t\t\u003c/button\u003e\n\t\n\t\t\t\u003cbutton type=\"button\" class=\"btn btn-danger\" id=\"close\"\u003e\n\t\t\t\t닫기\n\t\t\t\u003c/button\u003e\n\t\t\u003c/form\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\n```\n\n- white-bg 클릭 시 : white-bg, black-bg 2번 클릭한거임\n\n- h4 클릭 시 : h4, white-bg, black-bg 3번 클릭한거임\n\n현재, js 코드를 `black-bg` 클릭 시 모달창이 닫히도록 코드를 짜놨다. 그러면 만약 input 태그를 클릭했다고 하면 div.my-3도 눌리고 div.white-bg도 눌리고 div.black-bg도 눌린 효과가 되어서 결국 모달창이 닫히는 것이다.\n\n\u003cbr\u003e  \n\n맨 처음 누른 요쇼가 진짜 black-bg 이면 모달창이 닫히도록 코드를 짜면 된다.\n\n\u003cbr\u003e\n\n### 유용한 이벤트관련 함수들\n\n- 콜백함수 파라미터에 `e`를 넣어보자. 그러면 사용가능한 함수들이 있다.\n\n```javascript\ndocument.querySelector(\".black-bg\").addEventListener(\"click\", function (e) {\ndocument.querySelector(\".black-bg\").classList.remove(\"show-modal\");\n});\n```\n\n- `e.target;` : 이벤트 발생한 곳 (ex. 유저가 실제로 클릭한 곳)\n\n- `e.currentTarget;` : 이벤트리스너 달린 곳 (`=this`)\n\n- `e.preventDefault();` : 이벤트 기본동작 막아줌, 이벤트 발생 안한것처럼\n\n- `e.stopPropagation();` : 내 상위요소로 이벤트 버블링 막아줌\n\n\u003cbr\u003e\n\n최종본\n\n- javascript\n\n```javascript\ndocument.querySelector(\".black-bg\").addEventListener(\"click\", function (e) {\nif (e.target == document.querySelector(\".black-bg\")) {\ndocument.querySelector(\".black-bg\").classList.remove(\"show-modal\");\n}\n});\n```\n\n- jQuery\n\njQuery는 애초에 셀렉터끼리 비교가 불가능해서 `if ( $(e.target) == $('.black-bg') )`는 안된다. `is()`를 이용하여 `if ( $(e.target).is($(\".black-bg\")) )` 이렇게 작성하자.\n\n```javascript\n$(\".black-bg\").on(\"click\", function (e) {\n\tif ($(e.target).is($(\".black-bg\"))) {\n\t\t$(\".black-bg\").removeClass(\"show-modal\");\n\t}\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 이벤트버블링 응용\n\n- 탭기능 다르게 만들기 (이벤트리스너 1개만 사용)\n\n위에서 만들었던 탭기능은 반복문을 사용해서 이벤트리스너를 3개 사용했다. 이벤트리스너 1개를 쓸 때 마다 램 용량을 차지하기 때문에 성능적인 이점을 가지기 위하여 줄여보겠다.\n\n```html\n\u003cul class=\"list\"\u003e\n\t\u003cli class=\"tab-button\"\u003eProducts\u003c/li\u003e\n\t\u003cli class=\"tab-button orange\"\u003eInformation\u003c/li\u003e\n\t\u003cli class=\"tab-button\"\u003eShipping\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n해당하는 코드의 `.list` 1개에만 이벤트리스너를 부착한다고 하자. 이벤트버블링은 항상 일어나니까 `.tab-button` 무엇을 클릭하든 `.list`를 클릭한 효과가 생긴다.\n\n```javascript\n// 이벤트리스너 1개 버전\nlet 탭버튼 = $(\".tab-button\");\nlet 탭내용 = $(\".tab-content\");\n\nfunction 탭열기(구멍) {\n\t탭버튼.removeClass(\"orange\");\n\t탭버튼.eq(구멍).addClass(\"orange\");\n\t탭내용.removeClass(\"show\");\n\t탭내용.eq(구멍).addClass(\"show\");\n} \n\n$(\".list\").on(\"click\", function (e) {\n\tif ($(e.target).is(탭버튼.eq(0))) {\n\t\t탭열기(0);\n\t}\n\n\tif ($(e.target).is(탭버튼.eq(1))) {\n\t\t탭열기(1);\n\t}\n\n\tif ($(e.target).is(탭버튼.eq(2))) {\n\t탭열기(2);\n\t}\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Datasest\n\n- `data-자료이름=값`을 이용하여 html 태그에 몰래 정보숨기기 가능하다.\n\n- `셀렉터.dataset.자료이름`을 이용하여 숨겼던 자료 출력 가능\n\n```html\n\u003cli class=\"tab-button\" data-id=\"0\"\u003eProducts\u003c/li\u003e\n```\n\n```javascript\nconsole.log(document.querySelector('.tab-button').dataset.id)\n// 0\n```\n\n- dataset 이용하여 탭기능 코드 줄이기\n\n```html\n\u003cul class=\"list\"\u003e\n\t\u003cli class=\"tab-button\" data-id=\"0\"\u003eProducts\u003c/li\u003e\n\t\u003cli class=\"tab-button orange\" data-id=\"1\"\u003eInformation\u003c/li\u003e\n\t\u003cli class=\"tab-button\" data-id=\"2\"\u003eShipping\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n```javascript\n$(\".list\").on(\"click\", function (e) {\n\t탭열기(parseInt(e.target.dataset.id));\n});\n```\n\n- 내가 누른 것에 숨겨져있는 dataset이 id인 녀석의 값을 가져오는 것을 이용","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-js/apple-js-03":{"title":"LEVEL 03","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/javascript-jquery-ui/' target='_blank'\u003eJavaScript 입문과 웹 UI 개발\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## Array, Object\n\n\u003cbr\u003e\n\n### Array 자료형\n\n- `let 변수 = [];` 대괄호 이용, **순서O**\n\n- 변수 하나에 여러 자료 저장하는 쉬운 방법\n\n\n```javascript\nlet car = ['소나타', 50000, 'white'];\ncar[0] = ['아반떼'];\nconsole.log(car[0]);\nconsole.log(car[1]);\n\n// 아반떼\n// 50000\n```\n\n\u003cbr\u003e  \n\n- 순서 있으니까 **정렬 가능** (숫자 -\u003e 영어 -\u003e 한글 순)\n\n```javascript\nlet car = ['소나타', 50000, 'white'];\ncar.sort();\nconsole.log(car);\n// [50000, 'white', '소나타']\n```\n\n\u003cbr\u003e  \n\n- 순서 있으니까 중간에 **자르기 가능** (**슬라이싱**)\n- `slice(n, m)` : n부터 m 전까지\n\n```javascript\nlet car = ['소나타', 50000, 'white'];\nconsole.log(car.slice(1, 3));\n// [50000, 'white'] 1부터 2까지네\n```\n\n- 자료검색도 가능, 맨앞/맨뒤에 자료추가 가능\n\n\u003cbr\u003e  \n\n### Object 자료형  \n\n- `let 변수 = {key1: value1, key2: value2};` 중괄호 이용, **순서 X**\n\n- 이름을 **key**, 자료를 **value**라고 함.\n\n- `key: value` 형태로 저장가능한 것이 장점\n\n- 실제로 object 자료형에 저장되는 자료는 value만 저장되고 key는 이름일 뿐임\n\n```javascript\nlet car2 = {name: '소나타', price: 50000};\nconsole.log(car2);\n// { name: '소나타', price: 50000 }\n\nconsole.log(car2['name']);\nconsole.log(car2.name);\n// 소나타\n// 소나타\n\ncar2.price = 60000;\nconsole.log(car2.price);\n// 60000\n```\n\n\u003cbr\u003e  \n\n### array / object 차이\n\n- Array 자료형 : 순서대로 자료 저장 가능, `순서 개념 O`, `따라서 자료간 정렬 가능`\n\n- Object 자료형 : 자료에 이름 붙혀서 저장 가능 `순서 개념 X`, `따라서 인덱싱 불가`\n\nex) 쇼핑몰 제작 시, 상품 정보들을 10개, 20개 보관해야 한다고 하자. 뭐 쓸래? \u003cbr\u003e\n\nsol) object 쓰는게 좋을 듯. 예를 들어, 가격을 꺼낸다고 하면 몇 번째에서 꺼낼래? 순서보다 prcie 이름을 기억하고 자료를 꺼내는게 편함.\n\n\u003chr\u003e\n\n## 웹서비스 방식\n\n실제 웹서비스는 유저가 내 사이트에 접속했을 때 html 파일을 보내주는 것이 끝이다. 어떤 사람이 접속하면 나의 html 파일 보여주는 원리이다. 이때 **서버에서 유저에게 html 파일을 보내줄 때 방식이 두 가지가 있다.** html 파일을 어디에서 완성해주느냐에 따라 server-side / client-side로 나뉜다.\n\n1. **server-side rendering**\n\n**완성된 html 파일을 서버에서 보내는 방식**. 예를 들어, 쇼핑몰 상세페이지를 만든다고 하면 소나타, 50000원 이런식으로 미리 다 채워서 html 파일 만들고 보내준다. 서버가 html 파일 다 만들어야해서 서버가 귀찮다.\n\n\u003cbr\u003e\n\n2. **client-side rendering**\n\n**텅 빈 html 파일 + 데이터를 보내는 방식**. 이때 html 완성은 javascript하고 하도록 한다. 유저의 브라우저에서 js가 이리저리 일을 할 것 이다. 자동차 자리에 소나타 자료를 넣고 가격 자리에 50000원 넣고 이런식으로 클라이언트 단에서 html 파일을 완성해준다. 서버가 편하다. \u003cbr\u003e\n\nlevel3.html 실습에서 `let car2 = { name: '소나타', price: [50000, 3000, 4000]};` 여기에서 `document.querySelector('.car-price').innerHTML = car2.price[0]` 데이터를 car-price 클래스에 박아넣고 있었다. 이것이 client-side rendering을 하고 있는 거이다. 이때, **html에 데이터를 꽂는 행위를 데이터바인딩**이라고 한다. 데이터바인딩 쉽게 해주는 js 라이브러리가 바로 **jQuery, React, Vue** 등등 이다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Select 01 : 인풋 다루기\n\n기본적으로 ,`\u003cselect\u003e` 사용법은 \u003ca href='/brain/Lecture/apple/apple-js/apple-js-01' target='_blank'\u003eJS 입문과 웹 개발 01\u003c/a\u003e에서 설명한 input 태그 사용법과 동일하다. input 대신 select를 사용하는 이유는, input은 자유로운 반면 **select는 선택지를 제공해줘서 데이터를 쉽게 관리**할 수 있기 때문이다.\n\n\u003cbr\u003e\n\ninput과 사용법이 비슷하기에 역시 **value**를 가져와서 처리할 수 있고 이벤트에 `input`, `change`를 사용가능하다. 아래 코드를 보면 select에 이벤트 발생 시 value를 가져와서 문자열을 비교해주고 해당하는 코드를 조작하고 있다. input 이벤트는 값에 변화가 생길 때마다, change 이벤트는 포커스를 잃을 때마다처럼 `\u003cinput\u003e` 에서 썼던 것과 동일하다.\n\n```html\n\u003cform class=\"container my-5 form-group\"\u003e\n\t\u003cp\u003e상품선택\u003c/p\u003e\n\t\n\t\u003cselect class=\"form-select mt-2\"\u003e\n\t\t\u003coption\u003e모자\u003c/option\u003e\n\t\t\u003coption\u003e셔츠\u003c/option\u003e\n\t\u003c/select\u003e\n\t\n\t\u003cselect class=\"form-select mt-2 form-hide\"\u003e\n\t\t\u003coption\u003e95\u003c/option\u003e\n\t\t\u003coption\u003e100\u003c/option\u003e\n\t\u003c/select\u003e\n\u003c/form\u003e\n```\n\n\u003cbr\u003e\n\n```javascript\ndocument.querySelectorAll('.form-select')[0].addEventListener('input', function () {\n\t// this는 여기서 이벤트리스너에 function() 썼으니까\n\t// e.currentTarget을 의미\n\n\tlet value = this.value;\n\tif (value == '셔츠') {\n\t\tdocument.querySelectorAll('.form-select')[1]\n\t\t\t\t.classList.remove('form-hide');\n\t} else {\n\t\tdocument.querySelectorAll('.form-select')[1]\n\t\t\t\t.classList.add('form-hide');\n\t}\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Select 02 : JS로 html 생성\n\n그러나, 위와 같이 하드코딩 해놓으면 **확장성**이 떨어진다. 만약, 셔츠 사이즈에 변동이 생겨 105나 110이 생겼다. 혹은 품절이 되었다면 그때마다 html 파일 열어서 수정할 것인가? 아니지 않느냐. html을 만들어놨다가 보여주기만 하는게 아니라 자바스크립트로 html을 조작, 생성 하는식으로 만들어야한다.\n\n\u003cbr\u003e\n\n1. 자바스크립트로 html 생성법 첫번째 (정통적, 요새 잘 안씀)\n\n\t- `document.createElement('')`로 html 자료 생성\n\n\t- 생성한 태그에 `.innerHTML`로 내용 첨부\n\n\t- 클래스명 짓고 싶으면 `.classList.add('')`\n\n\t- 마지막으로 해당하는 html document 가져와서 `appendChild()`\n\n\n```javascript\nlet a = document.createElement('p');\na.innerHTML = '안녕';\na.classList.add('p_test');\ndocument.querySelector('#test').appendChild(a);\n```\n\n\u003cbr\u003e\n\n2. 자바스크립트로 html 생성법 두번째 (최근 트렌드, 리액트에서도 이런거 본듯)\n\n\t- html 문서에서 짤 때 처럼 문자열에 만들어서 넣기\n\n\t- `insertAdjacentHTML()`는 문자형 HTML 추가해주는 함수\n\n\t- `beforeend`는 안에서 맨 밑에 추가하라는 의미\n\n```javascript\nlet 템플릿 = '\u003cp\u003e안녕!!\u003c/p\u003e';\ndocument.querySelector('#test').insertAdjacentHTML('beforeend', 템플릿);\n\n//jQuery 버전\n$('#test').append(템플릿);\n```\n\n\u003cbr\u003e\n\n1번과 2번 방법 모두 기존의 html에 **추가**하는 형식이라서 맨 뒤에 추가될거임. `innerHTML`써서 그냥 내용 다 엎어버리고 그걸로 대체해도 괜찮음. 1번이 2번보다 2배 빠르지만, 1번은 코드가 길고 귀찮으니까 2번을 더 많이씀. 사실, 0.0000x초 차이라서 크게 성능 하락 없음\n\n\u003cbr\u003e\n\n```html\n\u003cform class=\"container my-5 form-group\"\u003e\n\t\u003cp\u003e상품선택\u003c/p\u003e\n\t\u003cselect class=\"form-select mt-2\"\u003e\n\t\t\u003coption\u003e모자\u003c/option\u003e\n\t\t\u003coption\u003e셔츠\u003c/option\u003e\n\t\u003c/select\u003e\n\t\u003cselect class=\"form-select mt-2 form-hide\"\u003e\n\t\t\u003coption\u003e95\u003c/option\u003e\n\t\t\u003coption\u003e100\u003c/option\u003e\n\t\u003c/select\u003e\n\u003c/form\u003e\n```\n  \n\u003cbr\u003e\n\n```javascript\ndocument.querySelectorAll('.form-select')[0].addEventListener('input', function () {\n\t// this는 여기서 이벤트리스너에 function() 썼으니까\n\t// e.currentTarget을 의미\n\tlet value = this.value;\n\n\tif (value == '셔츠') {\n\t\tdocument.querySelectorAll('.form-select')[1]\n\t\t\t\t.classList.remove('form-hide');\n\n\t\tlet 셔츠 = `\u003coption\u003e95\u003c/option\u003e\n\t\t\t\t\t\u003coption\u003e100\u003c/option\u003e`;\n\n\t\tdocument.querySelectorAll('.form-select')[1].innerHTML = 셔츠;\n\n\t} else if (value == '바지') {\n\t\tdocument.querySelectorAll('.form-select')[1]\n\t\t\t\t.classList.remove('form-hide');\n\t\t\t\t\n\t\tlet 바지 = `\u003coption\u003e28\u003c/option\u003e\n\t\t\t\t\u003coption\u003e30\u003c/option\u003e`;\n\n\t\tdocument.querySelectorAll('.form-select')[1].innerHTML = 바지;\n\n\t} else {\n\t\tdocument.querySelectorAll('.form-select')[1]\n\t\t\t\t.classList.add('form-hide');\n\t}\n});\n```\n\n이렇게 하면 HTML 파일에 하드코딩 했다기보다 JS 조작을 통해 셔츠 사이즈를 다 날려버리고 바지 선택하면 바지 사이즈가 나오게 됨. 추가로, **JS에서 html 저렇게 만들 때 문자열 기호에 넣고 하면 엔터키 치면 안내려갈거임. 백틱 키 쓰셈**\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Select 03 : forEach, for in 반복문\n\n위에서 자바스크립트로 html 만들어서 html에 박는 것을 배웠다. 하지만 아직까지는 자바스크립트로 html 코드 그대로 짰으니까 여전히 하드코딩이다. 만약, 셔츠/바지 사이즈가 매일매일 달라진다면? **실제로 서버에서 데이터 가져와서 갯수만큼 option 태그 생성하도록 해보자.**\n\n- for 반복문 : `for (let i = 0; i \u003c 어쩌구; i++)`\n\n- forEach 반복문 : **Array 자료형** 뒤에 붙일 수 있는 기본 함수, 반복문 역할\n\n- for in 반복문 : **Object 자료형** 반복문 돌리고 싶을 때 사용\n\n\u003cbr\u003e\n\n\u003e [!note] Memo\n\u003e\n\u003e array 자료형이나 object 자료형의 자료를 전부 꺼내어서 사용하고 싶을 때 forEach, for in 반복문은 매우 유용하다. \u003cbr\u003e\n\u003e array 자료형에서 기본함수 .forEach() 말고 for in 같은 반복문 for of가 있다. 단, index를 얻지 못한다는 단점 있음  \n\n\u003cbr\u003e\n\n### forEach 반복문\n \n- forEach 반복문은 **콜백함수** 써줘야 한다.\n\n- 콜백함수에 파라미터 2개까지 넣을 수 있다.\n\n- 첫번째 파라미터 : **반복문 돌 때 마다 array 안에 있던 하나하나의 데이터**\n\n- 두번째 파라미터 : **반복문 돌 때 마다 0부터 1씩 증가하는 정수**  \n\n```javascript\nlet pants = [28, 30, 32];\npants.forEach(function () {\n\tconsole.log('안녕');\n});\n// 안녕\n// 안녕\n// 안녕\n\npants.forEach(function (a, i) {\n\tconsole.log(a); // 28 30 32\n\tconsole.log(i); // 0 1 2\n});\n\nfor (let pant of pants) {\n\tconsole.log(pant); // 28 30 32\n}\n```\n\n\u003cbr\u003e\n\n```javascript\n// 서버에서 보내준 데이터라고 가정\nlet shirts = [90, 95, 100, 105];\nlet pants = [28, 30, 32, 34];\n\ndocument.querySelectorAll('.form-select')[0].addEventListener('input', function () {\n\t// this는 여기서 이벤트리스너에 function() 썼으니까\n\t// e.currentTarget을 의미\n\tlet value = this.value;\n\tlet optionSelector = document.querySelectorAll('.form-select')[1];\n\n\tif (value == '셔츠') {\n\t\toptionSelector.classList.remove('form-hide');\n\t\toptionSelector.innerHTML = '';\n\n\t\t// for 반복문\n\t\tfor (let i = 0; i \u003c shirts.length; i++) {\n\t\t\toptionSelector.insertAdjacentHTML('beforeend',\n\t\t\t`\u003coption\u003e${shirts[i]}\u003c/option\u003e`);\n\t\t}\n\t\n\t\t// forEach 반복문\n\t\tshirts.forEach(function (data) {\n\t\t\toptionSelector.insertAdjacentHTML('beforeend',\n\t\t\t\t`\u003coption\u003e${data}\u003c/option\u003e`);\n\t\t});\n\t\t\n\t\t// forEach 반복문 arrow function 사용\n\t\tshirts.forEach((data) =\u003e {\n\t\t\toptionSelector.insertAdjacentHTML('beforeend',\n\t\t\t\t`\u003coption\u003e${data}\u003c/option\u003e`);\n\t\t});\n\t}\n});\n```\n\n\u003cbr\u003e\n\n### for in 반복문\n\n- object 자료 갯수만큼 반복문 돌리고 싶으면 사용 가능\n\n- key라고 작명한 부분은 object 자료형의 key 부분\n\n- key, value 모두 출력 가능\n\n```javascript\nlet obj = {name: 'shin', age: 27};\n\nfor (let key in obj) {\n\tconsole.log('안녕');\n}\n// 안녕\n// 안녕\n\nfor (let key in obj) {\n\tconsole.log(key);\n\tconsole.log(obj[key]);\n}\n// name\n// shin\n// age\n// 27\n```\n\n\u003chr\u003e\n\n## arrow function 맛보기\n\n- 함수 만드는 또다른 문법이 arrow function 이다.\n\n- 기본적으로 함수와 this 빼고 거의 동일한 역할을 한다.\n\n- **특히, 콜백함수 만들 때 자주 사용**\n\n- `function() {}`는 `() =\u003e {}`와 같다.\n\n- 심지어 파라미터가 1개라면 소괄호 생략하고 사용하기도 한다.\n\n`function(a) {}`는 `a =\u003e {}`와 같다.\n\n```javascript\nlet pants = [28, 30, 32];\n\npants.forEach(function (a) {\n\tconsole.log(a);\n});\n\npants.forEach((a) =\u003e {\n\tconsole.log(a);\n});\n```\n\n- 함수 표현식의 형태로 쓰는 사람도 있다.\n\n```javascript\nlet 함수1 = function () {\n\tconsole.log('안녕');\n};\n\nlet 함수2 = () =\u003e {\n\tconsole.log('안녕');\n};\n```\n\n\u003cbr\u003e\n\n함수 안에서 **this**를 사용해야할 경우 `함수`와 `화살표 함수`는 **기능적인 차이**가 존재한다.\n\n- `function()` : 함수 안에서 this를 알맞게 **재정의** 해줌\n\n- `arrow function` : 함수 안에서 this를 재정의하지 않고 **바깥에 있던 this를 그대로 사용**\n\n\u003cbr\u003e  \n\n위에서 사용했던 this를 살펴보겠다.\n\n```javascript\ndocument.querySelectorAll('.form-select')[0].addEventListener('input', function () {\n\t// this는 여기서 이벤트리스너에 function() 썼으니까\n\t// e.currentTarget을 의미\n\tlet value = this.value;\n});\n```\n\n현재 **function()** 을 썼기 때문에 함수 안에서 this가 재정의 되어서 `document.querySelectorAll('.form-select')[0].addEventListener`가 동작했을 때를 뜻하니까 `e.currentTarget`이 된다. 하지만, 만약 여기서 **화살표함수를 사용해버리면 함수 바깥의 this를 가져와서 사용하기 때문에 의도와 다르게 동작할 수 있다.** 따라서 주의가 필요하다.\n\n\u003cbr\u003e\n\n\u003e [!note] Memo\n\u003e\n\u003e 이벤트리스너 콜백함수 안에서 this를 사용해야하면 **arrow function 사용 시에 의도와 다르게 동작할 수 있으니까** 그런데서 사용하지말고 조심해서 사용하자. \u003cbr\u003e\n\u003e 참고로, 브라우저 환경의 전역객체는 **window** node 환경의 전역객체는 **global**이다. 예시 코드에서 밖에 특별한 this가 없다면, 화살표 함수를 썼을 때 this는 window를 뜻하게 된다.\n  \n\u003chr\u003e\n\n## Ajax\n\n먼저 \u003ca href='https://velog.io/@leehaeun0/Ajax-%EB%8A%94-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%9D%B8%EA%B0%80%EC%9A%94' target='_blank'\u003e링크\u003c/a\u003e 읽어보고 오기\n\n**서버**는 데이터 보내달라고 요청하면 데이터를 보내주는 것이다. 예를 들어, 네이버 웹툰 서버라고 하면 네이버 웹툰 달라고 하면 웹툰 보내주는 것이다. 서버는 데이터를 보내주기도 하고 유저 데이터를 받아서 DB에 저장하기도 하는 역할을 한다.\n\n1. 어떤 데이터인지 : 데이터의 url\n\n\t- 예를 들어, comic.naver.com 이라는 url\n\n\t- 데이터 url은 서버 개발자가 작성한 api 문서에 따라 요청한다.\n\n2. 어떤 방법으로 데이터를 요청할건지 : get인지, post인지 정확히\n\n\t- **get은 데이터 읽을 때, post는 데이터를 보낼 때**\n\n\u003cbr\u003e\n\nQ. 특정 url로 get 요청하는 법?  \n\n- 인터넷의 주소창에 url을 입력하는 것이 일종의 get 요청하는 것이다. 즉, **주소창이 get 요청하는 곳**이라고 이해하면 된다.\n\nQ. 특정 url로 post 요청하는 법?\n\n- `\u003cform action=\"/url\" method=\"post\"\u003e\u003c/form\u003e`태그를 이용한다. 전송버튼을 누르면 서버에 post 요청 하는 것이다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n### ajax의 등장\n\n단순히 get요청과 post요청하면 **브라우저가 새로고침이 된다는 것이 단점**이다. 새로고침이 매번 발생하면 불편하기 때문에 **새로고침 없이 get, post 요청할 수 있도록 ajax**가 등장하는 것이다. 예를 들어, 쇼핑몰의 경우에 상품더보기 버튼을 누르면 새로고침 없이 서버와 통신하여 새로운 상품 목록을 불러오는 것이다. \u003cbr\u003e\n\n참고로, ajax를 편하게 쓰고 싶을 때 사용하는 것이 axios 라이브러리 이다. 리액트나 뷰에서는 주로 axios 라이브러리를 사용할 것이다.\n\n\u003cbr\u003e\n\n- ajax로 get요청 하는 방법\n\n```javascript\n$.get('url~~');\n```\n\n예시로, `https://codingapple1.github.io/hello.txt`로 get요청 하면 인삿말 보내준다. 그리고, `.done()` 함수를 이용하면 get요청이 성공했을 때 콜백함수 실행시킬 수 있다.\n\n```javascript\n$.get('https://codingapple1.github.io/hello.txt').done(function (data) {\n\tconsole.log(data);\n});\n\n// '안녕하세요 반갑습니다요.'\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n- ajax로 post요청 하는 방법\n\n```javascript\n$.post('url~~', data);\n\n$.post('https://codingapple1.github.io/hello.txt', {name: 'kim'}).done(\n\tfunction (data) {\n\t\tconsole.log(data);\n\t}\n);\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n- ajax 실패시 특정 코드 실행 `.fail()`\n\n- 보통 **404 error**는 서버에 url이 없다는 오류\n\n```javascript\n$.get('https://codingapple1.github.io/hello.txt').done(function (data) {\n\tconsole.log(data);\n}).fail(function () {\n\tconsole.log('실패함');\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### 브라우저 기본 함수 fetch\n\najax말고 브라우저 기본 함수를 써서 쌩 자바스크립트로 구현할 수도 있다.\n\n```javascript\n// ajax 사용\n$.get('https://codingapple1.github.io/price.json')\n.done(function (data) {\n\tconsole.log(data.price);\n}).fail(function () {\n\tconsole.log('실패함');\n});\n\n// fetch 사용\nfetch('https://codingapple1.github.io/price.json')\n.then((res) =\u003e res.json())\n.then((data) =\u003e {\n\tconsole.log(data.price);\n}).catch((error) =\u003e {\n\tconsole.log(error);\n});\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### JSON 자료형\n\n서버와 클라이언트는 **문자자료만 주고 받을 수 있다.** object, array를 보내고 싶으면 \"\"를 쳐서 문자처럼 만들고 보내야한다. 이렇게 **따옴표 친 object, array 자료가 바로 JSON**이라고 한다.\n\n```javascript\n// object\n{price : 5000}\n\n// JSON\n\"{\"price\" : 5000}\"\n```\n\nJSON으로 변환하면 문자형 자료라서 원하는 자료만 뽑아쓰기 힘들다. 그래서 JSON자료를 다시 object나 array로 변환해서 사용하면 뽑아쓰기 편하다. fetch를 사용할 때 `((res) =\u003e res.json())`이 응답받은 response를 json으로 변환해주는 과정이다. ajax는 자동으로 변환해주기 때문에 신경쓰지 않았다.\n\n\u003chr\u003e\n\n## Array 자주 쓰는 함수\n\n\u003cbr\u003e\n\n### sort() 함수\n\n- `sort()` 함수는 **문자정렬**이다.\n\n- `sort()` 함수는 **원본을 변형**시킨다.\n\n- 문자가 아닌 숫자를 그냥 정렬하려고 하면 아래와 같이 원치 않는 결과가 나온다.\n\n```javascript\nlet 어레이 = [7, 3, 5, 2, 40];\n어레이.sort();\nconsole.log(어레이);\n\n// [2, 3, 40, 5, 7]\n```\n\n\u003cbr\u003e\n\narray **숫자 정렬**은 콜백함수를 사용하고 return 값을 따로 지정해줘야 한다. 아래와 같이 코드를 작성하면 **오름차순 숫자 정렬**이다.\n\n```javascript\nlet 어레이 = [7, 3, 5, 2, 40];\n어레이.sort(function (a, b) {\n\treturn a - b;\n});\n\nconsole.log(어레이);\n// [2, 3, 5, 7, 40]\n```\n\n\u003cbr\u003e\n\narray 안에 object가 있는 형태라면? ex) `[ {}, {}, {} ]` 그 경우 return 값이 `{} - {}`이니까 양수나 음수가 나오는 구조가 아니다. object의 value를 가져와서 비교해주고 return 해주면 되겠구나.\n\n\n```javascript\nlet 상품배열 = [\n\t{id: 0, price: 70000, title: 'Blossom Dress'},\n\t{id: 1, price: 50000, title: 'Springfield Shirt'},\n\t{id: 2, price: 60000, title: 'Black Monastery'},\n];\n\n상품배열.sort(function (a, b) {\n\treturn a.price - b.price;\n});\n\nconsole.log(상품배열);\n\n// [\n//    { id: 1, price: 50000, title: 'Springfield Shirt' },\n//    { id: 2, price: 60000, title: 'Black Monastery' },\n//    { id: 0, price: 70000, title: 'Blossom Dress' }\n// ]\n\n```\n\n\u003cbr\u003e\n\n### array 숫자 정렬 원리\n  \n1. 콜백함수의 a와 b는 array 안에 있던 자료들이다. ex) `7, 3`\n\n2. return 결과가 양수면 a를 오른쪽으로 보낸다.\n\n3. return 결과가 음수면 b를 오른쪽으로 보낸다. ex) `7 - 3 = 4` 양수니까, a가 b보다 크다는 의미이다. 따라서, a를 오른쪽으로 보낸다.\n\n\u003cbr\u003e\n\n### 문자 가나다순 정렬\n\n- 그냥 `.sort()` 사용\n\n```javascript\nlet 어레이2 = ['a', 'c', 'b'];\n어레이2.sort();\nconsole.log(어레이2);\n// ['a', 'b', 'c']\n```\n\n\u003cbr\u003e\n\n```javascript\nlet 어레이3 = ['a', 'd', 'c', 'b'];\n어레이3.sort(function (a, b) {\n\tif (a \u003e b) {\n\t\treturn 1;\n\t} else {\n\t\treturn -1;\n\t}\n});\nconsole.log(어레이3);\n```\n\n### 정렬 결론\n\n`sort()` 함수는 배열의 요소를 compareFunction에게 2개씩 반복해서 보낸 뒤, compareFunction이 반환하는 값을 기준으로 정렬한다. 보내는 요소들의 이름을 a, b라고 했을 때 기준은 아래와 같다.\n\n- `반환 값 \u003e 0` : b가 a보다 앞에 있어야 한다. **a가 우측으로 감**\n\n- `반환 값 \u003c 0` : a가 b보다 앞에 있어야 한다. **b가 우측으로 감**\n\n- `반환 값 = 0` : a와 b의 순서를 바꾸지 않는다\n\n자세한 설명은 \u003ca href='https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort' target='_blank'\u003e링크\u003c/a\u003e에서 참조하도록 하자.\n\n\u003cbr\u003e\u003cbr\u003e\n\n### filter() 함수\n\n- `filter()` 함수는 array 자료에서 원하는 것만 고르고 싶을 때 사용하는 함수\n\n- `filter()` 함수는 **원본을 변형시키지 않기 때문**에 결과를 변수에 저장해서 사용해야 한다.\n\n\n```javascript\nlet 어레이 = [7, 3, 5, 2, 40];\n\n// a는 array에 있던 자료들\nlet 새어레이 = 어레이.filter(function (a) {\n\treturn a \u003c 4;\n});\n\nconsole.log(어레이);\n// [7, 3, 5, 2, 40]\n\nconsole.log(새어레이);\n// [3, 2]\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n### map() 함수\n\n- `map()` 함수는 array 자료 전부 변형할 때 사용하는 함수\n\n- `map()` 함수는 **원본을 변형시키지 않기 때문**에 결과를 변수에 저장해서 사용해야 한다.\n\n```javascript\nlet 어레이 = [7, 3, 5, 2, 40];\n\n// a는 array에 있던 자료들\nlet 새어레이 = 어레이.map(function (a) {\n\treturn a * 4;\n});\n\nconsole.log(새어레이);\n// [28, 12, 20, 8, 160]\n```\n\n\u003chr\u003e\n\n## DOM\n\n- DOM (Document Object Model)\n\n자바스크립트가 html을 어떻게 조작할까? 이는 DOM이 있기에 가능한데, DOM은 HTML을 파싱한 결과물이다. HTML은 단순 텍스트로 이루어진 문자열이라서 브라우저가 이해하도록 객체 자료구조로 변환시켜야 한다. document에 객체를 저장한다는 느낌이다.\n\n```html\n\u003cdiv style=\"color : red;\"\u003e안녕하세요\u003c/div\u003e\n```\n\n\u003cbr\u003e\n\n```javascript\nlet document = {\n\tdiv1 : {\n\t\tstyle : {color : 'red'};\n\t\tinnerHTML : '안녕하세요';\n\t}\n}\n```\n\n이런식으로 HTML 문서를 파싱해서 object 자료형으로 바꿔주는 것이다. (_실제 DOM의 형태가 저렇지는 않고 간단하게 설명한 것이다._) 실제로는 파싱하여 가장 최소단위인 토큰부터 토큰을 다시 노드로 바꾸는 등 복잡하다. 모던 자바스크립트 딥다이브 667페이지를 참조하자.\n\n\u003chr\u003e\n\n- script 태그 위치의 중요성\n\nHTML을 파싱하여 DOM을 생성하는 것은 위에서부터 아래로 차례로 읽어나가며 진행된다.\n\n```html\n\u003cscript\u003e\n\tdocument.getElementById('test').innerHTML = '안녕';\n\u003c/script\u003e\n\n\u003cp id=\"test\"\u003e임시글자\u003c/p\u003e\n```\n\n이 코드는 당연히 에러가 날 것이다. 위에서부터 읽어내려오며 파싱을 하고 있는데 아직 DOM에 추가하지도 않은 p 태그를 불러오려고 하니까.\n\n1. head의 script 태그\n\n2. body 마지막의 script 태그\n\n3. 외부 자바스크립트 파일\n\n\u003cbr\u003e\n\n뭔가 이상하다면 이 경우에 HTML이 파싱이 됐는지 안됐는지 잘 생각해보자. html 파일 내부의 script 태그에 자바스크립트 코드를 작성할 때는 웬만하면 body 끝에다가 작성하자. **HTML을 파싱하다가 script 태그를 만나면 HTML 파싱을 멈추고 자바스크립트 파싱을 하기 때문에, head에 작성하면 문제가 생긴다.**\n\n\u003cbr\u003e\n\n외부 자바스크립트 파일을 불러올 때 **src** 속성을 주는 이유가 바로 이때문이다. 위에서부터 차례대로 코드를 실행한다는 것은 **동기적**으로 실행하고 있다는 의미이다. HTML5 이후 추가된 script src 속성에는 `async`와 `defer`가 있다. 두 속성 다 비동기적으로 js 파일을 로드해온다. HTML을 파싱해오면서 동시에 js파일을 로드한다는 의미이다.\n\n- `\u003cscript async src=\"js파일\"\u003e\u003c/script\u003e`\n\n- HTML 파싱, js파일 로드 동시 -\u003e js파일 로드 다되면 HTML 파싱 멈추고 js 파싱, 실행\n\n- `\u003cscript defer src=\"js파일\"\u003e\u003c/script\u003e`\n\n- HTML 파싱, js파일 로드 동시 -\u003e HTML 파싱 끝나면 그때 js 파싱, 실행\n\n\u003chr\u003e\n\n코딩애플 강의에서는 자바스크립트 실행을 약간 나중으로 미루는 방법을 addEventListener 방식으로 소개했다. **이 코드는 HTML 전부 다 읽고 실행해주세요**라는 의미이다. 자바스크립트 파일을 어디에 작성하는지 위치를 내가 정할 수 없을 경우에 유용한 방법이기는 하지만, 개인적인 생각으로 잘 안쓸듯하다.\n\n```javascript\n// jQuery\n$(document).ready(function() {실행할 코드})\n\n// javascript\ndocument.addEventListener('DOMContentLoaded', function() {실행할 코드})\n```\n\n\u003cbr\u003e\n\n```html\n\u003cscript\u003e\n\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\tdocument.getElementById('test').innerHTML = '안녕';\n\t});\n\u003c/script\u003e\n\n\u003cp id=\"test\"\u003e임시글자\u003c/p\u003e\n```\n\n\u003cbr\u003e\n\n**load 이벤트리스너**를 사용하면, DOM 생성뿐만 아니라 이미지, css, js파일 로드 모두 체크 가능하다.\n\n```javascript\n셀렉터로찾은이미지.addEventListener('load', function () {\n\t// 이미지 로드 완료 시 실행할 코드\n});\n```\n\n하지만, 만약 외부 자바스크립트 파일에 load를 작성해놓으면 js파일보다 이미지가 더 먼저 로드되는 경우에는 이벤트 발생 체크를 못할 것이다.\n\n\n```javascript\n// jQuery\n$(window).on('load', function () {\n\t// document 안의 이미지, js 파일 포함 전부 로드가\n\t// 되었을 경우 실행할 코드\n});\n\nwindow.addEventListener('load', function () {\n\t// document 안의 이미지, js 파일 포함 전부 로드가\n\t// 되었을 경우 실행할 코드\n});\n```\n\n이렇게 window에 붙혀도 된다.\n\n\u003chr\u003e\n\n## localStorage\n\n\u003cbr\u003e\n\n쇼핑몰 장바구니 기능을 만든다고 하자. 장바구니에 물품을 담는다고 쳤을 때, 저장해야할 공간이 필요할 것이다. (현재 서버는 없다고 가정) 이때, 변수에 저장하는 것은 적합하지 않다. **변수는 브라우저 새로고침 시 초기화 되기 때문**이다. 그래서 생각한 방법이 **브라우저 안에 localStorage에 몰래 데이터를 저장하는 방법**이다.\n\n\u003cbr\u003e\n\n크롬의 개발자도구에서 Application에 가보면 Storage가 있다.\n\n- localStorage, sessionStorage\n\n- `key: value` 형태로 저장 가능\n\n- `localStorage` : 사이트 재접속해도 유지 (유저가 브라우저 청소하지 않는 이상)\n\n- `sessionStorage` : 사이트 나가면 자동 삭제\n\n- IndexedDB\n\n- 데이터가 크고 복잡할 때 구조화 시켜서 저장 시\n\n- Cookies\n\n- 유저의 인증 정보, 보통 로그인정보 저장\n\n- Cache Storage\n\n- 웹 사이트 접속했을 때 html css js 파일을 새로 다운받는 것이 아니라 하드에 몰래 저장하는 것\n\n\u003cbr\u003e\n\nlocalStorage, sessionStorage의 **용량은 약 5MB**, 그리고 array나 object 이런거는 저장 못하고 **문자/숫자만 저장 가능**하다. 문자만 5MB는 엄청난 양이다. 걱정 ㄴㄴ\n\n\u003cbr\u003e\n\n### localStorage 사용법\n\n- sessionStorage는 local만 session으로 바꿔주면 됨\n\n```javascript\n// 로컬스토리지에 데이터 저장\nlocalStorage.setItem('key', 'value');\n\n// 로컬스토리지 데이터 출력\nlocalStorage.getItem('key');\n\n// 로컬스토리지 데이터 삭제\nlocalStorage.removeItem('key');\n```\n\n\u003cbr\u003e\n\nlocalStorage에 array, object를 그냥 저장하면 깨져서 저장된다. 문자만 저장되니까.\n\n```javascript\nlocalStorage.setItem('num', [1, 2, 3]);\n// num 1, 2, 3\n// 대괄호가 사라지고 그냥 1, 2, 3만 저장된거\n```\n\n그래서 array, object 저장하고 싶으면 **JSON으로 변환해서 저장해야한다.** JSON은 문자 취급을 받기 때문이다.\n\n- `JSON.stringify()` : array/object -\u003e JSON\n\n- `JSON.parse()` : JSON -\u003e array/object\n\n```javascript\nlet arrTest = [1, 2, 3];\nlet newArrTest = JSON.stringify(arrTest);\n\nlocalStorage.setItem('num', newwArrTest);\nlet getArrTest = localStorage.getItem('num');\n\nconsole.log(JSON.parse(getArrTest));\n```\n\n\u003cbr\u003e\n\nlocalStorage에 저장된 데이터를 수정하는 함수는 없다. 따라서 아래의 과정을 수행한다.\n\n1. 자료를 꺼낸다\n\n2. 꺼낸 자료를 수정한다.\n\n3. 다시 localStorage에 수정한 자료를 넣는다.\n\n\u003cbr\u003e\n\n추가로, localStorage 내부에 값이 있나 없나 확인할 때 사용했는데 find와 findIndex 함수는 **배열**의 요소에 관한 함수이다.\n\n- `.find( (a) =\u003e {return } )`\n\n- `.findIndex( (a) =\u003e {return } )`\n\n둘다 콜백함수 써줘야하고, 나는 findIndex 함수 이용했음. findIndex 함수는 배열 내부 요소의 값에 없다면 -1을 return, 있다면 해당하는 인덱스 번호를 return\n\n```javascript\nlet outItem = JSON.parse(localStorage.getItem('cart'));\nlet outItemIndex = outItem.findIndex((a) =\u003e {\n\treturn a === storageItem;\n});\n\nif (outItemIndex === -1) {\n\toutItem.push(storageItem);\n\tlocalStorage.setItem('cart', JSON.stringify(outItem));\n\talert('장바구니에 등록되었습니다.');\n} else {\n\talert('장바구니에 이미 물품이 있습니다.');\n}\n```\n\n\u003chr\u003e\n\n## scroll 애니메이션 심화\n\nLEVEL2 scroll에서는 one-way 방식을 생각했다면, 이제는 간단한 1차함수를 도입한다.\n\n```javascript\nwindow.addEventListener('scroll', function () {\n\tlet 높이 = this.window.scrollY;\n\tlet y = (-1 / 500) * 높이 + 115 / 50;\n\tlet z = (-1 / 5000) * 높이 + 565 / 500;\n\n\tthis.document.querySelectorAll('.card-box')[0].style.opacity = y;\n\tthis.document.querySelectorAll('.card-box')[0].style.transform = `scale(${z})`;\n\tconsole.log(z);\n});\n```\n\n예를 들어, 스크롤 650px ~ 1150px 구간에 opacity를 1~0으로 조정하기를 원한다고 하면, 간단한 함수 개념을 도입한다.  \n\n```javascript\ny = 650 * a + b\ny = 1150 * a + b\n\n식 2개, 미지수 2개니까 값 구할 수 있음\n```\n\n\u003chr\u003e\n\n## 캐러셀 심화 (스와이프)  \n\n캐러셀을 드래그 했을 때 다음 사진으로 넘어가냐 마냐 하는 것은 마우스에 관련된 이벤트를 추가로 학습할 필요가 있다.\n\n- `mousedown` : 어떤 요소에 마우스버튼 눌렀을 때\n\n- `mouseup` : 어떤 요소에 마우스버튼 뗐을 때\n\n- `mousemove` : 어떤 요소 위에서 마우스 이동할 때\n\n\u003cbr\u003e\n\n추가적인 이벤트 관련 함수\n\n- `e.clientX` : 현재 마우스 X 좌표\n\n- `e.clientY` : 현재 마우스 Y 좌표\n\n\u003cbr\u003e\n\n모바일 관련  \n\n- `touchstart` : 터치 했을 때\n\n- `touchmove` : 터치하고 드래그 할 때\n\n- `touchend` : 터치 뗐을 때\n\n\u003cbr\u003e\n\n모바일 관련 이벤트 함수\n\n- `e.touches[0].clientX` : 손가락 여러 개 눌릴 수 있으니까 지정해줘야함\n\n- `e.changedTouches[0].clientX` : touchend에는 `touches[0]`이 아닌 `changedTouches[0]`을 해줘야 함\n\n실습 예제는 \u003ca href='/brain/Lecture/apple/apple-js/apple-js-02' target='_blank'\u003eJS 입문과 웹 개발 02\u003c/a\u003e를 참고하도록 하자.\n\n\u003cbr\u003e\n\n드래그가 제대로 안된다면? HTML 기본 옵션 수정\n\n- `contextmenu=\"return false\"` : 우클릭 방지\n\n- `ondragstart=\"return false\"` : 드래그 방지\n\n- `onselectstart=\"return false\"` : 선택 방지\n\n```html\n\u003cbody ondragstart=\"return false\"\u003e\u003c/body\u003e\n```\n\n\u003chr\u003e\n\n## switch 문법  \n\n- switch는 if문과 비슷한 역할을 한다.\n\n- 소괄호 안에 특정 값을 넣어서 **조건 분기**를 일으키는 것이다.\n\n- 용도가 끝나면 `break`로 switch문을 빠져나간다.\n\n- 즉, break가 없다면 밑에 코드도 다 실행할 것\n\n- if는 다양한 조건식 가능하지만, switch는 변수 1개만 테스트 가능\n\n- `default`로 어떤 case에도 해당 안될 때를 지정할 수 있음\n\n```javascript\nlet 변수 = 2 + 2;\n\nswitch (변수) {\n\tcase 3:\n\t\talert('변수가 3이네요');\n\t\tbreak;\n\n\tcase 4:\n\t\talert('변수가 4이네요');\n\t\tbreak;\n\n\tdefault:\n\t\talert('아무것도 해당안됨');\n}\n```","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/frontend/apple-js/js-library":{"title":"js-library","content":"\n\u003e 해당 게시글은 \u003ca href='https://codingapple.com/course/javascript-jquery-ui/' target='_blank'\u003eJavaScript 입문과 웹 UI 개발\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n\u003e[!note] 자바스크립트 라이브러리 \n\u003e 1. Swiper\n\u003e 2. Chart.js\n\u003e 3. Animate On Scroll\n\u003e 4. EmailJS\n\u003e 5. Lodash\n\u003e 6. React / Vue\n\u003e 7. Fullpage.js\n\n\u003cbr\u003e\n\n## Swiper\n\n\u003cbr\u003e\n\n![](brain/image/js-library-1.png)\n  \n부트스트랩의 캐러셀을 활용해도 괜찮지만, swiper를 이용하여 다양한 캐러셀 활용 가능. 이미지 lazy loading, 터치/드래그 가능 사실 쓸지는 의문\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Chart.js (추천)\n\n\u003cbr\u003e\n\n![](brain/image/js-library-2.png)\n\n웹페이지에 차트 도입할 때 싸용, 관리자 페이지, 어드민 페이지에서 통계 만들 때 유용할 듯. 이건 진짜 많이 사용할 예정\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Animate On Scroll (약간 추천)\n\n\u003cbr\u003e\n\n![](brain/image/js-library-3.png)\n\n스크롤 내리면 요소가 등장하는 애니메이션 사용할 때 좋음. \u003ca href='https://github.com/michalsnik/aos' target='_blank'\u003e깃허브 페이지\u003c/a\u003e에서 사용법 나와있음. 아래 코드 넣으면 설치 끝\n\n```html\n\u003chead\u003e\n\t\u003clink rel=\"stylesheet\" href=\"https://unpkg.com/aos@next/dist/aos.css\" /\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n\t\u003cscript src=\"https://unpkg.com/aos@next/dist/aos.js\"\u003e\u003c/script\u003e\n\t\u003cscript\u003eAOS.init();\u003c/script\u003e\n\u003c/body\u003e\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n## EmailJS\n  \n\u003cbr\u003e\n\n서버로 이메일 전송 하지만, 서버를 빌려서 자바스크립트만으로 이메일 전송 가능하게 해주는 라이브러리. \u003ca href='https://www.emailjs.com/docs/introduction/how-does-emailjs-work/' target='_blank'\u003e링크\u003c/a\u003e에서 시키는대로 하면 되지만, 나는 서버 만들거니까 별로 사용 안할듯\n\n\u003cbr\u003e\u003cbr\u003e  \n\n## Lodash\n\narray, object, 문자, 숫자 자료 등을 편하게 다루도록 기본 함수 제공해줌. 근데 안쓸듯\n\n\u003cbr\u003e\u003cbr\u003e\n\n## React, Vue (강력 추천, 따로 공부)\n\n컴포넌트 단위처럼 페이지가 많아서 라우팅 하고 이런거 UI 재활용 자주 해야하고 페이지 새로고침 없이 필요한 부분만 렌더링 하도록 동작하는 방식인 SPA(Single Page Application)을 만들 때 유용한 자바스크립트 라이브러리\u003cbr\u003e\n\n자바스크립트 기본부터 제대로 배우고 이용하는 것을 추천\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Fullpage.js\n\n웹페이지를 PPT처럼 만들어줌. 이것도 안쓸 예정","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/network/":{"title":"Network","content":"","lastmodified":"2024-12-05T16:13:38.258758363Z","tags":null},"/brain/Lecture/network/free-dev/":{"title":"널널한개발자","content":"","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/network/free-dev/network-basic/":{"title":"네트워크 핵심 - 기초","content":"","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/network/free-dev/network-basic/intro":{"title":"네트워크 기초","content":"\n인프런 널널한 개발자님의 \u003ca href='https://www.inflearn.com/course/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%95%B5%EC%8B%AC%EC%9D%B4%EB%A1%A0-%EA%B8%B0%EC%B4%88' target='_blank'\u003e네트워크 핵심이론 - 기초\u003c/a\u003e를 정리한 노트\n\n1. [section 0 - intro](brain/Lecture/network/free-dev/network-basic/section0.md)\n2. [section 1 - network](brain/Lecture/network/free-dev/network-basic/section1.md)\n3. [section 2 - L2](brain/Lecture/network/free-dev/network-basic/section2.md)\n4. [section 3 - L3](brain/Lecture/network/free-dev/network-basic/section3.md)\n","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/network/free-dev/network-basic/section0":{"title":"section 0 - intro","content":"\n인프런 널널한 개발자님의 \u003ca href='https://www.inflearn.com/course/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%95%B5%EC%8B%AC%EC%9D%B4%EB%A1%A0-%EA%B8%B0%EC%B4%88' target='_blank'\u003e네트워크 핵심이론 - 기초\u003c/a\u003e를 정리한 노트\n\n\u003chr\u003e\n\n### Layer와 Layered 구조\n\nIT 업계에서는 어떤 **구성요소**를 **도식화** 할 때 **계층적 구조**를 이루도록 설계하는 경우가 많다.\n\n- Layered 구조로 무언가를 나열하여 도식화하는 것은 **이해를 돕기 위한 행동**\n- 보통, ==**요소들 간의 관계를 표현하기 위해 도식화**==를 많이 한다.\n- 상위 계층은 하위 계층에 의존적이다. \n\t- 행위, 기능에 관하여 의존적\n\n\u003cbr\u003e\n\n좀 더 나아가서, 존립에 관하여 의존적일 수 있다. 즉, ==**상위 계층이 존재하려면 하위 계층이 반드시 전제되어야 하는 상황**==일 수도 있는 것이다.\n- 이 과정에서 계층이 직렬화되면, 이는 Layered 구조를 가지는 것이다.\n- OSI 7 Layer와 연관지어 생각해보면, 물리적인 상황인 1계층 없이 위의 계층이 존재할 수 있을까? 존재 못하겠지.\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### 네트워크와 네트워킹\n\n네트워크, 네트워킹을 번역하기 굉장히 애매하지만, 네트워크는 ==**관계**==, 네트워킹은 ==**상호작용**==으로 이해해보면 어떨까?\n\n내가 홍길동과 대화를 하려는 상황이라고 생각해보자.\n1. 소리는 공기 중을 타고 전달되어야겠네. 2m 이내처럼 짧은 거리면 좋겠네\n2. 말을 통해 전달해보자\n3. 언어는? 한국어로 말해보자.\n\n이 모든 과정이 협의가 되면 그제서야 ==**상호작용**==이 가능하게 되는 것이다. Layer를 이루게 되면서 하위 계층이 존재한다는 전제하에 상위 계층이 존재할 것이고. 상위 → 하위로 의존관계 또한 형성되겠군. 바로 ==**Layered 구조**==이겠군.\n\n이렇게 협의하는 과정을 규칙을 정한다고 하여 ==**Protocol**== 이라고 한다.\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### User mode와 Kernel mode\n\n\u003cbr\u003e\n\n![](brain/image/section0-1.png)\n\n- NIC (Network Interface Card, LAN Card) 와 같은 하드웨어를 제어하기 위한 소프트웨어가 존재하는데, 그것을 Driver 라고 부른다.\n- 운영체제의 커널 수준에 프로토콜로 구현된 형태가 TCP/IP\n- User 수준에서 Kernel 수준으로 말을 전달하려면, ==**어떤 인터페이스를 통하여야 한다.**==\n\t- 인터페이스의 형태는 File 형태로 되어있음\n\t- 그러나, 특별하게 ==**TCP/IP를 추상화시킨 인터페이스**== 파일은, 파일이라 하지않고 ==**소켓(socket)이라고 부른다.**== 이 말은, 소켓도 그냥 파일이라는 말도 되긴 하겠네 !\n","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/network/free-dev/network-basic/section1":{"title":"section 1 - network","content":"\n인프런 널널한 개발자님의 \u003ca href='https://www.inflearn.com/course/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%95%B5%EC%8B%AC%EC%9D%B4%EB%A1%A0-%EA%B8%B0%EC%B4%88' target='_blank'\u003e네트워크 핵심이론 - 기초\u003c/a\u003e를 정리한 노트\n\n\u003chr\u003e\n\n### OSI 7 Layer, 식별자\n\n![](brain/image/section0-1.png)\n\n![](brain/image/section1-6.png)\n\n- 보통 논리적인 것을 IT 에서는 ==**가상(Virtual)**==로 많이 표현함\n\t- 가상에 관련된 기술은 꼭 구름모양으로 해놓더라 ㅋㅋ 팁\n- 하드웨어를 소프트웨어 형태로 구현이 가능한가? → 가능하다.\n\t- ex) CPU를 Machine이라고 하는데, 하드웨어인 CPU를 소프트웨어 형태로 구현했으니까 Virtual이네? 따라서 ==**Virtual Machine이 되는 것**==\n\t- 하드웨어를 소프트웨어로 구현하는 기술을 ==**가상화 기술**==이라고 함\n\n\u003cbr\u003e\n\n**OSI 7계층에서의 식별자**\n- 식별자란, 어떤 것을 식별하기 위한 것. 사람을 예시로 들면 주민등록번호\n\n\u003cbr\u003e\n\n**대표적인 식별자 3가지를 알아보자**\n- MAC 주소\n\t- L2에서 NIC (랜카드)를 식별하기 위한 식별자\n\t- NIC는 전기 신호가 들어오면 L2에서 데이터 형태(패킷)로 변환하여 내용을 구분하고 물리적인 도착지 MAC 주소를 확인함\n- IP 주소\n\t- L3에서 host를 식별하기 위한 식별자\n- Port 번호\n\t- 포트 번호는 어디서 보느냐에 따라 다양한 의미를 가짐\n\t- L2의 하드웨어 관점에서 보면 인터페이스(유선 케이블 꽂는 단자)를 식별하기 위한 식별자\n\t- L3, L4의 네트워크 관점에서 보면 (Web)Service를 식별하기 위한 식별자\n\t- 엔드포인트 관점에서 보면 Process를 식별하기 위한 식별자\n\n\u003cbr\u003e  \n\n정리하자면, OSI 7계층에서의 식별자는 아래와 같이 이해하자\n- ==**L2 Frame**==에서는 ==**MAC 주소**==\n\t- 48bit, 보통 16진수로 표기\n- ==**L3 Packet**==에서는 ==**IP 주소**==\n\t- IPv4 기준 32bit, 10진수(8bit)씩 끊어서 점으로 구분하여 표기\n- ==**L4 Segment**==에서는 ==**Port 번호**==\n\t- 16bit 양의 정수\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### Host\n\n\u003cbr\u003e\n\n**Host : Computer + Network**\n- **호스트**는 인터넷에 연결된 컴퓨터이구나 ~\n\n\u003cbr\u003e\n\n![](brain/image/section1-3.png)\n\n**Host는 크게 Switch / End-point로 나뉜다.**\n- Switch : ==**Network 그 자체를 이루는 host. Infrastructure**==\n\t- 다 그렇지는 않다. L2 switch는 호스트라고 하지는 않음\n\t- Router, IPS (Security Switch), Tab Switch, Aggregation Switch \n- End-point : ==**Network 인프라를 이용하는 주체**==\n\t- 단말\n\t- Client, Server, Peer (P2P 통신) 등등\n\n\u003cbr\u003e \n\n\u003chr\u003e\n\n### Switch\n\n\u003cbr\u003e\n\n![](brain/image/section1-4.png)\n\n1. ==**도로 망**==이 존재하고, ==**사람**==이 출발지에서 목적지까지 가는 상황\n2. ==**교차로**==에서 ==**경로를 선택**==하여 정해서 가야함\n3. 경로를 선택할 때 그에 대한 근거는 ==**이정표**==를 보고 선택\n4. 최종적으로 목적지까지 도착\n\n\u003cbr\u003e\n\nL3 네트워크 계층이라고 생각해보자.\n\n1. ==**Network 망**==을 통해 ==**Packet**==이 출발지에서 목적지까지 가는 상황\n2. ==**Switch**==에서 ==**Interface를 선택**==하여 정해서 가야함\n\t- 경로를 선택했다 = switching 했다\n3. 경로를 선택할 때 그에 대한 근거는 ==**IP주소**==를 보고 선택\n4. 최종적으로 목적지까지 도착\n\n\u003cbr\u003e\n\n- MAC 주소를 보고 스위칭 한다면? **L2 Switch**\n- IP 주소를 보고 스위칭 한다면? **L3 Switch**\n- Port 번호를 보고 스위칭 한다면? **L4 Switch**\n- HTTP의 정보를 보고 스위칭 한다면? **L7 Switch**\n\n\u003cbr\u003e\n\n**L3 Switch와 Router는 거의 동일한 기능을 수행함**\n- Rotuer는 Routing table에 근거하여 경로를 선택함\n\n\u003cbr\u003e\n\n**경로를 찾을 때 항상 \"비용\"을 고민해야 함**\n- 어떤 경로로 갈 때에 대한 비용을 ==**Metric 값**==이라고 함\n- 출발지에서 목적지까지 가는 임의의 단위로, 값의 단위는 프로토콜에 따라 다름\n- 라우팅 경로 순서는 Metric 값에 의해 결정\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n### L3 switch / Router\n\n원래, 보통 알고 있는 스위치는 L2 switch로 MAC address를 기준으로 가는 것으로 많이 이해한다. L2의 스위치 기능과 L3의 라우터 기능을 모두 갖춘 장비가 바로 L3 switch 이다.\n\n- **L3 switching = L2 \u003ca href='http://www.ktword.co.kr/test/view/view.php?m_temp1=640\u0026id=459' target='_blank'\u003eswitching\u003c/a\u003e + L3 \u003ca href='http://www.ktword.co.kr/test/view/view.php?m_temp1=539\u0026id=345' target='_blank'\u003erouting\u003c/a\u003e**\n- **L3 switch = L2 switch + 라우터 기능**\n\n\u003cbr\u003e\n\n==**L2 Switching vs L3 Switching**==\n\n![](brain/image/section1-5.png)\n\n\u003cbr\u003e\n\n==**L3 switch 기본 동작방식**==\n- 기본적으로 서로 다른 \u003ca href='http://www.ktword.co.kr/test/view/view.php?m_temp1=3477\u0026id=844' target='_blank'\u003eVLAN ID\u003c/a\u003e 간에는 \u003ca href='http://www.ktword.co.kr/test/view/view.php?m_temp1=448\u0026id=859' target='_blank'\u003e라우터\u003c/a\u003e를 통하여 \u003ca href='http://www.ktword.co.kr/test/view/view.php?m_temp1=421\u0026id=484' target='_blank'\u003e패킷\u003c/a\u003e을 전송\n- L3 switch는 수신된 **패킷**에서 L3에 해당하는 **IP 정보 부분**을 살펴보고 있다가, 자신이 이미 알고 있는 (캐시되어있는) 주소이면 굳이 라우터를 통하지 않고, 자신이 직접 **하드웨어적으로 곧바로 전송**함\n- 패킷 플로우에서 첫번째 패킷에 대한 목적지 경로는 라우터로부터 파악하고, 이후 수신되는 패킷들은 자신의 스위칭 기능에 의해 **고속 포워딩** 수행\n\n\u003cbr\u003e\n\n==**그렇다면 L3 switch와 Router의 차이는?**==\n\n- 사실상, 큰 차이가 없어서 둘을 동일시해서 부르기도 함\n- L3 switch : 하드웨어 기반의 라우팅\n\t- CPU에 의한 소프트웨어적인 라우팅이 아닌, \u003ca href='http://www.ktword.co.kr/test/view/view.php?m_temp1=612\u0026id=204' target='_blank'\u003eASIC\u003c/a\u003e 기반의 고속 라우팅\n- Router : 소프트웨어 기반의 라우팅\n- 그나마 차이를 꼽자면, ==**L3 switch는 ASIC chip 하드웨어 기반의 고속 라우팅으로 Router와 비교하여 성능적인 측면에서 차이가 난다.**==\n\n|                      | Router                 | L3 Switch            |\n| -------------------- | ---------------------- | -------------------- |\n| Routing 수행방법            | **소프트웨어 처리가 메인** | **하드웨어 처리가 메인** |\n| 포트 수              | 적음                   | 많음                 |\n| 처리 속도            | 느림                   | 빠름                 |\n| 지원 기능 수         | 많음                   | 적음                 |\n| 지원 인터페이스 종류 | 많음                   | 적음                 |\n| 확장성               | 많음                   | 적음                     |\n\n\u003cbr\u003e","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/network/free-dev/network-basic/section2":{"title":"section 2 - L2","content":"\n인프런 널널한 개발자님의 \u003ca href='https://www.inflearn.com/course/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%95%B5%EC%8B%AC%EC%9D%B4%EB%A1%A0-%EA%B8%B0%EC%B4%88' target='_blank'\u003e네트워크 핵심이론 - 기초\u003c/a\u003e를 정리한 노트\n\n\u003chr\u003e\n\n### NIC, Frame, MAC 주소\n\n![](brain/image/section2-1.png)\n\n\u003cbr\u003e\n\n**NIC**\n- **NIC**(Network Interface Card)는 **LAN**(Local Area Ntwork) 카드\n- NIC도 유선, 무선이 있지만 굳이 구별하지 않고 NIC라고 많이 함\n- ==**NIC는 하드웨어이며, MAC 주소를 가짐**==\n- 여러 Host (Computer + Network) 들이 모여서 근거리 통신망 LAN을 이룸\n\n\u003cbr\u003e\n\n**LAN Card**\n- 속도가 1Gbps는 초당 1기가 **비트**\n- 속도가 1GBps는 초당 1기가 **바이트** (이건 말도 안됨. 잘못 쓴거임!)\n\n\u003cbr\u003e\n\n**Frame**\n- L3에서의 데이터 유통단위는 Packet 이었다.\n- L2에서의 데이터 유통단위는 Frame !!\n- 크기가 보통 1514 bytes 정도밖에 안됨\n\t- Jumbo Frame (점보 프레임)으로 가면 10KB 정도\n\n\u003cbr\u003e\u003chr\u003e\n\n### L2 Switch\n\n\u003cbr\u003e\n\n![](brain/image/section2-2.png)\n\n\u003cbr\u003e\n\n**L2 Access switch**\n- PC 혹은 랜 케이블과 같은 **End-point와 직접 연결되는 스위치**\n- L2 스위치니까 ==**MAC 주소를 근거로 스위칭**==\n\n![](brain/image/section2-3.png)\n\n- 구멍 하나가 인터페이스 1개 → 이걸 Port 라고도 함\n- 연결 가능한 것이 24개다? → 24 Port Hub\n- 물리적으로 케이블이 연결되었다면 → **Link-up**\n- 물리적으로 케이블이 끊어졌다면 → **Link-down**\n- L2 스위치에서 L3 계층의 라우터로 간다면 → **uplink**\n\n\u003cbr\u003e\n\n**L2 Distribution switch**\n- L2 Access switch를 위한 스위치\n- ==**VLAN (Virtual LAN) 기능을 제공하는 것이 일반적**==\n- 평균적으로 Access switch보다 Distribution switch가 더 비쌈\n- 대~략) L2 Access switch 10만원, L2 Distribution switch 수십~수백만원, L3 switch(Router) 100만원 이상, L4 switch 1000만원 이상, L7 switch 1억 이상\n\n![](brain/image/section2-6.png)\n\n![](brain/image/section2-5.png)\n\n\u003cbr\u003e\u003chr\u003e\n\n### LAN, WAN, Broadcast\n\n\u003cbr\u003e\n\n**Broadcast**\n- 방송 주소, 네트워크 효율이 떨어짐\n- 이와 정반대의 개념이 **unicast**\n\t- 유니캐스트는 단 둘이 대화하는 것\n- 브로드캐스트는 시끄러운 것, 유니캐스트는 조용한 것\n\n\u003cbr\u003e\n\n**Broadcasting**\n- 송신 호스트가 전송한 데이터가 ==**네트워크에 연결된 모든 호스트에 전송되는 방식**==\n- 하나의 호스트가 브로드캐스팅 하는 순간 끝날때까지 나머지 호스트는 통신하지 못함\n- 따라서, **브로드캐스팅은 무조건 최소화 되는 것이 좋음**\n\n\u003cbr\u003e\n\n**Broadcast 주소**\n- Broadcast라는 매우 특별한 주소가 존재\n- MAC Address, IP Address 모두 존재\n- 특정 네트워크의 ==**맨 마지막 주소를 브로드캐스트 주소로 사용**==\n\t- MAC Address \n\t\t- 48자리 비트가 모두 1로 되어있는 MAC 주소를 브로드캐스트 MAC 주소라 함\n\t\t- `FF-FF-FF-FF-FF-FF`\n\t- IP Address\n\t\t- 예를 들어, C클래스 하나로 특정 IP를 할당했고 ip의 네트워크 주소가 `192.168.2.0`이라고 하자.\n\t\t- 서브넷 마스크의 `0` 부분을 모두 1로 바꾸면 된다.\n\t\t- IP 주소는 32비트 = 8비트 x 4이니까 `0`에 해당하는 부분이 8비트이다. 2 \u003csup\u003e8\u003c/sup\u003e은 256이니까, 0~255겠네\n\t\t- 따라서, 바꾸면 255니까 `192.168.2.255`\n\n\u003cbr\u003e\n\n**LAN, WAN**\n\n이전의 그림을 다시 봐보자.\n\n![](brain/image/section1-6.png)\n\n- 완벽한 정답은 아니고, 이해하기 편한 팁 정도로 이해하자.\n- physical network에 해당하는 부분이 **LAN**\n- logical network에 해당하는 부분이 **WAN**\n- 인터넷을 설명할 때, L3 부터는 소프트웨어적으로 존재하는 **논리적인 네트워크**\n- 물리적으로 네트워크가 존재한다는 것은 랜 케이블이 꽂혔냐? 무선 신호가 실제로 도달하냐?\n- 이 ==**물리적인 네트워크를 기반으로 논리적인 네트워크가 존재하는 것**==","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/network/free-dev/network-basic/section3":{"title":"section 3 - L3","content":"\n인프런 널널한 개발자님의 \u003ca href='https://www.inflearn.com/course/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%95%B5%EC%8B%AC%EC%9D%B4%EB%A1%A0-%EA%B8%B0%EC%B4%88' target='_blank'\u003e네트워크 핵심이론 - 기초\u003c/a\u003e를 정리한 노트\n\n\u003chr\u003e\n\n### IPv4 주소의 기본구조\n\n\u003cbr\u003e\n\n![](brain/image/section3-1.png)\n\n**L3 IP 주소는 8비트가 4개인 32 bit로 이루어져 있음**\n- 예를 들어, **`192.168.0.10`**이라고 하자. 8비트씩 4개로 쪼개보자.\n\t- `1111 0000` / `1010 1000` / `0000 0000` / `0000 1010`\n- IP 주소는 Host를 식별하기 위한 식별자라고 했었다 !\n- IP 주소는 ==**Network ID + Host ID**== 두 부분으로 나눈다\n\n쉽게 예를 들어서, 택배를 생각해보자. 가까운 택배 물류센터까지 일단 와야하는데, 그것을 **Network ID**라고 생각하고, 그 물류센터에서부터 구체적으로 우리집 주소까지 오는 것을 **Host ID**라고 생각하면 된다.\n\n==**네트워크에 일단 진입하고 난 이후, 구체적인 호스트를 찾는다고 생각!**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### L3 Packet\n\n![](brain/image/section3-2.png)\n\n- L3의 데이터 유통단위인 Packet은 ==**L3 IP Packet**==으로 외우자.\n- Packet = Header + Payload (상대적인 분류)\n\t- ==**Header에 가장 중요한 출발지(Source) 목적지(Destination) 정보 있음**==\n- 최대 크기는 ==**MTU (Maximum Transmission Unit, 최대 전송 단위)**==\n\t- 특별한 이유가 없다면, 보통 **1500 bytes ( = 1.4kB)** 으로, 굉장히 작다.\n\t- **패킷이나 프레임의 최대 크기** 로 데이터의 크기가 크다면 단편화해야 한다.\n\n\u003cbr\u003e\u003chr\u003e\n\n### Encapsulation\n\n![](brain/image/section3-3.png)\n\n**Encapsulation (캡슐화)**\n- 택배 박스 포장하는 것으로 생각\n- ==**포장하는 과정에서 단위화**== 해서 집어넣는다.\n\t- 포장한 박스는 까기 전까지 내용물을 모르겠지 ?\n- L2 Frame의 Payload가 L3 IP Packet 전체가 되는 것\n\n\u003cbr\u003e\u003chr\u003e\n\n### 패킷의 생성, 전달, 소멸\n\n\u003cbr\u003e\n\n**철수가 영희에게 책을 택배로 보내는 과정이라고 하자.**\n1. 철수가 책을 택배박스에 포장한다.\n2. 현관을 통해 택배박스가 나간다.\n3. 택배기사님에게 전달한다.\n4. 택배 물류 체계에 의해서 택배를 모으고 분류하는 과정을 한다.\n5. 택배가 목적지까지 간다.\n6. 누구의 택배인지 선택해서 택배박스를 준다. 받는 사람 이름이 영희라고 표시되어있을 것\n\n\u003cbr\u003e\n\n**A 프로세스가 B 프로세스에게 인터넷을 통해 Data를 보내는 과정이라고 하자.**\n1. A 프로세스에서 보내는 Data를 Packet으로 만든다.\n2. Interface를 통해 Packet이 나간다.\n3. Gateway에게 전달한다.\n4. Gateway가 packet을 Routing 한다.\n5. IPv4의 Destination까지 간다.\n6. B 프로세스의 어떤 포트인지 선택해서 packet을 준다. Port 번호가 적혀있을 것\n\n\u003cbr\u003e\n\n![](brain/image/section3-4.png)\n\n\u003e [!note] 💡 복습 \u003cbr\u003e\n\u003e Socket 은 TCP/IP 를 추상화한 인터페이스 \u003cbr\u003e\n\u003e User mode Process가 접근할 수 있도록 추상화 시켜준 인터페이스 \u003cbr\u003e\n\u003e \u003cbr\u003e\n\u003e 일종의 File 이라고 했지? File에 write 쓰는 행위 \u003cbr\u003e\n\u003e 그러나, tcp니까 send라고 이해하자\n\n\u003cbr\u003e\u003chr\u003e\n\n### 계층별 데이터 단위\n\n![](brain/image/section3-7.png)\n\n- Socket Stream은 열리고 닫히기 전까지니까 데이터 크기가 클 것\n\t- 따라서, Stream을 데이터의 단위라고 하기에는 애매하다 ~\n- 예를 들어서, 4MB라고 해보자. Segment 최대 단위인 MSS (Maximum Segment Size) 보다 크니까, ==**Stream이 Segment화 되는 과정에서 데이터를 잘라낸다.**==\n- 이 과정을 ==**Segmentation (세그멘테이션), 즉, 분할**==이라고 한다.\n- TCP 말고 **UDP 에서는 Datagram이라는 데이터 단위를 사용**한다.\n\n\u003cbr\u003e\u003chr\u003e\n\n### TCP/IP 송수신 구조\n\n","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/os/":{"title":"Operating System","content":"","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/os/easy-os/":{"title":"쉬운코드 OS","content":"","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/os/easy-os/lecture00":{"title":"강의소개","content":"\n유튜버 쉬운코드님의 강의 플레이리스트 중  \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e운영체제\u003c/a\u003e를 정리한 노트\n\n1. [01. 프로세스, 스레드](brain/Lecture/os/easy-os/lecture01.md)\n2. [02. 컨택스트 스위칭](brain/Lecture/os/easy-os/lecture02.md)\n3. [03. CPU/IO bound](brain/Lecture/os/easy-os/lecture03.md)\n","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/os/easy-os/lecture01":{"title":"01. 프로세스/스레드","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e운영체제\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## \u0008프로세스/스레드\n\n### 기초용어\n\n\u003cbr\u003e\n\n==**프로그램 (program)**==\n- 컴퓨터가 실행할 수 있는 명령어들의 집합\n\n\u003cbr\u003e\n\n==**프로세스 (process)**==\n- 컴퓨터에서 ==실행 중인 프로그램==\n- 각각의 프로세스는 ==독립된 메모리 공간==을 할당 받음\n- 명령어들과 데이터를 가짐\n\n\u003cbr\u003e\n\n==**CPU (Central Processing Unit)**==\n- 명령어를 실행하는 연산 장치\n- 프로세스의 명령어를 해석하고 실행하는 장치\n\n\u003cbr\u003e\n\n==**메인 메모리 (Main Memory)**==\n- 프로세스가 CPU에서 실행되기 위해 대기하는 곳\n\n\u003cbr\u003e\n\n==**IO (Input / Output)**==\n- 파일을 읽고 쓰거나 네트워크의 어딘가와 데이터를 주고 받는 것\n- 입출력 장치와 데이터를 주거나 받는 것\n\n\u003cbr\u003e\u003chr\u003e\n\n### 단일 프로세스\n\n\u003cbr\u003e\n\n**단일 프로세스 시스템**\n- 한 번에 하나의 프로그램만 실행되는 시스템\n\t- 다른 프로그램을 실행하려면 먼저 실행 중인 프로그램을 종료시키고 그 다음 프로그램을 실행해야함\n\t- 아주 초창기의 시스템 모델\n\n![](brain/image/lecture01-7.png)\n\n- 단점 : CPU 사용률이 좋지 ❌\n\t- 어떤 프로그램 P1은 CPU을 사용하기도 하고 IO 작업을 하기도 함\n\t- P1이 IO 작업을 하는 동안 CPU는 그냥 놀고있음\n- 이게 단일 프로세스 시스템의 단점\n\t- **실행 중에 있는 프로세스가 IO 작업을 하는 동안 CPU가 아무것도 안하고 노는 것**\n\n![](brain/image/lecture01-8.png)\n- **해결책 : 여러 개의 프로그램을 메모리에 올려놓고 동시에 실행시키자!**\n\t- IO 작업이 발생하면 다른 프로세스가 CPU에서 실행됨\n\n\u003cbr\u003e\n\n**멀티 프로그래밍 (Multi Programming)**\n- 여러 개의 프로그램이 동시에 실행되는 것\n\t- ==**CPU 사용률을 극대화 시키는데 목적**==\n- 단점 : CPU 사용 시간이 길어지면 다른 프로세스는 계속 대기\n\n![](brain/image/lecture01-9.png)\n\n- **해결책 : 프로세스는 한 번 CPU를 사용할 때 아주 짧은 시간(=quantum)만 CPU에서 실행되도록 하자 !!**\n\n\u003cbr\u003e\u003chr\u003e\n\n### 멀티태스킹\n\n**멀티태스킹 (multitasking)**\n\n![](brain/image/lecture01-10.png)\n\n![](brain/image/lecture01-11.png)\n\n- 멀티 프로그래밍과 유사하지만, **CPU 타임을 아주 짧게 쪼개서, 그 CPU 타임 안에서 프로세스들이 번갈아 CPU를 사용할 수 있게 만들었다는 점에서 차이가 있음**\n\t- 아주 짧은 시간(=quantum)은 ms 단위까지 time slot이 아주아주 짧게 구분됨\n\t- time slot 시간 안에서만 각 프로세스들이 CPU를 최대한 사용할 수 있게 됨\n- 멀티태스킹은 ==**프로세스의 응답 시간을 최소화 시키는데 목적**==\n\t- 일반 사용자가 느끼기에는 마치 여러 프로그램이 **동시에 실행되는 것처럼 느끼게 함**\n\n\u003cbr\u003e\n\n**멀티태스킹의 아쉬움**\n- ==하나의 프로세스가 동시에 여러 작업을 수행하지는 ❌==\n\t- 여러 프로세스를 만들어서 실행시킬 수 있겠지만, 프로세스를 여러 개 만들어서 실행시키기에는 [컨택스트 스위칭](brain/Lecture/os/easy-os/lecture02.md) 같은 단점이 있음\n- ==프로세스의 컨택스트 스위칭은 무거운 작업==\n\t- \u0008컨택스트 스위칭은 CPU에서 실행되기 위해서 어느 한 프로세스에서 다른 프로세스로 교체되는 것을 의미\n- ==프로세스끼리 데이터 공유가 까다로움==\n\t- 프로세스는 독립적인 메모리 공간을 가지기 때문\n\t- ![](brain/image/lecture01-13.png)\n- ==듀얼 코어가 등장했는데, 잘 쓰기 어려움==\n\n→ 이런 멀티태스킹 아쉬움 문제의 해결책이 바로 ==**스레드(Thread)**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 스레드\n\n==**스레드(Thread)**==\n- 프로세스는 한 개 이상의 스레드를 가질 수 있음\n- 스레드는 **CPU에서 실행되는 단위**이다. (unit of execution)\n- 같은 프로세스의 스레드들끼리 컨택스트 스위칭은 가볍다.\n- 스레드들은 자신들이 속한 프로세스의 메모리 영역을 공유함\n\n\u003e 지금 이야기 하는 것은 OS Level에서의 스레드 \u003cbr\u003e\n\u003e User Level에서의 스레드도 있음\n\n\u003cbr\u003e\n\n\u003e 오늘날의 프로세스는 기본적으로 최소 1개의 스레드를 가짐 \u003cbr\u003e\n\u003e 스레드가 CPU/코어에서의 실행되는 **기본 단위**이기 때문 \u003cbr\u003e\n\n\u003cbr\u003e\n\n==**메모리 구조 비교 (싱글 스레드 vs 멀티 스레드)**==\n\n![](brain/image/lecture01-14.png)\n- 지금 보이는 메모리 구조가 1개의 프로세스가 할당받은 메모리 영역\n- 같은 프로세스에 속한 스레드들은 그 프로세스의 메모리 영역을 공유\n\t- Heap 영역은 공유 🟢\n\t- 자신만의 고유한 영역인 Stack은 공유 ❌\n\t- 각각의 스택을 가리키는 stack pointer, PC는 공유 ❌\n\t- PC (Program Counter)는 다음번에 실행되어야 할 명령어가 있는 메모리 주소를 가리킴\n\n\u003cbr\u003e\n\n**ex) CPU 코어 1개의 경우**\n\n![](brain/image/lecture01-15.png)\n- 기존의 멀티태스킹 시스템처럼 쪼갠 시간만큼 조금씩 실행\n\n\u003cbr\u003e\n\n**ex) CPU 멀티 코어의 경우**\n\n![](brain/image/lecture01-16.png)\n- 병렬적으로 스레드가 실행되는 진정한 의미의 **동시성**\n\n\n\u003cbr\u003e\u003chr\u003e\n\n### 멀티스레딩\n\n==**멀티스레딩 (Multi Threading)**==\n- 하나의 프로세스가 동시에 여러 작업을 실행하는데 목적\n\t- 여러 작업은 스레드들을 통해서 동작되는 것을 의미\n- 확장된 멀티태스킹의 개념\n\t- 여러 프로세스와 여러 스레드가 아주 짧게 쪼개진 cpu time을 나눠갖는 것\n\n\u003cbr\u003e\n\n==**멀티프로세싱 (Multi Processing)**==\n- 두 개 이상의 프로세스나 코어를 활용하는 시스템\n\n\u003cbr\u003e\u003chr\u003e\n\n### 종합 예제\n\n\u003cbr\u003e\n\n**ex) 싱글코어 CPU에 싱글-스레드 프로세스가 2개**\n\n![](brain/image/lecture01-17.png)\n\n\u003cbr\u003e\n\n**ex) 싱글코어 CPU에 듀얼-스레드 프로세스 1개**\n\n![](brain/image/lecture01-18.png)\n\n- CPU 코어 1개를 가지고 경합하기 때문에 멀티태스킹 🟢\n- 듀얼-스레드니까 멀티스레딩 🟢 \n- CPU 1개니까 멀티프로세싱 ❌\n\n\u003cbr\u003e\n\n**ex) 듀얼코어 CPU에 싱글-스레드 프로세스 2개**\n\n![](brain/image/lecture01-19.png)\n\n- 코어 2개라서 헷갈리면 안됨. CPU 코어 1개를 가지고 경합하는 것이 없기 때문에 멀티태스킹 ❌\n- 싱글-스레드니까 멀티스레딩 ❌\n- 코어가 2개니까 멀티프로세싱 🟢\n\n\u003cbr\u003e\n\n**ex) 듀얼코어 CPU에 듀얼-스레드 프로세스 1개**\n\n![](brain/image/lecture01-20.png)\n\n- 각 코어별로 경합하는 것이 아니니까 역시 멀티태스킹 ❌\n- 하나의 프로세스에 스레드가 2개니까 멀티스레딩 🟢\n- 코어가 2개니까 멀티프로세싱 🟢\n\n\u003cbr\u003e\n\n**ex) 듀얼코어 CPU에 듀얼-스레드 프로세스 2개**\n\n![](brain/image/lecture01-21.png)\n\n- 각 코어마다 경합하는 것이 있으니까 멀티태스킹 🟢\n- 듀얼-스레드니까 멀티스레딩 🟢\n- 코어가 2개 + 프로세스 2개니까 멀티프로세싱 🟢\n\n![](brain/image/lecture01-22.png)\n\n- 각 코어마다 경합하는 것이 있으니까 멀티태스킹 🟢\n- 듀얼-스레드니까 멀티스레딩 🟢\n- 코어가 2개 + 프로세스 2개니까 멀티프로세싱 🟢\n","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/os/easy-os/lecture02":{"title":"02. 컨택스트 스위칭","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e운영체제\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## 컨택스트 스위칭\n\n==**컨택스트 스위칭 (Context Switching)**==\n- CPU/코어에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것\n\n\u003e 프로세스 → 프로세스로 교체된다는 것은 엄밀히 말하면, **어떤 프로세스 안에서 실행되던 스레드가 다른 프로세스 안에 실행되는 스레드로 바뀐다는 의미**이다. 서로 다른 프로세스에 속한 스레드가 바뀌는 것이기에 이때는 **프로세스가 교체된다**고 한다.\n\n\u003cbr\u003e\n\n==**컨택스트 (Context)**==\n- CPU에서 혹은 메모리에서 프로세스/스레드의 상태\n\n\u003cbr\u003e\n\n==**컨택스트 스위칭은 왜 필요할까?**==\n- 여러 프로세스/스레드를 **동시에** 실행시키기 위해서 필요\n\n\u003cbr\u003e\n\n==**컨택스트 스위칭은 언제 발생하는가?**==\n- 주어진 time slice(quantum)를 다 사용했을 때\n- IO 작업을 해야할 때\n- 다른 리소스를 기다려야할 때\n- 기타 등등\n\n\u003cbr\u003e\n\n**ex) 멀티태스킹 시스템에서 컨택스트 스위칭**\n\n![](brain/image/lecture02-25.png)\n\n\u003cbr\u003e\n\n==**컨택스트 스위칭은 누구에 의해 실행되는가?**==\n- **OS 커널(kernel)**\n\t- 각종 리소스를 관리/감독하는 역할\n\t- 커널이 통제권을 가지고 실행한다고 이해\n- **컨택스트 스위칭의 총괄하는 주체**에 관한 것인지, 이 컨택스트 스위칭을 누가 발생하는가, 누가 트리거하는가와는 다른 것이다.\n\n\u003cbr\u003e\n\n==**컨택스트 스위칭은 구체적으로 어떤 과정으로 일어나는가?**==\n- 다른 프로세스끼리 스위칭인지\n\t- ==**Process Context Switching**==\n- 같은 프로세스의 스레들끼리 스위칭인지에 따라 다름\n\t- ==**Thread Context Switching**==\n\n\u003cbr\u003e\u003chr\u003e\n\n### 컨택스트 스위칭 공통점\n\n**Process Context Switching과 Thread Context Switching 공통점**\n1. 커널 모드에서 실행\n2. CPU의 레지스터 상태를 교체\n\n\u003cbr\u003e\n\n**커널 모드에서 실행**\n\n![](brain/image/lecture02-26.png)\n\n- 프로세스 P1이 실행되다가, 하드웨어와 밀접한 일들, 혹은 컴퓨터에 있는 여러 리소스들을 다뤄야하는 상황이 왔을 때\n- **프로세스가 직접 컴퓨터의 리소스에 접근하는 것이 아니라 운영체제의 커널을 통해 접근하게 됨**\n- **커널 모드 : 프로세스에서 커널로 통제권이 넘어가서 커널에 의해서 실행되는 것**\n\t- 프로세스 컨택스트 스위칭이건, 스레드 컨택스트 스위칭이건, 컨택스트 스위칭은 통제권이 커널로 넘어가서 커널 모드에서 실행하게 됨\n\n\u003cbr\u003e\n\n**CPU의 레지스터 상태를 교체**\n\n![](brain/image/lecture02-27.png)\n\n- CPU 안에 여러 **레지스터**가 존재\n\t- 레지스터는 각종 명령어들을 수행하기 위해 필요한 여러 데이터를 저장하는 곳\n- 프로세스(P1)가 실행되는 동안 CPU의 레지스터는 여러 값들이 계속 바뀌면서 실행되고 있었을 것\n- 다른 프로세스(P2)가 실행되게 되면 기존에 실행 중이던 프로세스(P1)의 레지스터 상태들을 어딘가에 저장하고 실행하는 것\n\t- 나중에 다시 P1을 실행하게 됐을 때 **어디까지 실행했는지에 대한 레지스터의 상태 정보를 알고 있어야 이어서 실행할 수 있으니까**\n \n\u003cbr\u003e\u003chr\u003e\n\n### 컨택스트 스위칭 차이점\n\n**Process Context Switching과 Thread Context Switching 차이점**\n- **프로세스 컨택스트 스위칭**은 ==**가상(virtual) 메모리 주소 관련 처리를 추가로 수행**==\n\t- 서로 다른 프로세스는 메모리 주소 체계가 다르기 때문임\n\t- **MMU (Memory Manage Unit, 메모리 관리 장치)** 도 새로운 프로세스의 주소 체계를 바라볼 수 있도록 수정해야 함\n\t- **TLB (Translation Lookaside Buffer, 변환 색인 버퍼)** 도 비워야 함\n- **스레드 컨택스트 스위칭**은 가상 메모리 주소 관련 처리 추가작업 필요 ❌\n\t- 같은 프로세스에 속하는 스레드끼리 컨택스트 스위칭은 같은 프로세스에 속하기 때문에 그 프로세스의 메모리 영역을 공유한다고 했었음\n\t- 그래서 컨택스트 스위칭이 발생해도 메모리 관련하고 추가 작업 필요 ❌\n\n\u003e TLB는 범위 밖이라 자세히 다루지는 않고 간단하게만 하겠음 \u003cbr\u003e\n\u003e 가상 메모리 주소와 실제 메모리 주소의 매핑 정보를 가지고 있는 캐시를 의미\n\n\u003cbr\u003e\u003chr\u003e\n\n### 컨택스트 스위칭 예제\n\n\u003cbr\u003e\n\n**스레드 컨택스트 스위칭**\n\n![](brain/image/lecture02-28.png)\n\n\u003cbr\u003e\n\n**프로세스 컨택스트 스위칭**\n\n![](brain/image/lecture02-29.png)\n\n- MMU, TLB 작업을 반드시 수행해야함.\n- 예를 들어, P2가 실행됐을 때 이 작업이 수행되지 않았다면 P1의 메모리 주소로 잘못 접근하는 일이 발생할 수 있음\n\n\u003cbr\u003e\n\n==**스레드 컨택스트 스위칭이 더 빠른 이유?**==\n- 프로세스 컨택스트 스위칭과는 다르게 스레드 컨택스트 스위칭은 같은 메모리 공간을 공유하기 때문에 **메모리 주소 관련 처리를 하지 않기 때문**\n\n\u003cbr\u003e\u003chr\u003e\n\n### 캐시 오염\n\n==**캐시 오염 (cache pollution)**==\n- 컨택스트 스위칭이 미치는 **간접적인 영향을 의미**\n- 컨택스트 스위칭이 발생하면 서로 다른 데이터들이기 때문에 컨**택스트 스위칭 직후에 캐시에 가봤자, 어차피 캐시에는 이전의 프로세스 혹은 스레드에서 실행됐던 정보를 가지고 있을 것**\n- 그래서 내가 원하는 데이터를 찾으려면 다시 메모리까지 가야하고, 처리 속도가 떨어져서 성능에 안좋은 영향을 끼치게 됨\n\n\u003cbr\u003e\u003chr\u003e\n\n### 유저관점 컨택스트 스위칭\n\n==**유저 관점에서 컨택스트 스위칭은 어떤 의미?**==\n- 순수한 (pure) 오버헤드 (overhead)\n- 내가 실행한 프로그램의 동작과는 전혀 상관없는 순수하게 CPU를 잡아먹는 간접비용\n- 따라서, **컨택스트 스위칭이 많이 일어나는 것은 좋은 것이 아니다.**\n","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/os/easy-os/lecture03":{"title":"03. CPU/IO bound","content":"\n유튜버 쉬운코드 님의 \u003ca href='https://www.youtube.com/@ez./playlists' target='_blank'\u003e운영체제\u003c/a\u003e 강의를 정리한 내용\n\n\u003chr\u003e\n\n## CPU/IO bound\n\n### 기초용어\n\n**CPU (Central Processing Unit)**\n- 명령어를 실행하는 연산 장치\n- 프로세스의 명령어를 해석하고 실행하는 장치\n\n\u003cbr\u003e\n\n**IO (Input / Output)**\n- 파일을 읽고 쓰거나 네트워크의 어딘가와 데이터를 주고 받는 것\n- 입출력 장치와 데이터를 주거나 받는 것\n\n\u003cbr\u003e\n\n==**버스트 (Burst)**==\n- 어떤 현상이 짧은 시간 안에 집중적으로 일어나는 일\n\n\u003cbr\u003e\n\n==**CPU 버스트**==\n- **프로세스가 CPU에서 한 번에 연속적으로 실행되는 시간**\n- 메모리에 올라가있는 프로세스가 자신의 차례가 되어서 CPU에서 실행됐을 때, 자신의 명령어들이 CPU에서 연속적으로 실행되는 시간을 의미\n\n\u003cbr\u003e\n\n==**IO 버스트**==\n- **프로세스가 IO 작업을 요청하고 결과를 기다리는 시간**\n\n\u003cbr\u003e\n\n==**프로세스의 인생은 CPU 버스트와 IO 버스트의 연속**==\n\n![](brain/image/lecture03-29.png)\n\n\u003cbr\u003e\n\n==**CPU 버스트 길이에 따른 빈도**==\n\n![](brain/image/lecture03-30.png)\n\n- 대부분의 프로세스들의 CPU 버스트가 8ms 안으로 끝나는 것을 볼 수 있음\n- 보통의 프로세스는 CPU 작업을 수행할 때 길게하지 않고 짧게 끝낸다는 것을 의미\n\n\u003cbr\u003e\n\n==**CPU bound 프로세스**==\n- CPU burst가 많은 프로세스 (연산 작업이 많은)\n- ex) 동영상 편집 프로그램, 머신러닝 프로그램\n\n==**IO bound 프로세스**==\n- IO burst가 많은 프로세스\n- ex) (일반적인) 백엔드 API 서버\n\t- 보통의 API 서버들은 HTTP 요청을 받으면 DB 서버나 캐시 서버에 데이터를 요청하고 요청한 데이터를 받아서 적당한 형태로 가공한 뒤에 HTTP 응답을 하는 것이 일반적인 형태이니까\n\t- DB 서버나 캐시 서버에 요청하는 작업이 IO 작업\n\t- 이 IO 작업은 네트워크를 타는 부분이라서 CPU에서 명령어가 몇 십개 처리되는 것보다 훨씬 오래걸림\n\n\u003cbr\u003e\u003chr\u003e\n\n### CPU bound 프로그램\n\n**Quiz) 듀얼 코어 CPU에서 동작할 CPU bound 프로그램을 구현한다면 몇 개의 스레드를 쓰는게 좋을까?**\n- ex) 10억 개의 사진을 읽어서 사진에 사람이 있는지 없는지 마킹하는 프로그램\n- 무조건 스레드가 많으면 처리 속도가 빠를까?\n\n\u003e **Goetz (2002, 2006) recommends** \u003cbr\u003e\n\u003e CPU bound 프로그램에서 적절한 스레드 수는 **`number of CPUs + 1`**\n\n\u003cbr\u003e\n\n**ex) 듀얼 코어 CPU에 스레드가 4개인 상황**\n\n![](brain/image/lecture03-31.png)\n\n- 컨택스트 스위칭이 많이 발생 → 오버헤드 커질 것\n\n\u003cbr\u003e\n\n**ex) 듀얼 코어 CPU에 코어 개수만큼만 스레드 2개인 상황**\n\n![](brain/image/lecture03-32.png)\n\n- 컨택스트 스위칭이 발생하지 않기 때문에 이로 인한 CPU 낭비 발생 ❌\n- 그래서 스레드를 코어 개수 정도나, 코어 개수보다 1개 더 둔 정도로 추천한다는 의미\n\n\u003cbr\u003e\u003chr\u003e\n\n### IO bound 프로그램\n\n**Quiz) IO bound 프로그램은 스레드 몇 개로 구현해야 적절할까?**\n- 사실 CPU bound 프로그램과 다르게 적절한 가이드라인은 없음\n- 여러 상황에 맞춰서 적절한 스레드 수를 찾아야 함\n\t- 컴퓨터 스펙, 프로그램 특성 등등 ...\n\n\u003cbr\u003e\n\n**ex) 만약 백엔드 API 서버가 thread per request 방식이라면?**\n- 몇 개의 스레드들을 미리 만들어 놓을지 **여러 상황**을 고려해서 결정하는 것이 필요\n\t- API 서버의 **하드웨어 스펙이 어느정도**인지\n\t- API **애플리케이션의 IO burst 비중**이 대략적으로 어느 정도인지\n\t- 예상되는 **트래픽의 패턴**은 어떤지\n\n\n","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/":{"title":"Programming Language","content":"","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/":{"title":"부부개발단 - Java","content":"","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java":{"title":"개요. 즐거운 자바","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 노트\n\nSpring과 코딩테스트 문법을 공부하기 이전에 최대한 빠르게 1바퀴 보는 것이 목적. 상세한 내용은 자바의 정석으로 다시 공부하기\n\n\u003cbr\u003e\n\n1. [01. Java 시작](brain/Lecture/pl/fun-java/fun-java01.md)\n2. [02. Java 기본 문법](brain/Lecture/pl/fun-java/fun-java02.md)\n3. [03. 객체지향 1/3](brain/Lecture/pl/fun-java/fun-java03.md)\n4. [04. 객체지향 2/3](brain/Lecture/pl/fun-java/fun-java04.md)\n5. [05. 객체지향 3/3](brain/Lecture/pl/fun-java/fun-java05.md)\n6. [06. 배열과 Arrays 클래스](brain/Lecture/pl/fun-java/fun-java06.md)\n7. [07. 제네릭과 컬렉션 프레임워크](brain/Lecture/pl/fun-java/fun-java07.md)\n8. [08. 주석문, 예외처리, enum](brain/Lecture/pl/fun-java/fun-java08.md)\n9. [09. Java I/O](brain/Lecture/pl/fun-java/fun-java09.md)\n10. [10. Java Thread](brain/Lecture/pl/fun-java/fun-java10.md)\n11. [11. Java Network](brain/Lecture/pl/fun-java/fun-java11.md)","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java01":{"title":"01. Java 시작","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 내용\n\n\u003chr\u003e\n\n## Java의 특징\n\n- 객체지향 언어\n- Java는 느리지만, 버전 업 되면서 다른 언어들의 장점들을 흡수\n\t- Java 8 이후부터를 모던 자바라고 함\n\t- 람다(Lambda) : 함수형 프로그래밍\n\t- Stream API : 람다 표현식, 메서드 참조 등의 기능과 결합하여 매우 복잡하고 어려운 데이터 처리 작업을 쉽게 조회하고 필터링하고 변환하고 처리할 수 있게 함\n\t- 병렬 프로그래밍 : 여러 개의 CPU 코어에서 작업을 배분하여 동시에 작업을 수행\n\n\u003cbr\u003e\n\n### 작성과 실행\n\n- JDK(Java Development Kit) 프로그램을 다운하고 설치\n- 여러 종류의 JDK 존재\n\t- OpenJDK, Oracle JDK, Azul Julu JDK, Amazon Corretto OpenJDK, Adoptium Termurin 등\n\t- 이클립스 재단의 어댑티움 프로젝트가 '이클립스 테무린(Eclipse Temurin) 자바 SE 바이너리'의 첫 번째 릴리즈 출시함. 이는 Intel 64-bit 프로세서 기반 윈도우, 리눅스, 맥 OS용 자바 SE8, 자바 SE11, 자바 SE 16의 최신 버전을 다루는 오픈JDK(OpenJDK)의 '프로덕션 레디(production-ready)' 빌드이다.\n- LTS 버전은 유지보수를 길게 지원하겠다고 선언한 버전\n\n\u003cbr\u003e\n\n### Hello 파일 분석\n\n1. 클래스 선언\n\n```java {title=\"Hello.java\"}\npublic class Hello {\n\t...\n}\n```\n\n- public class로 정의된 Hello 클래스\n- public class의 클래스 이름과 파일 이름은 같아야 한다. (중요! 대소문자 구분함)\n- ==**클래스(Class)와 객체(Object)는 구분되어야 한다. 즉, 설계도와 설계도로 만들어진 것은 구분해야한다는 의미**==\n\n\u003cbr\u003e\n\n2. 메서드 선언\n\n```java\n\tpublic static void main(String[] args) {\n\t\t...\n\t}\n```\n\n- 클래스 안에는 필드(Field)와 메서드(Method)를 가질 수 있음\n- 프로그램이 실행하려면 반드시 가져야 하는 **main 메서드**\n- Java로 만든 프로그램이 실행되려면 위의 코드(code)를 가지고 있어야 한다. **프로그램 시작점**이라고도 말한다.\n\n\u003cbr\u003e\n\n3. 출력\n\n```java\n\tSystem.out.println(\"Hello\");\n```\n\n- 앞으로 Java에서 단어의 첫 번째 글자가 대문자로 시작하면 클래스로 이해하자.\n- `System.out`은 **System 클래스가 가지고 있는 out 필드라는 의미**\n- `out.println`은 **out 필드가 가지고 있는 println 메서드라는 의미**\n- println 뒤에 괄호 있으니까 println 메서드\n- out은 괄호가 붙지 않았는데 이건 out 필드\n- out이 가지고 있는 println 메서드의 역할은 괄호 안의 내용을 화면에 출력한다.\n- **in 필드는 InputStream 클래스, out 필드는 PrintStream 클래스**\n\n\u003cbr\u003e\n\n\u003ca href='https://docs.oracle.com/javase/8/docs/api/java/lang/System.html' target='_blank'\u003eOracle System API docs\u003c/a\u003e에 들어가서 System 클래스에 관한 설명을 보면 된다. 앞으로 구글에다가 Java api docs와 같이 검색하거나 Java System api 같이 검색해서 찾아보도록 하자.\n\n\u003cbr\u003e\n\n### 컴파일 과정\n\n- 컴파일하려면 반드시 javac 프로그램이 필요. javac는 자바 컴파일러\n- 터미널에서 `javac Hello.java` 입력하면 Hello.java 파일을 읽어들여서 컴파일\n- 컴파일 성공 시 `Hello.class` 파일 생성, 컴파일 실패 시 오류 메시지 보여짐\n- Hello.class 파일을 `바이트(byte) 파일`이라고 함. 사람이 이해하는 언어와 기계가 이해하는 언어인 기계어의 중간에 위치하는 녀석이다. JVM이 이해하는 코드가 바이트 코드\n- 정리하자면, ==**Java에서 컴파일은 기계어로 바로 바꿔주는 것이 아니라 바이트 코드로 만들어준다. 컴파일되서 만들어진 바이트코드는 CPU/OS에 맞게 설치된 JDK 안에 있는 JVM이 한 줄 한 줄 읽어가며 인터프리터 방식으로 실행한다.**==\n\n\u003cbr\u003e\n\n### IntelliJ 프로젝트 구조\n\n![](brain/image/fun-java01-1.png)\n\n- `.idea` 폴더는 인텔리제이에서 프로젝트를 관리하기 위한 파일로 직접 수정하거나 삭제하면 안됨\n- `Fun-Java.iml` 파일은 인텔리제이의 설정 파일로 직접 수정하거나 삭제하면 안됨\n- 사용자는 src 폴더에 Java 소스 코드 작성","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java02":{"title":"02. Java 기본 문법","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 내용\n\n\u003chr\u003e\n\n## 변수와 리터럴\n\n### int 1 = 1;\n\n- int : 정수 타입(type)을 나타내는 키워드\n\t- 키워드란, Java 언어에서 정한 예약어\n\t- public, class, static, while과 같은 단어들이 키워드\n- i : \"변수 i\"라고 말함. 변수는 **하나의 값을 가질 수 있는 공간**을 의미한다. 여기서 공간이란 **메모리의 어떤 영역**을 의미한다. i는 변수의 이름, 즉 변수명\n\t- 컴퓨터는 정수 하나를 저장하기 위해 메모리에 4 byte 크기의 저장공간을 필요로 한다.\n\t-  변수를 선언한다 = 선언한 변수 이름으로 어떤 위치에 있는 메모리를 얼마만큼의 크기로 사용하겠다.\n- 1 : \"**정수 리터럴(literal) 1**\"이라고 말함. 리터럴이란, 변수에 입력되는 값을 의미\n- `int i = 1;`은 정수 타입의 변수 i를 선언함과 동시에 1로 초기화한다는 의미\n\n정수 타입은 4byte의 메모리를 사용한다고 했다. 4byte 메모리에 숫자 1이 2진수로 저장된다.\n\n| 1byte    | 2byte    | 3byte    | 4byte    |\n| -------- | -------- | -------- | -------- |\n| 00000000 | 00000000 | 00000000 | 00000001 | \n\n\u003cbr\u003e\n\n### 기본형 타입\n \n==**기본형(primitive) 타입 : 첫 번째 글자가 모두 소문자이면서 정해진 크기의 메모리 영역을 확보하고 값을 가진다.**== \n\n- 1byte = 8bits\n- boolean 타입은 1byte를 사용하는데, 사실 1bit로도 참(1)과 거짓(0)을 표현할 수 있지만 컴퓨터에서 자료를 표현하는 최소 단위가 1byte라서 메모리 1byte를 사용하는 것이다.\n\n| |정수형|문자형|실수형|논리형|\n|:---:|:-----:|:-----:|:-----:|:-----:|\n|1바이트|byte|-|-|boolean|\n|2바이트|short|char|-|-|\n|4바이트|int|-|float|-|\n|8바이트|long|-|double|-|\n\n\u003cbr\u003e\n\n### 참조형 타입\n\n==**참조형(reference) 타입 : 첫 번째 글자가 대문자이면서, 기본형 타입이 아닌 모든 타입이다. class, interface 등이 있으며 참조형 타입은 값을 가지지 않고 값을 참조하게 된다.**==\n\n\u003cbr\u003e\n\n### 변수명 규칙\n\n변수명은 아무 이름이 될 수 없다.\n\n- 하나 이상의 글자로 이루어져야 함\n- 첫 번째 글자는 문자, $, _ 만 가능\n- 두 번째 이후의 글자는 숫자, 문자, $, _ 만 가능\n- $, _ 이외의 특수문자 사용 불가능\n- 길이 제한 없음\n- 키워드는 변수명으로 사용 불가\n- 상수 값을 표현하는 단어인 true, false, null은 변수명으로 사용 불가\n\n\u003cbr\u003e\n\n### 초기화\n\n- 메서드 안에서 사용된 변수 ( = 지역변수 ) : 반드시 초기화해서 사용, 그렇지 않으면 `java: variable 변수명 might not have been initialized` 오류 발생\n- 클래스 안에 선언된 변수 ( = 필드 ) : 초기화하지 않아도 사용 가능\n\n\u003cbr\u003e\n\n### 논리형 연산자\n\n![](brain/image/fun-java02-1.png)\n\n\u003cbr\u003e\n\n- `\u0026\u0026` : and\n- `||` : or\n- 비트연산자\n\t- `^` : XOR, 둘다 같으면 false, 달라야 true\n\t- `\u0026`, `|` : 논리 연산자 `\u0026\u0026`, `||`는 결과가 확정되면 뒤에껀 실행 안하는데, 비트 연산자 `\u0026`, `|`는 뒤에꺼도 실행한다\n\t- 예를 들어, `\u0026\u0026`의 경우 앞에 것이 false 면 결과가 false로 확정이니까 뒤에 것을 실행 안하지만, `\u0026`는 뒤에 있는 식도 실행한다.\n\n\u003cbr\u003e\n\n### 정수, 실수, 산술연산자\n\n- ==**Java는 기본적으로 정수를 int형(4byte)으로 인식**==\n- `int x = 5;`에서 변수에 대입되는 숫자 **5는 리터럴**이다.\n- `long y = 5L;`이라고 하면 숫자 **5L은 long 타입 리터럴**이다.\n- 타입 별 값의 범위는 표와 같다.\n\t- 맨 앞에꺼는 부호비트라서 0이면 양수, 1이면 음수이다.\n\n![](brain/image/fun-java02-2.png)\n\n\u003cbr\u003e\n\n- ==**Java는 기본적으로 실수를 double형(8byte)으로 인식**==\n- `double x = 5.2;`에서 변수에 대입되는 실수 **5.2는 리터럴**이다.\n- `float y = 5.2F;`에서 변수에 대입되는 실수 **5.2F는 float 타입 리터럴**이다.\n\n![](brain/image/fun-java02-3.png)\n\n\u003cbr\u003e\n\nfloat와 double의 유효 자릿수 차이\n\n![](brain/image/fun-java02-4.png)\n\n\u003cbr\u003e\n\n**산술 연산자**\n\n```\na = 5 + 4;\nb = 4 - 3;\nc = 3 * 2;\nd = 5 / 2;\ne = 4 % 3;\n```\n\n- a는 9, b = 1, c = 6, d = 2, e = 1\n- 정수를 정수로 나누면 잘림 현상 발생, 2.5가 아닌 2가 d에 저장\n- **나머지 연산자(=모듈러 연산자)는 앞의 숫자를 나누고 나눈 나머지 값을 구함**\n\n\u003cbr\u003e\n\n**정수와 실수의 최솟값과 최댓값**\n\n\u003cbr\u003e\n\n```java\npublic class NumberExam01 {  \n    public static void main(String[] args) {  \n        int maxInt = Integer.MAX_VALUE;  \n        int minInt = Integer.MIN_VALUE;  \n  \n        double maxDouble = Double.MAX_VALUE;  \n        double minDouble = Double.MIN_VALUE;  \n  \n        System.out.println(maxInt);  \n        System.out.println(minInt);  \n        System.out.println(maxDouble);  \n        System.out.println(minDouble);  \n    }  \n}\n```\n\n- \u003ca href='https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html' target='_blank'\u003eOracle docs Integer Class API\u003c/a\u003e를 보면 Integer 클래스는 필드에 static 하면서 int 타입인 MAX_VALUE, MIN_VALUE를 확인할 수 있다.\n\n\u003cbr\u003e\n\n### 오버플로우\n\n==**오버플로우(Overflow)는 계산 결과가 최댓값을 넘거나, 최솟값보다 작을 경우에 음수는 양수로, 양수는 음수로 바뀌는 문제가 발생하는 것을 의미한다.**==\n- 발생 원인을 살펴보면, 1byte가 가지는 가장 큰 값을 살펴보자\n- 01111111인데, 여기에서 1을 더하면? 10000000이 된다. 가장 좌측 비트는 부호비트라고 했었다.\n\n```java\npublic class NumberExam02 {  \n    public static void main(String[] args) {  \n        int value = 10;  \n        int maxInt = Integer.MAX_VALUE;  \n  \n        System.out.println(value + 1);  \n        System.out.println(maxInt + 1);  \n    }  \n}\n\n// 11\n// -2147483648\n```\n\n\u003cbr\u003e\n\n### 문자형\n\n- 문자는 작은 따옴표로 묶인 **문자 하나**를 말한다.\n- 문자는 2byte 크기를 가지며 **유니코드 값**을 가진다.\n- 유니코드 값은 \u003ca href='https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_0000~0FFF' target='_blank'\u003e위키피디아\u003c/a\u003e 참고\n- 0000 ~ 0FFF는 16진수 의미하는 것이다. 1byte를 반으로 쪼갠 4bit로 16진수 1개를 표현할 수 있다.\n\t- 유니코드표를 참조하면 A는 0041, a는 0061이라고 나온다. 이를 10진수로 바꿔보자.\n\t- A는 `4 * 16 + 1 = 65`,  a = `6 * 16 + 1 = 97`이다. A와 a의 10진수는 많이 나오니 외워두자.\n- 2byte 정수 타입은 short도 있었고 char도 있다. 이때, short는 음수, 0, 양수를 표현하고 char는 0, 양수를 표현한다.\n\t- short형은 -32,768 ~ 32,767를 저장할 수 있는 정수 타입\n\t- char형은 0 ~ 65,535를 저장할 수 있는 정수 타입\n\n\u003cbr\u003e\n\n## 타입의 변환\n\n형 변환 기본 원칙 (작고 덜 정밀 -\u003e 크고 더 정밀은 자동)\n\n1. **바이트 크기가 작은 자료형 -\u003e 큰 자료형** : 자동으로 형 변환\n\n2. **덜 정밀한 자료형 -\u003e 더 정밀한 자료형** : 자동으로 형 변환\n\n![](brain/image/chap02-2.png)\n\n\u003cbr\u003e\n\n ### 묵시적 형변환 ( = 자동 형변환, implict conversion) \n\n**바이트 크기가 작은 자료형 -\u003e 큰 자료형으로 대입하는 경우**\n\n```java\nbyte bNum = 10;\nint iNum = bNum;\n```\n\n1바이트 -\u003e 4바이트이므로 자료 손실 없이 다 저장됨. 남은 3바이트는 0으로 채워짐\n\n\u003cbr\u003e\n\n**덜 정밀한 자료형 -\u003e 더 정밀한 자료형으로 대입하는 경우**\n\n```java\nint iNum2 = 20;\nfloat fNum = iNum2;\n```\n\n4바이트 -\u003e 4바이트이지만, float 자료형이 더 정밀하게 표현가능해서 변환됨\n\n\u003cbr\u003e\n\n**연산 중 자동 형 변환**\n\n```java\nint iNum = 20;\nfloat fNum = iNum;\ndobule dNum;\ndNum = fNum + iNum;\n```\n\n대입 전 float + int 해서 float형으로 먼저 되고, float -\u003e double로 형 변환 됨.\n\n\u003cbr\u003e\n\n### 명시적 형변환 ( = 강제 형변환, explict conversion)\n\n**바이트 크기가 큰 자료형 -\u003e 작은 자료형**\n\n```java\nint iNum = 10;\nbyte bNum = (byte)iNum;\nSystem.out.println(bNum);\n// 10\n  \nint iNum2 = 1000;\nbyte bNum2 = (byte)iNum2;\nSystem.out.println(bNum2);\n// -24\n```\n\n4바이트 -\u003e 1바이트이므로 자료 손실 발생 가능하다. \u003cbr\u003e\n\n예를 들어, 10은 1바이트에 표현 가능하니까 자료손실 X \u003cbr\u003e\n\n하지만, 1000의 경우 byte 범위 (-128~127) 벗어나니까 자료손실 O\n\n\n\u003cbr\u003e\n\n**더 정밀한 자료형 -\u003e 덜 정밀한 자료형**\n\n```java\ndouble dNum = 3.14;\nint iNum = (int)dNum;\n  \nSystem.out.println(dNum);\nSystem.out.println(iNum);\n// 3.14\n// 3\n```\n\n더 정밀 -\u003e 덜 정밀이니까 자료 손실 발생 가능. 실수의 소수점 이하 부분이 생략되고 정수 부분만 대입되는 것을 확인 가능\n\n\u003cbr\u003e\n\n**연산 중 형 변환**\n\n```java\npackage chapter2;\n  \npublic class ExplicitConversion {\n\tpublic static void main(String[] args) {\n\t\tdouble dNum1 = 1.2;\n\t\tfloat fNum2 = 0.9F;\n\t\t  \n\t\tint iNum3 = (int)dNum1 + (int)fNum2;\n\t\tint iNum4 = (int)(dNum1 + fNum2);\n\t\tSystem.out.println(iNum3);\n\t\tSystem.out.println(iNum4);\n\t}\n}\n\n// 1\n// 2\n```\n\n형 변환이 언제 이루어지는 지도 key point. 위에는 형 변환을 하고 더하기 때문에 소수점 아래를 버려버리면 `1 + 0 = 1`의 결과가 나오고, 아래에는 더한 이후 형 변환을 하기 때문에 `1.2 + 0.9 = 2.1을 소수점 아래 버리면 2`이다.\n\n\u003cbr\u003e\n\n## 비트연산자\n\n**비트(bit)와 바이트(byte)**\n- 비트는 컴퓨터가 처리하는 정보의 최소 단위\n\t- 한 개만으로는 많은 양의 데이터를 나타내기에 턱없이 부족함\n\t- 따라서, 정보를 표현하는 기본단위로는 8개의 비트를 묶은 바이트(byte) 사용\n- 1byte는 `00000000`부터 `11111111`까지 값을 표현할 수 있음\n- 1byte는 정수로 표현하면 0~254까지 표현 가능\n- 1byte를 16진수로 표현하면 00~FF까지 표현 가능\n\t- 4비트는 0부터 15까지 표현가능하니까\n\n\u003cbr\u003e\n\n**비트 연산자는 논리 연산자와 비슷하지만, 비트(bit)단위로 논리연산 할 때 사용하는 연산자**\n\n![](brain/image/fun-java02-5.png)\n\n- `\u003c\u003c`는 명시된 수만큼 비트들을 전부 왼쪽으로 이동\n- `\u003e\u003e`는 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동\n\t- 정수형 타입을 비트로 표현했을 때, 맨 좌측의 비트를 부호화 비트라고 한다. 맨 좌측의 비트가 1이면 음수, 0이면 양수를 나타낸다.\n\n\u003cbr\u003e\n\n**쉬프트 연산자 논리**\n- 컴퓨터는 내부적으로 쉬프트 연산을 수행해서 계산이 굉장히 빠름\n- 우측으로 n만큼 쉬프트 (`\u003e\u003e`) : 2\u003csup\u003en\u003c/sup\u003e 으로 나눈 결과\n- 좌측으로 n만큼 쉬프트 (`\u003c\u003c`) : 2\u003csup\u003en\u003c/sup\u003e 으로 곱한 결과\n\n\u003cbr\u003e\n\n**`\u003e\u003e\u003e`는 지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 모두 0이 됨**\n- `\u003e\u003e\u003e`는 결과가 무조건 양수\n- 그래서 양수화 쉬프트라고도 함\n\n\u003cbr\u003e\n\n## 제어문\n\n### if문\n\n- if는 제어문(control flow statements) 중 하나이다. 순차적인 흐름 안에서 조건에 따라 제어를 할 필요가 있을 경우 if를 사용\n\n```java\nif (조건문1) {\n\n} else if (조건문2) {\n\n} else {\n\n}\n```\n\n\u003cbr\u003e\n\n**삼항연산자**\n- `조건식 ? 반환값1 : 반환값2`\n- 조건식이 참일 경우 반환값1, 거짓일 경우 반환값2\n\n\u003cbr\u003e\n\n### switch문\n\n- switch는 제어문(control flow statements) 중 하나이다. switch문은 경우에 따라 if문보다 가독성이 좋을 수 있다.\n- 이론적으로는 switch가 if보다 빠르다고 하지만 의미 없는 수준이다.\n- break문이 있으면 switch문 탈출, 없으면 아래로 쭉 실행\n- JDK 7 이상부터 변수 자리에 String 타입 가능\n- \u003ca href='https://catch-me-java.tistory.com/31' target='_blank'\u003eJDK 13 이후부터 생긴 switch문에 람다식 쓰거나 yield 산출하기\u003c/a\u003e\n\n\n```java\nswitch (변수) {\n\tcase 값1:\n\t\t변수가 값1일때 실행\n\t\tbreak;\n\tcase 값2:\n\t\t변수가 값2일때 실행\n\t\tbreak;\n\tdefault:\n\t\t변수의 값이 어떤 case에도 해당되지 않을 경우 실행\n}\n```\n\n\u003cbr\u003e\n\n## 반복문\n\n### while문\n\n- while은 반복문(iteration statements) 중 하나\n- 컴퓨터가 잘하는 일이 반복하면서 일을 처리하는 것\n- break 사용 시 반복문 자체를 종료해버림\n- continue 사용 시 해당 루프만 끝내고 다음 루프 실행\n\n```java\n변수의 초기화\nwhile (탈출 조건식) {\n\t탈출 조건식이 참일 경우 실행되는 코드;\n\t변수의 증감식;\n}\n```\n\n\u003cbr\u003e\n\n**인텔리제이에서 디버거 활용하기**\n\n![](brain/image/fun-java02-6.png)\n\n- while 옆에 빨간색으로 브레이킹 포인트 설정\n- Run 버튼 옆에 벌레 모양 디버깅 버튼 클릭\n\n![](brain/image/fun-java02-7.png)\n\n- `F8` , Step Over 버튼 누르면서 하나하나 확인 가능\n\n\u003cbr\u003e\n\n### do-while문\n\n- do-while문은 반복문(iteration statements) 중 하나\n- while문과 비슷하지만, 무조건 한 번은 실행된다는 특징\n\n```java\n변수의 초기화\ndo {\n\t탈출 조건식이 참일 경우 실행되는 코드;\n\t변수의 증감식;\n} while (탈출 조건식);\n```\n\n\u003cbr\u003e\n\n### for문\n\n- for문은 반복문(iteration statements) 중 하나\n- while 문은 변수 선언, 탈출 조건식, 증감식 3줄로 구성해야하지만, for문은 1줄에 모두 표현\n- 중첩반복문도 가능~\n\n```java\nfor (변수의 초기화; 탈출조건식; 증감식) {\n\t탈출 조건식이 참인 경우 실행되는 부분\n}\n```\n\n\u003cbr\u003e\n\n### break, continue\n\n- break : 현재 반복문 빠져나갈 때 사용\n- continue : continue문 아래 부분을 실행하지 않고 다시 반복\n- 그렇다면 중첩 반복문을 한 번에 빠져나가려면? continue 이하를 실행하지 않고 한 번에 중첩 반복문을 반복하려면 어떻게 해야할까?\n- 이럴 때 **label** 사용\n\n```java\npublic class LabelExam01 {  \n    public static void main(String[] args) {  \n        outter:  \n        for (int i = 0; i \u003c 3; i++) {  \n            for (int k = 0; k \u003c 3; k++) {  \n                if (i == 0 \u0026\u0026 k == 2)  \n                    break outter;  \n                System.out.println(i + \", \" + k);  \n            }  \n        }  \n    }  \n}\n\n// 0, 0\n// 0, 1\n```\n\n이렇게, outter라는 라벨을 지정해두고 조건이 맞으면 저 위치로 바로 뛰어나가게!\n\n```java\npublic class LabelExam02 {  \n    public static void main(String[] args) {  \n        outter:  \n        for (int i = 0; i \u003c 3; i++) {  \n            for (int k = 0; k \u003c 3; k++) {  \n                if (i == 0 \u0026\u0026 k == 2)  \n                    continue outter;  \n                System.out.println(i + \", \" + k);  \n            }  \n        }  \n    }  \n}\n\n// 0, 0\n// 0, 1\n// 1, 0\n// 1, 1\n// 1, 2\n// 2, 0\n// 2, 1\n// 2, 2\n```\n\n이렇게, outter 라벨로 가서 다시 반복문 실행!","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java03":{"title":"03. 객체지향 1/3","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 내용\n\n\u003chr\u003e\n\n## 객체지향 프로그래밍\n\n객체지향 프로그래밍 (Object-Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나이다. 객체 지향 프로그래밍은 ==**컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 \"객체\"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고 받고 데이터를 처리할 수 있다.**==\n\n\u003cbr\u003e\n\n예를 들어, 자동차를 가지고 싶다고 했을 때, 자동차 설계 도면을 가지고 싶다는 의미는 아니다. 설계 도면을 기반으로 만들어진 자동차를 가지고 싶다는 의미이다. 객체지향 프로그래밍이라는 뜻은 설계도를 통해 돌아가는 프로그래밍이 아니라 이 ==**오브젝트, 인스턴스를 기반으로 돌아간다는 의미**==이다. 클래스만 가지고는 아무것도 못하고 클래스를 기반으로 인스턴스를 만들어야지만 사용할 수 있는 것이다.\n\n\u003chr\u003e\n\n==**클래스(Class) : 설계도**==\n\n==**객체(Object) : 설계도를 기반으로 구현하고 싶은 대상**==\n\n==**인스턴스(Instance) : 객체의 생성자를 통해 실체화 한 것**==\n\n\u003cbr\u003e\n\n\u003e **예시** \u003cbr\u003e\n\u003e 1. 컴퓨터(**객체**)를 만들어보자.\n\u003e 2. 컴퓨터(**객체**)는 컴퓨터 설계도(**클래스**)를 이용해서 만들 것이다. \u003cbr\u003e\n\u003e \t - 컴퓨터(객체)에는 CPU, RAM, 파워 등(**필드**)이 있음 \u003cbr\u003e\n\u003e \t - 컴퓨터(객체)에는 CPU 구동, RAM에 올리기 등(**메서드**)이 있음 \u003cbr\u003e\n\u003e 3. 컴퓨터(**객체**)를 만들면 설계도(**클래스**)대로 작동할 것이라고 기대함\n\u003e 4. 컴퓨터(**객체**)를 공장(**메모리**)에서 만들면 실제 제품(**인스턴스**)이 생성됨\n\u003e 5. 컴퓨터(**객체**)를 실제로 만들 때마다 시리얼 번호(**메모리 상 주소**)를 붙임\n\n\u003cbr\u003e\n\n인스턴스는 우리가 사용하려면 특별한 이름으로 참조(reference)해야 한다.\n- 참조형 변수(Reference Variable)를 선언\n- 참조되지 않은 인스턴스는? 쓰레기(Garbage)\n- new 클래스이름()이라는 것은 클래스 이름에 해당하는 인스턴스를 생성한다는 의미이다.\n\n\u003cbr\u003e\n\n```java\nBook b = new Book();\n```\n\n- **생성자로 인스턴스를 생성**해야 책이 만들어지는 것\n- 이 책을 **참조하는 변수**가 `b`이다. `Book`이라는 생성된 인스턴스를 참조한다.\n- 참조 변수 `b` 앞의 Book을 **레퍼런스 타입**이라고 한다.\n\n![](brain/image/fun-java03-2.png)\n\n\u003cbr\u003e\n\n- 만약에 참조하는 변수 없이 `new Book();`만 한다면 Heap에 인스턴스는 생성된 상태이지만, 참조하는 녀석이 없다는 의미\n- 참조하는 변수가 없을 경우 Heap 메모리에 생성된 인스턴스를 사용할 수 없다.\n- **사용할 수 없는 인스턴스는 쓰레기(Garbage)이므로 GC 될 것**\n- 다시 말하지만, ==**참조형 타입은 값을 가지는 것이 아닌 객체를 참조하는 것**==\n\t- 참조형 타입의 변수가 주소를 가지는 것처럼 설명하는 사람이나 책이 있는데, 자바는 어떤 주소에 어떤 값이 저장되는 지 알 수 있는 방법이 없다. 자바에는 그런 포인터 연산자가 없으므로 알 수 없다.\n\n\u003chr\u003e\n\n## 클래스\n\n- 클래스는 필드(Field)와 메서드(Method)를 가진다.\n- 필드는 클래스의 속성이라고 말할 수 있다.\n- 메서드는 클래스의 기능, 행위라고 말할 수 있다.\n\n\u003cbr\u003e\n\n### 클래스 선언 방법\n\n1. 클래스 앞에는 접근제한자(==public, private, protected, default(없음)==)가 붙는다.\n\n2. 클래스 이름\n\t1. 첫 문자가 문자, `_`, `$`의 특수문자로 시작되어야 하고 숫자로 시작할 수 없다. (참고로 한글도 가능하다)\n\t2. 첫 문자가 아니라면 문자, `_`, `$`, 숫자로 구성될 수 있다. JDK 8에서는 `_` 한 글자로 이루어진 변수는 예약어로 정의되어 있기 때문에 사용할 수 없다.\n\t3. 자바의 예약어는 식별자로 사용할 수 없다.\n\t4. 자바의 식별자는 대소문자를 구분한다.\n\t5. 식별자 길이는 제한이 없고 공백은 포함할 수 없다.\n\n3. 클래스 이름 관례\n\t- 클래스 명은 대문자로 시작\n\t- 단어와 단어가 만날 경우 2번째 단어의 시작은 대문자로 시작\n\t\t- HelloWorld 같이 적는 것, 이를 카멜 표기법이라고 함\n\n```java\n접근제한자 class 클래스이름 {\n\t필드들 ;\n\t생성자들 ;\n\t메서드들 ;\n}\n```\n\n\u003cbr\u003e\n\n### 클래스 다이어그램\n\n![](brain/image/fun-java07-2.png)\n\n![](brain/image/fun-java03-3.png)\n\n\u003cbr\u003e\n\n![](brain/image/fun-java03-4.png)\n\n\u003cbr\u003e\n\n1. `static`이 붙은 메서드는 ==**클래스 메서드**==\n\t- 클래스 메서드는 ==**인스턴스를 생성하지 않아도 사용 가능**==\n\t- 사용 가능하다는 것은 ==**메모리에 올라가있다는 의미**==\n\n2. VendingMachineMain은 VendingMachine에 ==**의존한다.**==\n\t- main 메서드가 동작하려면 VendingMachine 클래스 필요\n\t\t- main 메서드가 쓰고 있으니까 필요한 것, 없으면 컴파일 에러\n\t- 메서드 안에서 사용하는 것은 의존한다는 의미\n\t- VendingMachineMain은 `main(String[] args)`를 쓰니까 당연히 String 클래스에도 의존한다는 의미\n\n\u003cbr\u003e\n\n### 클래스의 인스턴스 생성\n\n**인스턴스를 만드는 3가지 방법**\n\n1. new 연산자와 생성자를 이용하여 인스턴스를 만드는 방법\n2. 클래스로더를 이용하는 방법\n3. 메모리에 있는 인스턴스를 복제(clone)하여 만드는 방법\n\n2번 3번은 나중에 설명, 1번만 일단 이해하자\n\n![](brain/image/fun-java03-5.png)\n\n\u003cbr\u003e\n\n인스턴스를 만들 떄마다 메모리에 인스턴스가 생성되기에 필요한 개수만큼 잘 만드는 것은 매우 중요하다. 객체지향 프로그래밍에서 인스턴스 생성은 굉장히 중요하기 때문에 디자인 패턴에도 분류된다.\n\n- 디자인 패턴 : 클래스를 작성하는 패턴\n\t- 3가지 카테고리 중 인스턴스 생성 패턴이 있음. 그정도로 굉장히 중요!\n\n\u003chr\u003e\n\n## 메서드\n\n### 메세지 교환\n\n앨런 커티스 케이형이 말했다. 객체지향의 핵심은 \"메시징\"이다 !\n- 훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떠한가보다 ==**모듈이 어떻게 커뮤니케이션하는가**==에 달려있다.\n- 객체지향 프로그래밍을 한다는 것은 메서드가 언제 호출되고, 어떻게 호출될까? 메서드의 이름은 어떻게 지어야 할까? 어떻게 호출해야 할까?를 고민해야 한다.\n\n\u003cbr\u003e\n\n**객체는 자율적인 책임을 가진다.**\n- 객체지향의 사실과 오해 책에 나오는 말\n- 자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체\n- 객체가 어떤 행동을 하는 유일한 이유는 **다른 객체로부터 요청을 수신했기 때문**\n- **요청을 처리하기 위해 객체가 수행하는 행동을 책임**이라고 함\n- 자율적인 책임의 특징은 객체가 어떻게 해야 하는가가 아니라 ==**무엇을 해야하는가를 설명한다는 것**==이다.\n\n\u003cbr\u003e\n\n메시징은 객체가 다른 객체의 메서드를 호출하는 것이라고 했고, 객체가 어떤 행동을 하는 유일한 이유는 이 객체의 메서드를 다른 객체가 호출했을 때이다. 즉, ==**핵심은 객체는 기능이 호출되었을 때 그에 맞는 기능을 하는 책임을 가지고 있다는 의미이다.**==\n\n\u003cbr\u003e\n\n자판기의 동전 잔액을 보여주는 디스플레이 장치가 있다고 하면 어떤 책임이 있을까? 사용자가 넣은 동전의 정보를 정확히 표시해주는 책임이 있다. 상품 선택 버튼을 눌렀을때? 버튼은 잘 동작해야한다. 버튼에도 책임이 있다.\n\n\u003cbr\u003e\n\n**메서드 선언 방법**\n\n```java\n[접근제한자] [static] 리턴타입 메서드이름([매개변수, ...]) {\n\t실행문\n\t.....\n}\n\n// [] 대괄호는 생략가능하다는 의미\n```\n\n- 클래스 이름은 대문자로 시작하는 것이 관행\n- 메서드 이름은 소문자로 시작하는 것이 관행\n\n\u003cbr\u003e\n\n\u003e [!note] 헷갈리지말자!!! \u003cbr\u003e\n\u003e **매개변수(parameter)** :  메서드의 정의부분에 나열되어 있는 변수들을 의미 \u003cbr\u003e\n\u003e **전달인자(argument)** : 메서드를 호출할 때 전달되는 실제 값 \u003cbr\u003e\n\n\u003cbr\u003e\n\n### 메서드 선언방법\n\n- 들어가는 것이 **매개변수** 나오는 것이 **return**\n\n\u003cbr\u003e\n\n![](brain/image/fun-java03-6.png)\n\n\u003cbr\u003e\n\n![](brain/image/fun-java03-7.png)\n\n\u003cbr\u003e\n\n![](brain/image/fun-java03-8.png)\n\n\u003cbr\u003e\n\n![](brain/image/fun-java03-9.png)\n\n\u003cbr\u003e\n\n![](brain/image/fun-java03-10.png)\n\n\u003cbr\u003e\n\n![](brain/image/fun-java03-12.png)\n\n\u003cbr\u003e\n\n### static 메서드\n\n==**static한 메서드는 인스턴스를 생성하지 않아도 호출할 수 있다.**==\n- static 메서드는 인스턴스를 만들지 않아도 사용할 수 있다 !!!!!!!!\n\n```java {title=\"VendingMachine\"}\npublic class VendingMachine {  \n    public static void printVersion() {  \n        System.out.println(\"v1.0\");  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"VendingMachineMain\"}\npublic class VendingMachineMain {\n\tpublic static void main(String[] args) {\n\t\tVendingMachine vm1 = new VendingMachine();\n\t\t// 이렇게 쓰지말자\n\t\tvm1.printVersion();\n\t\t// 이렇게 쓰자. 다른 사람을 위해서!\n\t\tVendingMachine.printVersion();\n\t}\n}\n```\n\n\u003cbr\u003e\n\n이렇게, 인스턴스를 생성하고 사용하는 것도 가능은 하다\n- 하지만, 프로그래머끼리 관례상 static 메서드는 `인스턴스.static메서드()` 이렇게 쓰지말자\n- `클래스.static메서드()` 이렇게 쓰자\n\n\u003cbr\u003e\n\n### 메서드 실행 시 발생하는 일\n\n먼저, 자바 파일이 어떻게 실행되는지 알아보자. **JVM은 어떤 경로에서 클래스 파일을 찾을까?** 현재 폴더에 Hello.class 파일이 있다고 하더라도 현재 폴더에서 찾는다고 하면 틀렸다.\n\n `javac Hello.java`\n - 틀린 답 ) 현재 폴더에서 찾는다.\n - 정답 ) JVM은 ==**CLASSPATH 경로에서 클래스를 찾는다.**==\n\t - `CLASSPATH=.` 이라고 하면 CLASSPATH 경로가 현재 폴더(`.`)으로 찎혀있다고 하면 현재 폴더에서 찾는 것이다.\n\t - 인텔리제이는 소스를 컴파일하고 `out/production/프로젝트폴더` 아래에 class 파일을 생성하기 때문에 해당 경로를 CLASSPATH로 인식하게 해준다.\n\n![](brain/image/fun-java03-13.png)\n\n\u003cbr\u003e\n\n\u003ca href='https://jae-yoon.tistory.com/17' target='_blank'\u003e블로그 포스팅을 참조하며 글을 읽도록 하자.\u003c/a\u003e\n\n`java VendingMachineMain`\n1. CLASSPATH에서 VendingMachineMain 클래스를 찾는다.\n\t- JVM은 읽어들인 클래스 정보를 Metaspace라는 Native Memory 영역에 저장한다.\n\t- 인스턴스가 아니라 클래스 자체에 대한 정보가 올라가는 것이다.\n2. JVM은 프로그램 시작점인 main 메서드를 metaspace에 저장된 VendingMachineMain에서 먼저 찾고 실행한다.\n3. JVM Stack이라고 불리는 메모리 영역에 실행된 메서드 정보를 올린다.\n\t- 스택은 FILO (First In Last Out) 자료구조\n\t- JVM Stack에 저장된 메서드 실행 정보 1개는 스택 프레임(Stack Frame)에 있다.\n\t- main 메서드 안에 선언된 변수들은 스택 프레임에 저장되고 이러한 변수를 지역(local) 변수라고 한다.\n4. main에 있는 `String[]` String 배열 인스턴스가 Heap 메모리에 생성된다.\n\t- 이 인스턴스를 `args` 변수가 참조한다. Stack Frame -\u003e Heap\n5. PC(Program Counter) Register를 통해 몇 번째 줄을 실행하고 있는지에 대한 정보도 기억하고 있다.\n\n즉, 메서드가 실행될 때마다 JVM stack에 하나씩 올라가는 것이다.\n- FILO 구조이니까 차곡차곡 쌓이는 것이다.\n- 다쓰고 나면 빼서 제거하는 원리니까 당연히 main 메서드가 제일 아래에 위치\n- 지역 변수는 메서드가 종료되면 사라진다. 스택에서 빠지니까. 즉, 메서드가 호출될 때 생성, 메서드가 종료될 때 지역변수 사라짐\n\t- 만약, 같은 메서드를 동시에 10번 호출한다고 해도 그 메서드 안의 지역 변수는 각각 다른 영역에 저장되어 사용됨. 스레드마다 영역 다르니까.\n\t- 즉, 동시에 메서드가 호출되어도 문제가 없다.\n\t- 하지만, 메서드에서 클래스 안에 선언된 변수를 사용할 경우 문제가 발생할 수 있음\n\n\u003chr\u003e\n\n## Math Class\n\n자바 API란 자바 개발자가 제공하는 명령어를 의미하고 API 문서란 이런 명령어들의 사용법과 규격을 제공하는 문서이다. Math Class를 \u003ca href='https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html' target='_blank'\u003eJava Math API 문서\u003c/a\u003e에서 보도록 하자.\n\n\u003cbr\u003e\n\n![](brain/image/fun-java03-14.png)\n\n- Math Class가 가지고 있는 메서드는 모두 static한 메서드\n- 이 말은 인스턴스를 만들 필요 없이 사용하다는 의미! 모든 필드와 메서드를!\n\n```java\npublic class MathTest {  \n    public static void main(String[] args) {  \n        int value = Math.abs(-5);  \n        System.out.println(value);  \n    }  \n}\n\n// 이렇게 인스턴스 안만들고 바로 사용 가능하다는 의미\n```\n\n\u003cbr\u003e\n\n### private\n\n그런데, Math 클래스를 인스턴스 생성하여 사용하려고 하면 컴파일에러가 뜬다.\n- 이 클래스를 만든 사람은 일부러 인스턴스 생성 안해도 사용할 수 있게 만든건데, **쓰는 사람이 인스턴스 생성해서 쓰면 메모리 낭비니까 강제로 막아뒀음**\n\n\u003cbr\u003e\n\n==**접근제한자를 public이 아닌 private으로 바꾸면, 해당 클래스 안에서만 접근 가능하다.**==\n- 즉, 다른 클래스에서 인스턴스를 만들어서 사용할 수 없다.\n- 인스턴스를 생성하지 못하면 인스턴스 메서드는 사용할 수 없고 static이 붙은 클래스 메서드만 사용할 수 있다.\n- 여러 개 인스턴스를 생성하지 못하게 하고 강제로 static한 메서드만 사용하도록 하고싶으면 클래스 생성자의 접근제한자를 private으로 하면 됨","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java04":{"title":"04. 객체지향 2/3","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 내용\n\n\u003chr\u003e\n\n## instance 필드\n\n### 클래스 메서드 vs 인스턴스 메서드\n\n- **클래스 메서드 : static이 붙은 메서드**\n- **인스턴스 메서드 : static이 붙지 않은 메서드**\n- 인스턴스 별로 다르게 동작해야 한다면 인스턴스 메서드\n- static 메서드는 객체 생성이나 유틸리티 관련에서 사용될 때가 있음\n- 되도록 인스턴스 메서드를 사용하도록 하자.\n\n\u003cbr\u003e\n\n### 필드(field)\n\n- 필드 : 클래스가 가지는 정보 (=속성)\n\t- 다른 언어에서는 멤버변수라고 말하는 경우도 있음\n- 필드는 어떤 키워드와 함께 사용되느냐에 따라 사용방법이 달라짐\n- **클래스 필드 : static 키워드와 함께 사용**\n- **인스턴스 필드 : static 키워드를 사용하지 않음**\n\n\u003cbr\u003e\n\n**필드 선언 방법**\n\n\u003cbr\u003e\n\n```java\n// 대괄호는 생략 가능\n[접근제한자] [static] [final] 타입 필드명 [=초기값];\n```\n\n- 접근제한자 public, protected, 아무것도 없는 경우(=default), private 가능\n- 필드명은 식별자 규칙 따름\n\t- 다만, 필드는 첫 번째 글자 소문자로 시작하는 것이 관례\n- 타입(type)은 기본형과 참조형 가능\n\t- 기본형 : boolean, byte, char, short, int, long, float, double\n\t- 참조형 : class, interface, 배열 등\n- 초기값이 없을 경우 아래와 같이 초기화 됨\n\t- ==**기본형 : 0으로 초기화**==\n\t- ==**boolean형 : false로 초기화**==\n\t- ==**참조형 : null로 초기화**==\n\n\u003cbr\u003e\n\n**필드 선언 예제**\n\n\u003cbr\u003e\n\n```java\nString name;\nString address = \"경기도 고양시\";\npublic int age = 50;\nprotected boolean flag;\n```\n\n1. String은 참조타입인데 초기화 안했으니까 name 변수는 null로 초기화 됨\n2. address는 `\"경기도 고양시\"`라는 문자열 인스턴스를 참조\n3. int age는 기본형이니까 메모리 4byte의 저장 공간이 잡히고 그 안에 50을 저장\n4. boolean은 기본형이니까 메모리 1byte의 저장 공간이 잡히지만 초기화 안했으니까 false로 초기화 됨\n\n\u003cbr\u003e\n\n```java {title=\"Person.java\"}\npublic class Person {\n\tString name;\n\tString address;\n\tboolean isVip;\n}\n\n// 딱히 초기화 안했으니까\n// 참조형은 null, boolean은 false겠네\n```\n\n\u003cbr\u003e\n\n```java {title=\"PersonTest.java\"}\npublic class PersonTest {  \n    public static void main(String[] args) {  \n        Person p1 = new Person();\n        Person p2 = new Person();\n  \n        System.out.println(p1.name);  \n        System.out.println(p1.address);  \n        System.out.println(p1.isVip);\n\n\t\tSystem.out.println(p2.name);  \n        System.out.println(p2.address);  \n        System.out.println(p2.isVip);  \n    }  \n}\n\n// null\n// null\n// false\n// null\n// null\n// false\n```\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-2.png)\n\n\u003cbr\u003e\n\n특이하게, 문자열(String)은 new를 사용하지 않고도 인스턴스를 생성할 수 있다.\n- 되도록 new를 사용하지 않고 큰따옴표로 묶어서 인스턴스를 참조하는 것이 좋다.\n- String은 너무 자주 사용하기 때문에 자바를 만든 개발자들이 따로 String constant pool이라는걸 만들어놔서 그럼\n\n\u003cbr\u003e\n\n### String Class\n\n\u003ca href='https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html' target='_blank'\u003eOracle docs String Class API\u003c/a\u003e를 확인해보자.\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-3.png)\n\n- java.lang.Object를 상속받음\n- Serializable, CharSequence, Comparable\\\u003cString\u003e 3개의 인터페이스를 구현\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-5.png)\n- 자주 사용하는 메서드인 `length()`를 보자.\n\t- 메서드의 정의 부분에 나열된 파라미터가 없네.\n\t- return 타입은 int형이네 (근데 이게 문자열의 길이라는 말이네)\n\n\u003cbr\u003e\n\n### NullPointerException\n\n그렇다면, 위에서 작성한 코드를 예시로 `p1.address.length()`를 출력해보면 어떨까?\n\n![](brain/image/fun-java04-6.png)\n\n\u003cbr\u003e\n\nNullPointerException 에러가 발생하면서 프로그램이 종료된다. 지긋지긋하게도 많이 보던 널포인터이다. 차근차근 생각해보자.\n- Person 인스턴스를 생성했고 이를 p1 참조변수가 참조하고 있음\n- Person 인스턴스의 address 필드는 초기화하지 않았음\n- 참조형 타입인 address는 초기화하지 않았기 때문에 null 값을 가짐\n- p1 참조변수가 Person 인스턴스의 address를 참조해보면 null이 나옴\n- null을 참조하여 길이를 계산하려고 하니 NullPointerException 발생\n\n![](brain/image/fun-java04-7.png)\n\n이렇게 디버깅하는 습관도 반드시 가지자 !\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-8.png)\n\n1. Evaluate Expression (option키 + F8) \n2. Expression에 원하는 형식으로 넣으면 더 편하게 찾을 수도 있음\n\n\u003chr\u003e\n\n## Class 필드 (static 필드)\n\n==**클래스로더에 의해 클래스가 로드될 때, 클래스 내부에 static 필드가 있다면,  Static Pool이라는 영역에 저장한다. 인스턴스 별로 가지는 것이 아니라 정적 영역에서 따로 관리한다.**==\n- static 필드는 `클래스명.필드명` 형식으로 사용하자.\n- 인스턴스 만들어서 사용하지 말자. \n\n\u003cbr\u003e\n\n```java {title=\"Person.java\"}\npublic class Person {\n\tString name;\n\tString address;\n\tboolean isVip;\n\t// 새로 추가\n\tstatic int count = 0;\n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"PersonTest2.java\"}\npublic class PersonTest2 {  \n    public static void main(String[] args) {  \n        Person p1 = new Person();  \n        Person p2 = new Person();  \n\n        System.out.println(p1.count);  \n        System.out.println(p2.count);  \n        p1.count++;  \n        System.out.println(p1.count);  \n        System.out.println(p2.count);  \n        p2.count++;  \n        System.out.println(p1.count);  \n        System.out.println(p2.count);  \n    }  \n}\n\n// 0\n// 0\n// 1\n// 1\n// 2\n// 2\n```\n\n- Person 인스턴스를 만들기 전에, JVM이 CLASSPATH에 Person 클래스가 존재하는지 먼저 찾아봄\n- 이후, 클래스가 없다면 ClassNotFoundException 던지고 있으면 클래스 정보를 메모리에 올림\n- 클래스 정보 자체는 실행되는 것이 아니라 정적이다.\n- 그래서 메모리에 올릴 때 ==**static 필드가 있는지 확인**==해본다.\n- Person이 가지고 있는 static 필드인 count를 별도의 Static Pool이라는 영역에 저장한다. 인스턴스 별로 가지는 것이 아니라 정적 영역에 따로 관리한다.\n\n\u003cbr\u003e\n\n### non-static (중요)\n\n클래스 메서드에서 인스턴스 필드를 사용할 수 있을까?\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-9.png)\n\n여기에서 클래스 메서드인 `printCount()`는 인스턴스 필드인 `String name, String address, boolean isVip`를 사용할 수 있을까? 아니 사용할 수 없다.\n- ==**메모리에 생성되는 시점이 다르기 때문**==\n\t- 클레스 메서드는 인스턴스가 없어도 사용 가능\n\t- 인스턴스 메서드는 힙 영역에 인스턴스가 생성되어야 사용할 수 있음\n\n![](brain/image/fun-java04-10.png)\n\n\u003cbr\u003e\n\n그냥 `Person.printName()`과 같이 인스턴스 메서드를 사용하면?\n\n- `java: non-static method printName() cannot be referenced from a static ontext` 오류가 발생\n- 인스턴스 필드와 인스턴스 메서드는 `클래스명.필드명`, `클래스명.메서드명()`과 같은 형태로 사용할 수 없다.\n- ==**인스턴스 필드, 인스턴스 메서드를 사용하려면 반드시 인스턴스를 생성한 이후, 인스턴스를 참조하는 참조 변수를 이용해서 사용해야 한다. 인스턴스가 만들어지지 않으면 사용할 수 없다.**==\n\n\u003cbr\u003e\n\n### static-block\n\n![](brain/image/fun-java04-11.png)\n\n- 이렇게 static 블록에서 static 필드를 초기화 가능\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-12.png)\n\n이 경우, 실행 순서를 보자.\n1. javac Hello2.java  \n2. java Hello2  \n3. CLASSPATH에서 Hello2 클래스를 찾고 그 클래스 정보를 메모리에 올림  \n4. 클래스 필드(class field)나 클래스 메서드(class method)는 실행 가능한 상태가 되게 한다  \n5. 클래스 필드는 static 블록에서 초기화 할 수 있다.  \n6. 이후 JVM이 클래스 메서드 중 `String[]`을 받아들이는 main 메서드를 찾고 실행  \n7. 그래서 main 메서드가 실행되기 전에 static 블록 안의 코드가 실행되는 것을 볼 수 있다.\n\n![](brain/image/fun-java04-13.png)\n\nstatic 블록은 main 메서드보다 먼저 실행된다.\n\n\u003cbr\u003e\n\n### JVM 메모리, 인스턴스 생성\n\n![](brain/image/fun-java04-14.png)\n\n- Java 7까지는 JVM이 관리하는 메모리 영역인 PermGen에 클래스 정보가 올라갔음\n- Java 8까지는 Native Memory가 관리하는 영역인 Metaspace 영역에 클래스 정보가 올라감\n\n\u003cbr\u003e\n\n**소스 코드, 클래스 파일 자체는 정적이다.**\n- 동적인 것들은 실행되면서 생성되는 것들을 의미\n- 클래스 정보 자체는 정적\n\t- ==**클래스가 저장된 HDD나 SSD는 RAM보다 속도가 느리기 때문에 클래스가 필요할 때마다 매번 보조 기억장치에서 읽어들이는건 성능 저하가 클 것**==이다.\n\t- 그래서 클래스 정보는 처음 사용될 때 메모리에 그 정보를 올리고 필요할 때마다 사용하는 것\n\n\u003cbr\u003e\n\n**클래스는 로딩될 때 메타스페이스 영역에 클래스가 로딩된다.**\n\n![](brain/image/fun-java04-15.png)\n\n\u003cbr\u003e\n\n**static 정보는 어디에 저장되는가?**\n\n![](brain/image/fun-java04-16.png)\n\n- Java 7 전까지는 non-heap 영역에 저장\n- Java 8 이상부터는 heap에 저장\n\n\u003cbr\u003e\n\n### 총정리\n\n- new 연산자를 사용할 때마다 메모리에 인스턴스가 생성됨\n- 인스턴스는 더이상 참조되는 것이 없을 때, 나중에(언제인지는 모르고 보통 메모리가 부족할 때) 가비지 컬렉션(Garbage Collection)된다.\n- static한 필드는 클래스가 로딩될 때 딱 한 번 메모리에 올라가고 초기화 된다.\n- 인스턴스 메서드(static이 붙지 않은 메서드)는 인스턴스를 생성하고 나서 참조변수를 이용하여 사용할 수 있다.\n- 클래스 메서드는 `클래스명.메서드명()`으로 사용가능하다.\n- 메서드 안에 선언된 변수들은 메서드가 실행될 때 메모리에 생성되었다가, 메서드가 종료될 때 사라진다.\n\n\u003chr\u003e\n\n객체지향적 특성\n\n### 추상화\n\n- ==**중요한 것은 남기고, 불필요한 것은 제거한다.**==\n\n예를 들어서, 책상을 누가 바라보느냐에 따라 중요한 부분이 달라진다.\n- 책상을 만드는 사람이 바라보는 책상\n- 책상을 이용하는 학생이 바라보는 책상\n- 책상을 옮기는 용도로 쓰는 이삿짐 센터 아저씨가 바라보는 책상\n\n자동차도 마찬가지이다.\n- 자동차를 타는 사람이 바라보는 자동차\n- 자동차를 만드는 제작자가 바라보는 자동차\n- 자동차를 정비하는 정비공이 바라보는 자동차\n\n\u003cbr\u003e\n\n==**앞으로, 프로그램을 만들 때 비즈니스 영역(도메인 영역)에 맞도록 추상화 해야한다.**==\n- 너무 먼 미래까지 대비해서 클래스를 만들 필요 없다는 의미\n- 나의 고객으로부터 필요한 정보가 이름, 성별, 나이라면 해당하는 필드만 가지도록 한다.\n- 메서드도 필요한 기능만 가지도록 한다.\n- 이것을 ==**추상화, 중요한 것만 남기고 불필요한 것은 제거하는 것**==이다.\n\n\u003cbr\u003e\n\n### 캡슐화\n\n- ==**관련된 것을 잘 모아서 가지고 있는 것을 캡슐화**==라고 함\n- ==**관련된 것을 잘 모아서 가지고 있을수록 응집도(Cohesion)가 높다**==고 표현\n\t- 캡슐화가 잘되면 응집도가 높다는 말이네\n- 캡슐화는 \u003ca href='/brain/Lecture/fun-java/fun-java04/#정보-은닉'\u003e정보 은닉\u003c/a\u003e과도 관련있다.\n\n\u003cbr\u003e\n\n### 좋은 객체 vs 나쁜 객체\n\n좋은 객체는 응집도는 높고 결합도는 낮아야한다.\n\n- 응집도가 높다\n\t- 객체는 책임이 있다. 기능이 호출되었을 때 그에 맞는 기능을 잘 하는가에 대한 책임\n\t- 예를 들어, 세탁기라면 세탁에 관련된 기능을 잘 모아서 가지고 있어야 한다. 이를 응집도가 높다고 한다.\n- 결합도가 낮다.\n\t- 결합도가 낮을 수록 사용이 편리하다.\n\t- 예를 들어, 컴퓨터를 샀는데 부가적인 장비가 있어야만 컴퓨터가 동작한다면 컴퓨터의 사용성은 떨어질 것이다.\n\n==**따라서, 객체를 만들 땐 관련된 기능을 잘 모아서 가지고 있어야 하니까 응집도가 높게, 객체와 객체간 결합도는 낮춰서 사용성이 편리하게!**==\n\n\u003cbr\u003e\n\n**객체의 역할, 책임, 협력**\n\n- 좋은 객체란 역할과 책임에 충실하면서 다른 객체와 잘 협력하여 동작하는 객체\n- 반대로 나쁜 객체란 여러가지 역할을 한 가지 객체에게 부여하거나, 이름과는 맞지 않는 속성과 기능을 가지도록 하거나, 제대로 동작하지 않는 객체. 또한 다른 객체와 동작이 매끄럽지 않는 것도 나쁜 객체\n\n\u003cbr\u003e\n\n### 다형성\n\n프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, ==**각 요소들(상수, 변수, 식, 오브젝트, 함수, 메서드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질**==을 의미한다.\n- 반대는 단형성으로 프로그램 언어의 각 요소가 한 가지 형태만 가지는 성질을 가리킴\n\n\u003cbr\u003e\n\n**`System.out.println()`**\n- println은 \"인자를 출력하고 줄바꿈을 한다\"는 기능\n- 여기에서 인자는 int, float, double, String 등이 될 수 있음\n- 중요한 건 **메서드 이름이 같다는 것**이다. 메서드 이름이 같은 것이 왜 중요할까?\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-17.png)\n\n![](brain/image/fun-java04-19.png)\n\nout은 표준 출력 장치를 의미하며, PrintStream 클래스라는 타입이다. PrintStrem 클래스를 보면 `println()` 메서드만 10개가 있다. int를 출력하든 double을 출력하든 메서드 이름이 `println()`으로 같다는 것이다. 메서드 이름은 같지만 다양한 타입을 받아들이도록 여러 개가 선언되어 있는 것이다.\n\n프로그램을 설계한다는 것은 **이름을 잘 짓는다는 것**이다. 숫자를 출력하고 줄 바꿈을 하든, 문자를 줄 바꿈을 하든 **메서드 이름을 다르게 지을 필요가 없다.**\n\n이렇게 ==**같은 이름의 메서드가 여러 개 있는데 매개변수(parameter)의 타입이 다르거나 매개변수의 개수가 다른 경우를 오버로딩(Overloading) 했다**==고 말한다.\n\n\u003cbr\u003e\n\n### 다형성, 오버로딩\n- 간단하게, ==**메서드 이름은 같은데, 다양한 타입으로 사용하는 것을 오버로딩(Overloading)**==이라고 생각하자\n- 메서드의 이름은 같고 매개변수의 개수나 타입이 다른 메서드를 정의하는 것을 의미\n- 리턴값만을 다르게 갖는 오버로딩은 작성할 수 없음\n- 어떤 메서드가 실행될 지는 JVM이 실행하면서 동적으로 결정함\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-20.png)\n\n- 객체를 만들 때 나는 어렵게 만들어도, 사용하는 사람은 쉽게 쓸 수 있도록 만들자.\n\n\u003cbr\u003e\n\n### 패키지\n\n- 클래스는 패키지를 이용하여 관련된 클래스들을 관리한다. 자바에서 패키지는 폴더와 같은 기능을 제공한다고 생각하면 된다.\n- 클래스가 관련된 것을 잘 모아서 가지고 있으면 응집도가 높다고 하였는데, 그것을 패키지가 도와주는 것이다.\n\n\n**패키지 이름 규칙**\n- 아키텍처에 맞게 패키지를 작성하는 방법도 정의된다.\n- ==**보통 도메인 이름을 거꾸로 적은 후에 프로젝트 이름 등을 붙여서 만듦**==\n\t- 예를 들어, `com.example.util`\n\t\t- `com.example`은 도메인 이름을 거꾸로 적은 것\n\t\t- `util`은 프로젝트나 모듈의 이름\n\t- **왜 도메인 이름을 거꾸로 적을까?**\n\t\t- 앞으로 오픈 소스를 많이 사용할 것\n\t\t- 다른 사람이 만든 클래스 중에 내가 만든 클래스와 이름이 같은 경우 발생\n\t\t\t- 폴더에는 같은 이름의 파일이 여러 개 있을 수 없음. 그래서 충돌남\n\n\u003cbr\u003e\n\n```java\npackage 패키지명;\n```\n- 주석문이나 빈 줄을 제외하고 가장 윗 줄에 위와 같은 형식으로 선언\n\n\u003cbr\u003e\n\n```bash\njavac -d . 클래스이름.java\n```\n- 이렇게 `-d` 옵션을 붙이고 `.` 현재위치로 지정해야한다.\n- 이러면 현재위치에 com, example, util폴더가 생성되고 거기에 `클래스이름.class`가 생성됨\n\n\u003cbr\u003e\n\n```java\nimport com.example.util.Calculator;\n```\n- `import`는 JVM에게 어떤 패키지의 Calculator 클래스를 사용하게 할 것 인지 알려주는 역할이다.\n- 메모리에 올리거나 그런 일을 하는 것이 아니다.\n\n\u003cbr\u003e\n\n```java\nimport com.example.util.Calculator;\n\npublic class CalculatorTest {\n\tCalculator cal = new Calculator();\n\tint value = cal.plus(50, 100);\n\tSystem.out.println(value);\n\n\tcom.example.util2.Calculator cal2 = new com.example.util2.Calculator();\n\tint value2 = cal2.divide(100, 50);\n\tSystem.out.println(value2);\n}\n```\n\n- 이렇게 다른 패키지에 동일한 이름의 클래스가 있을 경우, 하나는 import 해서 사용 가능하지만 다른 클래스는 import 하지 못하고 저렇게 패키지명까지 같이 적어줘야한다.\n\n\u003chr\u003e\n\n## 상속\n\n- ==**OO는 OO다. OO는 OO의 종류 중 하나다. 라고 표현할 수 있다면 이것은 상속관계**==\n- 상속 관계는 ==**IS-A 관계 혹은 kind of 관계**==라고 말하기도 한다. 일반화시킨다.\n- 일반화란, 자식클래스들을 부모클래스로 부를 수 있는 것을 말함.\n- 상속 = 일반화 + 확장\n- 예를 들면\n\t- 노트북은 컴퓨터다(O)\n\t- 세탁기는 가전제품이다(O)\n\t- 선풍기는 가전제품이다(O)\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-21.png)\n\n- 위에 있는 것이 부모 클래스, 아래에 있는 것이 자식 클래스\n- 자식 -\u003e 부모로 실선, 화살표\n- 전자제품을 상속 받은 클래스는 모두 끄다(), 켜다() 메서드 가짐\n\n\u003cbr\u003e\n\n==**상속은 일반화 + 확장**==\n\n- 상속이란 일반화와 확장이라는 개념을 합한 것이다.\n- 부모 클래스를 상속받는다는 것은 부모가 가지고 있는 것을 자식이 물려받아 사용할 수 있다는 것을 의미한다.\n- 포크레인 = 자동차 + 삽, 자동차를 확장시켜서 만듦\n\n\u003cbr\u003e\n\n==**상속은 굉장히 강한 결합이라서 반드시 써야 할 때만 쓰고 되도록 사용 안하는 것이 좋다.**==\n- 좋은 객체란, 응집도는 높고 결합도는 낮아야하니까.\n- 상속은 가장 강한 결합이라 잘못 상속받으면 타격이 너무 크다.\n\n\u003cbr\u003e\n\n**상속 선언 방법**\n\n```java\n[접근제한자] [abstract | final] class 클래스명 extends 부모클래스명 {\n\n}\n```\n\n\u003cbr\u003e\n\n**아무것도 상속받지 않으면 자동으로 java.lang.Object를 상속받는다.**\n- ==**모든 클래스는 Object의 자손**==이다.\n\n\u003cbr\u003e\n\n### 상속 - 부모 타입으로 자식 참조\n\n부모 타입으로 자식 타입을 참조할 수 있다.\n\n```java\nCar car = new Bus();\n```\n\n- 버스는 자동차다.\n- ==**참조타입(`Car`)과 인스턴스 타입(`Bus`)이 다르다.**==\n- `Bus bus = new Bus();`로 생성해도 되는데 왜 참조타입을 부모타입으로 했을까?\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-22.png)\n\n- 실제 메모리에 올라간 인스턴스는 Bus\n- 참조변수 c1을 이용해 사용할 수 있는 메서드는 `달리다()` 뿐!\n- ==**즉, 참조 변수(`c1`)의 타입(`Car`)만 보더라도 아, 이런 메서드만 사용하겠다는걸 알게 되니 코드 분석이 쉬워진다.**==\n\n\u003cbr\u003e\n\n### 상속 - 객체 형변환\n\n만약, 다시 참조타입을 인스턴스 타입으로 바꾼 다음 인스턴스 타입의 메서드를 쓰고 싶으면 어떻게 할까? 형변환하면 된다.\n- 이게 가능한 이유는, 참조변수 `c1`의 참조타입이 `Car`이기는 하지만, 결국 참조하는 것은 인스턴스 타입 `Bus`이기 때문이다.\n- 그래서 참조변수 c1이 가리키던 것을 b1 보고 가리키라고 해도 어차피 인스턴스 타입 `Bus`를 참조하기 때문에 괜찮은 것이다.\n\n```java\npublic class CarExam01 {\n\tpublic static void main(String[] args) {\n\t\tCar c1 = new Bus();\n\t\tBus b1 = (Bus)c1;\n\t\tb1.안내방송();\n\t}\n}\n```\n\n\u003cbr\u003e\n\n### 상속 - 다형성, 오버라이딩\n\n- ==**메서드 오버라이딩(Overriding) : 상위 클래스의 메서드를 하위 클래스가 재정의하는 것이다.**==\n- 다형성에서 오버라이딩은 상속과 관련된 성질 !\n- 메서드의 이름은 물론 매개변수(parameter)의 개수나 타입도 모두 동일해야함\n\t- 주로 상위 클래스의 동작을 상속받은 하위 클래스에서 변경하기 위해 사용됨\n\n\u003cbr\u003e\n\n==**메서드가 오버라이딩 되면 무조건 자식의 메서드가 실행된다.**==\n\n```java\nclass Car {  \n    public void run() {  \n        System.out.println(\"전륜구동으로 달린다.\");  \n    }  \n}  \n  \nclass Bus extends Car {  \n    public void run() {  \n        System.out.println(\"후륜구동으로 달린다.\");  \n    }  \n  \n    public void 안내방송() {  \n        System.out.println(\"버스 안내방송 입니다.\");  \n    }  \n}  \n  \npublic class CarExam1 {  \n    public static void main(String[] args) {  \n        Bus b1 = new Bus();  \n        b1.run();  \n  \n        Car c1 = new Bus();\n        c1.run();  \n    }  \n}\n\n// 후륜구동으로 달린다.\n// 후륜구동으로 달린다.\n```\n\n- Car도 `public void run()` 메서드를 가지고 있고 Bus도 `public void run()` 메서드를 가지고 있으면? =\u003e Bus의 `run()` 메서드가 실행\n- 왜냐하면, b1도 c1도 참조하는 것은 Bus 인스턴스이다.\n\t- Bus는 `run()` 메서드를 오버라이딩 한 상태\n- `Car c1 = new Bus();` = **버스는 자동차다**\n- `c1.run();` = **그(c1) 자동차는 달린다.**\n\t- 후륜으로 달리도록 바꿔놨는데 갑자기 전륜으로 달리지는 않겠지\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-23.png)\n\n\n\u003cbr\u003e\n\n### 오버로딩 vs 오버라이딩\n\n- 오버로딩(Overloading) : 매개변수(parameter)의 타입이 다르거나, 매개변수의 개수가 다른 같은 이름의 메서드를 여러 개 만드는 것이다. 주의할 점은 리턴값만 다른 것은 오버로딩 할 수 없다.\n- 오버라이딩(Overriding) : 매개변수의(parameter)의 타입, 개수, 이름, 리턴값 모두 동일하면서 상위 클래스의 동작을 상속받은 하위 클래스에서 동작을 변경하기 위해 사용하는 것\n\n\u003cbr\u003e\n\n### 오버라이딩 주의점\n\n==**필드는 Type을 따라가고, 메서드는 오버라이딩 된 자식의 메서드가 실행된다.**==\n- 필드가 오버라이딩 돼서 자식의 값이 사용된다면, 부모 클래스를 만든 사람이 예상하지 못한 결과가 출력될 것이기 때문\n- 그래서 필드는 부모의 타입을 따라간다.\n\t- 만약, 필드도 오버라이딩 된다면 `printII()` 메서드의 호출 값이 30이 되어야할 것\n- 따라서, 필드가 아닌 ==**메서드 오버라이딩만 기억하자.**==\n\n```java\nclass Parents {  \n    public int i = 5;  \n    public void printI() {  \n        System.out.println(\"parent - printI() : \" + i);  \n    }  \n  \n    public void printII() {  \n        System.out.println(\"parent - printII() : \" + i * 2);  \n    }  \n}  \n  \nclass Child extends Parents {  \n    public int i = 15; // 필드에 대한 오버라이딩  \n    public void printI() { // 메서드에 대한 오버라이딩  \n        System.out.println(\"child - printI() : \" + i);  \n    }  \n}  \n  \npublic class Exam01 {  \n    public static void main(String[] args) {  \n        Parents p1 = new Parents();  \n        System.out.println(p1.i);  \n        p1.printI();  \n        System.out.println(\"------------------------\");  \n        Child c1 = new Child();  \n        System.out.println(c1.i);  \n        c1.printI();  \n        System.out.println(\"------------------------\");  \n        Parents p2 = new Child();   // Child는 Parent의 후손이다.  \n        System.out.println(p2.i);  \n        p2.printII();  \n        p2.printI();  \n    }  \n}\n\n// 5\n// parent - printI() : 5\n// ------------------------\n// 15\n// child - printI() : 15\n// ------------------------\n// 5\n// parent - printII() : 10\n// child - printI() : 15\n```\n\n\u003cbr\u003e\n\n### 정보 은닉\n\n- 정보 은닉(information hiding)은 객체지향의 중요한 기법이다.\n- ==**중요한 필드는 은닉하고, 필드는 메서드를 통해서만 접근해서 사용하도록 하자.**==\n\n\u003cbr\u003e\n\n**Getter, Setter**\n- ==**Spring에서는 Getter, Setter를 프로퍼티(property)라고도 한다.**==\n- 아래의 예시는 price 프로퍼티이다.\n\t- price 필드와 price 프로퍼티의 차이\n\t\t- price 필드 : 클래스가 가지는 속성\n\t\t- price 프로퍼티 : price에 대한 getter, setter 메서드\n- 아래처럼 필드를 직접 접근하는 것은 정보은닉 관점에서 안좋다.\n\n```java\nclass Book {  \n    public int price;  \n}  \n  \npublic class BookExam01 {  \n    public static void main(String[] args) {  \n        Book b1 = new Book();  \n        b1.price = 100;  \n        System.out.println(b1.price);  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n- 접근제한자를 private으로 바꿔서 외부에서 직접 접근하지 못하게 만든다.\n- 필드에 접근할 수 있는 메서드를 만들자.\n- ==**`this`는 내 자신 인스턴스를 말하는 예약어**==\u0004\n\t- this는 static 메서드(클래스 메서드)에서 사용 불가능\n\t- 클래스 메서드는 인스턴스가 생성되지 않아도 사용 가능하다. 메모리에 생성되는 시점이 다르기 때문에 클래스 메서드에서는 this를 사용할 수 없다.\n\n```java\nclass Book {  \n    private int price; // field price  \n  \n    // 필드의 값을 수정하고 얻기 위한 메서드 getter, setter    \n    public int getPrice() {  \n        return price;   // this는 내 자신 인스턴스를 참조하는 예약어  \n    }  \n  \n    public void setPrice(int price) {   // 지역변수 price        \n\t    // 매개변수로 받은 지역변수 price로  \n\t    // 내 자신 인스턴스를 참조하는 this.price를 초기화  \n        this.price = price;  \n    }  \n}  \n  \npublic class BookExam01 {  \n    public static void main(String[] args) {  \n        Book b1 = new Book();  \n        b1.setPrice(500);  \n        System.out.println(b1.getPrice());  \n    }  \n}\n```\n\n\u003chr\u003e\n\n## Object 메서드\n\n==**Object가 오버라이딩하라고 제공하는 메서드**==\n\n- `toString()`\n- `equals()`, `hashCode()`\n- 오버라이딩 하면 자식의 메서드로 실행된다는 의미였지?? 이거 그냥 쓰면 아무 의미없다. ==**무조건 오버라이딩 해서 써야한다.**==\n\n\u003cbr\u003e\n\n### toString()\n\n\u003cbr\u003e\n\n```java\npublic class CarExam02 {  \n    public static void main(String[] args) {  \n        Car c1 = new Car();  \n        System.out.println(c1);  \n    }  \n}\n// Car@7c75222b\n```\n\nCar 클래스는 내가 작성한 클래스이지만, System 클래스는 Java를 만든 사람이 작성한 클래스이다. 그런데 어떻게 컴파일 오류가 안날까? 어떻게 자바 개발자는 오버로딩해서 내가 작성할 코드를 알았을까?\n\n![](brain/image/fun-java04-24.png)\n\n- `println(Object x)`에서 println 메서드가 파라미터로 Object를 받고 있다.\n\n\u003cbr\u003e\n\n우리가 \u003ca href='/brain/Lecture/fun-java/fun-java04/#상속---부모-타입으로-자식-참조' \u003e위에서\u003c/a\u003e 이런 말을 했다.\n- 부모타입의 변수로 자식 인스턴스를 참조할 수 있다.\n- 조상타입의 변수로 후손 인스턴스를 참조할 수 있다.\n\t- `Car c1 = new Bus();` 오류가 안난다면, Bus는 Car의 자식이다.\n\t- `Car c2 = new 이층버스();` 오류가 안난다면, 이층버스는 Car의 자식이다.\n- 근데 아무것도 상속받지 않으면 Object를 상속받는다고 했으니 아래도 가능할 것\n\t- `Object o1 = new Car();`\n\t- `Object o2 = new Bus();`\n\t- `Object o3 = new 이층버스();`\n\n==**따라서, `println(Object x)`의 의미는 Object로 참조할 수 있는 것은 무엇이든 받을 수 있다는 의미이다.**==\n\n\u003cbr\u003e\n\n![](brain/image/fun-java04-25.png)\n\n![](brain/image/fun-java04-26.png)\n\n- `println()` 메서드는 Object가 가지고 있는 `toString()` 메서드를 출력해주는 것\n- `System.out.println(o1.toString()); == System.out.println(o1);`\n\n\u003cbr\u003e\n\n```java\npublic class CarExam02 {  \n    public static void main(String[] args) {  \n        Car c1 = new Car();  \n        System.out.println(c1);  \n        System.out.println(c1.toString());  \n    }  \n}\n\n// Car@7c75222b\n// Car@7c75222b\n```\n\n- 하지만 이 결과는 아무 쓸모가 없음.\n- 오버라이딩하여 내가 원하는 문자열이 출력되게 해보자.\n- `ctrl + enter` 해서 generator 메뉴에서 Override - toString() 생성하기\n\n```java\nclass Car {  \n    public void run() {  \n        System.out.println(\"전륜구동으로 달린다.\");  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return \"자동차\";  \n    }  \n}\n\npublic class CarExam02 {  \n    public static void main(String[] args) {  \n        Car c1 = new Car();  \n        System.out.println(c1);  \n    }  \n}\n\n// 자동차\n```\n\n\u003cbr\u003e\n\n### equals(), hashCode()\n\n`equals()` 메서드\n- 참조가 아니라, 같은 **값**이냐? 를 비교하는 것\n- 따라서, 개발자가 **기준**을 정해줘야함. 반드시 메서드 오버라이딩 해야함.\n\n\u003cbr\u003e\n\nHash(해쉬)라고 불리는 알고리즘이 있다.\n- 이걸 쓰려면 `hashCode()`를 만드는 기능과 `equals()`로 값이 같은지를 비교하는 것이 매우 중요하다. 이때문에 같이 적어놨음\n- Hash, HashSet, HashMap 쓰려면 `hashCode()`, `equals()`를 반드시 오버라이딩 해서 사용해야함.","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java05":{"title":"05. 객체지향 3/3","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 내용\n\n\u003chr\u003e\n\n## 생성자\n\n- 인스턴스를 생성할 때 사용\n- **어떤 값을 가지고 인스턴스가 만들어지게 하고 싶다**면 생성자를 사용\n- 클래스 작성 시 생성자를 하나도 만들지 않았다면 자동으로 기본 생성자(default) 생성자 생성\n\t- 기본생성자는 매개변수를 하나도 받지 않는 생성자를 의미\n- **생성자를 하나라도 만들게 되면 기본 생성자가 자동으로 안만들어짐**  \n- **생성자 오버로딩(Overloading) 가능**\n- ==**`cmd + p` 누르면 생성자에 어떤 파라미터 들어가는지 확인 가능**==\n\n\u003cbr\u003e\n\n**생성자 생성**\n\n```java\nclass Car {\n\tpublic Car() {\n\t\tSystem.out.println(\"자동차가 1대 생성됩니다.\");\n\t}\n}\n```\n- 생성자는 메서드와 비슷하다.\n- ==**return type이 없고, 클래스이름과 같아야 한다.**==\n\n\u003cbr\u003e\n\n**생성자로 만들 때 필드 가지게**\n\n```java\nclass Car {  \n\t// 필드가 가지는 것  \n\t// 처음에 참조형으로 선언하고 초기화 안했으니 당연히 null이겠네\n    private String name;\n  \n    public Car() {  \n        System.out.println(\"자동차가 1대 생성됩니다.\");  \n    }  \n  \n    public Car(String name) {  \n        this.name = name;  \n    }  \n  \n    public void printName() {  \n        System.out.println(\"자동차 이름 : \" + name);  \n    }\n}\n\npublic class CarExam02 {  \n    public static void main(String[] args) {  \n        Car c1 = new Car();  \n        c1.printName();  \n        System.out.println(\"----------------------\");  \n        Car c2 = new Car(\"람보르기니\");  \n        c2.printName();  \n    }  \n}\n\n// 자동차가 1대 생성됩니다.\n// 자동차 이름 : null\n// ----------------------\n// 자동차 이름 : 람보르기니\n```\n\n\u003cbr\u003e\n\n### 불변객체\n\n- 생성자에 넣어준 값은 return하는 기능만 있음.\n- setter 메서드를 만들어놓지 않았음\n- 인스턴스가 만들어질때 값을 넣어주고 getter 메서드만 가지고 있는 객체를 ==**불변 객체(immutable Object)라고 함.**==\n- 태어날 때 어떤 값을 가지고 태어나게 한 다음에 외부에 전달할 때 불변객체를 사용\n\t- 외부에 전달했을 때 값이 바뀌지 않았다는 불변성이 보장되어야 하는 경우 !\n- 참고로, ==**문자열 String 클래스는 대표적인 불변객체이다.**==\n\t- 이 말은 String이 가지고 있는 모든 메서드는 String 내부의 값을 변화시키지 않는다는 의미이다. \n\n```java\npublic class User {  \n    private String email;  \n    private String password;  \n    private String name;  \n  \n    // 생성자를 하나라도 만들게 되면 기본 생성자가 자동으로 안만들어짐  \n    public User(String name, String email) {  \n        this.name = name;  \n        this.email = email;  \n    }  \n  \n    // 생성자 오버로딩(Overloading)  \n    public User(String name, String email, String password) {  \n        this.name = name;  \n        this.email = email;  \n        this.password = password;  \n    }  \n  \n    public String getEmail() {  \n        return email;  \n    }\n  \n    public String getName() {  \n        return name;  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### 생성자 toString()으로 출력\n\n근데 귀찮게 매번 `user.getName()`, `user.getEmail()` 이렇게 한꺼번에 하기 힘들지않니? 이전시간에 배운 `toString() 오버라이딩`을 이용해보자.\n\n\u003cbr\u003e\n\n```java\npublic class User {  \n    private String email;  \n    private String password;  \n    private String name;  \n  \n    // 생성자를 하나라도 만들게 되면 기본 생성자가 자동으로 안만들어짐  \n    public User(String name, String email) {  \n        this.name = name;  \n        this.email = email;  \n    }  \n  \n    // 생성자 오버로딩(Overloading)  \n    public User(String name, String email, String password) {  \n        this.name = name;  \n        this.email = email;  \n        this.password = password;  \n    }  \n  \n    public String getEmail() {  \n        return email;  \n    }  \n  \n    public String getName() {  \n        return name;  \n    }  \n\n\t// password는 일부로 뺐음\n    @Override  \n    public String toString() {  \n        return \"User{\" +  \n                \"email='\" + email + '\\'' +  \n                \", name='\" + name + '\\'' +  \n                '}';  \n    }  \n}\n\npublic class UserExam {  \n    public static void main(String[] args) {  \n        User user2 = new User(\"신재윤\", \"wlwhsvkdlxh@gmail.com\", \"1234\");  \n        System.out.println(user2);  \n    }  \n}\n\n// User{email='wlwhsvkdlxh@gmail.com', name='신재윤'}\n```\n\n\u003cbr\u003e\n\n### this 생성자\n\n근데 위에 생성자쪽 코드보면 중복이 생긴다. `this.name=name;`, `this.email=email;`\n\n```java\npublic User(String name, String email) {  \n    this.name = name;  \n    this.email = email;  \n}  \n  \npublic User(String name, String email, String password) {  \n    this.name = name;  \n    this.email = email;  \n    this.password = password;  \n}\n```\n\n- 위에껀 2개를 받는 생성자\n- 아래껀 3개를 받는 생성자\n- 중복된 코드를 줄이기 위하여 생성자 안에서 자기 자신의 생성자를 호출할 수 있음\n\n```java\npublic User(String name, String email) {  \n\t// password는 없으니까 null\n    this(name, email, null);\n}  \n  \npublic User(String name, String email, String password) {  \n    this.name = name;  \n    this.email = email;  \n    this.password = password;  \n}\n```\n\n- 되도록 파라미터를 많이 받아들이는 쪽의 생성자를 this로 호출!\n\t- 2개쪽에서 3개쪽의 생성자를 호출\n-  ==**this는 인스턴스 자기 자신을 참조할 때 사용하는 키워드**==\n\t- this() 생성자는 자기 자신의 생성자를 의미\n\t- this() 생성자는 생성자 안에서만 사용 가능\n\t- this() 생성자는 생성자 안에서 super() 생성자를 호출하는 코드 다음이나, 첫 번째 줄에 위치해야함.\n\n\u003cbr\u003e\n\n### super()\n\n- ==**super는 인스턴스 부모를 참조할 때 사용하는 키워드**==\n- super() 생성자는 부모 생성자를 의미\n- super() 생성자는 생성자 안에서만 사용 가능\n- super() 생성자는 생성자 안에서 무조건 첫 번째 줄\n- 생성자는 무조건 super() 생성자를 호출해야 한다.\n\t- ==**사용자가 super() 생성자를 호출하는 코드를 작성하지 않았다면 자동으로 부모의 기본 생성자가 호출**==된다.\n- ==**부모클래스가 기본 생성자를 가지고 있지 않다면, 사용자는 반드시 자식 클래스에서 직접 super() 생성자를 호출하는 코드를 작성해야 한다.**==\n\n\u003cbr\u003e\n\n```java\npublic class Car2 {  \n    public Car2() {  \n        System.out.println(\"Car2() 생성자 호출\");  \n    }  \n}\n\npublic class Bus2 extends Car2{  }\n\npublic class Car2Exam {  \n    public static void main(String[] args) {  \n        Car2 c1 = new Car2();  \n        Bus2 b1 = new Bus2();  \n    }  \n}\n\n// Car2() 생성자 호출\n// Car2() 생성자 호출\n```\n\n- Bus2 클래스에 아무것도 안적었는데 이게 무슨일 !?\n- 사실 기본 생성자(=디폴트 생성자)에 `super()` 메서드가 컴파일 타임에 자동으로 들어가서 그렇다.\n\n```java\npublic class Car2 {  \n    public Car2() {  \n\t    super();  // 자동으로 들어간다.\n        System.out.println(\"Car2() 생성자 호출\");  \n    }  \n}\n\npublic class Bus2 extends Car2{ \n\tpublic Bus2() { // 자동으로 들어간 디폴트 생성자\n\t\tsuper();  // 자동으로 들어간다.\n\t}\n}\n\npublic class Car2Exam {  \n    public static void main(String[] args) {  \n        Car2 c1 = new Car2();  \n        Bus2 b1 = new Bus2();  \n    }  \n}\n\n// Car2() 생성자 호출\n// Car2() 생성자 호출\n```\n\n- 실질적인 코드는 이와 같다.\n\n```java\npublic class Car2 {  \n    public Car2() {  \n        System.out.println(\"Car2() 생성자 호출\");  \n    }  \n}\n\npublic class Bus2 extends Car2{ \n\tpublic Bus2() {\n\t\tSystem.out.println(\"Bus2() 생성자 호출\");\n\t}\n}\n\npublic class Car2Exam {  \n    public static void main(String[] args) {  \n        Car2 c1 = new Car2();  \n        Bus2 b1 = new Bus2();  \n    }  \n}\n\n// Car2() 생성자 호출\n// Car2() 생성자 호출\n// Bus2() 생성자 호출\n```\n\n- 이 코드도 자동으로 `super()` 이 자동으로 추가되어서 부모 생성자도 같이 호출됨\n\n\u003cbr\u003e\n\n### 부모에 기본생성자 없으면?\n\n- 만약 아래와 같이 부모 Car2 클래스에서 기본 생성자가 없는 상황이라고 하자.\n\n```java\npublic class Car2 {  \n    public Car2(String name) {  \n        System.out.println(\"Car2() 생성자 호출\");  \n    }  \n}\n```\n\n```java\npublic class Bus2 extends Car2{  \n    public Bus2() {  \n        super();  // 에러!!\n        System.out.println(\"Bus2() 생성자 호출\");  \n    }  \n}\n```\n\n이러면 Car2를 상속받는 Bus2의 `super()` 에서 문제가 생긴다. \n- 부모가 기본생성자를 가지고 있지 않으니까, 그에 맞는 형식으로 만들어줘야함\n- ==**부모가 기본 생성자가 없으면, 자식 생성자에서는 부모가 가지고 있는 생성자를 super를 통해 호출해줘야한다. 안그러면 컴파일 오류난다.**==\n\n\u003chr\u003e\n\n## 추상 클래스\n\n- 추상 클래스는 ==**인스턴스가 될 수 없는 클래스**==\n\t- 추상 클래스를 상속받는 자손이 인스턴스가 된다.\n\t- 따라서, 반드시 자식 클래스가 필요하다.\n- `abstract` 키워드를 사용하여 클래스 정의\n- 추상 클래스는 보통 1개 이상의 추상 메서드 가짐\n\t- 추상 메서드가 없어도 오류가 발생하진 않음\n\t- 추상 메서드는 메서드가 선언만 되어있고 구현되어있지 않은 메서드\n- `public abstract class 클래스명 { ... }`\n- ==**즉, 추상 클래스는 미완성인 클래스이다. 메서드가 여러 개 있다면 그 중 몇 개는 구현되어있지 않고 선언만 되어있음**==\n\n\u003cbr\u003e\n\n```java\npublic abstract class Car2 {  \n    public Car2(String name) {\n        System.out.println(\"Car2() 생성자 호출\");  \n    }  \n\n    public abstract void run();  \n}\n```\n\n- 추상 메서드 `run()`가 선언만 되어있고 구현되어있지는 않다.\n- Car2 추상 클래스를 상속받는 자식들은 `run()` 메서드를 구현하지 않으면 컴파일 에러가 발생한다.\n\n\u003cbr\u003e\n\n```java\npublic class Bus2 extends Car2 {  \n    public Bus2() {  \n        super(\"Bus!!\");  \n        System.out.println(\"Bus2 기본 생성자\");  \n    }  \n\n    @Override  \n    public void run() {  \n        System.out.println(\"후륜구동으로 동작한다.\");  \n    }  \n}\n\npublic class SportsCar extends Car2 {  \n    public SportsCar(String name) {  \n        super(name);  \n    }  \n  \n    @Override  \n    public void run() {  \n        System.out.println(\"사륜구동으로 동작한다.\");  \n    }  \n}\n```\n\n- Car2를 상속받은 두 클래스 모두 `run()` 메서드를 `@Override`를 이용하여 오버라이딩해서 구현했다.\n- 부모가 기본 생성자가 없기 때문에 반드시 super()를 호출하는 모습 또한 확인가능하다.\n\n\u003cbr\u003e\n\n### 인스턴스를 만들면 어떻게 될까?\n\n**아래와 같은 코드일 때 어떤 결과가 나올까?**\n\n\u003cbr\u003e\n\n```java\nCar2 c = new Car2();  \nc.run();\n```\n\n- `Car2' is abstract; cannot be instantiated` 오류 발생\n- 추상 클래스는 인스턴스가 될 수 없는 클래스이니까!\n\n\u003cbr\u003e\n\n### 부모 타입으로 자식 참조\n\n\u003cbr\u003e\n\n```java\nCar2 c = new Bus2();\nc.run()\n\n// Car2() 생성자 호출\n// Bus2 기본 생성자\n// 후륜구동으로 동작한다.\n```\n\n- 이전 시간에 한 것처럼 부모의 타입으로 자식 인스턴스를 참조한다.\n- ==**메서드가 오버라이딩되면 무조건 자식의 메서드가 실행되니까**==\n\n\u003cbr\u003e\n\n### 추상클래스와 배열\n\n\u003cbr\u003e\n\n```java\npublic class Car2Exam {  \n    public static void main(String[] args) {  \n        Car2[] array = new Car2[2];  \n        array[0] = new Bus2();  \n        array[1] = new SportsCar(\"스포츠카\");  \n        for (Car2 c2 : array) {  \n            c2.run();  \n        }  \n    }  \n}\n```\n\n- Car2를 2개 참조할 수 있는 배열을 선언  \n- 자동차의 배열 = 자동차의 후손들을 참조할 수 있는 배열\n- 오브젝트 배열 = 모든 객체를 참조할 수 있는 배열  \n- ==**일반화시켜서 여러가지 것들을 마치 하나의 종류인 것처럼 다룰 수 있다. 추상클래스와 배열을 사용하면 편리하게 다룰 수 있음!**==\n\t- 그래서, 버스든 스포츠카든 자동차라는 하나의 종류로 일반화시켜서 다루는 것\n\n\u003cbr\u003e\n\n### 템플릿 메서드 패턴, protected\n\n==**추상 클래스는 템플릿 메서드 패턴(Template Method Pattern)에서 가장 많이 사용된다고 생각함.**==\n\n프로그래밍을 작성하는데, 어떤 기능들이 있다고 하자. 이 기능들은 항상 **초기화, 실행, 마무리**의 순서로 작성되어야한다. 그런데 이때, **초기화와 마무리는 동일하고 실행만 다르다**고 해보자. Controller 클래스를 상속받도록 하여 만들자.\n\n\u003cbr\u003e\n\n```java {title=\"Controller.java\"}\npublic abstract class Controller {  \n    public void init() {  \n        System.out.println(\"초기화 하는 코드\");  \n    }  \n  \n    public void close() {  \n        System.out.println(\"마무리 하는 코드\");  \n    }  \n  \n    public abstract void run(); // 매번 달라지는 코드  \n  \n    public void execute() {  \n        this.init();\n        this.run();  \n        this.close();  \n    }  \n}\n```\n\n- `init()`과 `close()`는 미리 구현해놓고 `run()`은 추상 메서드로 선언하여 선언만하고 구현은 Controller를 상속받는 클래스에게 하도록 한다.\n- 추가로 `execute()` 메서드를 만들어서 ==**정해진 순서대로 실행하도록 만든 메서드를 추가했다. 이런 메서드를 템플릿 메서드라고 한다.**==\n\n\u003cbr\u003e\n\n```java {title=\"FirstController.java\"}\npublic class FirstController extends Controller {  \n    @Override  \n    public void run() {  \n        System.out.println(\"별도로 동작하는 코드 111111\");  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"ControllerMain.java\"}\npublic class ControllerMain {  \n    public static void main(String[] args) {  \n        Controller c1 = new FirstController();  \n        c1.execute();  \n        }  \n}\n```\n\n- 부모 타입(Controller)으로 자식(FirstController)을 참조하도록 했다.\n- 하지만 이렇게하면 **부모 클래스인 Controller의 init과 close 메서드의 접근제한자가 public이라서 ControllerMain 클래스에서 `c1.init()`과 같은 형태로 사용할 수 있게 되버린다.**\n\n\u003cbr\u003e\n\n```java {title=\"Controller.java\"}\npublic abstract class Controller {  \n    protected void init() {  \n        System.out.println(\"초기화 하는 코드\");  \n    }  \n  \n    protected void close() {  \n        System.out.println(\"마무리 하는 코드\");  \n    }  \n  \n    public abstract void run(); // 매번 달라지는 코드  \n  \n    public void execute() {  \n        this.init();\n        this.run();  \n        this.close();  \n    }  \n}\n```\n\n- 접근제한자 public을 protected으로 바꿔서 상속받는 클래스만 사용할 수 있게 코드를 수정했다.\n- ==**접근제한자 protected는 동일한 패키지 내에 존재하거나, 상속받는 클래스만 사용 가능**==하다.\n- 하지만, 이렇게하면 문제점이 `init()`과 `close()`를 상속받는 클래스에서 수정할 수 있다.\n\n\u003cbr\u003e\n\n```java {title=\"Controller.java\"}\npublic abstract class Controller {  \n    protected final void init() {  \n        System.out.println(\"초기화 하는 코드\");  \n    }  \n  \n    protected final void close() {  \n        System.out.println(\"마무리 하는 코드\");  \n    }  \n  \n    public abstract void run(); // 매번 달라지는 코드  \n  \n    public void execute() {  \n        this.init();\n        this.run();  \n        this.close();  \n    }  \n}\n```\n\n- init()과 close()의 수정을 막기 위해 ==**`final` 키워드를 붙여 재선언이 불가능하게 만들었다.**==\n\n\u003cbr\u003e\n\n정리한 내용은 아래와 같다.\n\n\u003e - 반복되는 메서드는 미리 선언과 구현을 해줬음\n\u003e - 매번 달라지는 메서드는 추상 메서드로 선언만 하고 구현은 상속받는 클래스에 넘김\n\u003e - 제작자가 원하는 순서대로 메서드가 실행되도록 **템플릿 메서드를 구현**했음\n\u003e - 사용하는 곳에서 반복되는 메서드를 직접 사용하지는 못하게 접근제한자를 protected으로 수정했음\n\u003e - 상속받는 곳에서 반복되는 메서드를 직접 수정하지 못하게 final 키워드를 추가했음\n\n\u003cbr\u003e\n\n### 접근제한자\n\n\u003cbr\u003e\n\n| 접근제한자 | 클래스 내부 | 동일 패키지 | 하위 클래스 | 그 외 |\n|:----------:|:-----------:|:-----------:|:-----------:|:-----:|\n|   **public**   |      O      |      O      |      O      |   O   |\n| **protected**  |      O      |      O      |      O      |   X   |\n|  **default(없음)**   |      O      |      O      |      X      |   X   |\n|  **private**   |      O      |      X      |      X      |   X   | \n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## final 클래스, 불변객체 String\n\n### final\n\n- 부모가 될 수 없는 클래스가 있다.\n\t- abstract 클래스는 인스턴스가 될 수 없기 때문에 반드시 자식이 필요하다고 했다.\n- ==**상속을 금지시키려면 클래스를 정의할 때 final 키워드를 사용한다.**==\n- `public final class 클래스명 { ... }`\n\n\u003cbr\u003e\n\n### String 클래스\n\n- String 클래스는 대표적인 ==**final 클래스이다. 따라서, 상속받을 수 없다.**==\n- String은 대표적인 ==**불변 객체**==이다. 따라서, 문자열을 만들 때마다 내부적으로 새로운 문자열을 만든다.\n\n\u003cbr\u003e\n\n```java {title=\"StringExam.java\"}\npublic class StringExam {  \n    public static void main(String[] args) {  \n        String str1 = \"hello\";  \n        String str2 = \"hello\";  \n        String str3 = new String(\"Hello\");  \n        String str4 = new String(\"hello\");  \n  \n        if (str1 == str2)  \n            System.out.println(\"str1 == str2\");  \n        if (str1 == str3)  \n            System.out.println(\"str1 == str3\");  \n        if (str3 == str4)  \n            System.out.println(\"str3 == str4\");  \n    }  \n}\n\n// str1 == str2\n```\n\n- `\"\"`로 선언한 문자열은 Heap 영역의 String Pool에 미리 저장되고, 동일한 문자열에 대해서 동일하게 참조를 한다. 따라서, ==**String은 불변을 보장한다는 의미이다.**==\n- new로 선언하면 Heap 영역에 인스턴스 형태로 매번 새로 생성한다. 따라서 메모리 낭비이기 때문에 String을 new로 선언하는 것은 좋지 못하다.\n\n\u003cbr\u003e\n\n### equals()\n\n- ==**문자열의 값이 같은지를 확인할 때는 `equals()` 메서드를 사용하자.**==\n- `toUpperCase()`는 소문자를 대문자로 바꾸는 메서드\n- `substring()`은 파라미터에 입력한 인덱스부터 출력해주는 메서드\n\n```java {title=\"StringExam02.java\"}\npublic class StringExam2 {  \n    public static void main(String[] args) {  \n        String str1 = \"hello\";  \n        String str2 = new String(\"hello\");  \n  \n        if (str1.equals(str2)) {    // 값이 같나요?  \n            System.out.println(\"str1과 str2의 값이 같다.\");  \n        }  \n  \n        String s = str1.toUpperCase();  \n        System.out.println(s);  \n        System.out.println(str1);  \n  \n        String substring = str1.substring(3);  \n        System.out.println(substring);  \n        System.out.println(str1);  \n    }  \n}\n// str1과 str2의 값이 같다.\n// HELLO\n// hello\n// lo\n// hello\n```\n\n\u003chr\u003e\n\n## 인터페이스\n\n==**인터페이스(interface)는 기능들의 목록이다. 선언만 있고 구현은 없다.**==\n\n- \"무슨 기능을 만들어야 할까?\" vs \"구현부터 하기\"\n- ==**어떤 기능을 만들어야 할 지 부터 고민하자**==\n\t- 회원가입 기능? 로그인 기능? 게시판 글쓰기 기능?\n- 만들어야 할 기능들을 관련된 것끼리 묶은 후 이름을 지어준다.\n\t- 기능들을 잘 모아서 가지는 것을 **응집도가 높다!** \n- 다시 한 번 말하지만, ==**설계라는 것은 이름을 정하는 것**==이다.\n\t- 클래스의 이름을 정하고 메서드의 이름을 정하고 그들간의 관계를 형성\n\n\u003cbr\u003e\n\n### 인터페이스 작성법\n\n\u003cbr\u003e\n\n```java\n[public] interface 인터페이스이름 { ... }\n\n// 예시\npublic interface User { ... }\n```\n\n- \"인터페이스이름\"은 Upper Camel Case로 작성\n- interface도 확장자가 .java 파일로 작성\n- interface도 추상 클래스처럼 인스턴스화 할 수 없다.\n- **인터페이스의 모든 필드는 public static final 이어야 하며, 모든 메서드는 public abstract** 이어야 한다.\n\t- ==**필드가 public static 하다는 건 메모리에 인스턴스가 올라가지 않아도 사용할 수 있다는 의미**==이다.\n\t- 따라서, `클래스명.필드명`이 가능하다는 의미\n\t- ==**메서드가 추상메서드라는 말은 구현하는 클래스에서 메서드를 오버라이딩 해야한다는 것**==\n- Java 7까지는 **final, abstract를 생략하면 자동으로 붙는다.**\n- Java 8부터는 **디폴트(default) 메서드와 정적(static) 메서드도 선언 가능**\n\n\u003cbr\u003e\n\n### JDK8 추가 문법\n\n- A라는 사용자가 3개의 메서드가 선언된 인터페이스를 작성한 후 라이브러리로 제공하는 형태로 외부에 공개하였음\n- 여러 사용자가 해당 인터페이스를 이용해 구현함\n- A라는 사용자가 인터페이스에 1개의 메서드를 추가하였음\n- 여러 사용자들은 라이브러리가 업데이트 된 줄 알고 업데이트함. 어떤 일이 발생할까?\n\t- 새로 추가된 추상 메서드 때문에 컴파일 에러가 발생할 것\n\n\u003cbr\u003e\n\n이 때문에 ==**디폴트(default) 메서드**==가 나왔다.\n- 새로 추가된 메서드를 선언만 한게 아니라 ==**구현까지 해버린 것**==\n- 그래서 라이브러리 업데이트 해도 마치 상속받는 것처럼 추가된 메서드를 사용할 수 있음\n- 원한다면 메서드 오버라이딩도 가능!\n\n\u003cbr\u003e\n\n추가로 ==**정적(static) 메서드**==도 추가되었다.\n- 인터페이스를 구현한 클래스가 없어도 `인터페이스명.method()`의 형태로 사용가능\n\n\n\u003cbr\u003e\n\n### 로또 번호 생성기 실습\n\n먼저, 구현할 기능에 대한 인터페이스 작성을 해보자.\n\n1. 1~45까지 번호가 있는 공을 로또 기계에 넣는다.\n2. 로또 기계에 있는 공들을 섞는다.\n3. 섞인 공 중 6개를 꺼낸다.\n\n\u003cbr\u003e\n\n```java {title=\"LottoMachine.java\"}\npublic interface LottoMachine {  \n    int MAX_BALL_COUNT = 45;  \n    int RETURN_BALL_COUNT = 7;  \n  \n    public void setBalls(Ball[] balls); // Ball[]은 Ball 여러 개를 받겠다. 45개를 받는다.  \n    public void mix();  // 자기가 가지고 있는 Ball들을 섞는다.  \n    public Ball[] getBalls();   // 6개의 Ball을 반환한다.  \n}\n```\n\n- 모든 필드에는 `public static`, 모든 메서드에는 `abstract`를 붙여야하지만, Java 8부터는 생략해도 자동으로 붙는다.\n- 필드가 public static 하다는거니까 `LottoMachine.MAX_BALL_COUNT`처럼 쓸 수 있다는 의미\n- 생각의 과정\n\t- 코드를 보면 `Ball[]`을 쓰니까 Ball 객체를 위해 Ball 클래스를 만들어야겠네.\n\t- 인터페이스를 구현할 LottoMachineImpl 클래스를 만들어야겠네.\n\t- 메인 메서드를 포함할 LottoMachineMain 클래스를 만들어야겠네.\n\n\u003cbr\u003e\n\n```java {title=\"Ball.java\"}\n// 생성자를 통해서만 값을 받고 setter가 없으니 불변객체\npublic class Ball {  \n    private int number;  \n  \n    public Ball(int number) {  \n        this.number = number;  \n    }  \n  \n    public int getNumber() {  \n        return number;  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"LottoMachineImpl.java\"}\n// 인터페이스를 구현하게 되면 반드시 인터페이스가 가지고 있는 메서드를 오버라이딩 할 필요가 있다.  \npublic class LottoMachineImpl implements LottoMachine {  \n  \n    private Ball[] balls;  \n  \n    @Override  \n    public void setBalls(Ball[] balls) {  \n        this.balls = balls;  \n    }  \n  \n    @Override  \n    public void mix() {  \n        for(int i = 0; i \u003c 10000; i++) {  \n            int x1 = (int) (Math.random() * LottoMachine.MAX_BALL_COUNT);  \n            int x2 = (int) (Math.random() * LottoMachine.MAX_BALL_COUNT);  \n            if (x1 != x2) {  \n                Ball tmp = balls[x1]; // 값을 치환할 때는 같은 Type의 임시변수가 필요하다.  \n                balls[x1] = balls[x2];  \n                balls[x2] = tmp;  \n            }  \n        }  \n    }  \n  \n    @Override  \n    public Ball[] getBalls() {  \n        // Ball 6개를 참조할 수 있는 배열  \n        Ball[] result = new Ball[LottoMachine.RETURN_BALL_COUNT];  \n        for (int i = 0; i \u003c LottoMachine.RETURN_BALL_COUNT; i ++) {  \n            result[i] = balls[i];  \n        }  \n        return result;  \n    }  \n}\n```\n\n- `Math.random()` : 숫자를 랜덤하게 정하고 싶을 때\n\t- 이 메서드는 `0.0 \u003c= x \u003c 1.0`의 실수값이 나온다. 예를 들어, 0.5432342 같은거\n\t- 여기에 45를 곱했다고 생각해보자. `0.0 \u003c= x \u003c 45.0`이겠네\n\t- 이걸 int로 형변환 해주면 정밀한 범위 -\u003e 덜 정밀한 범위니까 정보의 손실 발생\n\t- 따라서, `0 \u003c= x \u003c 45`니까 0~44 정수겠네!\n- 이렇게 랜덤한 값을 구하고 나면 둘을 swap 한다.\n\t- 0~44 인덱스를 가지는 배열이 있다.\n\t- 랜덤하게 뽑은 인덱스가 3번과 9번이라고 하자.\n\t- 3번 인덱스는 숫자가 4인 공을 참조, 9번 인덱스는 숫자가 10인 공을 참조\n\t- 이때, 참조를 서로 바꾼다. 3번 인덱스는 숫자가 10인 공을 참조하게 바꾸고 9번 인덱스는 숫자가 4인 공을 참조하도록 바꾼다.\n\t- 컴퓨터는 속도가 빠르기 때문에 이 과정을 10,000번 반복한다.\n\t- 이러면 공을 섞는 효과가 나는 것이다.\n\n\u003cbr\u003e\n\n```java {title=\"LottoMachineMain.java\"}\npublic class LottoMachineMain {  \n    public static void main(String[] args) {  \n        Ball[] balls = new Ball[LottoMachine.MAX_BALL_COUNT];  \n        for (int i = 0; i \u003c LottoMachine.MAX_BALL_COUNT; i++) {  \n            balls[i] = new Ball(i + 1);  \n        }  \n  \n        // 인터페이스도 참조하는 레퍼런스 타입은 가능하다.  \n        // LottoMachine 인스턴스가 생성된다.  \n        LottoMachine lottoMachine = new LottoMachineImpl();  \n        lottoMachine.setBalls(balls);  \n        lottoMachine.mix();  \n        Ball[] result = lottoMachine.getBalls();  \n  \n        for (int i = 0; i \u003c result.length; i++) {  \n            System.out.println(result[i].getNumber());  \n        }  \n    }  \n}\n```\n\n- `Ball b1 = new Ball(1);`과 같이 b1~b45까지 한다고 하면, 변수가 45개나 필요하다.\n\t- 이렇게 ==**같은 타입의 변수가 여러 개 필요한 상황에 배열을 사용하면 유용하다.**==\n- `Ball[] balls = new Ball[45];`와 같이 배열로 만들었음\n\t- Ball 인스턴스 45개를 참조할 수 있는 배열이 만들어진 것\n\t- 방이 45개 있는 것이고, 각각의 방이 인스턴스를 참조할 수 있는 변수\n\t- 따라서, 아직은 참조형 변수를 초기화 안해서 null을 참조하는 상태\n- `balls[i] = new Ball(i + 1);`\n\t- Ball 인스턴스를 만들어서 방이 이것을 참조하게 만들었음\n- 즉, **배열 변수인 balls는 배열의 방을 참조하고 배열의 방은 Ball 인스턴스를 참조하는 형태**\n\n![](brain/image/fun-java05-1.png)\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 팩토리 메서드 패턴\n\n- 자동차를 구입하여 사용하고 싶은데, 고객 입장에서 자동차가 만들어지는 과정은 궁금하지 않음\n- 객체가 생성되는 과정을 숨겨주는 패턴이 팩토리 메서드 패턴이다.\n- ==**공장에서 하는 복잡한 생산 과정을 숨기고, 완성된 인스턴스만 반환한다.**==\n\n\u003cbr\u003e\n\n```java {title=\"BeanFactory.java\"}\npublic class BeanFactory {  \n    // 1. private 생성자를 만들어서 외부에서 인스턴스를 생성하지 못하게 한다.  \n    private BeanFactory() {}  \n  \n    // 2. 자기 자신 인스턴스를 참조하는 static한 필드를 선언한다.  \n    private static BeanFactory instance = new BeanFactory();  \n  \n    // 3. 2번에서 생성한 인스턴스를 반환하는 static한 메서드를 만든다.  \n    public static BeanFactory getInstance() {  \n        return instance;  \n    }\n\n\t// 객체 생성 메서드\n\tpublic Bus getBus() {  \n\t    return new Bus();  \n\t}\n}\n```\n\n- 싱글턴 패턴으로 작성된 BeanFactory 클래스가 있다고 하자.\n- 여기에 `getBus()` 메서드를 통해 `new Bus()`라는 새로 생성한 인스턴스를 반환한다.\n\n\u003cbr\u003e\n\n```java {title=\"BeanFactoryMain.java\"}\npublic class BeanFactoryMain {  \n    public static void main(String[] args) {  \n        BeanFactory bf1 = BeanFactory.getInstance();  \n        BeanFactory bf2 = BeanFactory.getInstance();  \n        if (bf1 == bf2) {  \n            System.out.println(\"bf1 == bf2\");  \n        }  \n  \n        Bus b1 = bf1.getBus();  \n        Bus b2 = bf1.getBus();\n    }  \n}\n```\n\n- 원래는 객체를 사용하는 클래스에서 `Bus bus = new Bus();`와 같이 직접 인스턴스를 생성했다면, 팩토리 메서드 패턴을 통해 객체 생성 과정을 가릴 수 있다.\n- `Bus bus = bf1.getBus();`라고 작성하면 bf1에 객체 생성을 맡겨서 그 과정을 가릴 수 있게 된다. ==**객체 생성을 대신 해주는 곳을 팩토리라고 한다.**==\n\n\u003cbr\u003e\n\n### 클래스로더 이용 인스턴스 생성\n\n생각의 과정을 살펴보자.\n\n1. `a()` 메서드를 가지는 클래스가 있다.\n2. 하지만 클래스의 이름을 아직은 모른다.\n3. 나중에 클래스 이름을 가르쳐준다.\n4. 이때 `a()` 메서드를 실행할 수 있도록 코드를 작성하라.\n\n\u003cbr\u003e\n\n이런 경우, 사용할 수 있는 방법이 클래스로더를 이용한 인스턴스 생성이다.\n- JVM의 클래스로더는 클래스를 CLASSPATH 에서 찾는다.\n- 이를 이용하면 아래의 코드와 같다.\n\n```java\nString className = \"클래스풀네임\";\nClass clazz = Class.forName(className);\nObject obj = clazz.newInstance();\n```\n\n\u003cbr\u003e\n\n예를 들어, Car 추상 클래스가 있고 이를 상속받는 Bus, SuperCar 클래스가 있다고 하자.\n\n\u003cbr\u003e\n\n```java {title=\"chap05/Car.java\"}\npublic abstract class Car {  \n    public abstract void a();  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"chap05/Bus.java\"}\npublic class Bus extends Car {  \n    public void a() {  \n        System.out.println(\"Bus 클래스 a()\");  \n    }\n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"chap05/SuperCar.java\"}\npublic class SuperCar extends Car {  \n    public void a() {  \n        System.out.println(\"SuperCar 클래스 a()\");  \n    }\n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"ClassLoaderMain.java\"}\npublic class ClassLoaderMain {  \n    public static void main(String[] args) throws Exception {  \n        String className = \"chap05.Bus\";  \n        Class clazz = Class.forName(className);  \n        Object obj = clazz.newInstance();  \n\n\t\tCar car = (Car)obj;\n    }  \n}\n\n// Bus 클래스 a()\n```\n\n- className에 해당하는 클래스 정보를 CLASSPATH에서 읽어들이고 그 정보를 참조변수 clazz가 참조하도록 하였다.\n- 그를 통해 인스턴스를 생성하고 obj에 저장했다.\n- Bus와 SuperCar를 Car라는 추상 클래스로 일반화하여 형변환 했다.\n\t- 이때문에 className이 `chap05.Bus`든 `chap05.SuperCar`든 상관없다.\n\n그러나, 만약 아예 Car와 관련없는 MyHome이라는 클래스를 받아온다면? 위 코드는 동작하지 않을 것이다. Car 타입으로 형변환 할 수 없기 때문이다.\n\n\u003cbr\u003e\n\n```java {title=\"ClassLoaderMain.java\"}\npublic class ClassLoaderMain {  \n    public static void main(String[] args) throws Exception {  \n        String className = \"chap05.MyHome\";  \n        Class clazz = Class.forName(className);  \n        Object obj = clazz.newInstance();  \n\n\t\tMethod m = clazz.getDeclaredMethod(\"a\", null);\n\t\tm.invoke(obj, null);\n    }  \n}\n\n// MyHome 클래스 a()\n```\n\n- Method 타입으로 참조하는 참조변수 m은 className에서 `a()` 메서드 정보를 가지고 있는 메서드를 반환받은 것이다. m은 메서드 정보라는 말이다.\n- `m.invoke()`는 Object obj가 참조하는 객체의 m 메서드를 실행하라는 의미이다.\n\n\u003cbr\u003e\n\n\u003e 정리하자면, ==**클래스 정보를 얻고 그 정보를 통해서 인스턴스를 만든다. 그리고 메서드 이름을 통해서 실행한다. 즉, 문자열로 된 클래스 이름과 문자열로 된 메서드 이름만 있어도 인스턴스를 만들도록 표현할 수 있는 방법이 있다는 말이다. 이것이 자바의 리플렉션(Reflection)이다.**==\n\n\u003cbr\u003e\n\n### 팩토리 메서드 패턴 + 리플렉션\n\n- 객체를 생성해주는 공장(팩토리)이 있다.\n- 이 공장에서는 클래스로더를 이용한 인스턴스 생성처럼 리플렉션을 이용해 복잡한 과정을 거쳐 객체를 생성해준다.\n- 하지만 사용하는 입장에서는 이 과정을 모른다.\n- ==**따라서, 복잡한 과정은 모르겠지만, 클래스 이름만 가지고도 인스턴스를 생성해주는 공장을 얻게 된 것이다.**==\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 익명 클래스\n\n### 이름없는 클래스\n\n- Anonymous Class\n- `new 생성자() {...}`\n- 원래라면 생성자가 나오면 세미콜론으로 끝난다.\n\t- `Car car = new Car();`\n- ==**익명 클래스는 생성자 뒤에 중괄호가 나오고 보통 코드를 오버라이딩 하여 구현**==한다.\n- ==**재사용 하지 않고 특정 부분에서만 수행할 때 사용한다.**==\n\n\u003cbr\u003e\n\n```java {title=\"Car.java\"}\npublic abstract class Car {  \n    public abstract void a();  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"CarExam.java\"}\npublic class CarExam {  \n    public static void main(String[] args) {\n        Car car = new Car(){  \n            @Override  \n            public void a() {  \n                System.out.println(\"이름없는 객체의 a() 메서드 오버라이딩\");  \n            }  \n        };  \n  \n        car.a();  \n    }  \n}\n\n// 이름없는 객체의 a() 메서드 오버라이딩\n```\n\n- Car 클래스는 추상 클래스이기 때문에 `Car car = new Car();`와 같이 인스턴스화 할 수 없다.\n- 이때 Car를 상속받고 있기는 하지만 클래스를 만들고 싶지 않다고 하자. 그래서 Car를 상속받고 있는 이름없는 객체를 만들었다.\n- 필요한 부분만 메서드 오버라이딩 하여 사용할 수 있음.\n\n\u003cbr\u003e\n\n```java {title=\"MyRunnable.java\"}\npublic interface MyRunnable {  \n    public void run();  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"MyRunnableMain.java\"}\npublic class MyRunnableMain {  \n    public static void main(String[] args) {  \n        MyRunnable r = new MyRunnable() {  \n            @Override  \n            public void run() {  \n                System.out.println(\"MyRunnable run!!!\");  \n            }  \n        };  \n  \n        r.run();  \n    }  \n}\n\n// MyRunnable run!!!\n```\n\n- 인터페이스도 추상 클래스처럼 인스턴스화 할 수 없다.\n- 하지만, 익명 객체를 만들면 바로 메서드 오버라이딩 되면서 사용할 수 있게 되는 것을 확인할 수 있다.\n\n\u003cbr\u003e\n\n### 추가 예시\n\n\u003cbr\u003e\n\n```java {title=\"MyRunnable.java\"}\npublic interface MyRunnable {  \n    public void run();  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"RunnableExecute.java\"}\npublic class RunnableExecute {  \n    public void execute(MyRunnable myRunnable) {  \n        myRunnable.run();  \n    }  \n}\n```\n\n- 이렇게 인터페이스를 메서드의 매개변수(파라미터)로 넣을 수도 있다.\n\t- 뭐, 인스턴스화만 못할 뿐이지 당연한 것 아니겠는가?\n\n\u003cbr\u003e\n\n```java {title=\"MyRunnableMain2.java\"}\npublic class MyRunnableMain2 {  \n    public static void main(String[] args) {  \n\t\tMyRunnable myRunnable = new MyRunnable() {  \n\t\t    @Override  \n\t\t    public void run() {  \n\t\t        System.out.println(\"hello!!!\");  \n\t\t    }  \n\t\t};  \n\t\t  \n\t\tRunnableExecute runnableExecute = new RunnableExecute();  \n\t\trunnableExecute.execute(myRunnable);  \n    }  \n}\n\n// hello!!!\n```\n\n- RunnableExecute 클래스의 `execute()` 메서드는 MyRunnable 인터페이스를 파라미터로 받고 있다.\n- 따라서, 그에 대하여 익명 객체를 생성하여 파라미터로 넣어줬다.\n- ==**재사용할 일이 없다고 생각하면 이렇게 이름없는 객체를 사용할 수 있다.**==\n\n\u003cbr\u003e\n\n```java {title=\"MyRunnableMain2.java\"}\npublic class MyRunnableMain2 {  \n    public static void main(String[] args) {  \n\t\tRunnableExecute runnableExecute = new RunnableExecute();  \n\t\trunnableExecute.execute(new MyRunnable() {  \n\t\t    @Override  \n\t\t    public void run() {  \n\t\t        System.out.println(\"hello!!!\");  \n\t\t    }});  \n    }  \n}\n\n// hello!!!\n```\n\n- 이와 같이 바로 `execute()` 메서드의 파라미터에서 익명 객체를 생성해줘도 된다. \n\n\u003cbr\u003e\n\n### 람다 인터페이스\n\n==**람다(Lambda) 인터페이스는 메서드를 딱 하나만 가지고 있는 인터페이스 일 때 사용할 수 있다.**==\n- 람다(lambda) interface는 메서드를 딱 \"한 개\" 가지고 있다.\n- 객체를 이름없는 객체로 만들어서 전달할 수 있다.\n- 람다 인터페이스를 사용하는 람다 표현식은 JDK 8에서 추가되었다.\n- JDK 8에 추가된 이러한 문법들을 사용할 때 보통 모던 자바(Modern JAVA)라고 한다.\n- Stream API와 만나면 굉장히 편리하게 사용할 수 있다.\n\n\u003cbr\u003e\n\n```java {title=\"MyRunnableMain2.java\"}\npublic class MyRunnableMain2 {  \n    public static void main(String[] args) {  \n        RunnableExecute runnableExecute = new RunnableExecute();  \n        runnableExecute.execute(() -\u003e {  \n            System.out.println(\"hello!!!\");  \n        });   \n    }  \n}\n// hello!!!\n```\n\n- 추가적인 예시에서 보여줬던 형태 말고 이렇게 작성할 수 있다.\n- ==**이름없는 객체를 간략화시켜서 람다(Lambda) 인터페이스로 구현했다.**==\n\n\u003cbr\u003e\n\n```java\n@Override  \npublic void run() {  \n   System.out.println(\"hello!!!\");  \n}\n\n// 위에께 이렇게 간략화 !\n\n() -\u003e {  \n   System.out.println(\"hello!!!\");  \n}\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java06":{"title":"06. 배열과 Arrays 클래스","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 내용\n\n\u003chr\u003e\n\n## 배열\n\n- ==**참조 타입**==\n- 같은 타입의 변수가 여러 개 필요할 때 사용\n- ==**배열은 참조 전에 반드시 초기화를 하여야 사용 가능하다**==\n\t- 그렇지 않으면 참조타입은 null로 초기화되니까 ==**NullPointerException 발생**==\n- 배열은 **기본형 배열**과 **참조형 배열**로 나뉨\n\t- 기본형 배열 : boolean, byte, short, char, int, long, float, double 타입의 변수를 여러 개 선언할 필요가 있을 때 사용\n\t- 참조형 배열 : 참조형 타입을 참조할 수 있는 배열\n\n\u003cbr\u003e\n\n### 기본형 배열\n\n- boolean, byte, short, char, int, long, float, double 타입의 변수를 여러 개 선언할 필요가 있을 때 사용\n\n```java\n기본형타입[] 변수명;\n기본형타입 변수명[];\n```\n\n\u003cbr\u003e\n\n```java\npublic class Array01 {  \n    public static void main(String[] args) {  \n        int[] array1;  \n        int array2[];  \n        int array3[];\n        // 아직 초기화하지 않았기 때문에 null을 참조\n        \n        array1 = new int[5];  \n        array2 = new int[5];  \n        array3 = new int[0];\n\n\t\tSystem.out.println(array1.length);  \n\t\tSystem.out.println(array2.length);  \n\t\tSystem.out.println(array3.length);\n    }  \n}\n\n// 5\n// 5\n// 0\n```\n\n- array1, array2, array3은 배열을 가리킬 수 있는 변수\n- `array3 = new int[0];`\n\t- 정수를 아무것도 가질 수 없는 배열 인스턴스를 만드는 것\n\t- 길이가 0인 배열\n\n![](brain/image/fun-java06-1.png)\n\n\u003cbr\u003e\n\n```java\npublic class Array02 {  \n    public static void main(String[] args) {  \n        int[] array1, array2;  \n        int array3[], array4;  \n    }  \n}\n```\n\n- 위에껀 int 타입의 배열 array1, array2\n- 아래껀 int 타입의 배열 array3, int 타입의 변수 array4\n- ==**타입 뒤에 `[]`를 선언하여 모두 배열로 선언할 것이냐, 아니면 원하는 변수 뒤에 `[]`를 선언하여 원하는것만 배열로 선언할 것이냐의 차이**==\n\n\u003cbr\u003e\n\n**선언과 동시에 초기화**\n\n\u003cbr\u003e\n\n```java\n기본형타입[] 변수명 = new 기본형타입[배열의크기];\n변수명[index값] = 값;\n기본형타입[] 변수명 = new 기본형타입[]{값1, 값2, ...};\n기본형타입[] 변수명 = {값1, 값2, 값3, ...};\n```\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\u003csummary\u003e\u003cstrong\u003e코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\n```java\npublic class Array03 {  \n    public static void main(String[] args) {  \n        int[] array1 = new int[5];  \n        array1[0] = 1;  \n        array1[1] = 2;  \n        array1[2] = 3;  \n        array1[3] = 4;  \n        array1[4] = 5;  \n  \n        int[] array2 = new int[]{1, 2, 3, 4, 5};  \n        int[] array3 = {1, 2, 3, 4, 5};  \n  \n        System.out.println(\"array1의 값 출력\");  \n        for (int i = 0; i \u003c 5; i++) {  \n            System.out.println(array1[i]);  \n        }  \n  \n        System.out.println(\"array2의 값 출력\");  \n        for (int i = 0; i \u003c 5; i++) {  \n            System.out.println(array2[i]);  \n        }  \n  \n        System.out.println(\"array3의 값 출력\");  \n        for (int i = 0; i \u003c 5; i++) {  \n            System.out.println(array3[i]);  \n        }  \n    }  \n}\n```\n\u003cbr\u003e\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### 참조형 배열\n\n- 배열의 타입이 기본형이 아닌 경우\n- ==**배열 변수가 참조하는 배열의 공간**==이 값을 저장하는 것이 아니라 ==**값을 참조한다**==는 것을 의미\n\n```java {title=\"ItemForArray.java\"}\n// 불변 객체  \npublic class ItemForArray {  \n    private int price;  \n    private String name;  \n  \n    public ItemForArray(int price, String name) {  \n        this.price = price;  \n        this.name = name;  \n    }  \n  \n    public int getPrice() {  \n        return price;  \n    }  \n  \n    public String getName() {  \n        return name;  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"Array04.java\"}\npublic class Array04 {  \n    public static void main(String[] args) {  \n        ItemForArray[] array1;  \n        ItemForArray array2[];  \n        array1 = new ItemForArray[5];  \n        array2 = new ItemForArray[5];  \n    }  \n}\n```\n\n- array1, array2 모두 참조 타입 ItemForArray 인스턴스 5개를 가리킬 수 있는 방이 만들어 진 것이지 ==**아직은 null을 참조하는 상태**==\n- `array1[0] = new ItemForArray(500, \"item01\");`와 같이 인스턴스를 생성해야 가리킨다.\n\n![](brain/image/fun-java06-2.png)\n\n\u003cbr\u003e\n\n**선언과 동시에 초기화**\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\n```java\npublic class Array05 {  \n    public static void main(String[] args) {  \n        ItemForArray[] array1 = new ItemForArray[3];  \n        array1[0] = new ItemForArray(500, \"사과\");  \n        array1[1] = new ItemForArray(300, \"바나나\");  \n        array1[2] = new ItemForArray(900, \"수박\");  \n  \n        ItemForArray[] array2 = new ItemForArray[]{  \n                new ItemForArray(500, \"사과\"),  \n                new ItemForArray(300, \"바나나\"),  \n                new ItemForArray(900, \"수박\")  \n        };  \n  \n        ItemForArray[] array3 = {  \n                new ItemForArray(500, \"사과\"),  \n                new ItemForArray(300, \"바나나\"),  \n                new ItemForArray(900, \"수박\")  \n        }; \n    }  \n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### length\n\n\u003cbr\u003e\n\n```java\npublic class Array06 {  \n    public static void main(String[] args) {  \n        double[] array1 = new double[5];  \n        double[] array2 = {1.5, 2.4, 3.5};  \n        double[] array3;  \n        double[] array4 = null;  \n        System.out.println(array1.length);  \n        System.out.println(array2.length);  \n        //System.out.println(array3.length);  \n        //System.out.println(array4.length);    \n    }  \n}\n\n// 5\n// 3\n// NullPointerException\n// NullPointerException\n```\n\n- 참고로 array1은 기본형 타입인 double이라서 0.0으로 초기화되어있다.\n- **array3은 초기화되어있지 않으니까 자연스럽게 null로 초기화**\n\n\u003cbr\u003e\n\n### ArrayIndexOutOfBoundsException\n\n\u003cbr\u003e\n\n```java\npublic class Array07 {  \n    public static void main(String[] args) {  \n        double[] array1 = {1.5, 2.4, 3.5};  \n        System.out.println(array1[3]);  \n  \n        double[] array2 = new double[0];  \n        System.out.println(array2.length);\n        // 0\n        System.out.println(array2[0]);  \n    }  \n}\n```\n\n- `array1[3]`, `array2[0]`을 참조하려고 하면 초기화 된 배열의 방 크기 범위를 벗어나니까 `ArrayIndexOutOfBoundsException` 발생\n\n\u003cbr\u003e\n\n### 이차원 배열\n\n\u003cbr\u003e\n\n```java\n타입[][] 변수명 = new 타입[행의 수][열의 수];\n변수명[행 인덱스][열 인덱스] = 값;\n```\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\n```java\npublic class Array08 {  \n    public static void main(String[] args) {  \n        int[][] array = new int[2][3];  \n        array[0][0] = 0;  \n        array[0][1] = 1;  \n        array[0][2] = 2;  \n  \n        array[1][0] = 3;  \n        array[1][1] = 4;  \n        array[1][2] = 5;  \n  \n        for (int i = 0; i \u003c array.length; i++) {  \n            for (int j = 0; j \u003c array[i].length; j++) {  \n                System.out.print(array[i][j] + \"\\t\");  \n            }  \n            System.out.println();  \n        }  \n    }  \n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n==**이차원 배열 선언과 동시에 초기화**==\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\n```java\npublic class Array09 {  \n    public static void main(String[] args) {  \n        int[][] array = {  \n                {0, 1, 2},  \n                {3, 4, 5}  \n        };  \n  \n        for (int i = 0; i \u003c array.length; i++) {  \n            for (int j = 0; j \u003c array[i].length; j++) {  \n                System.out.print(array[i][j] + \"\\t\");  \n            }  \n            System.out.println();  \n        }  \n    }  \n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n==**이차원 가변 배열의 선언과 동시에 초기화**==\n\n```java\n타입[][] 변수명 = new 타입[행의 수][];\n변수명[행 인덱스] = new 타입[열의 수];\n```\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003e코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\n```java\npublic class Array10 {  \n    public static void main(String[] args) {  \n        int[][] array = new int[2][];  \n        array[0] = new int[2];  \n        array[1] = new int[3];  \n  \n        array[0][0] = 0;  \n        array[0][1] = 1;  \n        array[1][0] = 2;  \n        array[1][1] = 3;  \n        array[1][2] = 4;  \n  \n  \n        for (int i = 0; i \u003c array.length; i++) {  \n            for (int j = 0; j \u003c array[i].length; j++) {  \n                System.out.print(array[i][j] + \"\\t\");  \n            }  \n            System.out.println();  \n        }  \n    }  \n}\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### for each문\n\n\u003cbr\u003e\n\n```java\nfor (타입 변수명 : 배열명) {\n\t...\n}\n```\n\n- 배열 안에 있는 것을 하나씩 꺼내서 변수명에 담아서 사용할 수 있게 됨\n\n\u003cbr\u003e\n\n```java\npublic class Array12 {  \n    public static void main(String[] args) {  \n        int[] array = {1, 2, 3, 4, 5};  \n  \n        for (int i : array) {  \n            System.out.println(i);  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java\npublic class Array13 {  \n    public static void main(String[] args) {  \n        ItemForArray[] array = {  \n                new ItemForArray(500, \"사과\"),  \n                new ItemForArray(300, \"바나나\"),  \n                new ItemForArray(900, \"수박\")  \n        };  \n  \n        for (ItemForArray i : array) {  \n            System.out.println(i.getName());  \n            System.out.println(i.getPrice());  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n## Arrays\n\n- 배열을 다룰 때 사용하는 유틸리티, 자바가 제공해주는 클래스\n- \u003ca href='https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html' target='_blank'\u003eJava Arrays API\u003c/a\u003e를 확인해보면 static 메서드 임을 확인할 수 있다.\n\t- `Arrays.메서드()`로 사용하면 되겠네\n\n\u003cbr\u003e\n\n### copyOf()\n\n**`Arrays.copyOf(원본배열, 만들배열의크기)`**\n\n\u003cbr\u003e\n\n```java\nimport java.util.Arrays;  \n  \npublic class Array14 {  \n    public static void main(String[] args) {  \n        int[] copyFrom = {1, 2, 3};  \n        \n        int[] copyTo = Arrays.copyOf(copyFrom, copyFrom.length);  \n        for (int c : copyTo) {  \n            System.out.println(c);  \n        }  \n  \n        System.out.println(\"----------------------------------\");  \n  \n        int[] copyTo2 = Arrays.copyOf(copyFrom, 5);  \n        for (int c : copyTo2) {  \n            System.out.println(c);  \n        }\n        \n        System.out.println(\"----------------------------------\");  \n        \n\t\tint[] copyTo3 = copyFrom;  \n\t\tfor (int c : copyTo3) {  \n\t\t    System.out.println(c);  \n\t\t}\n    }  \n}\n\n// 1\n// 2\n// 3\n// ----------------------------------\n// 1\n// 2\n// 3\n// 0\n// 0\n// ----------------------------------\n// 1\n// 2\n// 3\n```\n\n- `Arrays.copyOf(원본배열, 만들배열의크기)`를 이용하여 만든 copyTo는 copyFrom과는 전혀 다른 인스턴스를 가리킨다.\n\t- 따라서, `copyTo != copyFrom`이다.\n- 그러나, `int[] copyTo3 = copyFrom;`는 copyFrom이 참조하는 인스턴스와 동일하게 copyTo가 참조한다. 따라서, `copyTo3 == copyFrom`이다.\n- ==**배열을 복사한다는 것과 참조한다는 것은 전혀 다른 이야기이다.**==\n\n\u003e 참고로, `a == b`는 a와 b가 참조하는 것이 같냐는 것이다.\n\n![](brain/image/fun-java06-3.png)\n\n\u003cbr\u003e\n\n### copyOfRange()\n\n**`Arrays.copyOfRange(원본배열, 시작인덱스, 끝인덱스)`**\n\n- 시작 인덱스부터 끝 인덱스 전까지만 복사해서 배열을 만들어냄\n\n```java\nimport java.util.Arrays;  \n  \npublic class Array15 {  \n    public static void main(String[] args) {  \n        char[] copyFrom = {'h', 'e', 'l', 'l', 'o', '!'};  \n        char[] copyTo = Arrays.copyOfRange(copyFrom, 1, 3);  \n        for (char c : copyTo) {  \n            System.out.println(c);  \n        }  \n    }  \n}\n\n// e\n// l\n```\n\n\u003cbr\u003e\n\n### 얕은복사 vs 깊은복사\n\n- 얕은 복사(Shallow Copy) : 같은 것을 참조\n- 깊은 복사(Deep Copy) : 진짜로 복사가 이루어지게\n\n여긴 나중에 찾아서 다시 공부하기\n\n\u003cbr\u003e\n\n### compare()\n\n**`Arrays.compare(배열1, 배열2)`**\n\n- 리턴값이 정수인 **양수, 0, 음수**\n- `x - y`의 결과이다.\n\t- 양수가 나오면 x가 큰 것\n\t- 0이 나오면 x = y\n\t- 음수가 나오면 y가 큰 것\n\n![](brain/image/fun-java06-4.png)\n\n```java\npublic class Array16 {  \n    public static void main(String[] args) {  \n        int[] array1 = {1, 2, 3, 4, 5};  \n        //int[] array2 = {1, 2, 3, 4, 5};  \n        //int[] array2 = {1, 2, 3, 4, 6};        \n        //int[] array2 = {1, 2, 3, 4, 4};  \n        int compare = Arrays.compare(array1, array2);  \n        System.out.println(compare);  \n    }  \n}\n\n// 0\n// -1\n// 1\n```\n\n\u003cbr\u003e\n\n### sort()\n\n**`Arrays.sort(배열)`**\n\n- 배열 자체를 오름차순으로 정렬해준다.\n- 자바는 내부적으로 DualPivotQuickSort 방식을 채택한다.\n\t- 일반적인 퀵소트와 다르게 피봇을 2개 둬서 구간을 3개로 나눴음\n\t- 삽입정렬과 퀵소트를 섞은 것\n\n\u003e Best Cases : O(nlog(n))  \u003cbr\u003e\n\u003e Average Cases : O(nlog(n))  \u003cbr\u003e\n\u003e Worst Cases :O(n^2)\n\n![](brain/image/fun-java06-5.png)\n\n```java\npublic class Array17 {  \n    public static void main(String[] args) {  \n        int[] array = {5, 1, 3, 4, 2};  \n  \n        Arrays.sort(array);  \n  \n        for (int i : array) {  \n            System.out.println(i);  \n        }  \n    }  \n}\n\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n\u003cbr\u003e\n\n### binarySearch()\n\n**`Arrays.binarySearch(배열, key)`**\n\n- 정렬된 배열로부터 key(찾고자 하는 수)를 이진탐색으로 찾아주는 메서드\n- 해당 key를 찾으면 그 위치를 return\n- 해당 key를 찾지 못하면 `- Insertion Point - 1`을 리턴한다.\n\t- Insertion Point는 key보다 큰 최초의 위치이다.\n\t- 예를 들어, `{1, 3, 5, 7, 9}` 배열이 있고 key는 6이라고 하자.\n\t- 6보다 큰 최초의 위치는 7이니까 7의 인덱스`-3-1`하여 `-4`이 리턴된다.\n\n```java\npublic class Array18 {  \n    public static void main(String[] args) {  \n        int[] array = {5, 1, 3, 4, 2};  \n  \n        Arrays.sort(array);  \n  \n        int i = Arrays.binarySearch(array, 3);  \n        System.out.println(i);  \n    }  \n}\n\n// 2\n// 정렬된 배열이 {1, 2, 3, 4, 5}이고\n// 3은 인덱스 2에 위치하니까\n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Comparable\n\n- Comparable은 Object의 어떤 부분이 큰 지, 작은 지 기준을 정하는 Interface이다.\n\n\u003cbr\u003e\n\n`Arrays.sort()` 메서드는 Object 배열도 sort가 가능하다고 나오는데, 막상 참조형 타입으로 인스턴스를 생성하고 나면 `ClassCastException`이 발생한다. 이는 정렬을 하기 위해 먼저 비교가 되어야 한다는 건데, 기준에 따라 달라지는 비교라면 정렬이 되지 않는다.\n\n```java\npublic class ArraySort {  \n    public static void main(String[] args) {  \n        Item[] items = new Item[]{  \n                new Item(\"java\", 5000),  \n                new Item(\"python\", 4000),  \n                new Item(\"c++\", 7500),  \n                new Item(\"javascript\", 1000),  \n                new Item(\"dart\", 20000)  \n        };  \n  \n        Arrays.sort(items);  \n  \n        for (Item item : items) {  \n            System.out.println(item);  \n        }  \n    }  \n}  \n  \nclass Item {  \n    private String name;  \n    private int price;  \n  \n    public Item(String name, int price) {  \n        this.name = name;  \n        this.price = price;  \n    }  \n  \n    public String getName() {  \n        return name;  \n    }  \n    \n    public int getPrice() {  \n        return price;  \n    }\n}\n\n// Exception in thread \"main\" java.lang.ClassCastException\n```\n\n\u003cbr\u003e\n\n### Item 내부 Comparable 구현\n\n- Item을 비교하고자 하니 Item 클래스에 Comparable을 구현하자.\n- `compareTo()` 메서드를 오버라이딩 해야한다.\n\t- 파라미터로 들어온 Object와 내 자신을 비교하는 메서드이다. 이때, 자기 자신과 같은 타입의 객체가 들어온다.\n\t- sort 할 때는 실제로 Item이 들어올 것이다.\n\n```java\nclass Item implements Comparable {  \n\n\t// 편의를 위해 toString() 메서드 오버라이딩\n    @Override  \n    public String toString() {  \n        return \"Item{\" +  \n                \"name='\" + name + '\\'' +  \n                \", price=\" + price +  \n                '}';  \n    }  \n  \n    @Override  \n    public int compareTo(Object o) {  \n        Item d = (Item)o;  \n        return this.name.compareTo(d.name);  \n    }  \n  \n    @Override  \n    public int compareTo(Object o) {  \n        Item d = (Item)o;  \n        return this.price - d.price;  \n    }  \n}\n\n// Item{name='c++', price=7500}\n// Item{name='dart', price=20000}\n// Item{name='java', price=5000}\n// Item{name='javascript', price=1000}\n// Item{name='python', price=4000}\n```\n\n- 위에꺼는 문자열을 기준으로 했다. \n\t- 인스턴스 자기 자신의 name 문자열과 같은 타입으로 들어오는 객체의 name 문자열을 비교하여 리턴한다.\n\t- String 클래스 내부를 보면 거기에도 `Comparable` 인터페이스를 구현하고 있고 `compareTo()` 메서드가 있기 때문에 위와 같이 사용했다.\n- 밑에꺼는 정수를 기준으로 했다.\n\t- 인스턴스 자기 자신의 price 정수와 같은 타입으로 들어오는 객체의 price 정수를 뺀다.\n\t- 자기 자신이 크면 양수, 같으면 0, 작으면 음수를 리턴한다.\n\n\u003cbr\u003e\n\n### Item 외부 Comparator 구현\n\n근데, 저렇게 Item 클래스 내부에서 compareTo를 구현하면 name을 기준으로 할 때는 밑에꺼 주석 처리, price를 기준으로 할 때는 위에꺼 주석처리 할거냐? 그럼 이상하지 않겠나. 따라서 Item 외부에서 **Comparator**를 이용하여 정렬해보자.\n\n\n```java\npublic class ArraySort {  \n    public static void main(String[] args) {  \n        Item[] items = new Item[]{  \n                new Item(\"java\", 5000),  \n                new Item(\"python\", 4000),  \n                new Item(\"c++\", 7500),  \n                new Item(\"javascript\", 1000),  \n                new Item(\"dart\", 20000)  \n        };  \n  \n        Arrays.sort(items, new ItemSorter());  \n  \n        for (Item item : items) {  \n            System.out.println(item);  \n        }  \n    }  \n}\n\nclass ItemSorter implements Comparator {  \n    @Override  \n    public int compare(Object o1, Object o2) {  \n        Item item1 = (Item)o1;  \n        Item item2 = (Item)o2;  \n        return item1.getName().compareTo(item2.getName());  \n    }  \n}\n```\n\n- `Arrays.sort(배열, 정렬 방법을 정의한 객체)`와 같이 사용할 수 있다.\n- Comparator를 구현하는 ItemSorter 클래스를 만들었고 여기에 정렬 방법을 정의하자.\n\t- Comparator 인터페이스는 `compare()` 메서드를 오버라이딩 했다.\n\n\u003cbr\u003e\n\n### 람다 인터페이스\n\n- Comparator 인터페이스에서 1개의 메서드만 사용했으니까 람다 인터페이스이다.\n- 한 번 코드를 줄여보자.\n\n\u003cbr\u003e\n\n1. 익명 클래스 써보기\n\n```java\nArrays.sort(items, new Comparator() {  \n    @Override  \n    public int compare(Object o1, Object o2) {  \n        Item item1 = (Item)o1;  \n        Item item2 = (Item)o2;  \n        return item1.getName().compareTo(item2.getName());  \n    }});\n```\n\n\u003cbr\u003e\n\n2. 람다 표현식으로 바꿔보기\n\n```java\nArrays.sort(items, (Object o1, Object o2) -\u003e {  \n    Item item1 = (Item)o1;  \n    Item item2 = (Item)o2;  \n    return item1.getName().compareTo(item2.getName());  \n});\n```\n\n\u003cbr\u003e\n\n3. 사실 파라미터에 item1, item2와 같이 적어도 자동으로 유추해줌\n\n```java\nArrays.sort(items, (item1, item2) -\u003e {  \n    return item1.getName().compareTo(item2.getName());  \n});\n```\n\n\u003cbr\u003e\n\n4. return 문도 생략 가능\n\n```java\nArrays.sort(items, (item1, item2) -\u003e item1.getName().compareTo(item2.getName()));\n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 명령행 아규먼트 args\n\n**명령행 아규먼트(Command-Line Arguments)** \n- 강좌에서 가장 많이 사용된 배열은 바로 main 메서드에 있는 `String[] args`이다.\n- main 메서드는 JVM이 실행하는 메서드이다.\n- ==**JVM이 main 메서드를 실행할 때 `String[]`을 아규먼트로 넘겨준다는 것을 의미**==\n\n```java\npublic class EmptyCommandLineArgumentExam {  \n    public static void main(String[] args) {  \n        System.out.println(args.length);  \n    }  \n}\n\n// 0\n```\n\n\u003cbr\u003e\n\n인텔리제이에서는 아래와 같이 Edit Configurations -\u003e Program arguments에 아규먼트를 추가할 수 있다.\n\n![](brain/image/fun-java06-6.png)\n\n![](brain/image/fun-java06-7.png)\n\n\u003cbr\u003e\n\nJVM이 실행 시킨 내용은 아래와 같다.\n- `String[] args = new String[0];`\n- `main(args);`  \n- `javac EmptyCommandLineArgumentExam .java` \n\n만약, Program arguments에 a b c d e를 입력하면\n- `java EmptyCommandLineArgumentExam a b c d e` \n\t- (a b c d e가 명령행 아규먼트), 여기서는 공백을 기준으로 5개 문자열 배열  \n\t- `\"d e\"`와 같이 큰 따옴표로 묶으면 1개로 취급\n\n\u003cbr\u003e\n\n실행창을 보면 아래와 같다.\n\n![](brain/image/fun-java06-8.png)\n\n![](brain/image/fun-java06-9.png)\n- `java -javaagent:어떤설정 EmptyCommandLineArgumentExam a b c`  \n\t- java 명령과 클래스명 사이에 있는건 자바에 옵션 주는거  \n\t- 클래스명 뒤에 있는건 프로그램 아규먼트\n\n\u003cbr\u003e\n\n### System.exit()의 의미\n\n\u003cbr\u003e\n\n```java\npublic class CommandLineArgumentExam {  \n    public static void main(String[] args) {  \n        if (args.length == 0) {  \n            System.out.println(\"사용법 : CommandLineArgumentExam 값 값 ...\");  \n            System.exit(0); // return; 으로 변경 가능  \n        }  \n    \n        for (String arg : args) {  \n            System.out.println(arg);  \n        }  \n    }  \n}\n\n// 사용법 : CommandLineArgumentExam 값 값 ...\n```\n\n\u003cbr\u003e\n\n**`System.exit(0)` 이 안에 0은 뭐를 의미할까?** \n  \nHello.java 파일 작성하고 javac Hello.java 했을 때  아무 메세지가 안나오면? 좋은거지. 에러 없이 컴파일 잘 된거니까. 명령을 실행할 때 성공하면 아무런 메시지도 출력하지 않는다는 것은 Unix의 철학이다. (참고로 Linux도 Unix의 계열)\n  \n- 작은 명령들을 조합해서 또 다른 명령을 만든다. (쉘 스크립트 작성)  \n- 작은 명령들이 실행되고 종료될 때, 이게 성공하고 실패하는 지 궁금하다  \n- 그때 사용되는 것이 `System.exit()`의 파라미터인 종료코드이다.  \n\n\u003cbr\u003e\n\n![](brain/image/fun-java06-10.png)\n터미널에서 `man wc`를 해보면 EXIT STATUS가 나온다. 0이면 성공, 오류가 발생하면 0보다 크다고 한다. 즉, `System.exit(0)`은 프로그램이 성공적으로 종료되었다는 의미이다.\n\n\u003cbr\u003e\n\n### 제한없는 아규먼트\n\n**제한없는 아규먼트(unlimited arguments)**\n- 경우에 따라서 메서드 아규먼트를 **가변적**으로 전달하고 싶은 경우가 있다.\n- 메서드에 정수값을 경우에 따라 3개, 어떤 경우에는 5개를 넘기고 싶다면 어떻게 해야할까?\n- ==**제한없는 아규먼트 문법인 `...` 을 써보도록 하자.**==\n\n```java\n리턴타입 메서드명(타입... 변수명) {\n\t...\n}\n```\n\n\u003cbr\u003e\n\n```java\npublic class UnlimitedArgumentsExam {  \n    public static void main(String[] args) {  \n        System.out.println(sum(5, 10));  \n        System.out.println(sum(1, 2, 4, 2));  \n        System.out.println(sum(3, 1, 2, 3, 4, 1));  \n    }  \n  \n    public static int sum(int... args) {  \n        System.out.println(\"print1 메서드 - args 길이 : \" + args.length);  \n        int sum = 0;  \n        for (int i : args) {  \n            sum += i;  \n        }  \n  \n        return sum;  \n    }  \n}\n\n// print1 메서드 - args 길이 : 2\n// 15\n// print1 메서드 - args 길이 : 4\n// 9\n// print1 메서드 - args 길이 : 6\n// 14\n```\n\n- `int... args` : 정수를 여러 개 받을 수 있다는 의미, 배열로 처리된다.","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java07":{"title":"07. 제네릭과 컬렉션","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 내용\n\n\u003chr\u003e\n\n## 제네릭\n\n### 제네릭이 나온 이유\n\n자바에는 어떤 객체든지 참조할 수 있는 것이 Object이다. 모든 클래스의 최상위 부모가 Object 클래스니까 어떤 객체든 참조할 수 있다. 이를 이용하여 무엇이든 담을 수 있는 상자를 만들어보자.\n\n```java\npublic class ObjectBox {  \n    private Object object;  \n  \n    public void set(Object obj) {  \n        this.object = obj;  \n    }  \n    public Object get() {  \n        return this.object;  \n    }  \n}\n```\n\n- 부모 타입으로 자식 인스턴스를 참조하는거니까 Object의 자손은 모~든 클래스니까 아무거나 들어올 수 있겠네\n\n\u003cbr\u003e\n\n```java\npublic class ObjectBoxMain {  \n    public static void main(String[] args) {  \n        ObjectBox box = new ObjectBox();  \n        box.set(\"kim\");  \n        String str = (String)box.get();  \n        System.out.println(str.toUpperCase());  \n  \n        box.set(new Integer(5));  \n        Integer i = (Integer)box.get();  \n        System.out.println(i.intValue());  \n    }  \n}\n```\n\n- `get()`은 return 타입이 Object니까 형변환 해준 것\n- ObjectBox는 어떤 Object든 저장할 수 있고, 어떤 Object든 꺼낼 수 있다.\n\t- 하지만, 꺼내서 사용할 때는 원래 타입으로 변환시키는 번거로운 과정이 필요\n\n\u003cbr\u003e\n\n### 제네릭 기본/장점\n\n\u003cbr\u003e\n\n**제네릭 기본**\n- T는 제네릭과 관련된 부분\n- 제네릭은 클래스 이름 뒤, 메서드의 리턴타입 앞에 붙을 수 있다\n- `\u003cT\u003e` 부분은 T라는 이름의 제네릭 타입을 선언한다는 것을 의미\n- T는 Type의 약자이기 때문에 많이 사용되는 문자이지 꼭 T를 쓸 필요는 X\n\n\u003cbr\u003e\n\n**제네릭의 장점**\n- ==**정해진 타입만 사용하도록 강제할 수 있다.**==\n- ==**타입을 강제함으로써 컴파일할 때 잘못된 타입의 값이 저장되는 것을 막을 수 있다.**==\n\n\u003cbr\u003e\n\n```java\npublic class GenericBox\u003cT\u003e {  \n    private T t;  \n  \n    public T get() {  \n        return t;  \n    }  \n  \n    public void set(T t) {  \n        this.t = t;  \n    }  \n}\n```\n\n- ==**GenericBox 클래스는 아직은 정해지지 않은 T라는 타입을 사용하겠다는 의미**==\n\n\u003cbr\u003e\n\n```java\npublic class GenericBoxMain {  \n    public static void main(String[] args) {  \n        GenericBox\u003cString\u003e genericBox = new GenericBox\u003c\u003e();  \n        genericBox.set(\"kim\");  \n        String str = genericBox.get();  \n        System.out.println(str.toUpperCase());  \n    }  \n}\n\n// KIM\n```\n\n- 이렇게 `\u003cString\u003e`이라고 해주면 GenericBox의 모든 `T`에 String이 들어가게 된다.\n- String 박스로 만들었기 때문에 `genericBox.set(new Integer(5));`와 같이 다른 타입을 넣으려고 하면 컴파일 에러가 발생한다.\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 컬렉션 프레임워크\n\n- Java Collections Framework라고 불리는 Collections API는 Java 2부터 추가된 자료구조 클래스 패키지를 의미한다.\n- 자료(Data)를 다룰 때 반드시 필요한 클래스의 모음이다. 반드시 숙지하자.\n- 참고로, ==**자료구조 객체들은 제네릭을 사용하지 않으면 Object 타입을 저장한다.**==\n\t- 그래서 걍 다 제네릭 쓴다고 이해하자.\n- \u003ca href='https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html' target='_blank'\u003eCollection api docs\u003c/a\u003e는 여기!\n\n핵심은, 여러 인터페이스들과 그를 구현하는 구현체인 클래스들을 사용하는 것이다.\n\n\u003cbr\u003e\n\n### 핵심 인터페이스\n\n![](brain/image/fun-java07-1.png)\n\n![](brain/image/fun-java07-2.png)\n\n\u003cbr\u003e\n\n### Collection Interface\n\n**Collection 인터페이스 : 여기에 자료가 있다는 것을 표현하는 인터페이스, 바구니**\n- 컬렉션 프레임워크 중 가장 기본이 되는 인터페이스\n- 해당 인터페이스는 순서를 기억하지 않고, 중복을 허용하며 자료를 다루는 목적\n- `add(Object) : boolean`  바구니에 자료 추가\n- `size() : int`  바구니에 몇 개 있음?\n- `iterator() : Iterator`  바구니에서 반복하여 자료 전부꺼내\n\t\t- 꺼낼 자료가 있는지 먼저 살핌\n\t\t- 꺼낼게 있으면 꺼냄\n\t\t- 꺼낼거 없을 때 까지 두 과정을 계속 반복\n\n\u003cbr\u003e\n\n### Iterator Interface\n\n**Iterator 인터페이스 : 자료구조에서 자료를 꺼내기 위한 목적으로 사용되는 인터페이스**\n- `hasNext() : boolean` 꺼낼거 있는 지 없는지\n- `next() : Object` 하나 꺼내라\n- 반드시 hasNext로 꺼낼거 있나 없나 체크하고 next로 꺼내기\n\n\u003cbr\u003e\n\n### List Interface\n\n**List 인터페이스 : 순서가 중요한 자료를 다룰 때 사용하는 인터페이스**\n- Collection 인터페이스를 상속받음, 즉 Collection 인터페이스의 모든 메서드 사용 가능\n- `get(int) : Object` 순서를 기억하고 있으니까 get으로 순서에 맞게 꺼낼 수 있음\n\n\u003cbr\u003e\n\n### Set Interface\n\n**Set 인터페이스 : 중복을 허용하지 않는 자료를 다룰 때 사용하는 인터페이스**\n- Collection 인터페이스를 상속받음, 즉 Collection 인터페이스의 모든 메서드 사용 가능\n- 중복을 허용하지 않음 = 같은 값을 저장할 수 없음\n- `add(Object) : boolean` 같은 값은 무조건 1개만 저장\n- ==Set 인터페이스에 저장되는 객체들은 Object가 가지고 있는 `equals()` 메서드, `hashCode()` 메서드를 오버라이딩 해야한다.==\n\n\u003cbr\u003e\n\n### Map Interface\n\n**Map 인터페이스 : key-value로 구성된 자료구조 인터페이스**\n- 같은 Key 값으론 하나의 값만 저장 가능\n- `put(Object, Object) : void` Map 자료구조는 put으로 자료를 저장한다.\n\t- 앞에 Obejct가 key\n\t- 뒤에 Object가 value\n- `get(Object) : Object`  key값을 넣어서 그에 해당하는 value 꺼냄\n\t- key에 해당하는 value 없으면 null 반환\n- `keySet() : Set` key는 유일하기 때문에 key만 모아놓으면 중복되지 않으니까 그게 바로 Set 자료구조가 된다. 그래서 Set 자료구조에 의존함\n\n\u003cbr\u003e\n\n### ArrayList Class\n\n**ArrayList 클래스**\n- List 인터페이스를 구현한 클래스\n\n![](brain/image/fun-java07-5.png)\n\n- 클래스 뒤에 `\u003cE\u003e` Element라는 뜻의 제네릭 표시가 되어있다.\n- 아직 타입이 정해져있지 않은 것들을 List 형태로 여러 개 가질 수 있는게 ArrayList\n\n\u003cbr\u003e\n\n**제네릭을 사용하지 않고 ArrayList 사용해보기**\n- 제네릭 안쓰니까 Object로 저장됐음. 그래서 형변환 해주는거\n\n```java\npublic class ListExam01 {  \n    public static void main(String[] args) {  \n        ArrayList list = new ArrayList();  \n        list.add(\"kim\");  \n        list.add(\"lee\");  \n        list.add(\"hong\");  \n  \n        String str1 = (String)list.get(0);  \n        String str2 = (String)list.get(1);  \n        String str3 = (String)list.get(2);  \n  \n        System.out.println(str1);  \n        System.out.println(str2);  \n        System.out.println(str3);  \n    }  \n}\n\n// kim\n// lee\n// hong\n```\n\n\u003cbr\u003e\n\n**제네릭과 함께 ArrayList 사용해보기**\n- 꺼낼 때 형변환 안해도 되고 너무 편하다 그죠잉~?\n\n```java\npublic class ListExam02 {  \n    public static void main(String[] args) {  \n        ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e();  \n        list.add(\"kim\");  \n        list.add(\"lee\");  \n        list.add(\"hong\");  \n  \n        String str1 = list.get(0);  \n        String str2 = list.get(1);  \n        String str3 = list.get(2);  \n  \n        System.out.println(str1);  \n        System.out.println(str2);  \n        System.out.println(str3);  \n    }  \n}\n\n// kim\n// lee\n// hong\n```\n\n\u003cbr\u003e\n\n### HashSet Class\n\n**HashSet 클래스 : Set 인터페이스를 구현한 클래스**\n\n1. HashSet에 자료를 저장하려고 하면 자료가 가지고 있는 **`hashCode()`** 메서드를 먼저 호출한다. 예를 들어, **A**를 저장하려고 한다면 **A의 hashCode 값**을 먼저 구한다.\n2. hashCode 값이 \"가\"라고 한다면 \"가\" 바구니를 하나 만들고 안에 A를 넣는다.\n3. B를 저장하려고 하면 B의 hashCode 값을 구한다. 값이 \"나\"라면 \"나\" 바구니를 만들고 바구니에 B를 넣는다.\n4. 그런데 만약, C를 저장하려고 C의 hashCode 값을 구하니 A와 동일하게 \"가\"가 나왔다고 하자. 그러면 `eqauls()` 메서드를 이용하여 C와 A를 비교한다. 같은 값을 가지지 않는다고 하면 C를 \"가\" 바구니에 저장한다.\n5. 이러한 과정을 ==**Hash(해시) 알고리즘이라 한다.**==\n\n![](brain/image/fun-java07-7.png)\n\n- 성능이 가장 좋으려면 hashCode 값이 다 달라야 한다. `equals()`로 값이 동일한지 하나하나 비교하는 과정에서 시간이 오래걸리기 때문이다.\n\n\u003cbr\u003e\n\n```java\npublic class SetExam {  \n    public static void main(String[] args) {  \n        Set\u003cString\u003e set = new HashSet\u003c\u003e();  \n        set.add(\"hello\");  \n        set.add(\"hi\");  \n        set.add(\"hong\");\n        set.add(\"hong\");\n  \n        Iterator\u003cString\u003e iterator = set.iterator();  \n        while (iterator.hasNext()) {  \n            String str = iterator.next();  \n            System.out.println(str);  \n        }  \n    }  \n}\n\n// 3개만 나옴\n```\n\n\u003cbr\u003e\n\n```java\npublic class SetExam2 {  \n    public static void main(String[] args) {  \n        Set\u003cMyData\u003e mySet = new HashSet\u003c\u003e();  \n        mySet.add(new MyData(\"kim\", 500));  \n        mySet.add(new MyData(\"lee\", 200));  \n        mySet.add(new MyData(\"hong\", 700));  \n        mySet.add(new MyData(\"hong\", 700));  \n  \n        Iterator\u003cMyData\u003e iter = mySet.iterator();  \n        while (iter.hasNext()) {  \n            MyData myData = iter.next();  \n            System.out.println(myData);  \n        }  \n    }  \n}  \n  \nclass MyData {  \n    private String name;  \n    private int value;  \n  \n    public MyData(String name, int value) {  \n        this.name = name;  \n        this.value = value;  \n    }  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public int getValue() {  \n        return value;  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return \"MyData{\" +  \n                \"name='\" + name + '\\'' +  \n                \", value=\" + value +  \n                '}';  \n    }  \n}\n\n// MyData{name='lee', value=200}\n// MyData{name='hong', value=700}\n// MyData{name='hong', value=700}\n// MyData{name='kim', value=500}\n```\n\n- 중복이 있는데도 왜 들어갔지? 라고 생각하면 안된다.\n- 내부적으로 `hashCode()` 메서드 -\u003e `equals()` 메서드를 사용하며 값이 동일한지 아닌지 비교를 하게 된다.\n- 하지만, 현재 MyData 클래스는 `hashCode()`, `equals()` 메서드를 오버라이딩 하지 않았기 때문에 부모인 Object 클래스의 것을 사용한다. \u003ca href='/brain/Lecture/fun-java/fun-java04' target='_blank'\u003e04. 객체지향 2/3\u003c/a\u003e에서 말한 것처럼 Object의 것은 아무것도 검사해주지 않아서 쓸모가 없기 때문이다.\n\n\u003cbr\u003e\n\n```java\nclass MyData {\n\t@Override  \n\tpublic boolean equals(Object o) {  \n\t    if (this == o)\n\t\t    return true;  \n\t    if (o == null || getClass() != o.getClass())\n\t\t    return false;  \n\t    \n\t    MyData myData = (MyData) o;  \n\t    return value == myData.value \u0026\u0026 Objects.equals(name, myData.name);  \n\t}  \n\t  \n\t@Override  \n\tpublic int hashCode() {  \n\t    return Objects.hash(name, value);  \n\t}\n}\n```\n\n- 이는 인텔리제이 자동완성 짱짱맨으로 메서드 오버라이딩 한 결과물이다.\n\n\u003cbr\u003e\n\n\n\n\u003cbr\u003e\n\n### HashMap Class\n\n**HashMap 클래스**\n- Map 인터페이스를 구현한 클래스\n- ==**참고로 Map의 key가 유일한 값을 가져야하니까 key를 저장할 때 Hash 알고리즘이 사용되는데 `hashCode()`, `equals()` 메서드를 오버라이딩 해줘야하고 String 값이 key가 될 수 있는 것은 String 클래스도 `hashCode()`, `equals()`를 구현하고 있기 때문에 그런 것이다.**==\n\n```java\npublic class MapExam {  \n    public static void main(String[] args) {  \n        Map\u003cString, String\u003e map = new HashMap\u003c\u003e();  \n        map.put(\"k1\", \"hello\");  \n        map.put(\"k2\", \"hi\");  \n        map.put(\"k3\", \"안녕\");  \n        map.put(\"k3\", \"안녕하세요\");  \n  \n        System.out.println(map.get(\"k1\"));  \n        System.out.println(map.get(\"k2\"));  \n        System.out.println(map.get(\"k3\"));  \n    }  \n}\n\n// hello\n// hi\n// 안녕하세요\n```\n\n- key가 동일하면 기존의 값을 덮어쓰는 것을 확인할 수 있다.\n\n\u003cbr\u003e\n\n```java\npublic class MapExam2 {  \n    public static void main(String[] args) {  \n        Map\u003cString, String\u003e map = new HashMap\u003c\u003e();  \n        map.put(\"k1\", \"hello\");  \n        map.put(\"k2\", \"hi\");  \n        map.put(\"k3\", \"안녕\");  \n  \n        Set\u003cString\u003e keySet = map.keySet();  \n        Iterator\u003cString\u003e iterator = keySet.iterator();  \n        while (iterator.hasNext()) {  \n            String key = iterator.next();  \n            String value = map.get(key);  \n  \n            System.out.println(key + \" : \" + value);  \n        }  \n    }  \n}\n\n// k1 : hello\n// k2 : hi\n// k3 : 안녕\n```\n\n- map에 있는 모든 값을 출력하고 싶어서, map이 가지고 있는 모든 key에 접근할 수 있는 `map.keySet()` 메서드를 이용했다. 이는 Set 자료구조니까 Set 타입의 keySet에 저장\n- key 들이 모이면 Set 자료구조 -\u003e Set 자료구조에서 모든걸 꺼내려면 iterator -\u003e map에서 value를 꺼낼때는 `get(key)`를 이용\n\n\u003cbr\u003e\n\n### 컬렉션 사용 Tip\n\n애초에 컬렉션 프레임워크를 만들 때, 자료구조에 대해서 반영했을 것이다. 자연스럽게 자료구조가 가지는 기능을 도출해냈을 것이고 이는 인터페이스의 출현과 관련이 있다. 그리고 이 인터페이스를 구현해주는 클래스가 나오게 됐을 것이다.\n\n**그래서 클래스를 이용할 때는 인터페이스를 사용한다는게 객체지향적으로 너무 자연스러운 것이다.**\n\n- 컬렉션을 사용할 때는 인스턴스가 무엇이 되든 인스턴스를 사용하고자 하는 목적에 맞는 인터페이스 타입으로 참조하도록 훈련해야한다.\n\t- 먼 훗날에 성능 좋은 클래스가 나오면 그걸로 갈아끼우기만 하면 되니까.\n- ==**참조 타입을 인터페이스로, 인스턴스 타입을 클래스로!**==\n\n```java\n인터페이스타입\u003cT\u003e 변수명 = new 클래스타입\u003c\u003e();\n```\n\n\u003cbr\u003e\n\n**인터페이스 타입 : Collection, 클래스 타입 : ArrayList**\n\n```java\npublic class ListExam03 {  \n    public static void main(String[] args) {  \n        Collection\u003cString\u003e collection = new ArrayList\u003c\u003e();  \n        collection.add(\"kim\");  \n        collection.add(\"lee\");  \n        collection.add(\"hong\");  \n  \n        System.out.println(collection.size());  \n  \n        Iterator\u003cString\u003e iterator = collection.iterator();  \n        while (iterator.hasNext()) {  \n            String str = iterator.next();  \n            System.out.println(str);  \n        }  \n    }  \n}\n\n// 3\n// kim\n// lee\n// hong\n```\n\n- ArrayList 클래스는 List 인터페이스를 구현 -\u003e List 인터페이스는 Collection 인터페이스를 상속받음 -\u003e ==**부모 타입을 참조 타입으로 하고 자식 인스턴스 참조 가능!**==\n- Collection과 List는 인터페이스니까 ArrayList 클래스의 인스턴스를 생성해서 참조하도록 함\n\t- 인터페이스는 인스턴스화 못하니까 `new Collection();` 못하잖아\n\t- 대신 이렇게 했으니 ArrayList, List가 가진 메서드인 `get()`을 이용하여 순서로 뽑아내는건 못하겠네. Collection이 가진 메서드만 사용 가능\n\t- ==**근데 출력을 보면 저장한 순서대로 나오는 걸 볼 수 있음. 이건 Collection을 구현하는게 ArrayList라서 그렇다. 실제로 `collection.iterator()` 부분의 iterator를 구현한건 ArrayList가 메서드 오버라이딩하여 구현했을거니까.**==\n\t- 실제로 `new ArrayList\u003c\u003e();`를 `new HashSet\u003c\u003e();`으로 바꾸고 출력 결과를 보면 순서가 보장되어있지 않음.\n\n\u003cbr\u003e\n\n`Collection\u003cE\u003e = new ArrayList\u003c\u003e();`와 같이 왜 쓰는지 다시 말해보면,\n\n![](brain/image/fun-java07-6.png)\n\n- 이렇게 Collection 인터페이스를 구현한 객체가 저렇게 많다.\n- 저들 각각의 메서드와 사용법을 전부 외우기 vs Collection 인터페이스의 메서드 외우기 뭐가 낫겠는가? 당연히 후자가 편하지.\n\n\u003cbr\u003e\n\n**인터페이스 타입 : List, 클래스 타입 : ArrayList**\n\n```java\npublic class ListExam02 {  \n    public static void main(String[] args) {  \n        List\u003cString\u003e list = new ArrayList\u003c\u003e();  \n        list.add(\"kim\");  \n        list.add(\"lee\");  \n        list.add(\"hong\");  \n  \n        String str1 = list.get(0);  \n        String str2 = list.get(1);  \n        String str3 = list.get(2);  \n  \n        System.out.println(str1);  \n        System.out.println(str2);  \n        System.out.println(str3);  \n    }  \n}\n```\n\n- 이렇게 인터페이스 타입인 List로 바꾸면 ArrayList보다 더 나은 객체가 나오면 그걸로 갈아끼우기만 하면 된다.\n\n\u003cbr\u003e\n\n### 정렬, 섞기\n\n- ==**자료구조에서 유용한 메서드들을 모아놓은 Collections 클래스라는게 있다.**== Collection 인터페이스랑은 다른거다.\n- Collections 클래스의 다양한 메서드를 사용해보자.\n\n\u003cbr\u003e\n\n**`Collections.sort(리스트)` - 리스트 정렬**\n\n```java\npublic class SortExam {  \n    public static void main(String[] args) {  \n        List\u003cString\u003e list = new ArrayList\u003c\u003e();  \n        list.add(\"kim\");  \n        list.add(\"lee\");  \n        list.add(\"hong\");  \n  \n        Collections.sort(list);  \n  \n        for (int i = 0; i \u003c list.size(); i++) {  \n            System.out.println(list.get(i));  \n        }  \n    }  \n}\n\n// hong\n// kim\n// lee\n```\n\n- 배열을 정렬할 때는 `Arrays.sort()`와 같이 사용했었는데 `Collections.sort(list)`와 같이 하면 객체들이 정렬된다.\n\n앞에서도 말했지만, 정렬이 되기 위해서는 **Comparable 인터페이스를 구현해야만 정렬이 된다.** Comparable 인터페이스의 `compareTo()` 메서드 오버라이딩을 해야하기 때문이다. 현재는 String 객체를 정렬하고 있는데 String 클래스는 내부적으로 Comparable을 구현하고 있기 때문이다.\n\n![](brain/image/fun-java07-8.png)\n\n![](brain/image/fun-java07-9.png)\n\n\u003cbr\u003e\n\n**`Collections.shuffle(리스트)` - 리스트 랜덤하게 섞기**\n\n```java\npublic class ShuffleExam {  \n    public static void main(String[] args) {  \n        List\u003cString\u003e list = new ArrayList\u003c\u003e();  \n        list.add(\"kim\");  \n        list.add(\"lee\");  \n        list.add(\"hong\");  \n  \n        Collections.shuffle(list);  \n  \n        for (int i = 0; i \u003c list.size(); i++) {  \n            System.out.println(list.get(i));  \n        }  \n    }  \n}\n\n// 출력결과가 매번 섞임\n```\n\n\u003cbr\u003e\n\n\u003e 참고로 배열과 리스트의 차이는 고정이냐 가변이냐이다. \u003cbr\u003e\n\u003e 앞에서 배열을 다룰 때는 방의 크기를 정하고 사용했었는데 (고정) \u003cbr\u003e\n\u003e 컬렉션에서 리스트를 다루면서 크기를 정한적 없지않느냐. (가변)","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java08":{"title":"08. 예외처리, enum","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 내용\n\n\u003chr\u003e\n\n## 주석문\n\n- 프로그래밍 실행과 관련 없는 문장\n- 프로그램에 설명을 붙이기 위해 사용\n\n| **주석기호** | **설명**                                                          |\n| ------------ | ----------------------------------------------------------------- |\n| `//`         | `//`부터 시작해서 줄 끝까지 주석처리                              |\n| `/* ... */`  | `/*`와 `*/` 사이의 내용 모두 주석처리                             |\n| `/** .. */`  | `/**`와 `*/` 사이의 내용 모두 주석처리. JavaDoc 주석문이라고도 함 | \n\n\u003cbr\u003e\n\n```java\n/**  \n * 책 한 권의 정보를 담기 위한 클래스  \n *   \n * @author jaeyoon(\u003ca href=\"mailto:wlwhsvkdlxh@gmail.com\"\u003e신재윤\u003c/a\u003e)  \n * @since 2023.03  \n * @version 0.1  \n * \n */  \n  \npublic class Book {  \n\n\t/**\n\t*  책의 제목을 반환한다.\n\t*  @return 책의 제목\n\t*/\n\t\n\tpublic String getName() { return title; }\n```\n\n이런식으로 주석문을 사용할 수 있다. JavaDoc 주석문에 `@`가 있는데 이 애노테이션들로 추가적인 정보를 제공할 수 있다. JavaDoc 주석문에서 사용하는 태그는 아래와 같다.\n\n\u003cbr\u003e\n\n| **annotation** | **설명**                                                |\n| -------------- | ------------------------------------------------------- |\n| `@version`     | 클래스나 메서드의 버전                                  |\n| `@author`      | 작성자                                                  |\n| `@deprecated`  | 더이상 사용되지 않거나, 삭제될 예정                     |\n| `@since`       | 언제 생성, 추가, 수정되었는가?                          |\n| `@see`         | 외부 링크나 텍스트, 다른 필드나 메서드를 링크할 때 사용 |\n| `@link`        | see와 동일한 기능. 링크 제공                            |\n| `@exception`   | 발생할 수 있는 Exception 정의                           |\n| ...            | ...                                                     | \n\n\u003cbr\u003e\n\n### JavaDoc 장점\n\n- JavaDoc 주석문을 활용하여 Java Document를 만들 수 있다.\n\n인텔리제이에서 JavaDoc 생성하기\n1. shift 키를 2번 연속 누른다.\n2. generate javaDoc을 입력\n3. custom scope를 선택한 후 JavaDoc을 생성할 패키지, 클래스, 인터페이스 등을 선택한다. exclude를 선택해서 생성하지 않을 것들도 지정할 수 있다.\n4. output directory에서 JavaDoc이 생성할 경로를 지정한다.\n5. other command line arguments에는 다음을 입력한다.\n\t- `-encoding UTF-8 -charset UTF-8 -docencoding UTF-8`\n6. OK 버튼 누르고 생성\n\n![](brain/image/fun-java08-1.png)\n\n![](brain/image/fun-java08-2.png)\n\n\u003cbr\u003e\n\n### 주석문을 잘 작성하는 법\n\n- 주석문이 없어도 이해할 수 있도록 클래스, 메서드, 변수 이름을 작성하는 것이다.\n- 즉, 주석문을 최소한으로 작성하라는 것이다.\n- 정~ 주석문을 쓸거면 JavaDoc 주석문을 잘 작성하자.\n\n\n\u003chr\u003e\n\n## 예외 처리\n\n**Error와 Exception : 비정상적으로 프로그램을 종료하게 되는 원인**\n\n자세한 예외 처리는 [개발바닥 2주차 스터디](brain/Interview/dog-study/dog-week02) 참고\n\n\u003cbr\u003e\n\n**Error의 종류**\n- 컴파일 에러\n\t- 컴파일 시 발생하는 에러 (아예 실행 자체가 불가)\n- 런타임 에러\n\t- 실행 시 발생하는 에러\n\n\u003cbr\u003e\n\n**자바에서는 실행 시 2가지 형태의 오류가 발생할 수 있다.**\n- Error : 수습할 수 없는 심각한 오류\n\t- 메모리 부족, 스택오버플로우(stack overflow) 등이 발생하여 프로그램이 죽는 것은 프로그래머가 ==**제어할 수 없음**==\n\t- 원인 자체를 해결해줘야함. 메모리를 늘리던지 과도하게 메모리를 사용하는 알고리즘을 재작성해서 프로그램을 실행하던지 등\n- Exception(예외) : 예외 처리를 통해 수습할 수 있는 덜 심각한 오류\n\t- 프로그래머가 이런 예외가 발생하면 이렇게 하라고 ==**제어할 수 있음**==\n\n\u003cbr\u003e\n\n```java\npublic class Exception01 {  \n    public static void main(String[] args) {  \n        ExceptionObj1 exobj = new ExceptionObj1();  \n        int value = exobj.divide(10, 0);  \n        System.out.println(value);  \n    }  \n}  \n  \nclass ExceptionObj1 {  \n    public int divide(int i, int k) {  \n        int value = 0;  \n        value = i / k;  \n        return value;  \n    }  \n}\n```\n\n![](brain/image/fun-java08-3.png)\n\n- 0으로 나눌 수 없다고 **Exception**이 발생하는 것을 볼 수 있다.\n\t- 이는 ==**JVM이 해당하는 예외 클래스의 객체 인스턴스를 생성하여 발생시키는 것**==이다.\n- `value = i / k;` 부분에서 발생하는 것인데 이 부분에서 발생하는 예외를 처리한다면, 프로그램이 비정상적으로 종료되는 것을 막을 수 있다.\n- 이를 예외 처리, Exception Handling이라고 한다.\n\n\u003cbr\u003e\n\n### try-catch\n\n- 예외 처리하는 가장 간단한 방법\n\n```java\ntry {\n\t코드1\n\t코드2\n\t....\n} catch (Exception클래스명1 변수명1) {\n\tException을 처리하는 코드\n} catch (Exception클래스명2 변수명2) {\n\tException을 처리하는 코드\n}\n```\n\n- 예외가 발생하면 JVM이 예외 클래스의 인스턴스를 생성하여 발생시킨다고 했었다.\n- 이때문에 catch(타입명 참조하는변수)와 같이 적는 것이다.\n\n\u003cbr\u003e\n\n```java\nclass ExceptionObj1 {  \n    public int divide(int i, int k) {  \n        int value = 0;  \n        try {  \n            value = i / k;  \n        } catch (ArithmeticException e) {  \n            System.out.println(\"0으로 나눌 수 없음\");  \n            System.out.println(e.toString());  \n        }  \n        return value;  \n    }  \n}\n\n// 0으로 나눌 수 없음\n// java.lang.ArithmeticException: / by zero\n// 0\n```\n\n- 출력을 보면 예외 때문에 프로그램이 비정상적으로 종료되던 것과는 다르게 종료되지 않음\n- e에 대하여 출력해보면 예외 클래스가 ArithmeticException 클래스임을 확인 가능\n\n근데 이게 좋은 코드일까 ??\n\n**1번 문제점 : 오류 발생한 결과보다 못한 경우**\n- 10을 0으로 나눈다면, 결과가 있는게 아니라 아예 안나와야한다.\n- 위와 같이 return 해주면 잘못된 value가 전달되는 것이다. 아까처럼 비정상적으로 프로그램이 종료되는게 훨씬 나을 결과다.\n\n**2번 문제점 : 사용자가 원하지 않는 출력**\n- ExceptionObj1 클래스를 A 개발자가 작성했고 B 개발자가 이를 이용한다고 하자.\n- 하지만, B 개발자는 A 개발자가 의도한 출력을 원하지 않는 상황이 있을 수 있다.\n\n\u003cbr\u003e\n\n### throws\n\n- 메서드를 호출한 쪽으로 예외를 떠넘기는 방법\n\n```java\n리턴타입 메서드명(아규먼트 리스트) throws Exception클래스명1, Exception클래스명2 ... {\n\t코드1\n\t코드2\n\t...\n}\n```\n\n\u003cbr\u003e\n\n```java\npackage chap08;  \n  \npublic class Exception01 {  \n    public static void main(String[] args) {  \n        ExceptionObj1 exobj = new ExceptionObj1();  \n        try {  \n            int value = exobj.divide(10, 0);  \n            System.out.println(value);  \n        } catch (ArithmeticException e) {  \n            System.out.println(\"0으로 나눌 수 없습니다.\");  \n        }  \n    }  \n}  \n  \nclass ExceptionObj1 {  \n    /**  \n     * i를 k로 나눈 나머지를 반환한다.  \n     * @param i  \n     * @param k  \n     * @return  \n     * @throws ArithmeticException  \n     */  \n    public int divide(int i, int k) throws ArithmeticException {  \n        int value = 0;  \n        value = i / k;  \n        return value;  \n    }  \n}\n\n// 0으로 나눌 수 없습니다.\n```\n\n- 이렇게 예외를 메서드에서 호출하는 쪽으로 던져버려서 처리할 수 있도록 하면 try-catch에서 언급한 문제점 1, 2를 모두 해결하였다.\n- 대신 중요한 점은 떠넘긴 예외를 반드시 처리해야한다. 무책임하게 떠넘기지만 하는 것은 좋지않다. 예를 들어, ==**main 메서드 뒤에 throws를 붙이는건 JVM에 예외를 떠넘기는 것으로, 굉장히 무책임한 행동이다.**==\n\n\u003cbr\u003e\n\n### Checked / UnChecked\n\n![](brain/image/fun-java08-5.png)\n\n![](brain/image/fun-java08-4.png)\n\n==**UnChecked Exception**==\n- **RuntimeException 클래스를 상속받는** 예외 클래스들\n- 컴파일 시에는 에러가 발생하지 않고, 실행 시에 에러가 발생해서 죽는 경우\n- ==**반드시 예외 처리를 해야하는 것은 아니다. 처리하지 않아도 컴파일은 된다.**==\n\n==**Checked Exception**==\n- **RuntimeException 클래스를 상속받지 않으면서** Exception 클래스를 상속받는 예외 클래스들\n- 컴파일 시에 에러가 발생함.\n- ==**반드시 예외 처리를 해야한다. 그렇지 않으면 컴파일 에러 발생**==\n\n![](brain/image/fun-java08-6.png)\n\n![](brain/image/fun-java08-7.png)\n\n- 애초에 IDE에서 빨간줄이 뜬다. 무시하고 실행해보면 빌드 자체가 안된다.\n\n![](brain/image/fun-java08-8.png)\n\n- RuntimeException을 상속받지 않는 Checked Exception임을 확인했다.\n- 이는 반드시 예외처리를 해줘야하는 것이다.\n\n\u003cbr\u003e\n\n번외로 Exception은 클래스이니까 ==**내가 커스텀한 예외 클래스**==도 만들 수 있을 것이다. 이 경우 Checked Exception 보다는 되도록이면, ==**UnChecked Exception으로 만드는 것이 좋다. 예외를 강제하지 않고 사용자가 알아서 처리하도록 하는 것이 여러 면에서 좋기 때문이다.**== 체크드가 많아지면 강제적으로 처리해야 하는 것이 너무 많아져서 귀찮고 좋지 않다.\u0004\n\n\u003cbr\u003e\n\n### 다중 catch\n\n- 여러 개의 catch 문을 사용해 다양한 예외를 처리할 수 있다.\n- 그런데, Exception 하나만으로 가능한데 왜 여러 개를 쓰는가?\n\t- 좀 더 예외에 관해 구체적으로 처리하고 싶어서\n- 주의할 점은 **catch 블록이 여러 개라 할지라도 단 하나의 catch 블록만 실행된다.**\n\t- 위에서부터 내려오다가 해당되면 그 catch 블록에서 처리하고 break 되는 것처럼 끝남\n\t- 이 때문에 ==**상위 예외 클래스가 하위 예외 클래스(더 상세한)보다 더 아래에 위치해야함**==\n\n```java\npublic class Exception03 {  \n    public static void main(String[] args) {  \n        int[] array = {4, 0};  \n        int[] value = null;  \n  \n        try {  \n            value[0] = array[0] / array[1];  \n        } catch (ArrayIndexOutOfBoundsException aiob) {  \n            System.out.println(aiob.toString());  \n        } catch (ArithmeticException ae) {  \n            System.out.println(ae.toString());  \n        } catch (Exception e) {  \n            System.out.println(e);  \n        }  \n    }  \n}\n```\n\n- ArithmeticException이 먼저 처리되니까 ArithmeticException 예외처리하고 끝!\n- `array[] = {4, 2};` 라면 ArrayIndexOutOf 해당 안됨 -\u003e ArithmeticException 해당 안됨 -\u003e Exception에는 해당됨. 이 중에서도 NullPointerException에 해당되니까 그거 뱉을거\n\n\u003cbr\u003e\n\n### Custom Exception\n\n- 사용자 정의 Exception과 예외 발생시키기 (throw)\n- ==**오류 메시지나, 발생한 Exception을 감싼 결과로 내가 만든 Exception을 사용하고 싶은 경우가 많아서 사용함**==\n\n![](brain/image/fun-java08-9.png)\n\n- 기본 RuntimeException이 가진 생성자 중에서 이 두 가지를 많이 사용함\n- RuntimeException 발생 시 받은 메시지를 부모에게 전달\n- Throwable은 또다른 Exception이나 RuntimeException을 받을 수 있다.\n- Throwable은 Exception으로 바꿔서 받을 수도 있다.\n\n얘는 문자열을 받거나 다른 Exception을 받아서 감싼 Exception을 만드려고 하는구나~로 이해\n\n\u003cbr\u003e\n\n```java\nclass Exception05 {  \n    public int divide(int i, int k) throws MyException {  \n        int value = 0;  \n        try {  \n            value = i / k;  \n        } catch (ArithmeticException ae) {  \n            throw new MyException(\"0으로 나눌 수 없슴\");  \n        }  \n        return value;  \n    }  \n}\n```\n\n- `value = i / k;`에서 JVM이 `throws` 해준 것을 개발자가 다시 받아서 개발자가 만든 `MyException`으로 다시 Exception을 `throw`로 재생성해서 발생하게 한 것\n\n\u003cbr\u003e\n\n![](brain/image/fun-java08-10.png)\n\n![](brain/image/fun-java08-11.png)\n\n\u003cbr\u003e\n\n### Custom 상세 사용법\n\nCustom Exception을 정확하게 어떤 경우에 사용하면 좋을까?\n\n![](brain/image/fun-java08-12.png)\n\n이러한 이유로, 아래와 같이 Custom Exception을 이용하면 훨씬 편할 것\n\n![](brain/image/fun-java08-13.png)\n\n\u003chr\u003e\n\n## enum\n\n- Enum은 Enumeration의 약자로 JDK 5부터 지원하는 기능\n- ==**Enum 덕분에 타입에 안전한, Type-Safety한 코드 작성 가능**==\n\n\u003cbr\u003e\n\n### 상수 사용 시 문제점\n\n- JDK 5 이전에 어떤 상수들을 표현하고자 할 때 아래와 같이 작성했다.\n\n```java\npublic class DayType {\n\tpublic final static int SUNDAY = 0;\n\tpublic final static int MONDAY = 1;\n\tpublic final static int TUESDAY = 2;\n\tpublic final static int WEDNESDAY = 3;\n\tpublic final static int THURSDAY = 4;\n\tpublic final static int FRIDAY = 5;\n\tpublic final static int SATURDAY = 6;\n\t\n}\n```\n\n- DayType 클래스는 `final static int`로 정의된 상수를 6개 가지고 있음\n\n\u003cbr\u003e\n\n```java\nint today = DayType.SUNDAY;\n// 0\n```\n\n- today는 SUNDAY 상수 값을 가지게 되니 0이라는 숫자 값을 가짐\n\n\u003cbr\u003e\n\n```java\nif (today == DayType.SUNDAY) {\n\tSystem.out.println(\"일요일입니다.\");\n}\n```\n\n- 이렇게 검사도 가능\n\n\u003cbr\u003e\n\n그런데 문제는, today는 int형이라서 상수로 정의한 일월화수목금토, 0~6사이 값 이외에 다른 값도 할당할 수 있다. ==**즉, 정해진 값만 변수에 할당할 수 있는 건 아니라는 문제점이 있다. 이를 타입에 안전하지 않다고 하여 (No-Type-Safety)라고 한다.**==\n\n\u003cbr\u003e\n\n### enum 사용\n\n- 위와 같은 문제를 해결하고자 enum이 나왔다.\n- 클래스를 생성하는 것과 같은 방식으로 Enum을 생성\n\t- 인텔리제이에서 new java class file 하면 목록에 enum 있음\n\n```java\npackage chap08.enumtype;  \n  \npublic enum Day {  \n    SUNDAY,  \n    MONDAY,  \n    TUESDAY,  \n    WEDNESDAY,  \n    THURSDAY,  \n    FRIDAY,  \n    SATURDAY  \n}\n```\n\n- Day 안에 상수를 나타내는 값을 적는다.\n- 보통 모두 대문자로 표현하는데, 상수와 상수는 콤마로 구분한다.\n\n\u003cbr\u003e\n\n```java\npackage chap08.enumtype;  \n  \npublic class Today {  \n    private Day day;  \n  \n    public Day getDay() {  \n        return day;  \n    }  \n  \n    public void setDay(Day day) {  \n        this.day = day;  \n    }  \n}\n```\n\n- Today 클래스에서 사용된 ==**Day 타입은 enum 타입**==이다.\n- enum Day에 선언된 것만 사용 가능하다.\n- ==**즉, setDay에 들어올 수 있는 값은 enum에 선언된 일월화수목금토만 가능하다는 의미**==\n\n\u003cbr\u003e\n\n```java\npackage chap08.enumtype;  \n  \npublic class TodayTest {  \n    public static void main(String[] args) {  \n        Today today = new Today();  \n        today.setDay(Day.SATURDAY);  \n        System.out.println(today.getDay());  \n    }  \n}\n\n// SATURDAY\n```\n\n- 타입에 안전한 코드 작성 가능!!\n\n\u003cbr\u003e\n\n### Enum 타입의 특징\n\n**밑에서 설명할 특징들**\n\n- Enum은 타입에 대해 안전하다. 미리 정의된 Enum 변수 안의 상수만을 대입할 수 있다.\n- Enum 값끼리 비교할 때는 비교 연산자를 사용한다.\n- Enum은 switch 문에서 사용 가능하다.\n- Enum은 인터페이스를 구현하고, 해당 인터페이스를 오버라이딩하여 구현할 수 있다.\n- Enum은 추상 메서드를 가질 수 있다. 추상 메서드를 가질 경우엔 상수를 정의할 때 추상 메서드를 함께 구현해 줘야한다.\n- Enum 생성자와 값을 지정할 수 있다.\n- Enum은 이 외에도 아래와 같은 특징을 가진다.\n\t- Enum 객체는 Enum 상수가 처음 호출되거나 참조될 때 생성된다.\n\t- Enum은 Serializable과 Comparable 인터페이스를 이미 구현하고 있다.\n\n\u003chr\u003e\n\n- ==**Enum은 타입에 대해 안전하다. 미리 정의된 Enum 변수 안의 상수만을 대입할 수 있다.**==\n\n```java\n// 가능\nDay day = Day.SUNDAY;\n\n// 불가능\nDay day = 5;\n```\n\n\u003cbr\u003e\n\n- ==**Enum 값끼리 비교할 때는 비교 연산자를 사용한다.**==\n\t- 상수기 때문에 메모리 상에 딱 하나만 올라가니까 같은 주소를 참조할 것\n\n```java\nDay day1 = Day.MONDAY;\nDay day2 = Day.MONDAY;\n\nif (day1 == day2) {\n\tSystem.out.println(\"같은 요일입니다.\");\n}\n```\n\n\n- ==**Enum은 switch 문에서 사용 가능하다.**==\n\t- JDK 7 이상부터는 switch 문에서 String도 사용 가능해서 그럼\n- switch 문을 사용하는 경우에는 case에 `day.SUNDAY`와 같이 쓰면 컴파일 오류가 나서 안되고 상수만 적어야 한다.\n\n```java\npackage chap08.enumtype;  \n  \npublic class DaySwitchTest {  \n    public static void main(String[] args) {  \n        Day day = Day.SUNDAY;  \n  \n        switch (day) {  \n            case SUNDAY:  \n                System.out.println(\"일요일 입니다.\");  \n                break;  \n            case MONDAY:  \n                System.out.println(\"월요일 입니다.\");  \n                break;  \n            default:  \n                System.out.println(\"그 밖의 요일\");  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n- ==**Enum은 인터페이스를 구현하고, 해당 인터페이스를 오버라이딩하여 구현할 수 있다.**==\n\n```java\npublic interface Printer {\n\tpublic void print();\n}\n```\n\n\u003cbr\u003e\n\n```java\npublic enum Color implements Printer {  \n    RED(\"FF0000\"),  \n    GREEN(\"00FF00\"),  \n    BLUE(\"0000FF\");  \n      \n    private String rgb;  \n    private Color(String rgb) {  \n        this.rgb = rgb;  \n    }  \n  \n    @Override  \n    public void print() {  \n        System.out.println(\"rgb : \" + rgb);  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java\npublic class ColorTest {  \n    public static void main(String[] args) {  \n        Color color = Color.RED;  \n        color.print();  \n    }  \n}\n\n// rgb : FF0000\n```\n\n\u003cbr\u003e\n\n- ==**Enum은 추상 메서드를 가질 수 있다. 추상 메서드를 가질 경우엔 상수를 정의할 때 추상 메서드를 함께 구현해 줘야한다.**==\n\n```java\npublic enum Country {  \n    KOREA {  \n        public void print() {  \n            System.out.println(\"대한민국\");  \n        }  \n    },  \n    JAPAN {  \n        public void print() {  \n            System.out.println(\"일본\");  \n        }  \n    },  \n    USA {  \n        public void print() {  \n            System.out.println(\"미국\");  \n        }  \n    };  \n    public abstract void print();  \n}\n```\n\n\u003cbr\u003e\n\n```java\npublic class CountryTest {  \n    public static void main(String[] args) {  \n        Country country = Country.KOREA;  \n        country.print();  \n    }  \n}\n\n// 대한민국\n```\n\n\u003cbr\u003e\n\n- ==**Enum 생성자와 값을 지정할 수 있다.**==\n\t- Enum은 생성자를 가질 수 있지만, 단, private 해야한다.\n\t- Enum의 생성자는 내부에서만 호출 가능하다.\n\n```java\npublic enum Gender {  \n    MALE(\"XY\"),  \n    FEMALE(\"XX\");  \n  \n    private String chromosome; // 염색체  \n    private Gender(String chromosome) {  \n        this.chromosome = chromosome;  \n    }  \n}\n```\n\n- MALE과 FEMALE 2가지 상수 가짐\n- 위에서 나온 예제와 다르게 상수 뒤에 `(\"XY\")`, `(\"XX\")` 있음\n- **상수 뒤에 괄호 열고 닫고 기호가 있으면 Enum의 생성자를 호출하게 됨**\n- 생성자가 호출되어 chromosome가 초기화 된다.\n- 이렇게 값을 지정했다 하더라도 앞에서 설명한 것처럼 동일하게 enum 쓰면 됨\n\n\u003cbr\u003e\n\n```java\npublic class GenderTest {  \n    public static void main(String[] args) {  \n        Gender gender = Gender.MALE;  \n        System.out.println(gender);  \n    }  \n}\n\n// MALE\n```\n\n- Gender 타입의 변수 gender에는 `Gender.MALE`이나 `Gender.FEMALE` 값만 할당 가능\n- 해당 gender를 출력하면 상수 이름이 그대로 출력됨\n\n\u003cbr\u003e\n\n### Enum에 메서드와 변수 선언\n\n- Enum 안에 선언된 메서드나 변수를 가질 수 있음\n- 또한 Object가 가지고 있는 메서드를 오버라이딩 할 수도 있음\n\t- 오호라~ `toString()` 쓸 수 있겠구만?\n- Gender Enum을 생성할 때 chromosome 필드를 작성했었는데, Gender Enum에 Object가 가지고 있는 toString() 메서드를 오버라이딩 해보자\n\n```java\npublic enum Gender {  \n    MALE(\"XY\"),  \n    FEMALE(\"XX\");  \n  \n    private String chromosome; // 염색체  \n    private Gender(String chromosome) {  \n        this.chromosome = chromosome;  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return \"Gender{\" +  \n                \"chromosome='\" + chromosome + \"\\'\" +  \n                \"}\";  \n    }  \n  \n    public void print() {  \n        System.out.println(\"염색채 정보 : \" + chromosome);  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java\npublic class GenderTest {  \n    public static void main(String[] args) {  \n        Gender gender = Gender.MALE;  \n        System.out.println(gender);  \n        gender.print();  \n    }  \n}\n// Gender{chromosome='XY'}\n// 염색채 정보 : XY\n```\n\n- 동일하게 출력하면 `MALE`이라는 enum 상수값만 출시되는 아까와는 다르게 `toString()` 메서드를 오버라이딩 했기 때문에 저런 출력이 나온다.\n\n\u003cbr\u003e\n\n### EnumMap\n\n- EnumMap은 Enum 타입을 키(key)로 사용할 수 있도록 도와주는 클래스\n\t- 키 값으로 Enum에 정의된 것만 사용 가능\n- `import java.util.EnumMap;`으로 임포트해서 사용!\n\n```java\nimport java.util.EnumMap;  \n  \npublic class EnumMapTest {  \n    public static void main(String[] args) {  \n        EnumMap emap = new EnumMap(Day.class);  \n        emap.put(Day.SUNDAY, \"일요일은 자는 것이 최고\");  \n        emap.put(Day.FRIDAY, \"불금은 놀아야지\");  \n        emap.put(Day.MONDAY, \"월요병.. 극혐..\");  \n  \n        System.out.println(emap.get(Day.SUNDAY));  \n    }  \n}\n\n// 일요일은 자는 것이 최고\n```\n\n\u003cbr\u003e\n\n### EnumSet\n\n- EnumSet은 Enum 상수를 Set 자료구조로 다루기 위한 유용한 메서드를 제공하는 클래스\n\n```java\nimport java.util.EnumSet;  \nimport java.util.Iterator;  \n  \npublic class EnumSetTest {  \n    public static void main(String[] args) {  \n        EnumSet eset = EnumSet.allOf(Day.class);  \n        Iterator\u003cDay\u003e dayIter = eset.iterator();  \n  \n        while (dayIter.hasNext()) {  \n            Day day = dayIter.next();  \n            System.out.println(day);  \n        }  \n        \n        System.out.println(\"-------------------------------------\");  \n  \n        EnumSet eset2 = EnumSet.range(Day.MONDAY, Day.WEDNESDAY);  \n        Iterator\u003cDay\u003e dayIter2 = eset2.iterator();  \n        \n        while (dayIter2.hasNext()) {  \n            Day day = dayIter2.next();  \n            System.out.println(day);  \n        }  \n    }  \n}\n\n// SUNDAY\n// MONDAY\n// TUESDAY\n// WEDNESDAY\n// THURSDAY\n// FRIDAY\n// SATURDAY\n// --------------------------\n// MONDAY\n// TUESDAY\n// WEDNESDAY\n```\n\n- EnumSet의 static 메서드인 `allOf()` 메서드는 인자로 들어온 Enum 타입의 모든 상수를 가지고 있는 EnumSet 객체를 리턴한다","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java09":{"title":"09. Java I/O","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 내용\n\n\u003chr\u003e\n\n## Java I/O\n\n**I/O는 Input, Output이다.**\n- Input \u0026 Output, 입출력\n- 입력은 **키보드, 네트워크, 파일** 등으로부터 받을 수 있음\n- 출력은 **화면, 네트워크 파일** 등에 할 수 있음\n\n\u003cbr\u003e\n\n**Java IO도 객체다.**\n- Java IO에서 제공하는 객체는 자바 세상에서 사용되는 객체이다.\n- Java IO가 제공하는 객체는 어떤 대상으로부터 읽어들여, 어떤 대상에게 쓰는 일을 한다.\n\n\u003cbr\u003e\n\n### Decorator 패턴\n\u0003\n![](brain/image/fun-java09-1.png)\n\n- Java IO는 **조립되어 사용**되도록 만들어졌다.\n\t- Decorator 패턴으로 만들어졌다.\n\t- 연관관계 UML에 대한 참조는 [여기](brain/Lecture/pl/fun-java/fun-java07.md)\n\t- 그냥 화살표는 일반화, 마름모는 집합관계\n\t- ==**Decorator는 Component를 가질 수 있다.**==\n\t\t- ==**이 말은 Decorator의 생성자는 Component를 받아들일 수 있게 되어있다는 것**==\n\t\t- 이 말은 컴포넌트를 상속받고 있는 것들도 가질 수 있다. (ConcreteComponent)\n- 강사님 표현에 따르면 ConcreteComponent가 주인공, Decorator가 장식\n\n\u003cbr\u003e\n\n**주인공과 장식을 구분할 수 있어야 한다.**\n- 장식은 ==**InputStream, OutputStream, Reader, Writer**==를 생성자에서 받아들인다.\n\t- 이 네 가지가 ==**Component 역할을 수행**==\n\t- **추상 클래스라 new로 인스턴스 생성 불가**\n- 주인공은 어떤 대상에게서 읽어들일지, 쓸지를 결정\n- 주인공은 1byte or `byte[]` 단위로 읽고 쓰는 메서드를 가짐\n- 주인공은 1char or `char[]` 단위로 읽고 쓰는 메서드를 가짐\n- 장식은 다양한 방식으로 읽고 쓰는 메서드를 가짐\n\n\u003cbr\u003e\n\n**Java IO 클래스는 생성자가 중요하다.**\n- 장식(Decorator)은 InputStream, OutputStream, Reader, Writer를 생성자에서 받아들인다. 주인공은 생성자에서 위 4개를 받아들이지 않는다.\n\n==**정리하자면, InputStream, OutputStream, Reader, Writer이 생성자에 있으면 Decorator(장식) 없으면 ConcreteComponent(주인공)**==\n\n\u003cbr\u003e\n\n### Java IO의 특수한 객체\n\n\u003ca href='https://docs.oracle.com/javase/8/docs/api/java/lang/System.html' target='_blank'\u003eSystem 클래스 api\u003c/a\u003e를 참고하자.\n\n- `System.in` : 표준 입력 (InputStream)\n- `System.out` : 표준 출력 (PrintStream)\n- `System.err` : 표준 에러 출력 (PrintStream)\n\n![](brain/image/fun-java09-4.png)\n\n예를 들어, System 클래스의 in 필드의 타입은 InputStream이다.\n\n\u003cbr\u003e\n\n### Java IO의 클래스 상속도\n\n![](brain/image/fun-java09-2.png)\n\n\u003ca href='https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html' target='_blank'\u003eJava api I/O 문서\u003c/a\u003e를 참고하면서 보자.\n\n- **4가지 추상 클래스 InputStream, OutputStream, Reader, Writer**가 가장 중요\n\t- 들어가서 보면 `public abstract class InputStream`이라고 보일 것\n\n==**Java IO 클래스 이름이 굉장히 중요하다.**==\n\n\u003cbr\u003e\n\n| 클래스 이름                                | 기능                                                                                                                                                              |\n| ------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Stream으로 끝나는 클래스                   | byte 단위 입출력 클래스                                                                                                                                           |\n| InputStream으로 끝나는 클래스              | byte 단위로 입력을 받는 클래스                                                                                                                                    |\n| OutputStream으로 끝나는 클래스             | byte 단위로 출력을 하는 클래스                                                                                                                                    |\n| Reader로 끝나는 클래스                     | 문자 단위로 입력을 받는 클래스                                                                                                                                    |\n| Writer로 끝나는 클래스                     | 문자 단위로 출력을 하는 클래스                                                                                                                                    |\n| File로 시작할 경우 \u003cbr\u003e (File 클래스 제외) | File로부터 입력이나 출력을 하는 클래스                                                                                                                            |\n| ByteArrary로 시작할 경우                   | 입력 클래스의 경우 byte 배열로부터 읽어 들이고, \u003cbr\u003e 출력 클래스의 경우 클래스 내부의 자료구조에 출력을 \u003cbr\u003e 한 후 출력된 결과를 byte 배열로 반환하는 기능을 가짐 |\n| CharArray로 시작할 경우                    | 입력 클래스의 경우 char 배열로부터 읽어 들이고, \u003cbr\u003e 출력 클래스의 경우 클래스 내부의 자료구조에 출력을 \u003cbr\u003e 한 후 출력된 결과를 char 배열로 반환하는 기능을 가짐 |\n| Filter로 시작할 경우                       | Filter로 시작하는 입출력 클래스는 직접 사용하는 것 \u003cbr\u003e 보다는 상속받아 사용하며, 사용자가 원하는 내용만 \u003cbr\u003e 필터링할 목적으로 사용됨                            |\n| Data로 시작할 경우                         | 다양한 데이터 형을 입출력 할 목적으로 사용한다. \u003cbr\u003e 특히 기본형 값 (int, float, double 등)을 출력하는데 \u003cbr\u003e 유리하다.                                           |\n| Buffrered로 시작할 경우                    | 프로그램에서 Buffer라는 말은 메모리를 의미한다. \u003cbr\u003e 입출력 시에 병목현상을 줄이고 싶을 경우 사용한다.                                                            |\n| RandomAccessFile                           | 입력이나 출력을 모두 할 수 있는 클래스로써, 파일에서 \u003cbr\u003e 임의의 위치의 내용을 읽거나 쓸 수 있는 기능을 제공                                                                                                                                                                  |\n\n\u003cbr\u003e\n\n\n### BufferedReader 클래스\n\n**키보드로부터 한 줄씩 입력받고, 한 줄씩 화면에 출력하시오.**\n- 키보드 : `System.in`은 주인공, InputStream 타입\n- 화면 : `System.out`은 주인공, PrintStream 타입\n- 키보드로 입력받는다는 것은 문자를 입력받는 것, char 단위 입출력\n\t- char 단위 입출력 클래스는 Reader, Writer\n\n![](brain/image/fun-java09-5.png)\n\n- 한줄 읽기 : BufferedReader 클래스는 `readLine()` 메서드를 이용해 한 줄씩 입력 받음\n\t- 더 이상 읽어들일 것이 없으면(EOF, End Of File) null 반환\n- 한줄 쓰기 : PrintStream, PrintWriter\n- BufferedReader 클래스의 생성자를 보면 Reader.in이 들어와야하네. 얘는 장식이네\n\t- InputStream, OutputStream, Reader, Writer은 추상 클래스라서 인스턴스 생성이 불가능했잖아? 그럼 Reader를 상속받는 어떤 녀석을 찾아야겠네.\n\n![](brain/image/fun-java09-6.png)\n\n- Reader를 상속받는 InputStreamReader 클래스의 생성자를 보면 InputStream이 들어오네.\n- System.in이 주인공이고, 타입이 InputStream이었으니까 딱 맞네!\n\n\n\u003cbr\u003e\n\n```java\nimport java.io.BufferedReader;  \nimport java.io.IOException;  \nimport java.io.InputStreamReader;  \n  \npublic class KeyboardIOExam {  \n    public static void main(String[] args) throws IOException {  \n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        String line = null;  \n        while ((line = br.readLine()) != null) {  \n            System.out.println(\"읽어들인 값 : \" + line);  \n        }  \n    }  \n}\n```\n\n- 종료하려면 cmd + d 누르면 EOF라고 알려줘서 null 반환받고 프로그램 종료\n\n\u003cbr\u003e\n\n### File 클래스\n\n- `java.io.File` 클래스는 파일의 크기, 파일의 접근 권한, 파일의 삭제, 이름 변경 등의 작업을 할 수 있는 기능을 제공\n\t- 주의해야 할 것은 디렉토리(폴더) 역시 파일로써 취급됨\n- 여기서도 역시 주인공이 중요하다.\n\n- txt 파일로부터 한 줄씩 입력받아 화면에 출력한다.  \n\t- 입력 주인공 : 파일, 출력 주인공 : 화면\n- 키보드로부터 한 줄씩 입력받아 파일에 출력한다.  \n\t- 입력 주인공 : 키보드, 출력 주인공 : 파일\n- txt 파일로부터 한 줄씩 입력받아 다른 파일에 한 줄씩 출력한다.\n\t- 입력 주인공 : 파일, 출력 주인공 : 파일\n\n\u003cbr\u003e\n\n**File 클래스 생성자**\n\n| 생성자                            | 내용                                                    |\n| --------------------------------- | ------------------------------------------------------- |\n| File(File parent, String child)   | parent 디렉토리에 child 라는 파일에 대한 File 객체 생성 |\n| File(String child)                | child 라는 파일에 대한 File 객체 생성                   |\n| File(String parent, String child) |      parent 디렉토리에 child 라는 파일에 대한 File 객체 생성                                                   |\n\n- 파일 인스턴스를 만들었다고, 실제 폴더에 파일이 생성되는 것은 아니다.\n\n\u003cbr\u003e\n\n**File 클래스 중요 메서드**\n\n| 메서드                    | 내용                                                |\n| ------------------------- | --------------------------------------------------- |\n| boolean canRead()         | 파일이 읽기 가능하면 true, 아니면 false 반환        |\n| boolean canWrite()        | 파일이 쓰기 가능하면 true, 아니면 false 반환        |\n| boolean createNewFile()   | 지정한 파일이 없을 경우 파일 생성                   |\n| boolean delete()          | 파일 삭제, 디렉토리일 경우에는 비어있을 경우에 삭제 |\n| void deleteOnExit()       | JVM이 종료될 때 파일을 삭제                         |\n| boolean exists()          | 파일이 존재하면 true, 없으면 false                  |\n| String getAbsolutePath()  | 파일의 절대 경로를 문자열로 반환                    |\n| String getCanonicalPath() | 파일의 전체 경로를 문자열로 반환                    |\n| String getName()          | 파일이나 디렉토리의 이름 반환                       |\n| String getParent()        | 부모 경로에 대한 경로명을 문자열로 반환             |\n| File getParentFile()      | 부모 디렉토리를 File의 형태로 반환                  |\n| String getPath()          | 파일의 경로를 문자열의 형태로 반환                  |\n| boolean isDirectory()     | 디렉토리면 true, 아니면 false 반환                                                    |\n\n\u003cbr\u003e\n\n**예제 - java Fileinfo**\n\n```java\nimport java.io.File;  \nimport java.io.IOException;  \n  \npublic class FileInfo {  \n    public static void main(String[] args) {  \n        if (args.length != 1) {  \n            System.out.println(\"사용법 : FileInfo 파일이름\");  \n            System.exit(0);  \n        }   // if end  \n  \n        File f = new File(args[0]);  \n  \n        // 파일이 존재할 경우  \n        if (f.exists()) {  \n            System.out.println(\"length : \" + f.length());  \n            System.out.println(\"canRead : \" + f.canRead());  \n            System.out.println(\"canWrite : \" + f.canWrite());  \n            System.out.println(\"getAbsolutePath : \" + f.getAbsolutePath());  \n  \n            try {  \n                System.out.println(\"getCanonicalPath : \" + f.getCanonicalPath());  \n            } catch (IOException e) {  \n                System.out.println(e);  \n            }  \n  \n            System.out.println(\"getName : \" + f.getName());  \n            System.out.println(\"getParent : \" + f.getParent());  \n            System.out.println(\"getPath : \" + f.getPath());  \n        }  \n  \n        // 파일이 존재하지 않을 경우  \n        else {  \n            System.out.println(\"파일이 존재하지 않습니다.\");  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n**예제 - java FileDelete**\n\n```java\nimport java.io.File;  \n  \npublic class FileDelete {  \n    public static void main(String[] args) {  \n        if (args.length != 1) {  \n            System.out.println(\"사용법 : java FileDelete 파일이름\");  \n            System.exit(0);  \n        }   // if end  \n  \n        File f = new File(args[0]);  \n          \n        if (f.exists()) {  \n            boolean deleteflag = f.delete();  \n            if(deleteflag)  \n                System.out.println(\"파일 삭제를 성공하였습니다.\");  \n            else  \n                System.out.println(\"파일 삭제를 실패하였습니다.\");  \n        } else {  \n            System.out.println(\"파일이 존재하지 않습니다.\");  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n**예제 - FileList**\n- `ls -la` 같은거\n\n```java\npublic class FileList {  \n    public static void main(String[] args) {  \n        File file = new File(\"/Users/jaeyoon/Desktop\");  \n        printFiles(file);  \n    }  \n  \n    private static void printFiles(File file) {  \n        if (file.isDirectory()) {  \n            File[] files = file.listFiles();  \n            for (int i = 0; i \u003c files.length; i++) {  \n                System.out.println(\"[dir] - \" + files[i]);  \n                printFiles(files[i]);  \n            }  \n        } else {  \n            System.out.println(file.getName());  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n**예제 - 임시파일 생성**\n\n```java\nimport java.io.File;  \nimport java.io.IOException;  \n  \npublic class TempFile {  \n    public static void main(String[] args) {  \n        try {  \n            File f = File.createTempFile(\"tmp_\", \".dat\");  \n            System.out.println(f.getAbsolutePath());  \n            System.out.println(\"10초 동안 멈춰있습니다.\");  \n  \n            try {  \n                Thread.sleep(10000); // 10초 동안 프로그램 멈춤  \n            } catch (InterruptedException e) {  \n                System.out.println(e);  \n            }  \n  \n            f.deleteOnExit();   // JVM이 종료될 때 임시파일을 자동으로 삭제  \n        } catch (IOException e) {  \n            System.out.println(e);  \n        }  \n    }  \n}\n\n// /var/folders/mc/pg8hsl1s6ng960_zspk455cc0000gn/T/tmp_17714656951715397422.dat\n//  10초 동안 멈춰있습니다.\n```\n\n\u003cbr\u003e\n\n## IO Stream\n\n- ==**byte나 char의 흐름을 IO Stream이라 한다.**==\n- byte의 흐름은 Byte Stream\n\t- 추상 클래스\n\t- InputStream, OutputStream\n\t- byte 단위 입출력 클래스는 전부 InputStream, OutputStream의 후손\n- char의 흐름을 Char Stream\n\t- 추상 클래스\n\t- Reader, Writer\n\t- char 단위 입출력 클래스는 전부 Reader, Writer의 후손\n\n![](brain/image/fun-java09-7.png)\n\n![](brain/image/fun-java09-8.png)\n\n![](brain/image/fun-java09-9.png)\n\n![](brain/image/fun-java09-10.png)\n\n![](brain/image/fun-java09-11.png)\n\n![](brain/image/fun-java09-12.png)\n\n![](brain/image/fun-java09-13.png)\n\n![](brain/image/fun-java09-14.png)\n\n- `read(byte[])`가 아니라 `read(char[])`임\n\n![](brain/image/fun-java09-15.png)\n\n- `write(byte[])`가 아니라 `write(char[])`임\n\n\u003cbr\u003e\n\n### InputStream\n\n\u003cbr\u003e\n\n**InputStream이 가지는 중요 메서드**\n\n| 메서드명                                     | 내용                                                                                                          |\n| -------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |\n| `int available() throws IOException`         | 현재 읽을 수 있는 바이트 수 반환                                                                              |\n| `void close() throws IOException`            | 입력 스트림 닫음                                                                                              |\n| **`int read() throws IOException`**              | 입력 스트림에서 한 바이트 읽어서 int로 반환 \u003cbr\u003e 더이상 읽을 내용 없으면 -1 반환                              |\n| `int read(byte buf[]) throws IOException`    | 입력 스트림에서 `buf[]` 크기만큼 읽어 buf에 저장하고 읽은 바이트 수 반환 \u003cbr\u003e 더이상 읽을 내용 없으면 -1 반환 |\n| `int skip(long numBytes) throws IOException` | numBytes로 지정된 바이트 무시, 무시된 바이트 수 반환                                                                                                              |\n\n\u003cbr\u003e\n\n### InputStream - read()\n\n\u003cbr\u003e\n\n```java\nimport java.io.IOException;  \nimport java.io.InputStream;  \n  \npublic class InputStreamExam01 {  \n    public static void main(String[] args) {  \n        InputStream in = null;  \n        try {  \n            int data = in.read();  \n        } catch (IOException e) {  \n            System.out.println(\"io 오류 : \" + e);  \n        } finally {  \n            try {  \n                in.close();  \n            } catch (Exception e) {  \n                System.out.println(\"io 오류 : \" + e);  \n            }  \n        }  \n    }  \n}\n```\n\n위의 코드를 보면, InputStream 클래스는 byte 단위 입출력이라면서 `read()` 메서드는 왜 정수형 int일까?\n\n==**Q. byte 단위로 읽어들이는 read() 메서드가 왜 byte를 return 하지 않고 int를 return 하나?**  ==\n- A. 1byte의 범위인 (00000000 ~ 11111111) 만으로는 EOF를 표현할 수 있는 방법이 없어서.\n\n1byte가 표현할 수 있는 값은 8bits니까 00000000 ~ 1111111 중 하나이다. 만약 byte를 return 한다면 이 범위 중 하나의 값을 가졌을 것이다. 만약 파일 크기가 100byte라면 1byte씩 100번 읽어들이면 될 것임을 알 수 있는데, **파일 크기를 모른다면 몇 번 만큼 읽어야 할까?**\n\n그래서 파일의 마지막임을 알릴 EOF(End Of File)이라는 것이 필요하게 되었다. 이 EOF를 표현하기 위해 정수 -1을 사용하려고 했는데 1byte로 이를 표현할 수 있는가? 그래서 int형이 4byte니까 이를 이용하여 EOF를 표현한 것이다.\n\n- int(4byte) 1 : 00000000 00000000 00000000 00000001\n- 1의 보수 : 11111111 11111111 11111111 11111110\n- 2의 보수\n\t- 1의 보수 + 1\n\t- 11111111 11111111 11111111 11111111 = -1\n\n\u003cbr\u003e\n\n### InputStream OutputStream\n\n\u003cbr\u003e\n\n```java {title=\"HelloIO01.java\"}\nimport java.io.FileOutputStream;  \nimport java.io.OutputStream;  \n  \npublic class HelloIO01 {  \n    public static void main(String[] args) throws Exception {  \n        OutputStream out = new FileOutputStream(\"/Users/jaeyoon/Desktop/hello01.dat\");  \n        out.write(1); // 0000 0000  0000 0000   0000 0000   0000 0001  \n        out.write(255);  \n        out.write(0);  \n        out.close();  \n    }  \n}\n```\n\n- 3 바이트 크기의 파일이 생성됨. 1바이트씩 3번이니까\n\n\u003cbr\u003e\n\n```java {title=\"HelloIO02.java\"}\nimport java.io.FileInputStream;  \nimport java.io.InputStream;  \n  \npublic class HelloIO02 {  \n    public static void main(String[] args) throws Exception {  \n        InputStream in = new FileInputStream(\"/Users/jaeyoon/Desktop/hello01.dat\");  \n        int i1 = in.read();  \n        System.out.println(i1); // 1  \n        int i2 = in.read();  \n        System.out.println(i2); // 255  \n        int i3 = in.read();  \n        System.out.println(i3); // 0  \n        int i4 = in.read();  \n        System.out.println(i4); // -1, 파일의 끝 EOF        in.close();  \n    }  \n}\n```\n\n- 3바이트 파일을 3번 읽으니까 정상적으로 값이 나옴\n- 1번 더 읽으려고 하면 -1이 나옴. EOF니까\n\n\u003cbr\u003e\n\n```java\nimport java.io.FileInputStream;  \nimport java.io.InputStream;  \n  \npublic class HelloIO02 {  \n    public static void main(String[] args) throws Exception {  \n        InputStream in = new FileInputStream(\"/Users/jaeyoon/Desktop/hello01.dat\");  \n        int buf = -1;  \n        while ((buf = in.read()) != -1) {  \n            System.out.println(buf);  \n        }  \n        in.close();  \n    }  \n}\n```\n\n- 이렇게 하면 EOF 전까지 계속 출력해주는거임\n\n\u003cbr\u003e\n\n### Reader Writer\n\n\u003cbr\u003e\n\n```java {title=\"HelloIO03.java\"}\npublic class HelloIO03 {  \n    public static void main(String[] args) throws Exception {  \n        Writer out = new FileWriter(\"/Users/jaeyoon/Desktop/hello.txt\");  \n        out.write((int)'a');  \n        out.write((int)'h');  \n        out.write((int)'!');  \n        out.close();  \n    }  \n}\n```\n\n- 결과물로 저장된 hello.txt 파일의 크기는 3byte가 나온다.\n- 하지만, `가, 나, 다`와 같이 저장하면 파일의 크기가 9byte가 나온다.\n\n\u003cbr\u003e\n\n```java {title=\"HelloIO04.java\"}\nimport java.io.FileReader;  \nimport java.io.Reader;  \n  \npublic class HelloIO04 {  \n    public static void main(String[] args) throws Exception {  \n        Reader in = new FileReader(\"/Users/jaeyoon/Desktop/hello.txt\");  \n        int ch = -1;  \n        while ((ch = in.read()) != -1) {  \n            System.out.println((char)ch);  \n        }  \n        in.close();  \n    }  \n}\n\n// 가\n// 나\n// 다\n```\n\n\u003cbr\u003e\n\n### Stream 흐름\n\n![](brain/image/fun-java09-16.png)\n\n- Java IO는 다양하게 연결할 수 있다.\n- 이때 IO 스트림은 생성자에 들어온 것을 토대로 읽어들인다.\n- `readLine()` 메서드를 실행하면 BufferedReader가 생성자에 있는 Reader의 `read()` 메서드를 계속 호출 -\u003e InputStreamReader의 생성자에 있는 InputStream의 `read()` 메서드 계속 호출 -\u003e FileInputStream은 File에서 계속 읽어옴\n- buffer가 한 줄 가득차면 내보냄\n\n\u003cbr\u003e\n\n```java\nimport java.io.FileOutputStream;  \nimport java.io.OutputStreamWriter;  \nimport java.io.PrintWriter;  \n  \npublic class HelloIO05 {  \n    public static void main(String[] args) throws Exception {  \n        PrintWriter out = new PrintWriter(new OutputStreamWriter(new FileOutputStream(\"/Users/jaeyoon/Desktop/my.txt\")));  \n        out.println(\"hello\");  \n        out.println(\"world\");  \n        out.println(\"!!!!\");  \n        out.close();  \n    }  \n}\n```\n\n- FileOutputStream은 \"/Users/jaeyoon/Desktop/my.txt\"에 저장  \n- FileOutputStream은 write(int); int의 마지막 byte만 저장  \n- OutputStreamWriter는 생성자에 들어온 OutputStream의 write()를 이용하여야 한다.  \n- OutputStreamWriter는 write(int); int의 끝부분 char를 저장  \n- PrintWriter는 생성자에 들어온 OutputStreamWriter의 write() 메서드를 이용하여야 한다.  \n- PrintWriter는 println(문자열); 문자열을 출력  \n\n\u003cbr\u003e\n\n```java\nimport java.io.BufferedReader;  \nimport java.io.FileInputStream;  \nimport java.io.InputStreamReader;  \n  \npublic class HelloIO06 {  \n    public static void main(String[] args) throws Exception {  \n        BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(\"/Users/jaeyoon/Desktop/my.txt\")));  \n        String line = null;  \n        while ((line = in.readLine()) != null) {  \n            System.out.println(line);  \n        }  \n        in.close();  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### Composite 패턴\n\n![](brain/image/fun-java09-18.png)\n\n- Composite 패턴이란 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 것이다.\n- 인터페이스가 아니라 추상클래스가 되어도 상관없다.\n- Folder와 File은 둘 다 모두 공통적으로 가지고 있는 FileComponent를 상속받게 된다.\n- 추가적으로, Folder는 FileComponent를 가질 수 있다.( 마름모로 연결되어 있으니까 )\n- ==**Folder나 File을 공통인 FileComponent로 봄으로써 일체화시킨다는 의미**==\n- \u003ca href='https://refactoring.guru/ko/design-patterns/composite' target='_blank'\u003e링크 참고\u003c/a\u003e하기\n- 자바 IO는 데코레이터 패턴이라고 했는데, 위에 세 가지 부분 Component, ConcreateComponent, Decorater 부분을 보면 Composite 패턴과 닮았다는 것이 보일 것이다.\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\u003csummary\u003e\u003cstrong\u003e코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\t\n```java {title=\"Node.java\"}\npublic abstract class Node {  \n    private String name;  \n    public Node(String name) {  \n        this.name = name;  \n    }  \n\n    public String getName() {  \n        return name;  \n    }  \n\n    public void setName(String name) {  \n        this.name = name;  \n    }  \n\n    public abstract long getSize();  \n    public abstract boolean isFolder();  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"File.java\"}\npublic class File extends Node {  \n    private long size;  \n    public File(String name, long size) {  \n        super(name);  \n        this.size = size;  \n    }  \n\n    @Override  \n    public long getSize() {  \n        return this.size;  \n    }  \n\n    @Override  \n    public boolean isFolder() {  \n        return false;  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"Folder.java\"}\npublic class Folder extends Node { \n\tprivate List\u003cNode\u003e nodes;\n    public Folder(String name) {  \n        super(name);  \n        nodes = new ArrayList\u003c\u003e();  \n    }  \n\n    public void add(File file) {  \n        nodes.add(file);  \n    }  \n\n    public void add (Folder folder) {  \n        nodes.add(folder);  \n    }  \n\n    @Override  \n    public long getSize() {  \n        long total = 0L;\n        for (int i = 0; i \u003c nodes.size(); i++) {\n\t        total = total + nodes.get(i).getSize();\n        }\n        return total;  \n    }  \n\n    @Override  \n    public boolean isFolder() {  \n        return true;  \n    }  \n}\n```\n\u003cbr\u003e\n\n\u003c/Node\u003e\n\n\u003cbr\u003e\n\n```java\npublic class CompositePatternDemo {  \n    public static void main(String[] args) {  \n        File f1 = new File(\"file1\", 10L);  \n        File f2 = new File(\"file2\", 20L);  \n        File f3 = new File(\"file3\", 30L);  \n\n        Folder folder1 = new Folder(\"folder1\");  \n        Folder folder2 = new Folder(\"folder2\");  \n\n        folder1.add(f1);  \n        folder1.add(folder2);  \n\n        folder2.add(f2);  \n        folder2.add(f3);  \n        System.out.println(folder1.getSize());  \n    }  \n}\n```\n\n- 결과적으로, File과 Folder를 추상 클래스인 Node를 상속받으면서 Node 취급하여 일체화시켜서 처리할 수 있게 되었음\n- folder1의 크기를 물어봤는데, folder1은 파일인 f1과 폴더인 folder2의 합이다.\n- folder2는 다시 파일인 f2와 f3이다.\n- 따라서, 출력은 최종적으로 크기 60이 나온다.\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### Decorator 패턴 실습\n\n![](brain/image/fun-java09-19.png)\n\n- Shape를 상속받으면서 Shape를 가지지는 않는 Circle과 Rectangle이 주인공\n\t- 장식할 대상\n- Shape를 가질 수 있는 ShapeDecorator, RedShapeDecorator가 장식\n- Demo 코드를 보자.\n\t- `Shape shape = new RedShapeDecorator(new RedShapeDecorator(new Rectangle()));`\n\t- `InputStream in = new DataInputStream(new FileInputStream(\"a.txt\"));`\n\t\t- Shape --\u003e InputStream (추상클래스)\n\t\t- Rectangle --\u003e FileInputStream\n\t\t- RedShapeDecorator --\u003e DataInputStream\n\n\u003cdetails\u003e\u003csummary\u003e\u003cstrong\u003e코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\t\n\u003cbr\u003e\n\n```java {title=\"Shape.java\"}\npublic abstract class Shape {  \n    public abstract void draw();  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"Circle.java\"}\npublic class Circle extends Shape {  \n    @Override    \n    public void draw() {  \n        System.out.println(\"Shape : Circle\");  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"Rectangle.java\"}\npublic class Rectangle extends Shape {  \n    @Override    \n    public void draw() {  \n        System.out.println(\"Shape : Rectangle\");  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"ShapeDecorator.java\"}\npublic class ShapeDecorator extends Shape {  \n    protected Shape decoratedShape;  \n  \n    public ShapeDecorator(Shape decoratedShape) {  \n        this.decoratedShape = decoratedShape;  \n    }  \n  \n    public void draw() {  \n        decoratedShape.draw();  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"RedShapeDecorator.java\"}\npublic class RedShapeDecorator extends ShapeDecorator {  \n    public RedShapeDecorator(Shape decoratedShape) {  \n        super(decoratedShape);  \n    }  \n  \n    @Override  \n    public void draw() {  \n        setRedBorder(decoratedShape);  \n    }  \n  \n    private void setRedBorder(Shape decoratedShape) {  \n        System.out.println(\"Red ============== Start\");  \n        decoratedShape.draw();  \n        System.out.println(\"Red ============== End\");  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"DecoratorPatternDemo.java\"}\npublic class DecoratorPatternDemo {  \n    public static void main(String[] args) {  \n        Shape circle = new Circle();  \n  \n        // 빨간색으로 장식할 대상이 Circle        \n        Shape redCircle = new RedShapeDecorator(new Circle());  \n        Shape greenCircle = new GreenShapeDecorator(new Circle());  \n        Shape redRectangle = new RedShapeDecorator(new Rectangle());  \n  \n        System.out.println(\"Circle with normal border\");  \n        circle.draw();  \n  \n        System.out.println(\"\\nCircle of red border\");  \n        redCircle.draw();  \n  \n        System.out.println(\"\\nCircle of green border\");  \n        greenCircle.draw();  \n  \n        System.out.println(\"\\nRectangle of red border\");  \n        redRectangle.draw();  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n\u003c/details\u003e\n\n### DataStream\n\n- 기본형 타입과 문자열을 읽고 쓸 수 있다.\n- DataInputStream, DataOutputStream\n- Stream, 흐름에 맞게 순서대로 출력 및 입력 !\n\n\u003cbr\u003e\n\n\u003cdetails\u003e\u003csummary\u003e\u003cstrong\u003e코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\t\n```java\npublic class HelloIO07 {  \n    public static void main(String[] args) throws Exception {  \n        // 이름, 국어, 영어, 수학, 총점, 평균 점수를 /Users/jaeyoon/Desktop/score.dat 파일에 저장  \n        String name = \"kim\";  \n        int kor = 90;  \n        int eng = 50;  \n        int math = 70;  \n        double total = kor + eng + math;  \n        double avg = total / 3.0;  \n  \n        DataOutputStream out = new DataOutputStream(new FileOutputStream(\"/Users/jaeyoon/Desktop/score.dat\"));  \n        out.writeUTF(name);  \n        out.writeInt(kor);  \n        out.writeInt(eng);  \n        out.writeInt(math);  \n        out.writeDouble(total);  \n        out.writeDouble(avg);  \n  \n        out.writeUTF(name);  \n        out.writeInt(kor);  \n        out.writeInt(eng);  \n        out.writeInt(math);  \n        out.writeDouble(total);  \n        out.writeDouble(avg);  \n        out.close();  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java\npublic class HelloIO08 {  \n    public static void main(String[] args) throws Exception {  \n        // 이름, 국어, 영어, 수학, 총점, 평균 점수를 /Users/jaeyoon/Desktop/score.dat 파일에서 읽기  \n        DataInputStream in = new DataInputStream(new FileInputStream(\"/Users/jaeyoon/Desktop/score.dat\"));  \n        printStudent(in);  \n        printStudent(in);  \n        in.close();  \n    }  \n  \n    private static void printStudent(DataInputStream in) throws IOException {  \n        String name = in.readUTF();  \n        int kor = in.readInt();  \n        int eng = in.readInt();  \n        int math = in.readInt();  \n        double total = in.readDouble();  \n        double avg = in.readDouble();  \n  \n        System.out.println(name);  \n        System.out.println(kor);  \n        System.out.println(eng);  \n        System.out.println(math);  \n        System.out.println(total);  \n        System.out.println(avg);  \n    }  \n}\n// kim\n// 90\n// 50\n// 70\n// 210.0\n// 70.0\n// kim\n// 90\n// 50\n// 70\n// 210.0\n// 70.0\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### ByteArrayStream\n\n- `byte[]`에 데이터를 읽고 쓰기\n- ByteArrayInputStream, ByteArrayOutputStream\n- 생성자에 아무것도 안받는 것은 \"메모리에 쓴다는 의미\"\n\n\u003cdetails\u003e\u003csummary\u003e\u003cstrong\u003e코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\t\n```java\npublic class HelloIO09 {  \n    public static void main(String[] args) throws Exception {  \n        int data1 = 1;  \n        int data2 = 2;  \n        // 메모리 상에 저장한다  \n        ByteArrayOutputStream out = new ByteArrayOutputStream();  \n        out.write(data1);   // data1의 마지막 1 byte만 저장  \n        out.write(data2);   // data2의 마지막 1 byte만 저장  \n        out.close();  \n  \n        byte[] array = out.toByteArray();  \n        System.out.println(array.length);  \n        System.out.println(array[0]);  \n        System.out.println(array[1]);  \n    }  \n}\n// 2\n// 1\n// 2\n```\n\n\u003cbr\u003e\n\n```java\npublic class HelloIO10 {  \n    public static void main(String[] args) throws Exception {  \n        byte[] array = new byte[2];  \n        array[0] = (byte)1;  \n        array[1] = (byte)2;  \n  \n        ByteArrayInputStream in = new ByteArrayInputStream(array);  \n        int read1 = in.read();  \n        int read2 = in.read();  \n        int read3 = in.read();  \n        in.close();  \n  \n        System.out.println(read1);  \n        System.out.println(read2);  \n        System.out.println(read3);  \n    }  \n}\n// 1\n// 2\n// -1\n```\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### CharArray\n\n- `char[]`에 데이터를 읽고 쓰기\n- CharArrayReader, CharArrayWriter\n\n\u003cbr\u003e\n\n### StringReader, StringWriter\n\n- 문자열 쓰고 읽기\n- 생성자에 아무것도 안받는 것은 \"메모리에 쓴다는 의미\"\n\n\u003cdetails\u003e\u003csummary\u003e\u003cstrong\u003e코드 예시보기\u003c/strong\u003e\u003c/summary\u003e\n\t\n```java\npublic class HelloIO11 {  \n    public static void main(String[] args) throws Exception {  \n        StringWriter out = new StringWriter();  \n        out.write(\"hello\");  \n        out.write(\"world\");  \n        out.write(\"!!!\");  \n        out.close();  \n  \n        String str = out.toString();  \n        System.out.println(str);  \n    }  \n}\n// helloworld!!!\n```\n\n\u003cbr\u003e\n\n```java\npublic class HelloIO12 {  \n    public static void main(String[] args) throws Exception {  \n        StringReader in = new StringReader(\"helloworld!!!\");  \n        int ch = -1;  \n        while ((ch = in.read()) != -1) {  \n            System.out.print((char)ch);  \n        }  \n        in.close();  \n    }  \n}\n// helloworld!!!\n```\n\n\u003cbr\u003e\n\n\u003c/details\u003e\n\n\u003cbr\u003e\n\n### ObjectStream, 직렬화\n\n- ObjectIntputStream, ObjectOutputStream\n- 직렬화 가능한 대상을 읽고 쓸 수 있다.\n- ==**직렬화 가능한 대상은 `기본형 타입` or `java.io.Serializable` 인터페이스를 구현하고 있는 객체**==이다.\n\t- 아무 객체나 읽고 쓸 수 있는 것이 아니다.\n\t- Serializable 인터페이스는 메서드가 하나도 없어서 구현만 해주면 된다.\n\t- 이렇게 메서드가 하나도 없는 인터페이스를 ==**Mark Interface**==라고 하는데 이는 메소드 구현목적이 아니라 표시만 해두는 기능에 주 목적이 있다.\n\n\u003cbr\u003e\n\n==**객체 직렬화는 객체를 write 하게 되면, 객체가 byte의 흐름으로 바뀌어서 다른 장소로 전송될 수 있게 되는 것이다. 전송되는 공간은 파일이나 메모리 같은 것이 있다. 전송받은 곳에서는 객체의 byte의 흐름을 다시 역직렬화를 통하여 객체로 만들게 된다.**==\n\n\u003cbr\u003e\n\n```java\npublic class ObjectOutputExam {  \n    public static void main(String[] args) throws Exception {  \n        User user = new User(\"uni@example.com\", \"신재윤\", 1996);  \n        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"/Users/jaeyoon/Desktop/user.dat\"));  \n        out.writeObject(user);  \n        out.close();  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java\npublic class ObjectInputExam {  \n    public static void main(String[] args) throws Exception {  \n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"/Users/jaeyoon/Desktop/user.dat\"));  \n        User user = (User)in.readObject();  \n        in.close();  \n        System.out.println(user);  \n    }  \n}\n\n// User{email='uni@example.com', name='신재윤', birthYear=1996}\n```\n\n\u003cbr\u003e\n\n```java\npublic class ObjectOutputExam {  \n    public static void main(String[] args) throws Exception {  \n        User user1 = new User(\"uni@example.com\", \"신재윤\", 1996);  \n        User user2 = new User(\"zzzzz@example.com\", \"홍길동\", 1986);  \n        User user3 = new User(\"asdfasdf@example.com\", \"둘리\", 1972);  \n        ArrayList\u003cUser\u003e list = new ArrayList\u003c\u003e();  \n        list.add(user1);  \n        list.add(user2);  \n        list.add(user3);  \n  \n        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"/Users/jaeyoon/Desktop/userlist.dat\"));  \n        out.writeObject(list);  \n        out.close();  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java\npublic class ObjectInputExam {  \n    public static void main(String[] args) throws Exception {  \n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"/Users/jaeyoon/Desktop/userlist.dat\"));  \n        ArrayList\u003cUser\u003e list = (ArrayList)in.readObject();  \n        in.close();  \n        for (int i = 0; i \u003c list.size(); i++) {  \n            System.out.println(list.get(i));  \n        }  \n    }  \n}\n\n// User{email='uni@example.com', name='신재윤', birthYear=1996}\n// User{email='zzzzz@example.com', name='홍길동', birthYear=1986}\n// User{email='asdfasdf@example.com', name='둘리', birthYear=1972}\n```\n\n\u003cbr\u003e\n\n### 얕은복사 깊은복사\n\n\u003cbr\u003e\n\n![](brain/image/fun-java09-20.png)\n\n\u003cbr\u003e\n\n```java\npublic class ObjectInputOutExam {  \n    public static void main(String[] args) throws Exception {  \n        User user1 = new User(\"uni@example.com\", \"신재윤\", 1996);  \n        User user2 = new User(\"zzzzz@example.com\", \"홍길동\", 1986);  \n        User user3 = new User(\"asdfasdf@example.com\", \"둘리\", 1972);  \n        ArrayList\u003cUser\u003e list = new ArrayList\u003c\u003e();  \n        list.add(user1);  \n        list.add(user2);  \n        list.add(user3);\n\n\t\tArrayList\u003cUser\u003e list2 = list;  \n\t\t  \n\t\tfor (int i = 0; i \u003c list2.size(); i++) {  \n\t\t    System.out.println(list2.get(i));  \n\t\t}\n\n\t\tlist.remove(2);\n\t\tSystem.out.println(list.size());\n\t\tSystem.out.println(list2.size());\n    }\n}\n\n// User{email='uni@example.com', name='신재윤', birthYear=1996}\n// User{email='zzzzz@example.com', name='홍길동', birthYear=1986}\n// User{email='asdfasdf@example.com', name='둘리', birthYear=1972}\n// 2\n// 2\n```\n\n- 이와 같은 코드는 list배열이 list2에 복사된 것 일까? 아니다.\n- 기존 list에 있는 내용을 복사하는 것이 아니라 ==**기존 list를 참조하는 것을 동일하게 참조하는 것이다.**==\n\t- 그래서, `list.remove(2)` 하면 동일한 참조니까 같이 사라지는 것\n\n\n\u003chr\u003e\n\n![](brain/image/fun-java09-21.png)\n\n\u003cbr\u003e\n\n```java\npublic class ObjectInputOutExam {  \n    public static void main(String[] args) throws Exception {  \n        User user1 = new User(\"uni@example.com\", \"신재윤\", 1996);  \n        User user2 = new User(\"zzzzz@example.com\", \"홍길동\", 1986);  \n        User user3 = new User(\"asdfasdf@example.com\", \"둘리\", 1972);  \n        ArrayList\u003cUser\u003e list = new ArrayList\u003c\u003e();  \n        list.add(user1);  \n        list.add(user2);  \n        list.add(user3);\n\n\t\tArrayList\u003cUser\u003e list2 = new ArrayList\u003c\u003e();  \n\t\t  \n\t\tfor (int i = 0; i \u003c list2.size(); i++) {  \n\t\t    list2.add(list.get(i));  \n\t\t}\n\n\t\tlist.remove(2);\n\t\tSystem.out.println(list.size());\n\t\tSystem.out.println(list2.size());\n    }\n}\n```\n\n- 그렇다면 이런 상황은 어떠할까? 깊은 복사인가?\n- list만 새로 만들었을 뿐이지, User 객체 자체가 복사되는 것은 아니다. User가 바뀌면 역시 바뀌는 것이라서 얕은 복사이다.\n\n\u003cbr\u003e\n\n![](brain/image/fun-java09-22.png)\n\n**메서드 안 뺀 버전**\n\n```java\npublic class ObjectInputOutExam {  \n    public static void main(String[] args) throws Exception {  \n        User user1 = new User(\"uni@example.com\", \"신재윤\", 1996);  \n        User user2 = new User(\"zzzzz@example.com\", \"홍길동\", 1986);  \n        User user3 = new User(\"asdfasdf@example.com\", \"둘리\", 1972);  \n        ArrayList\u003cUser\u003e list = new ArrayList\u003c\u003e();  \n        list.add(user1);  \n        list.add(user2);  \n        list.add(user3);  \n  \n        ByteArrayOutputStream bout = new ByteArrayOutputStream();  \n        ObjectOutputStream out = new ObjectOutputStream(bout);  \n        out.writeObject(list);  \n        out.close();  \n        bout.close();  \n  \n        list.remove(2);  \n  \n        byte[] array = bout.toByteArray();  \n  \n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(array));  \n        ArrayList\u003cUser\u003e list2 = (ArrayList)in.readObject();  \n        in.close();  \n  \n        for (int i = 0; i \u003c list2.size(); i++) {  \n            System.out.println(list2.get(i));  \n        }  \n    }  \n}\n\n// User{email='uni@example.com', name='신재윤', birthYear=1996}\n// User{email='zzzzz@example.com', name='홍길동', birthYear=1986}\n// User{email='asdfasdf@example.com', name='둘리', birthYear=1972}\n```\n\n\u003cbr\u003e\n\n**메서드 뺀 버전**\n\n```java\npublic class ObjectInputOutExam {  \n    public static void main(String[] args) throws Exception {  \n        User user1 = new User(\"uni@example.com\", \"신재윤\", 1996);  \n        User user2 = new User(\"zzzzz@example.com\", \"홍길동\", 1986);  \n        User user3 = new User(\"asdfasdf@example.com\", \"둘리\", 1972);  \n        ArrayList\u003cUser\u003e list = new ArrayList\u003c\u003e();  \n        list.add(user1);  \n        list.add(user2);  \n        list.add(user3);  \n  \n        ArrayList\u003cUser\u003e list2 = copy(list);  \n  \n        for (int i = 0; i \u003c list2.size(); i++) {  \n            System.out.println(list2.get(i));  \n        }  \n    }  \n  \n    private static ArrayList\u003cUser\u003e copy(ArrayList\u003cUser\u003e list) throws IOException, ClassNotFoundException {  \n        ByteArrayOutputStream bout = new ByteArrayOutputStream();  \n        ObjectOutputStream out = new ObjectOutputStream(bout);  \n        out.writeObject(list);  \n        out.close();  \n        bout.close();  \n  \n        byte[] array = bout.toByteArray();  \n  \n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(array));  \n        ArrayList\u003cUser\u003e list2 = (ArrayList)in.readObject();  \n        in.close();  \n        return list2;  \n    }  \n}\n```\n\n- 이렇게, list가 참조하는 User 객체 자체를 직렬화하여 `byte[]`로 만들어놓는 것이다. Deep Copy! 이러고 나중에 역직렬화해서 사용하면 된다. 진짜 인스턴스가 두 쌍이 되는 것이다.\n- ==**객체 직렬화를 이용하여 객체를 복사하는 예제!**==\n- 다시 한 번 말하면, 직렬화가 가능하다는건 기본형 타입이거나 Serializable 인터페이스를 구현하고 있는 객체!","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java10":{"title":"10. Java Thread","content":"\n인프런의 \u003ca href='https://www.inflearn.com/course/%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%B0%94' target='_blank'\u003e부부 개발단 토토님의 즐거운 자바 강의\u003c/a\u003e를 정리한 내용\n\n\u003chr\u003e\n\n## 성능 향상시키기\n\n![](brain/image/fun-java10-3.png)\n\n성능이 좋은 프로그램을 만들고 싶다고 하자. \n- 예를 들어, 하나의 프로그램에서 위와 같은 작업이 있다.\n- **B** : 병렬화가 가능하지 않은 부분\n- **1 - B** : 병렬화가 가능한 부분\n\n\u003cbr\u003e\n\n![](brain/image/fun-java10-2.png)\n\n- 병렬화가 가능한 부분을 두 부분에서 동시에 실행되도록 하면 시간을 아낄 수 있다.\n\n\u003cbr\u003e\n\n![](brain/image/fun-java10-4.png)\n\n- 병렬화가 가능한 부분을 더 쪼개서 동시에 실행되도록 하면 더 시간을 아낄 수 있다.\n- 그러나, ==**병렬화가 가능하지 않은 부분인 B 때문에 성능을 무한으로 향상시킬 수는 없다.**==\n\n\u003cbr\u003e\n\n### 병렬화 시 고려\n\n병렬화 할 때 고려해야할 것들은 아래와 같다.\n\n- 메모리의 속도\n- CPU 캐시 메모리\n- 디스크\n- 네트워크\n- 커넥션\n- **순차적 실행이 병렬 실행보다 빠른 경우도 있다.** 동시 실행에 따르는 오버헤드가 없고, 단일 CPU 알고리즘은 하드웨어 작업에 더 친화적일 수 있기 때문\n- 등등 ...\n\n\u003cbr\u003e\n\n\u003e **암달의 법칙 (Amdahl's Law)** \u003cbr\u003e\n\u003e 암달의 법칙(Amdahl's law)은 암달의 저주로도 불리며, 컴퓨터 시스템의 일부를 개선할 때 \u003cbr\u003e\n\u003e 전체적으로 얼마만큼의 최대 성능 향상이 있는지 계산하는데 사용된다. \u003cbr\u003e\n\u003e 이론(theory)만 많은 컴퓨터과학 분야에서 몇 안되는 법칙(Law)이다.\n\n\u003cbr\u003e\n\n![](brain/image/fun-java10-5.png)\n\n- 병렬 컴퓨팅을 할 경우, 일부 병렬화 가능한 작업들은 사실상 계산에 참여하는 컴퓨터의 개수에 비례해서 속도가 늘어남\n- 이러한 경우 암달의 법칙에 의해 전체 수행시간의 개선 효과는, **병렬화가 불가능한 작업들의 비중에 크게 영향을 받게 됨**\n- ==**즉, 아무리 컴퓨터의 개수가 늘어나더라도 속도의 한계는 정해져있다는 것**==\n\n\u003cbr\u003e\n\n### 병행 vs 병렬\n\n![](brain/image/fun-java10-6.png)\n\n- ==**병행(Concurrent)**==은 ==**멀티스레드 프로그래밍**==을 의미\n- 병렬(Parallel)은 멀티코어 프로그래밍을 의미\n- 우리가 살펴볼 것은 병행 프로그래밍== **(동시성 프로그래밍, 멀티스레드 프로그래밍)**==\n\n\u003cbr\u003e\n\n![](brain/image/fun-java10-7.png)\n\n- 활성 상태 보기를 보면 이렇게 프로세스, 스레드 등을 확인할 수 있다.\n- ==**각각의 프로세스들은 자신만의 메모리 영역을 확보한 채로 실행되고 있다.**==\n\n\u003cbr\u003e\n\n### Context Switching\n\n![](brain/image/fun-java10-8.png)\n\n- 적절한 시간만큼 쪼개서 프로세스가 실행된다.\n- 컴퓨터는 굉장히 빠르기 때문에 P1~P4가 마치 \"동시에 실행되는 것처럼\" 보인다.\n\t- 실제로 동시에 실행되는 것은 아니다.\n\t- 예를 들어, 프로세스 1 실행동안 다른 프로세스는 멈춰있다.\n- 만약, P1이 실행되다가 잠시 멈췄다가 P2가 실행되는 상황이라고 하자. 그렇다면 나==**중에 다시 P1을 실행하려면, 어디까지 실행이 되었었는지, 메모리는 어디 부분을 사용하고 있었는지를 기억**==하고 있어야 할 것이다. 그래야 나중에 이어서 실행할 수 있으니까.\n\t- 이런 부분을 ==**Context Switching이 발생한다**==고 한다.\n\t- 이 과정에서 시간이 많이 걸린다. 오버헤드가 발생한다.\n\n\u003cbr\u003e\n\n### Process\n\n![](brain/image/fun-java10-9.png)\n\n- 각각의 프로세스는 메모리 공간에서 독립적으로 존재\n- 각각의 프로세스는 자신만의 메모리 구조를 가짐 (스택, 힙, BSS, Text)\n- 프로세스 A, B, C가 있을 경우 각각 프로세스는 모두 같은 구조의 메모리 공간을 가짐\n- 독립적인만큼 다른 프로세스의 메모리 공간에 접근할 수 없음\n\t- 그렇다면, **프로세스끼리 어떻게 통신할까?** -\u003e ==**IPC**==\n\n\u003cbr\u003e\n\n### IPC\n\n![](brain/image/fun-java10-10.png)\n\n**IPC (Inter-Process Communication) : 프로세스간 통신**\n\n- 프로세스 A에서 프로세스 B를 직접 접근할 수 없기 때문에, ==**프로세스 간의 통신을 하는 특별한 방식**==이 필요하다. 메일슬록(mailslot), 파이프(pipe) 등이 바로 프로세스 간의 통신, 즉, ==**IPC**==의 예시이다.\n- 프로세스는 독립적인 메모리 공간을 지니기 때문에 IPC를 통하지 않고 통신할 수 없다.\n- ==**프로세스가 여럿이 병렬적으로 실행되기 위해서는 필연적으로 Context Switching이 발생할 수 밖에 없다. 이것을 해결할 수 있는 것이 Thread이다.**==\n\t- 스레드도 컨택스트 스위칭이 없는 것은 아니다.\n\t- 하지만, 프로세스의 컨택스트 스위칭 비용보다 스레드의 컨택스트 스위칭 비용이 더 작아서 스레드가 더 유리하다.\n\n\u003cbr\u003e\n\n### Thread\n\n![](brain/image/fun-java10-11.png)\n\n- 스레드는 ==**하나의 프로그램 내에 존재하는 여러 개의 실행 흐름을 위한 모델**==\n- 우리가 생각하는 프로그램이 실행되기 위해서 하나의 실행흐름으로 처리할 수도 있지만, 다수의 실행흐름으로 처리할 수도 있음\n- 스레드는 프로세스와 별개가 아닌 프로세스를 구성하고 실행하는 흐름\n- 스레드도 Context Switching이 발생\n\n\u003cbr\u003e\n\n**메모리 공간에서의 스레드**\n\n![](brain/image/fun-java10-12.png)\n\n- ==**하나의 프로세스가 가지고 있는 메모리를 여러 개의 스레드가 공유한다.**==\n- 프로세스와 프로세스 간 전환보다 스레드와 스레드 간 전환의 비용이 당연히 적다.\n\n\u003cbr\u003e\n\n### Thread vs Process\n\n- 스레드는 프로세스 안에 존재하는 실행 흐름\n- 스레드는 프로세스의 heap, static, code 영역 등을 공유\n- 스레드는 stack 영역을 제외한 메모리 영역은 공유\n- 스레드가 code 영역을 공유하기 때문에, 프로세스 내부의 스레드들은 프로세스가 가지고 있는 함수를 자연스럽게 모두 호출할 수 있음\n- 스레드는 IPC 없이도 스레드 간 통신 가능\n\t- A, B 스레드는 통신하기 위해 heap 영역에 메모리 공간 할당, 두 스레드가 자유롭게 접근 가능\n- 스레드는 프로세스처럼 스케쥴링의 대상이다. 이 과정에서 컨택스트 스위칭이 발생\n\t- 하지만, 스레드는 공유하고 있는 메모리 영역 덕분에 컨택스트 스위칭 때문에 발생하는 오버헤드가 프로세스에 비해 적음\n\t\t- 동작 중인 프로세스가 바뀔 때 프로세스는 자신의 상태(context 정보)를 일단 보존한 후, 새롭게 동작 개시하는 프로세스는 이전에 보존해 두었던 자신의 context 정보를 다시 복구한다. 이와 같은 현상을 Context Switching이라 한다.\n\t\t- 스레드의 컨택스트 정보는 프로세스보다 적기에 스레드의 컨택스트 스위칭은 가볍게 행해지는 것이 보통\n\t\t- 하지만, 실제로 스레드와 프로세스의 관계는 JVM 구현에 크게 의존\n- 참고로, 플랫폼이 같아도 JVM의 구현방법에 따라 프로세스와 스레드의 관계는 달라질 수 있음\n\n\u003cbr\u003e\n\n무조건적으로 멀티 스레드 프로그래밍이 더 낫다는 의미는 아니다. 여러 스레드가 하나의 메모리를 공유해서 사용하는 경우에, 자원을 획득하기 위한 스레드 간 경쟁이 발생한다.\n- 메모리가 많고, 컴퓨터의 속도가 빠른 경우에는 여러 개의 프로세스를 이용하여 실행하는 것이 여러 개의 스레드보다 유리할 수 있다.\n\n\u003cbr\u003e\n\n**멀티스레드(Multi Thread) 실행 방식**\n\n![](brain/image/fun-java10-13.png)\n\n- ==**main 메서드부터 시작되어 흘러가는 하나의 흐름을 Main Thread**==라고 한다.\n- Main 흐름 안에서 새로운 스레드를 발생시켜서 동시에 여러 흐름이 흐르게 할 수 있다.\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## Java Thread 생성\n\nJava에서 스레드를 생성하는 방법은 2가지가 있다.\n1. Thread 클래스 상속받기\n2. Runnable 인터페이스 구현하기\n\n\u003cbr\u003e\n\n### Thread 클래스 상속\n\n1. Thread 클래스를 상속받는다.\n2. `run()` 메서드를 오버라이딩 한다.\n3. `start()` 메서드로 시작한다.\n\n![](brain/image/fun-java10-14.png)\n\n- Thread 클래스를 상속받아 스레드를 작성할 수 있음\n- Thread의 `run()` 메서드를 상속받는 클래스에서 반드시 오버라이딩 해야한다.\n- ==**`start()` 메서드가 굉장히 중요**==하다.\n\t- **Thread가 실행될 준비를 해주고**, `run()` 메서드를 실행시키면서 스레드 흐름이 하나 더 생기게 되는 것이다.\n\n\u003cbr\u003e\n\n```java\nclass Xxx extends Thread {\n\tpublic void run() {\n\t\t// 동시에 실행될 드 작성\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\nXxx x = new Xxx();\nx.start();\n```\n\n\u003cbr\u003e\n\n**예시**\n\n```java {title=\"MyThreadMain\"}\npublic class MyThreadExam {  \n    public static void main(String[] args) {  \n        String name = Thread.currentThread().getName();  \n        System.out.println(\"thread name : \" + name);  \n        System.out.println(\"thread start!\");  \n  \n        MyThread myThread1 = new MyThread(\"*\");  \n        MyThread myThread2 = new MyThread(\"+\");  \n\n\t\t// 3. start() 메서드로 실행\n        myThread1.start();  \n        myThread2.start();  \n  \n        System.out.println(\"thread end!\");  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"MyThread.java\"}\n// 1. Thread 클래스 상속받음\npublic class MyThread extends Thread {  \n  \n    private String str;  \n  \n    public MyThread(String str) {  \n        this.str = str;  \n    }  \n\n\t// 2. run() 메서드 오버라이딩\n    @Override  \n    public void run() {  \n        String name = Thread.currentThread().getName();  \n        System.out.println(\"---\" + name + \"---\");  \n        for (int i = 0; i \u003c 10; i++) {  \n            System.out.print(str);  \n            try {  \n                Thread.sleep(1000); // 1초간 쉰다  \n            } catch (InterruptedException ie) {  \n                ie.printStackTrace();  \n            }  \n        }  \n    }  \n}\n// thread name : main\n// thread start!\n// thread end!\n// ---Thread-0---\n// *---Thread-1---\n// +*++*+*+*+**+*++*+*\n```\n\n- ==**모든 스레드가 종료될 때 프로그램이 종료된다.**==\n\n\u003cbr\u003e\n\n### Runnable 인터페이스 구현\n\n1. Runnable 인터페이스 구현\n2. `run()` 메서드 오버라이딩\n3. Thread 인스턴스를 생성할 때, 생성자에 Runnable 인스턴스 넣기\n4. Thread가 가지고 있는 `start()` 메서드 호출\n\n![](brain/image/fun-java10-15.png)\n\n- Runnable 인터페이스를 구현하면 `run()` 메서드를 반드시 오버라이딩\n- 근데, Runnable 인터페이스에는 스레드가 실행될 준비를 해주는 `start()` 메서드가 없다.\n\t- 그래서 만든 클래스를 스레드가 **가지도록 해야 한다.**\n\n\u003cbr\u003e\n\n```java\nclass Xxx implements Runnable {\n\tpublic void run() {\n\t\t// 동시에 실행될 코드 작성\n\t}\n}\n```\n\n\u003cbr\u003e\n\n```java\nXxx x = new Xxx();\nThread t = new Thread(x);\nt.start();\n```\n\n\u003cbr\u003e\n\n```java {title=\"MyRunnable.java\"}\n\n// 1. Runnable 인터페이스 구현  \npublic class MyRunnable implements Runnable {  \n    private String str;  \n    \n    public MyRunnable(String str) {  \n        this.str = str;  \n    }  \n  \n    // 2. run() 메서드 오버라이딩  \n    @Override  \n    public void run() {  \n        String name = Thread.currentThread().getName();  \n        System.out.println(\"---\" + name + \"---\");  \n        for (int i = 0; i \u003c 10; i++) {  \n            System.out.print(str);  \n            try {  \n                Thread.sleep(1000); // 1초간 쉰다  \n            } catch (InterruptedException ie) {  \n                ie.printStackTrace();  \n            }  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"MyThreadExam2.java\"}\npublic class MyThreadExam2 {  \n    public static void main(String[] args) {  \n        String name = Thread.currentThread().getName();  \n        System.out.println(\"thread name : \" + name);  \n        System.out.println(\"thread start!\");  \n  \n        MyRunnable myRunnable1 = new MyRunnable(\"*\");  \n        MyRunnable myRunnable2 = new MyRunnable(\"+\");  \n  \n        // 3. Thread 인스턴스를 생성할 때, 생성자에 Runnable 인스턴스 넣기  \n        Thread thread1 = new Thread(myRunnable1);  \n        Thread thread2 = new Thread(myRunnable2);  \n  \n        // 4. Thread가 가지고 있는 start() 메서드를 호출  \n        thread1.start();  \n        thread2.start();  \n  \n        System.out.println(\"thread end!\");  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/fun-java/fun-java11":{"title":"11. Java Network","content":"\n## 네트워크 프로그래밍\n\n### 기초 용어\n\n**IP 주소와 Port**\n- **IP** : 컴퓨터를 구분하는 주소\n- **Port** : 컴퓨터 안에 있는 서버들을 구분하는 값\n\t- FTP서버, 웹서버 등 다양한 서버들이 컴퓨터에 실행될 수 있으니까\n\n\u003cbr\u003e\n\n| 구분                           | 범위          | 설명                                                      |\n| ------------------------------ | ------------- | --------------------------------------------------------- |\n| Well Known Port 번호           | 0 ~ 1023      | 국제 인터넷 주소 관리 기구 (ICANN)에서 미리 예약해둔 포트 |\n| Registered Port 번호           | 1024 ~ 49151  | 개인 또는 회사에서 사용하는 포트                          |\n| Dynamic 또는 Private Port 번호 | 49152 ~ 65535 | OS가 부여하는 동적 포트, 개인적인 목적으로 사용할 수 있는 포트                                                          |\n\n\u003cbr\u003e\n\n**127.0.0.1**\n- 컴퓨터 자신의 IP\n\n\u003cbr\u003e\n\n**도메인(Domain) 주소**\n- `https://www.naver.com`에서 `www.naver.com`은 도메인 주소이다.\n\n\u003cbr\u003e\n\n**도메인 네임 서버 (DNS, Domain Name Server)**\n- 도메인 주소를 IP로 변환한다.\n- `nslookup 도메인주소`\n\t- 이 명령으로 도메인에 해당하는 IP 주소를 알아낼 수 있음\n\n\u003cbr\u003e\n\n**Mac, Linux에서 DNS 설정**\n- `/etc/resolv.conf` 파일에서 설정\n- 보통 nameserver는 2개를 사용하는데, 하나가 죽었을 때 다른 것을 사용하기 위함\n\n![](brain/image/fun-java11-1.png)\n\n\u003cbr\u003e\n\n**localhost**\n- 컴퓨터 자신의 도메인\n\n\u003cbr\u003e\n\n### Java 네트워크\n\n**IP 주소 알아내기** : InetAddress로 알아냄\n\n- 사용자 컴퓨터의 IP 주소 알아내기\n\n```java\nInetAddress ia = InetAddress.getLocalHost();\nSystem.out.println(ia.getHostAddress());\n```\n\n\u003cbr\u003e\n\n- google의 IP 주소 알아내기\n\t- 하나의 도메인은 여러 개의 IP 주소와 매핑될 수 있으니까 배열로 받았음\n\n```java\nInetAddress[] iaArr = InetAddress.getAllByName(\"www.google.com\");\nfor (InetAddress ia : iaArr) {\n\tSystem.out.println(ia.getHostAddress());\n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"IpAddressExam\"}\nimport java.net.InetAddress;  \nimport java.net.UnknownHostException;  \n  \npublic class IpAddressExam {  \n    public static void main(String[] args) {  \n        try {  \n            InetAddress ia = InetAddress.getLocalHost(); // 내 컴퓨터의 IP 정보를 구함  \n            System.out.println(ia.getHostAddress());  \n        } catch (UnknownHostException ue) {  \n            ue.printStackTrace();  \n        }  \n  \n        try {  \n            InetAddress[] iaArray = InetAddress.getAllByName(\"www.google.com\");  \n            for (InetAddress ia : iaArray) {  \n                System.out.println(ia.getHostAddress());  \n            }  \n        } catch (UnknownHostException ue) {  \n            ue.printStackTrace();  \n        }  \n    }  \n}\n\n// 127.0.0.1\n// 142.250.206.228\n// 2404:6800:400a:805:0:0:0:2004\n```\n\n\u003cbr\u003e\n\n### 클라이언트-서버\n\n==**Client \u0026 Server 프로그래밍**==\n\n- Socket : Server에 접속하는 역할\n- ServerSocket : Client의 접속 요청을 기다리는 역할\n\t- Client 요청을 기다리다가 접속하면 Socket을 반환\n- Socket과 Socket 간에는 IO 객체를 이용하여 통신할 수 있다.\n\n\u003cbr\u003e\n\n사용자가 웹 브라우저에 `www.naver.com`을 입력하면\n\n1. 접속\n2. 클라이언트가 서버에게 요청 정보 보냄\n3. 서버가 클라이언트에게 응답 정보 보냄\n4. 접속 close\n\n이러한 방식으로 통신하겠다고 약속했다. 이것을 ==**HTTP 프로토콜(규약)**==이라고 한다.\n\n\u003cbr\u003e\n\n==**Java에서 Socket으로 통신하는 방법**==\n\n1. Port를 가지는 ServerSocket 인스턴스를 서버에서 생성\n2. `accept()` 메서드를 사용해서 클라이언트를 기다림\n\t- 이렇게 기다리는 메서드를 **blocking 메서드**라고 함\n3. IP와 Port를 가지는 Socket 인스턴스를 클라이언트에서 생성\n4. 클라이언트가 생성한 Socket 인스턴스로 서버의 ServerSocket에 접속\n\t- `accept()` 메서드가 return 값으로 Socket을 반환\n\t- 서버에서 반환된 Socket과 클라이언트의 Socket이 연결된 상태\n\t- IO 객체를 이용하여 통신할 수 있으니 InputStream, OutputStream 등 이용 가능\n\n동시에 읽고 쓰려면 어떻게 해야할까? 앞에서 생각한 Thread를 생각하기 !\n\n\u003cbr\u003e\n\n### 예제 실습\n\n\u003cbr\u003e\n\n```java\nimport java.net.ServerSocket;  \nimport java.net.Socket;  \n  \npublic class VerySimpleWebServer {  \n    public static void main(String[] args) throws Exception {  \n        // 9090 포트로 대기  \n        ServerSocket ss = new ServerSocket(9090);  \n  \n        // 클라이언트를 대기  \n        // 클라이언트가 접속하는 순간, 클라이언트와 통신할 수 있는 socket을 반환  \n        System.out.println(\"클라이언트 접속 대기중 ...\");  \n        Socket socket = ss.accept();  \n  \n        // 웹 브라우저(클라이언트)에서 http://127.0.0.1:9090에 접속하는 순간 출력됨  \n        System.out.println(socket.toString());  \n          \n        ss.close();  \n        System.out.println(\"서버가 종료됩니다 ...\");  \n    }  \n}\n\n// 클라이언트 접속 대기중 ...\n// Socket[addr=/127.0.0.1,port=51531,localport=9090]\n// 서버가 종료됩니다 ...\n```\n\n\u003cbr\u003e\n\n```java\nimport java.net.ServerSocket;  \nimport java.net.Socket;  \n  \npublic class VerySimpleWebServer {  \n    public static void main(String[] args) throws Exception {  \n        ServerSocket ss = new ServerSocket(9090);  \n        System.out.println(\"클라이언트 접속 대기중 ...\");  \n        Socket socket = ss.accept();  \n  \n        // Client와 읽고 쓸 수 있는 InputStream, OutputStream 반환됨  \n        OutputStream out = socket.getOutputStream();  \n        InputStream in = socket.getInputStream();  \n  \n        // HTTP 프로토콜은 클라이언트가 정보를 서버에게 보내준다. (요청 정보)  \n        byte[] buffer = new byte[512];  \n        int readCount = 0;  \n  \n        while ((readCount = in.read(buffer)) != -1) {  \n            System.out.write(buffer, 0, readCount);  \n        }  \n   \n        System.out.println(socket.toString());  \n  \n        ss.close();  \n        System.out.println(\"서버가 종료됩니다 ...\");  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```\n클라이언트 접속 대기중 ...\nGET / HTTP/1.1\nHost: 127.0.0.1:9090\nConnection: keep-alive\nsec-ch-ua: \"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"macOS\"\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: none\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nAccept-Encoding: gzip, deflate, br\nAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\n\nSocket[addr=/127.0.0.1,port=51560,localport=9090]\n서버가 종료됩니다 ...\n```\n\n- GET 요청 확인 가능 (`/`)로 들어왔네\n- Host ~ 빈 줄 전까지는 ==**브라우저가 보내주는 헤더 정보**==\n- ==**어떤 요청 방식인지 + 요청 보내는 쪽 정보**==\n\n\u003cbr\u003e\n\n```java {title=\"VerySimpleWebServer.java\"}\npublic class VerySimpleWebServer {  \n    public static void main(String[] args) throws Exception {  \n        ServerSocket ss = new ServerSocket(9090);  \n  \n        System.out.println(\"클라이언트 접속 대기중 ...\");  \n        Socket socket = ss.accept();  \n  \n        InputStream in = socket.getInputStream();  \n        BufferedReader br = new BufferedReader(new InputStreamReader(in));  \n        String firstLine = br.readLine();  \n        List\u003cString\u003e headers = new ArrayList\u003c\u003e();  \n        String line = null;  \n  \n        // 빈 줄을 만나면 while문 종료  \n        while (!(line = br.readLine()).equals(\"\")) {  \n            headers.add(line);  \n        }  \n  \n        System.out.println(firstLine);  \n        for (int i = 0; i \u003c headers.size(); i++) {  \n            System.out.println(headers.get(i));  \n        }  \n  \n        // 서버가 클라이언트에게 응답메시지 보내기  \n        OutputStream out = socket.getOutputStream();  \n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));  \n        pw.println(\"HTTP/1.1 200 OK\");  \n        pw.println(\"name : shin jae yoon\");  \n        pw.println(\"email : jaeyoon@email.com\");  \n        pw.println();  \n        pw.println(\"\u003chtml\u003e\");  \n        pw.println(\"\u003ch1\u003eHello!!!\u003c/h1\u003e\");  \n        pw.println(\"\u003c/html\u003e\");  \n        pw.close();  \n  \n        System.out.println(socket.toString());  \n  \n        ss.close();  \n        System.out.println(\"서버가 종료됩니다 ...\");  \n    }  \n}\n```\n\n- 응답 메시지는 \u003ca href='https://developer.mozilla.org/ko/docs/Web/HTTP/Messages#http_%EC%9D%91%EB%8B%B5' target='_blank'\u003eMdn web docs\u003c/a\u003e에 명시된 응답 메시지 형태로 작성해서 보냈음\n\n\u003cbr\u003e\n\n![](brain/image/fun-java11-2.png)\n\n![](brain/image/fun-java11-3.png)\n\n\u003cbr\u003e\n\n### 웹서버 동작\n\n- 위에서는 요청-응답 한 번 씩만 하고 종료되었다. 이것을 유지되도록 하면 어떻게 해야할까?\n- `while (true)`로 무한 루프 돌려야겠지. 그래야 요청-응답, 요청-응답 하니까!\n- 그런데, 하나의 과정이 끝나기 이전에 다른 요청이 들어오면 어떻게 처리할거임?\n\t- ==**그래서, 스레드를 사용하는 작업이 필요**==\n\n\u003cbr\u003e\n\n```java\npackage com.example.net.webserver;  \n  \nimport java.io.*;  \nimport java.net.ServerSocket;  \nimport java.net.Socket;  \n  \npublic class WebServer {  \n    public static void main(String[] args) throws Exception {  \n        // 클라이언트가 접속할 때까지 대기  \n        ServerSocket serverSocket = new ServerSocket(10000);  \n        // 클라이언트가 접속하면 클라이언트와 통신하는 clientSocket 반환  \n        System.out.println(\"1 - 클라이언트 접속 대기\");  \n  \n        try {  \n            while (true) {  \n                Socket clientSocket = serverSocket.accept();  \n  \n                ClientThread ct = new ClientThread(clientSocket);  \n                ct.start();  \n            }  \n        } finally {  \n            serverSocket.close();  \n        }  \n    }  \n}  \n  \nclass ClientThread extends Thread {  \n    private Socket clientSocket;  \n  \n    public ClientThread(Socket clientSocket) {  \n        this.clientSocket = clientSocket;  \n    }  \n  \n    public void run() {  \n        try {  \n            InputStream inputStream = clientSocket.getInputStream();  \n            BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));  \n  \n            OutputStream out = clientSocket.getOutputStream();  \n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));  \n  \n            System.out.println(\"2 - 클라이언트 접속 성공\");  \n  \n            String firstLine = br.readLine();  \n            String msg = \"\";  \n            if (firstLine.indexOf(\"/hello\") \u003e= 0) {  \n                msg = \"hello\";  \n            }  \n            else if (firstLine.indexOf(\"/hi\") \u003e= 0) {  \n                msg = \"hi\";  \n            }  \n            System.out.println(firstLine);  \n  \n            String line = null;  \n            while (!(line = br.readLine()).equals(\"\")) {  \n                System.out.println(line);  \n            }  \n  \n            System.out.println(\"3 - 응답한다.\");  \n  \n            pw.println(\"HTTP/1.1 200 OK\");  \n            pw.println(\"name : shin jae yoon\");  \n            pw.println(\"email : jaeyoon@email.com\");  \n            pw.println();  \n            pw.println(\"\u003chtml\u003e\");  \n            pw.println(firstLine + \"!!!\");  \n            pw.println(\"\u003c/html\u003e\");  \n  \n            pw.flush();  \n            br.close();  \n            pw.close();  \n            clientSocket.close();  \n  \n        } catch (Exception e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n\u003chr\u003e\n\n## 채팅 프로그램 예제\n\n\u003cbr\u003e\n\n### 구현 스케치\n\n![](brain/image/fun-java11-4.png)\n\n![](brain/image/fun-java11-5.png)\n\n- 채팅은 클라이언트가 메시지를 보내면, 서버가 연결된 모든 클라이언트에게 메시지를 보내야 한다.\n\t- 이게 ==**BroadCast**==\n- 클라이언트가 접속할 때마다 서버는 스레드를 생성한다.\n\n![](brain/image/fun-java11-7.png)\n\n- 서버의 스레드마다 소켓을 가지고 스레드 각각은 클라이언트와 연결\n- 이때, 서버가 연결된 모든 클라이언트에게 메시지를 보내기 위해 공유 객체도 사용\n\t- 공유 객체에서 스레드에 안전한 리스트를 생성  \n\t- 스레드 객체가 생성될 때마다 while 문 밖의 outList를 생성자로 하나씩 넣어줌  \n\t- 스레드가 10개 생성되면, outList라는 하나의 객체를 공유!!\n\t- `List\u003cPrintWriter\u003e outList = Collections.synchronizedList(new ArrayList\u003c\u003e());`\n\t- ==**Collections.synchronizedList()**==\n\n\u003cbr\u003e\n\n### 실습 코드 - 서버\n\n\u003cbr\u003e\n\n```java {title=\"ChatServer.java\"}\npublic class ChatServer {  \n    public static void main(String[] args) throws Exception {  \n        ServerSocket serverSocket = new ServerSocket(8888);\n          \n\t\t// 공유 객체에서 스레드에 안전한 리스트를 생성  \n\t\t// 스레드 객체가 생성될 때마다 while 문 밖의 outList를 생성자로 하나씩 넣어줌  \n\t\t// 스레드가 10개 생성되면, outList라는 하나의 객체를 공유!!\n        List\u003cChatThread\u003e list = Collections.synchronizedList(new ArrayList\u003c\u003e());  \n  \n        while (true) {  \n            Socket socket = serverSocket.accept();  \n            ChatThread chatClient = new ChatThread(socket, list);  \n            chatClient.start();  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"ChatThread.java\"}\npublic class ChatThread extends Thread {  \n    private String name;  \n    private BufferedReader br;  \n    private PrintWriter pw;  \n    private Socket socket;  \n    List\u003cChatThread\u003e list;  \n  \n    public ChatThread(Socket socket, List\u003cChatThread\u003e list) throws Exception {  \n        this.socket = socket;  \n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));  \n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));  \n  \n        this.br = br;  \n        this.pw = pw;  \n        this.name = br.readLine();  \n        this.list = list;  \n        this.list.add(this);  \n    }  \n  \n    public void sendMessage(String msg) {  \n        pw.println(msg);  \n        pw.flush();  \n    }  \n  \n    @Override  \n    public void run() {  \n        // broadcast  \n        // ChatThread 는 사용자가 보낸 메시지를 읽어들여서  \n        // 접속된 모든 클라이언트에게 메시지를 보냄  \n  \n        // 나를 제외한 모든 사용자에게 \"OO 님이 연결되었습니다.\" 보내기  \n        // 현재 ChatThread 를 제외하고 보내기  \n        try {  \n            broadcast(name + \"님이 연결되었습니다.\", false);  \n  \n            String line = null;  \n            while ((line = br.readLine()) != null) {  \n                if (\"/quit\".equals(line)) {  \n                    break;  \n                }  \n  \n                // 나를 포함한 ChatTrhead 에게 메시지 보냄  \n                broadcast(name + \" : \" + line, true);  \n            }  \n  \n        } catch (Exception e) { // Exception이 발생한건 ChatThread가 연결이 끊어진 결  \n  \n        } finally {  \n            broadcast(name + \"님이 연결이 끊어졌습니다.\", false);  \n            this.list.remove(this);  \n            try {  \n                br.close();  \n            } catch (Exception e) {  \n  \n            }  \n            try {  \n                pw.close();  \n            } catch (Exception e) {  \n  \n            }  \n            try {  \n                socket.close();  \n            } catch (Exception e) {  \n  \n            }        }  \n    }  \n  \n    private void broadcast(String msg, boolean includeMe) {  \n        List\u003cChatThread\u003e chatThreads = new ArrayList\u003c\u003e();  \n        for (int i = 0; i \u003c this.list.size(); i++) {  \n            chatThreads.add(list.get(i));  \n        }  \n  \n        try {  \n            for (int i = 0; i \u003c chatThreads.size(); i++) {  \n                ChatThread chatThread = chatThreads.get(i);  \n                if (!includeMe) {   // 나 자신은 포함하지 않기  \n                    if (chatThreads == this) {  \n                        continue; // break?  \n                    }  \n                }  \n                chatThread.sendMessage(msg);  \n            }  \n        } catch (Exception e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n### 실습코드 - 클라\n\n- configuration 설정\n\n![](brain/image/fun-java11-9.png)\n\n1. Application 누르면 Add new configuration 나옴\n2. 하나 생성하고 돌릴 코드위치 넣어주고\n3. Modify options에서 ALLOW MULTIPLE INSTANCES 추가하기\n\n\u003cbr\u003e\n\n- 결과\n\n![](brain/image/fun-java11-8.png)\n\n- 옆에 점 세개 누르면 바로 args 정할 수 있음\n\n\n\u003cbr\u003e\n\n```java {title=\"ChatClient.java\"}\npublic class ChatClient {  \n    public static void main(String[] args) throws Exception {  \n        if (args.length != 1) {  \n            System.out.println(\"사용법 : 닉네임 설정\");  \n            return;  \n        }  \n  \n        String name = args[0];  \n        Socket socket = new Socket(\"127.0.0.1\", 8888);  \n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));  \n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));  \n        BufferedReader keyboard = new BufferedReader(new InputStreamReader(System.in));  \n  \n        // 닉네임 전송  \n        pw.println(name);  \n        pw.flush();  \n  \n        // 백그라운드로 서버가 보내준 메시지를 읽어서 화면에 출력  \n        ClientInputThread clientInputThread = new ClientInputThread(br);  \n        clientInputThread.start();  \n  \n        // 클라이언트트 읽어들인 메시지를 서버에게 전송  \n        try {  \n            String line = null;  \n            while ((line = keyboard.readLine()) != null) {  \n                if (\"/quit\".equals(line)) {  \n                    break;  \n                }  \n                pw.println(line);  \n                pw.flush();  \n            }  \n        } catch (Exception e) {  \n            e.printStackTrace();  \n        } finally {  \n            socket.close();  \n        }  \n    }  \n}\n```\n\n\u003cbr\u003e\n\n```java {title=\"ClientInputThread.java\"}\npublic class ClientInputThread extends Thread {  \n    BufferedReader br;  \n  \n    public ClientInputThread(BufferedReader br) {  \n        this.br = br;  \n    }  \n  \n    @Override  \n    public void run() {  \n        try {  \n            String line = null;  \n            while ((line = br.readLine()) != null) {  \n                System.out.println(line);  \n            }  \n        } catch (Exception e) {  \n            System.out.println(\"연결이 종료되었습니다.\");  \n        }  \n    }  \n}\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/":{"title":"잔재미코딩 - Python","content":"","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny":{"title":"파이썬 입문","content":"\n\u003cbr\u003e\n\n\u003e [!note] 파이썬입문과 크롤링기초 부트캠프 필기노트\n\u003e \u003cbr\u003e\n\u003e 📅 **학습 기간** \u003cbr\u003e\n\u003e 2022.03.25 ~ 2022.04.05\n\u003e\u003cbr\u003e\u003cbr\u003e\n\u003e 🏆 **학습 목표** \u003cbr\u003e\n\u003e 머신러닝 전공 수업을 위하여 파이썬 간단하게 익히기\n\n## 목차\n\n- [잔재미코딩 - 01. 파이썬 입문](brain/Lecture/pl/funny-python/funny01.md)\n- [잔재미코딩 - 02. 파이썬 변수, 출력](brain/Lecture/pl/funny-python/funny02.md)\n- [잔재미코딩 - 03. 파이썬 String](brain/Lecture/pl/funny-python/funny03.md)\n- [잔재미코딩 - 04. 파이썬 List](brain/Lecture/pl/funny-python/funny04.md)\n- [잔재미코딩 - 05. 파이썬 Tuple](brain/Lecture/pl/funny-python/funny05.md)\n- [잔재미코딩 - 06. 파이썬 Dictionary](brain/Lecture/pl/funny-python/funny06.md)\n- [잔재미코딩 - 07. 파이썬 Set](brain/Lecture/pl/funny-python/funny07.md)\n- [잔재미코딩 - 08. 파이썬 Bool](brain/Lecture/pl/funny-python/funny08.md)\n- [잔재미코딩 - 09. 파이썬 Variable](brain/Lecture/pl/funny-python/funny09.md)\n- [잔재미코딩 - 10. 파이썬 Condition](brain/Lecture/pl/funny-python/funny10.md)\n- [잔재미코딩 - 11. 파이썬 For](brain/Lecture/pl/funny-python/funny11.md)\n","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny01":{"title":"01 - 파이썬 입문","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. Python 학습의 이유\n\n\u003cbr\u003e  \n\nJava와 Javascript를 학습하며 프론트엔드와 백엔드 모두를 경험해보고자 언어를 학습 중인 상태였고, 코딩 테스트와 프로젝트를 대비하려고 했으나, 크롤링에 친숙하고 라이브러리의 강점을 가지며 쉬운 언어인 Python도 경험해보고 싶다는 생각을 항상 가지고만 있었다. 추가로, Web project를 진행하기 위해 백엔드 framework 학습의 필요성을 느끼고 있었다. \u003cbr\u003e\n\n현재의 나는 개인 토이 프로젝트나 소규모 프로젝트를 희망하는 상태이다. 대표적인 후보군으로는 spring, django, flask 등이 있었는데, Java 기반 framework인 spring은 대규모 프로젝트를 하지 않는 나의 입장에서는 맞지 않다고 느꼈다. 하지만, Python 기반 framework는 django와 flask라는 선택지가 있었다. django는 extension이 기본적으로 포함되어 서비스 사용 용도에 적합하고, flask는 extension이 기본적으로 포함되어 있지 않아서, 학습에 용이하다는 검색 결과를 얻었다. \u003cbr\u003e\n\n**따라서, flask를 학습하기로 마음 먹었고 그것을 위하여 python에 대한 학습이 필요하다고 느꼈다.**\n\n나아가, python을 이용하여 database 학습을 하려는 계획도 세웠다. 아직 Java를 제대로 사용하지 못하는 것도 있어서, 이참에 주력 언어를 python으로 정하겠다는 결심이 섰기 때문에 기초를 탄탄히 하고자 언어의 기본 문법을 학습하고자 한다.\n\n\u003chr\u003e\n\n## 02. Python 설치\n\n\u003cbr\u003e  \n\nPython은 고급 언어이기 때문에, 컴퓨터가 이해하도록 하기 위한 컴파일러가 필요하다. 따라서, 기본 Python을 https://www.python.org/downloads/ 에서 설치해주도록 한다. 설치하는 과정에서 PATH에 체크하여 환경 변수를 미리 추가한다. \n\nPython을 사용하기 위한 여러 가지 옵션이 있다.\n\n- anaconda의 주요 툴인 jupyter notebook 활용하기\n\n- pycharm, visual studio code 같은 텍스트 에디터 활용하기\n\n\u003cbr\u003e\n\n### mac 초기 설정\n\n1. \u003ca href='https://jjam89.tistory.com/228' target='_blank'\u003emac의 기본 python을 건드리지 않고 pyen를 사용하는 이유와 설치 방법\u003c/a\u003e\n2. \u003ca href='https://seorenn.github.io/note/pyenv-virtualenv.html#d3f541ab' target='_blank'\u003evirtualpyenv 사용 방법\u003c/a\u003e\n3. \u003ca href='https://carmack-kim.tistory.com/90' target='_blank'\u003evirtualpyenv activate 오류 발생 시\u003c/a\u003e\n4. \u003ca href='https://codenoyes.tistory.com/63' target='_blank'\u003emac에 jupyter notebook 설치\u003c/a\u003e\n\n\u003chr\u003e\n\n## 03. Python IDE\n\n\u003cbr\u003e\n\n### **anaconda - jupyter**\n\nanaconda는 파이썬 컴파일러, 주요 라이브러리, 주요 툴을 모아놓은 패키지이다. anaconda의 주요 툴 중 하나인 jupyter notebook을 활용하여 python을 사용할 수 있다.\n\n![](brain/image/funny01-1.png)\n\njupyter notebook의 장점은 코드를 작성함과 동시에 컴파일하여 가시적으로 결과를 확인 가능하다는 점이다. 그리고 마크다운을 이용하여 필요한 메모를 즉각적으로 작성할 수 있어서 학습에 용이하다고 생각했다. 따라서, 학습하는 과정에서 jupyter notebook을 사용하기로 했다.\n\n설치 방법은 https://www.anaconda.com/products/individual 페이지에서 다운로드하여 설치한다. 이때, python 최신 버전을 다운로드 한다. 왜냐하면, 구버전인 python 2와 신버전인 python 3는 약간의 문법적 차이가 있을 수 있다. python 2 에서는 `print len(something)`이 올바른 문법이라면 python 3 에서는 `print (len(something))`이 올바른 문법이기 때문에 최신 버전을 다운 받아서 사용하도록 하자.\n\n\u003cbr\u003e\n\n### **pycharm, vs code**\n\npycharm 혹은 visual studio code의 extension에서 python을 설치하여 텍스트 에디터를 사용하는 방법도 있다. 언어의 학습을 위해서 강의를 들을 때는 jupyter notebook을 사용하기로 했지만, 추후에 프로젝트나 여러 작업을 진행하기 위해서는 텍스트 에디터를 이용한 python의 사용법 또한 필요하다고 생각했다.  \n\nhtml, css, javascript를 사용하면서 익숙했던 visual studio code를 사용하기로 결정했다. 위의 python 설치 과정에서 PATH 추가만 제대로 했다면, visual studio code의 extension에서 python만 추가로 설치해주면 된다.\n\n파일의 확장명은 .py이고 윈도우에서는 터미널 창에 `python 파일이름.py` 리눅스나 mac의 경우에는 터미널 창에 `python3 파일이름.py`라고 버전을 명시해줘야 한다. 나는 wsl2를 이용하여 윈도우 환경에서 리눅스를 사용할 때도 있기 때문에 아래에서 윈도우와 wsl2의 사용 예시를 보여줬다.\n\n![](brain/image/funny01-2.png)\n\n![](brain/image/funny01-3.png)\n\n\u003chr\u003e\n\n## 04. jupyter사용 TIP\n\n- jupyter notebook file을 python3 형태로 만든다.\n\n- 코드를 작성하고 실행할 때는 기본적으로 `shift + enter` 키를 활용한다.\n\n- 해당하는 셀을 코드 블록으로 사용하려면 `Y` 마크다운 블록으로 사용하려면 `M`을 누른다.\n\n- 해당하는 셀의 위에 새로운 블록 생성은 `a` 아래에 새로운 블록 생성은 `b`를 누른다.\n\n- 해당하는 셀을 삭제하려면 `d + d`, 복사는 `C`, 붙혀넣기는 `V`를 누른다.\n\n- 기본적인 단축키 이외에도 필요한 단축키가 있다면 그때 그때 학습하도록 한다.","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny02":{"title":"02 - 변수,출력","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 파이썬의 데이터구조\n\n\u003cbr\u003e\n\n2장부터 파이썬의 기초와 자료형에 관하여 다룰 것이다. 파이썬의 자료형에는 `숫자형, 문자열 자료형, 리스트 자료형, 튜플 자료형, 딕셔너리 자료형, 집합 자료형, 불 자료형`이 있다. 이러한 자료형, 데이터를 효율적으로 나타내기 위한 특정 데이터 타입이 있는데 이를 데이터 구조라고 한다. 대표적으로 리스트, 튜플, 딕셔너리 등이 있다.\n\n- **데이터 구조**\n- 선언 + 입력\n- 읽기\n- 추가\n- 삭제\n- 수정\n\n\u003chr\u003e\n\n## 01. 출력과 입력  \n\n언어의 기본은 \"Hello World!\"를 출력함에 있다. Python은 대표적인 인터프리터 언어이므로, 소스 코드를 작성하면 줄마다 번역하고 실행할 수 있다. 인터프리터와 컴파일러에 관한 내용은 \u003ca href='https://jae-yoon.tistory.com/3' target='_blank'\u003e개발자 유니\u003c/a\u003e에 추가로 포스팅하였다. \n\n\u003cbr\u003e\n\n```python\nprint(\"Hello World!\")\nprint('Hello World!')\nprint(1)\n  \n출력 결과 : Hello World!\n출력 결과 : Hello World!\n출력 결과 : 1\n```\n\n\u003cbr\u003e\n\nC언어와 같이 문장의 끝에 `;`를 찍을 필요도 없고, 문자열은 `\"\"`든 `''`든 상관없었다. 다음은 숫자 출력에서 나누기에 관한 몇 가지 예시이다.\n\n\u003cbr\u003e  \n\n```python\nprint (15 / 7)\nprint (15 // 7)\nprint (15 % 7)\nprint (2 * 4)\nprint (2 ** 4 )\n  \n출력 결과 : 2.142857142857143\n출력 결과 : 2\n출력 결과 : 1\n출력 결과 : 8\n출력 결과 : 16\n```\n\n\u003cbr\u003e\n\n파이썬 에서는 `/`는 나누기, `//`는 몫, `%`는 나머지를 뜻하고 `*`는 곱하기, `**`는 제곱 수를 뜻한다. 위의 경에우는 2의 4승을 뜻하는 것이다.  \n\n**소수점 아래의 몇 번째 자리까지 표시**하는 예시를 출력하는 경우 여러가지 방법이 있는데, 그 중 세 가지 방법을 소개하겠다.\n\n\u003cbr\u003e  \n\n```python\nfloat_data_pi = 3.1415\nround (float_data_pi, 1)\n  \nfloat_data2_pi = 3.1415\nprint(\"%.1f\" % float_data2_pi)\n  \nfloat_data3_pi = 3.1415\nprint ( format(float_data3_pi, \".1f\") )\n  \n출력 결과 : 3.1\n출력 결과 : 3.1\n출력 결과 : 3.1\n```\n\n\u003cbr\u003e\n\n1. round() 함수 사용\n\n`round(값, 자릿수)` 함수는 반올림 함수이다. 그러나, 주의해야할 것은 **파이썬에서 반올림은 반올림 하려는 수가 올림, 내림 했을 때 동일하게 차이가 나는 경우에는 짝수 값으로 반올림한다는 것이다.** 이 말은, 예를 들어 `round(0.5)`를 한다면 1이 출력되어야 하지만, 실제로는 0이 출력된다. 0.5는 0에도 0.5만큼 차이, 1에도 0.5만큼 차이가 나기 때문에 짝수인 0의 값에 맞춰지게 되는 것이다. 이를 유의하자. 그리고 40.000과 같이 표현해주고 싶은 경우에는 round 함수를 사용하면 안된다. 알아서 잘라먹고 40.0으로 표현할 것이다.\n\n\u003cbr\u003e\n\n2. %.f 사용\n\n`print(\"%.원하는자릿수f\" % 값)`\n\n\u003cbr\u003e\n\n3. format() 함수 사용\n\n`format(값, \".원하는자릿수f\")` 혹은 `print(\"{:.원하는자릿수f}\".format(값))`\n\n추가적인 내용은 [[잔재미] String](brain/Lecture/pl/funny-python/funny03.md)를 참조하라.\n\n\u003cbr\u003e  \n\n파이썬에서 입력은 `input()`함수를 사용하면 된다.\n\n```python\ndata = input()\nprint(data)\n  \n출력 : 사용자가 입력한 값\n```\n\n\u003cbr\u003e\n\n그런데, 여기서 주의해야할 점은 숫자 1을 입력했다고 해도 input의 타입이 문자열이기 때문에 정수로 인식하지 않는다. 따라서, 정수형 타입을 원한다면 형변환을 해줘야 한다.\n\n```python\ndata1 = input()\ndata2 = input()\n  \nprint( data1 + data2 )\nprint( data1 * data2 )\nprint( int(data1) + int(data2))\n  \n입력 값 : 1, 2\n출력 결과 : 12 ( 문자열이 붙혀진 형태 )\n출력 결과 : Type Error ( 문자열 곱하기 문자열의 형태니까 오류)\n출력 결과 : 3 ( 정수형으로 형변환 되어 더해진 형태)\n```\n\n\u003chr\u003e\n\n## 02. 변수, 데이터 타입\n\n\u003cbr\u003e\n\nPython에서 변수는 C, Java와 같이 먼저 변수형을 지정 안해줘도 된다. (int 같은 것을 안적어도 된다는 의미이다.) 변수에 값을 넣으면 변수형이 지정된다. 그리고 불리안 타입은 대문자를 사용해서 True, False와 같이 사용한다.\n\n```python\nage = 27\nname = \"신재윤\"\nheight = 177\nweight = 64\nfoot_size = 270\nglass = False\nmarriage = False\n```\n\n데이터 타입이 어떤 것인지를 확인해보려면 `print(type())`으로 확인할 수 있다.\n\n```python\nage = 27\nname = \"신재윤\"\nglass = False\n  \nprint(type(age))\nprint(type(name))\nprint(type(glass))\n\n출력 결과 : \u003cclass 'int'\u003e\n출력 결과 : \u003cclass 'str'\u003e\n출력 결과 : \u003cclass 'bool'\u003e\n```\n\n정리하자면, 파이썬에서의 데이터 타입은 아래와 같다. \u003cbr\u003e\u003cbr\u003e\n\n**Type**\n\n- 정수 : int\n\n- 부동소숫점 : float\n\n- 문자열 : str\n\n- Boolean : bool\n\n\u003cbr\u003e  \n\n타입 검사를 하기 위한 Tip\n\n```python\na = 1\nif (str(type(a)) == \"\u003cclass 'int'\u003e\"):\nprint(\"정수 타입이 맞습니다.\")\n```\n\n\u003chr\u003e\n\n## 03. print() 문의 옵션\n\n\u003cbr\u003e\n\n출력문에서 사용하는 print() 함수에는 옵션을 여러 가지 설정할 수 있다.\n\n1. sep(separation)\n\n단어 뜻 그대로 분리하여, 출력한다는 의미이다. 갈라놓을 문자를 지정할 수 있는데 이것을 `구분자`라고 한다.\n\n- `sep=' '` 형식으로 사용\n\n- 클론 기호`' '`를 사이에 두고 값을 출력\n\n```python\nprint('S','E','P', sep='@')\n출력 : S@E@P\n```\n\n\u003cbr\u003e\n\n```python\na, b = input().split(':')\nprint(a, b, sep=':')\n  \n입력 : 3:16\n출력 : 3:16\n```\n\n- 아무것도 없는 빈(empty) 문자는 그냥 `''`\n\n- join() 함수, 반복문 섞어서도 가능\n\n```python\n(a, b) = input().split(\"-\")\nprint(a, b, sep=\"\")\n  \na = input().split(\"-\")\nresult = ''.join(s for s in a)\nprint(result)\n  \n입력 : 000907-1121112\n출력 : 0009071121112\n```\n\n\u003cbr\u003e\n\n2. end\n\n단어 뜻 그대로 마지막이라는 의미이다. 줄바꿈을 하지 않고 이어서 출력하겠다는 뜻이다.\n\n```python\nprint(\"I like\", end=\" \")\nprint(\"money\")\n  \n출력 : I like money\n```\n  \n- end=' ' 사이에 무언가를 입력하면, sep와 비슷한 기능을 한다.(구분자를 사용할 수 있다) 첫번째 출력문과, 두번째 출력문 사이에 end에 넣어준 문자열이 출력된다.  \n\n```python\nprint(\"I like\", end=\" gold and \")\nprint(\"money\")\n  \n출력 : I like gold and money\n```\n\n\u003cbr\u003e\n\n3. format\n\nformat 함수를 이용한 print() 다루기는 [[잔재미] String](brain/Lecture/pl/funny-python/funny03.md)에서 상세히 설명한다.\n\n- `.format() 이용`\n\n```python\nprint(\"{0}월{1}일 입니다.\".format(3,9))\n출력 : 3월 9일 입니다.\n```\n\n- `%` 이용 포맷팅 (가장 많이 사용할 듯)  \n\n```python\nprint(\"%s을 %d개 주세요.\" % (\"초콜렛\", 10))\n출력 : 초콜렛을 10개 주세요.\n```\n\n\u003cbr\u003e\n\n```python\nprint(\"%d + %d = %d\" % (1, 2, 3))\n출력 : 1 + 2 = 3\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny03":{"title":"03 - String","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 문자열 다루기 기본\n\n\u003cbr\u003e  \n\npython은 문자열을 다루는데 특화된 프로그래밍 언어이다. 간결하면서 사용성은 매우 뛰어나다. 따라서, 크롤링을 공부하기에 매우 좋은 언어이다. 변수에 문자열을 지정할 때, `\"내용\"` 따옴표를 한 개씩만 넣었을 경우, 다음 줄로 넘어가면 EOF, End Of Line으로 한 줄을 넘어갔다고 오류가 발생할 수 있다. 그럴 경우, 당황하지 말고 `\"\"\"내용\"\"\"`와 같이 따옴표를 세 개씩 넣어주자. 이스케이프 문자 `\\n`을 넣어서 표현할 수도 있으나, 따옴표를 연속적으로 쓰는 것이 깔끔하니 그렇게 사용하도록 하자.\n\n\u003cbr\u003e\n\n```python\ncontext = \"South Korean director Bong Joon-ho has won the Cannes film festival's most prestigious award. The Palme d'Or was awarded for his film Parasite, a dark comedy thriller exploring social class dynamics. The festival came to a close this evening after 11 days of previews of new films and documentaries.\"  \n\nprint(context)\n\n출력결과 : SyntaxError: EOL while scanning string literal\n```\n\n\u003cbr\u003e\n\n```python\ncontext = \"\"\"South Korean director Bong Joon-ho has won the Cannes film festival's most prestigious award.\nThe Palme d'Or was awarded for his film Parasite, a dark comedy thriller exploring social class dynamics.\nThe festival came to a close this evening after 11 days of previews of new films and documentaries.\"\"\"\n\nprint(context)\n출력결과 : context 안의 문자열\n```\n\n\u003cbr\u003e  \n\n문자열을 더하거나 곱할 수 있다. 더하는 것은 말 그대로 더하는 것이지만 곱하는 것은 문자열끼리 곱하는 것이 아닌, 반복을 의미한다.\n\n```python\nstring1 = \"Hello\"\nstring2 = \"World\"\nprint(string1 + string2)\nprint(string1 * string2)\nprint(string1 * 2)\n  \n출력결과 : HelloWorld\n출력결과 : TypeError: can't multiply sequence by non-int of type 'str'\n출력결과 : HelloHello\n```\n  \n\u003cbr\u003e\n\n문자열을 곱하는 것을 응용하면 아래와 같이 사용할 수 있다.\n\n```python\nprint(\"=\" * 20)\nprint(\"안녕하세요. 깔끔하죠?\")\nprint(\"=\" * 20)\n  \n출력결과 :\n====================\n안녕하세요. 깔끔하죠?\n====================\n```\n\n\u003cbr\u003e\n\n문자열 길이를 구하는 대표적인 함수는 `len()` 함수가 있다.\n  \n```python\nstring = \"나는 뛰어난 주니어 개발자입니다.\"\nprint(len(string))\n  \n출력결과 : 18\n```\n  \n\u003cbr\u003e\n  \n- **인덱스 (index)**\n\n- 인덱스는 특정 데이터를 가리키는 번호를 나타냄\n\n|p|y|t|h|o|n|\n|:--:|:--:|:--:|:--:|:--:|:--:|\n|0|1|2|3|4|5|\n|-6|-5|-4|-3|-2|-1|\n  \n\u003cbr\u003e\n\n```python\nsome_string = \"python\"\nprint(some_string[0])\nprint(some_string[1])\nprint(some_string[-1])\nprint(some_string[-6])\n  \n출력결과 : p\n출력결과 : y\n출력결과 : n\n출력결과 : p\n```\n  \n- **슬라이싱 (slicing)**\n\n- 시작 인덱스 ~ 해당 인덱스 직전의 인덱스까지 출력\n\n```python\nsome_string = \"python\"\nprint(some_string[3:5]\nprint(some_string[1:5])\nprint(some_string[1:2])\n  \n출력결과 : ho\n출력결과 : ytho\n출력결과 : y\n```\n  \n- 슬라이싱 응용\n\n```python\nsome_string = \"python\"\nprint(some_string[:6]) # 문자열 시작 ~ 지정 인덱스 전까지\nprint(some_string[0:]) # 지정 인덱스 ~ 문자열 끝까지\nprint(some_string[:]) # 문자열 전체\n  \n출력결과 : python\n출력결과 : python\n출력결과 : python\n```\n  \n- 슬라이싱 이용해서 문자열 나누기\n\n```python\ntoday = \"20220219Sunny\"\nyear = today[:4]\nday = today[4:8]\nweather = today[8:]\n  \nprint(year, day, weather)\n출력결과 : 2022 0219 Sunny\n```\n\n- 슬라이싱 이용해서 문자열 바꾸기\n\n기본적으로 문자열 자료형은 그 요솟값을 바꿀 수 없는 immutable한 자료형이다. 이것이 의미하는 바는, python이라는 문자열이 있을 때, 아래와 같이 변경할 수 없다는 의미이다. 하지만, 슬라이싱 방법을 이용하면 가능하다.\n\n  \n\n```python\nstring = \"python\"\npython[1] = \"i\"\n  \nprint(string)\n출력결과 : NameError: name 'python' is not defined\n```\n\n\u003cbr\u003e\n  \n```python\nstring = \"python\"\nnew_string = string[:1] + \"i\" + string[2:]\n\nprint(new_string)\n출력결과 : pithon\n```\n\n\u003chr\u003e\n\n## 02. 코드 이용 포매팅\n\n\u003cbr\u003e\n\n|코드|설명|\n|:--:|:--:|\n|%s|문자열(string)|\n|%c|문자 1개(character)|\n|%d|정수(integer)|\n|%f|부동소수(floating-point)|\n|%o|8진수|\n|%x|16진수|\n|%%|Literal % (문자 % 자체)|\n\n\u003cbr\u003e\n  \n1. 숫자나 문자열 직접 대입\n\n```python\nstring1 = \"I eat %d bananas.\" % 3\nstring2 = \"I eat %s bananas.\" % \"sweet\"\n\nprint(string1)\nprint(string2)\n  \n출력결과 : I eat 3 bananas.\n출력결과 : I eat sweet bananas.\n```\n\n2. 변수 대입  \n\n```python\nnumber = 3\nthree = \"3\"\nstring1 = \"I eat %d bananas.\" % number\nstring2 = \"I eat %d bananas.\" % three\nstring3 = \"I eat %c bananas.\" % three\nstring4 = \"I eat %s bananas.\" % three\n\nprint(string1)\nprint(string2)\nprint(string3)\nprint(string4)\n\n출력결과 : I eat 3 bananas.\n출력결과 : TypeError: %d format: a number is required, not str\n출력결과 : I eat 3 bananas.\n출력결과 : I eat 3 bananas.\n```\n\n3. 두 개 이상의 값 대입  \n\n```python\nnumber1 = 5\nnumber2 = 2\nfruit = \"bananas\"\nstring = \"I bought %d %s. But, %d %s were rotten.\" % (number1, fruit, number2, fruit)\n\nprint(string)\n출력결과 : I bought 5 bananas. But, 2 bananas were rotten.\n```\n  \n4. 포맷팅 연산자와 함께 % 문자 삽입하는 방법\n\n```python\nstring1 = \"Error is %d%.\" % 98\nstring2 = \"Error is %d%%.\" % 98\nprint(string1)\nprint(string2)\n\n출력결과 : ValueError: incomplete format\n출력결과 : Error is 98%.\n```\n\n\u003cbr\u003e\n\n**포맷 코드와 숫자 함께 사용하기**\n\n- 정렬과 공백\n\n```python\nstring1 = \"%10s\" % \"hi\"\nstring2 = \"%-10s\" % \"hi\"\n\nprint(string1)\nprint(string2)\n\n출력결과 : hi (10개의 공간에서 대입되는 값을 우측 정렬)\n출력결과 : hi (10개의 공간에서 대입되는 값을 좌측 정렬)\n```\n\n- 소숫점 표현\n\n```python\nstring1 = \"%0.4f\" % 3.42134234\nstring2 = \"%10.4f\" % 3.42134234\n\nprint(string1)\nprint(string2)\n\n출력결과 : 3.4213\n출력결과 : 3.4213 (숫자를 소숫점 네 번째 자리까지만 표시하고 전체 10개의 문자열 공간에서 오른쪽 정렬)\n```\n\n\u003chr\u003e\n\n## 03. format 이용 포매팅\n\n\u003cbr\u003e\n\n1. 숫자나 문자열 직접 대입\n  \n```python\nstring1 = \"I eat {0} bananas.\".format(3)\nstring2 = \"I eat {0} bananas.\".format(\"sweet\")\n\nprint(string1)\nprint(string2)\n  \n출력결과 : I eat 3 bananas.\n출력결과 : I eat sweet bananas.\n```\n\n2. 변수 대입  \n\n```python\nnumber = 3\nthree = \"3\"\nstring1 = \"I eat {0} bananas.\".format(number)\nstring2 = \"I eat {0} bananas.\".format(three)\nstring3 = \"I eat {0} bananas.\".format(\"three\") # 이건 변수 대입이 아니겠지.\n\nprint(string1)\nprint(string2)\n  \n출력결과 : I eat 3 bananas.\n출력결과 : I eat 3 bananas.\n출력결과 : I eat three bananas.\n```\n\n3. 두 개 이상의 값 대입  \n\n```python\nnumber1 = 5\nnumber2 = 2\nfruit = \"bananas\"\nstring1 = \"I bought {0} {1}. But, {2} {3} were rotten.\".format(number1, fruit, number2, fruit)\nstring2 = \"I bought {2} {1}. But, {0} {3} were rotten.\".format(number1, fruit, number2, fruit)\n\nprint(string1)\nprint(string2)\n\n출력결과 : I bought 5 bananas. But, 2 bananas were rotten.\n출력결과 : I bought 2 bananas. But, 5 bananas were rotten.\n```\n\n4. 이름으로 대입\n\n```python\nstring = \"I bought {number} {fruit}.\".format(number=5, fruit=\"bananas\")\nprint(string)\n  \n출력결과 : I bought 5 bananas.\n```\n\n5. 인덱스와 이름 혼용\n\n```python\nstring = \"I bought {0} {fruit}.\".format(5, fruit=\"bananas\")\nprint(string)\n  \n출력결과 : I bought 5 bananas.\n```\n\n6. 왼쪽 정렬, 오른쪽 정렬, 가운데 정렬  \n\n```python\n# 문자열의 자릿수는 10으로 한 것\nleft = \"{0:\u003c10}\".format(\"hi\")\nright = \"{0:\u003e10}\".format(\"hi\")\ncenter = \"{0:^10}\".format(\"hi\")\n\nprint(left)\nprint(right)\nprint(center)\n  \n출력결과 : hi\n출력결과 : hi\n출력결과 : hi\n```\n\n7. 공백 채우기, \"{0: '공백내용' '정렬방법' '자릿수'}\".format(\"문자열\")\n\n```python\nstring1 = \"{0:=^10}\".format(\"hi\")\nstring2 = \"{0:!\u003c10}\".format(\"hi\")\nprint(string1)\nprint(string2)\n\n출력결과 : ====hi====\n출력결과 : hi!!!!!!!!\n```\n  \n8. 소숫점 표현하기\n\n```python\npi = 3.141592\nstring1 = \"{0:0.4f}\".format(pi)\nstring2 = \"{0:10.4f}\".format(pi)\n\nprint(string1)\nprint(string2)\nprint(format(3.141592, \"0.4f\"))\n\n출력결과 : 3.1416\n출력결과 : 3.1416\n출력결과 : 3.1416\n```\n\n9. `{` `}` 문자 사용하기\n\n```python\nstring = \"I bought {fruit} and {{apple}}. {apple} is delicious.\".format(fruit=\"banana\", apple=\"Apple\")\n\nprint(string)\n\n출력결과 : I bought banana and {apple}. Apple is delicious.\n```\n\n\u003chr\u003e\n\n## 04. f 문자열 이용 포매팅\n\n- 참고 : f 문자열 포맷팅\n\npython version 3.6부터 사용 가능한 기능\n\n```python\nname = \"신재윤\"\nage = 27\nstring = f'나의 이름은 {name}입니다. 나이는 {age}입니다.'\n  \nprint(string)\nprint(f'나의 이름은 {name}입니다. 나이는 {age}입니다.')\nprint(f'나의 이름은 {name}입니다. 나이는 {age+3}입니다.')\n  \n출력결과 : 나의 이름은 신재윤입니다. 나이는 27입니다.\n출력결과 : 나의 이름은 신재윤입니다. 나이는 27입니다.\n출력결과 : 나의 이름은 신재윤입니다. 나이는 30입니다.\n```\n\n- 딕셔너리 이용 f 문자열 포맷팅\n\n```python\nd = {\"name\" : \"신재윤\", \"age\" : 27}\n\nprint(f\"나의 이름은 {d['name']}입니다. 나이는 {d['age']}입니다.\")\n출력결과 : 나의 이름은 신재윤입니다. 나이는 27입니다.\n```\n\n- f 문자열 포맷팅 이용 정렬\n\n```python\n# format 함수\nprint(\"{0:\u003c10}\".format(\"hi\"))\nprint(\"{0:\u003e10}\".format(\"hi\"))\nprint(\"{0:^10}\".format(\"hi\"))\n  \n# f 문자열 포맷팅\nprint(f'{\"hi\":\u003c10}')\nprint(f'{\"hi\":\u003e10}')\nprint(f'{\"hi\":^10}')\n  \n출력결과 : hi\n출력결과 : hi\n출력결과 : hi\n```\n\n- f 문자열 포맷팅 공백 채우기\n\n```python\n# format 함수\nprint(\"{0:=\u003c10}\".format(\"hi\"))\nprint(\"{0:!\u003e10}\".format(\"hi\"))\n  \n# f 문자열 포맷팅\nprint(f'{\"hi\":=\u003c10}')\nprint(f'{\"hi\":!\u003e10}')\n  \n출력결과 : hi========\n출력결과 : !!!!!!!!hi\n```\n\n- f 문자열 포맷팅 소숫점 표현하기  \n\n```python\npi = 3.141592\n  \n# format 함수\nprint(\"{0:0.4f}\".format(pi))\nprint(\"{0:10.4f}\".format(pi))\nprint(format(pi, \"0.4f\"))\n  \n# f 문자열 포맷팅\nprint(f'{pi:0.4f}')\nprint(f'{pi:10.4f}')\n\n출력결과 : 3.1416\n출력결과 : 3.1416\n```\n\n\u003chr\u003e\n\n## 05. 문자열 다양한 함수들\n\n\u003cbr\u003e\n  \n- count()\n\t- 문자 개수 세기\n- find()\n\t- 문자 위치 찾기\n- index()\n\t- 문자 위치 찾기\n- join()\n\t- 문자열 삽입\n- upper()\n\t- 소문자를 대문자로\n- lower()\n\t- 대문자를 소문자로\n- lstrip()\n\t- 왼쪽 공백 제거\n- rstrip()\n\t- 오른쪽 공백 제거\n- strip()\n\t- 양쪽 공백 제거\n- replace()\n\t- 문자열 변경\n- split()\n\t- 문자열 나누기\n  \n\u003cbr\u003e\n\n\u003e [!warning] 주의 !\n\u003e\n\u003e 주의할 것은, 함수를 사용한다 해도 문자열 자체의 내용이 바뀌는 것은 아니다. 예를 들어 replace()를 이용해서 문자열을 변경한다는 것은 `print(string).replace(\"a\", \"b\"))` 일 경우 출력하는 과정에서 `a`를 `b`로 치환해주는 개념인 것이지 string의 문자열 내용 자체가 바뀌는 것은 아니다.\n\n\u003cbr\u003e\n  \n**count()**\n\n```python\nstring = \"python\"\nprint(string.count('p'))\n  \n출력결과 : 1\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**find(), index()** \u003cbr\u003e\n\n`find()`는 없는 값을 찾으면 -1을 반환하지만, `index()`는 없는 값을 찾으면 오류 값을 반환한다.\n\n```python\nstring = \"Python is the best programming language.\"\nprint(string.find('t'))\nprint(string.find('k'))\nprint(string.index('t'))\nprint(string.index('k'))\n  \n출력결과 : 2\n출력결과 : -1\n출력결과 : 2\n출력결과 : ValueError: substring not found\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**join()** \u003cbr\u003e\n\n`join()`는 문자열 뿐만이 아니라 리스트나 튜플에도 사용 가능하다.\n\n```python\n# 문자열 사용 예시\nprint(\",\".join('abcd'))\n\n# 리스트 사용 예시\nprint(\",\".join(['a', 'b', 'c', 'd']))\n  \n출력결과 : a,b,c,d\n출력결과 : a,b,c,d\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**upper(), lower()**\n\n```python\nstring1 = \"hi\"\nstring2 = \"HI\"\n\nprint(string1.upper())\nprint(string2.lower())\n  \n출력결과 : HI\n출력결과 : hi\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**lstrip(), rstrip(), strip()**\n\n```python\nstring = \" hi \"\nprint(string.lstrip())\nprint(string.rstrip())\nprint(string.strip())\n\n출력결과 : hi\n출력결과 : hi\n출력결과 : hi\n  \n#-------------------------------#\n\nstring = \",,,hi,,,\"\nprint(string.strip())\nprint(string.strip(\",\"))\n  \n출력결과 : ,,,hi,,,\n출력결과 : hi\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**replace()** \u003cbr\u003e\n\n```python\nstring = \"Python is good programming language\"\nstring.replace(\"Python\", \"Java\")\n  \nprint(string.replace(\"Python\", \"Java\"))\nprint(string)\n  \n출력결과 : Java is good programming language\n출력결과 : Python is good programming language\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n\n**split()** \u003cbr\u003e\n\n괄호 안이 공백일 경우 \"탭\", \"스페이스\", \"엔터\" 기준으로 쪼갠다.\n\n```python\nstring = \"Python is good programming language\"\nprint(string.split())\n  \n출력결과 : ['Python', 'is', 'good', 'programming', 'language']\n  \n#-------------------------------#\n\nstring = \"a:b:c:d:e\"\nprint(string.split(\":\"))\n  \n출력결과 : ['a', 'b', 'c', 'd', 'e']\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny04":{"title":"04 - List","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 리스트 자료형이란?\n\n데이터 구조 - 리스트(list)라고 하는데, 여기서 데이터 구조란, 연관있는 데이터를 어떻게 컴퓨터로 효율적으로 다룰 수 있을 지에 관한 것이다.\n\n- 리스트\n\n- 여러 가지 관계가 있는 데이터를 하나의 변수로 다루는 방법\n\n- `[ ]`안에 `,`를 사용해서 데이터를 넣으면 된다.\n\n- 예시) `mydata = [1, 2, 'hello', 1.2]`\n\n- 각 데이터는 인덱스를 사용해서 다룰 수 있다.\n\n\u003cbr\u003e  \n\n- 리스트 선언 방법\n\t- 빈 배열을 만들 때는 `[]` 보다는 `list()`를 써주도록 하자.\n\n```python\na = list()\nb = []\nc = [1, 2, 3]\nd = ['Python', 'is', 'good']\ne = [1, 2, ['Python', 'is', 'good']]\n```\n  \n\u003cbr\u003e\n\n- 리스트 다루기 쉬운 방법 (간략한 버전)  \n\n1. 리스트 선언\n\n```\n- 리스트변수 = [ ]\n- 리스트변수 = list()\n- 리스트변수 = [데이터1, 데이터2, ...]\n```\n  \n2. 리스트 추가\n\n```\n- 리스트변수.append(데이터)\n- 리스트변수.insert(인덱스번호, 데이터)\n```\n\n3. 리스트 삭제\n\n```\n- 리스트변수.remove(데이터)\n- del 리스트변수[인덱스번호]\n```\n  \n4. 리스트 데이터 수정\n\n```\n- 리스트변수[인덱스번호] = 수정할 데이터\n```\n\n\u003chr\u003e\n\n## 02. 인덱싱과 슬라이싱\n\n리스트 역시 문자열과 동일하게 인덱싱과 슬라이싱을 할 수 있는데, 이를 잘 활용하여야 한다.  \n\n\u003cbr\u003e\n\n### 리스트의 인덱싱\n\n\u003cbr\u003e  \n\n```python\na = [1, 2, 3]\nprint(a[0] + a[2])\n  \n출력결과 : 4\n```\n\n\u003cbr\u003e\n\n```python\na = [1, 2, 3, ['a', 'b', 'c']]\nprint(a[0])\nprint(a[3])\nprint(a[-1])\n  \n출력결과 : 1\n출력결과 : ['a', 'b', 'c']\n출력결과 : ['a', 'b', 'c']\n```\n\n\u003cbr\u003e  \n\n- 이중 리스트\n\n**C언어의 2차원 배열 느낌도 생각하자. `list[][]`**\n\n```python\na = [1, 2, 3, ['a', 'b', 'c']]\nprint(a[3][0])\nprint(a[-1][0])\n  \n출력결과 : a\n출력결과 : a\n```\n  \n\u003cbr\u003e\n\n- 삼중 리스트\n\n```python\na = [1, 2, ['a', 'b', ['Python', 'is', 'good']]]\nprint(a[2][2][0])\n  \n출력결과 : Python\n```\n\n\u003cbr\u003e\n  \n### 리스트의 슬라이싱\n\n\u003cbr\u003e\n\n```python\na = [1, 2, 3, 4, 5]\nb = a[:2]\nc = a[2:]\n\nprint(b)\nprint(c)\n  \n출력결과 : [1, 2]\n출력결과 : [3, 4, 5]\n```\n\n- 중첩된 리스트 슬라이싱\n\n```python\na = [1, 2, 3, ['a', 'b', 'c'], 4, 5]\nprint(a[2:5])\nprint(a[3][:2])\n  \n출력결과 : [3, ['a', 'b', 'c'], 4]\n출력결과 : ['a', 'b']\n```\n\n\u003cbr\u003e\n\n### split()으로 리스트 다루기  \n\n\u003cbr\u003e\n\n\u003e 사용자로부터 주민등록번호를 입력 받고, 사용자가 남성인지 여성인지 출력하시오. (주민등록번호 뒷자리의 시작이 1이거나 3이면 남성, 2이거나 4이면 여성이다.)  \n\n```python\ndata = input(\"주민등록번호를 '-' 포함해서 입력하세요. \")\n  \nif (int(data.split('-')[1][0]) == 1) or (int(data.split('-')[1][0]) == 3):\n\tprint(\"남성입니다.\")\n\nelif (int(data.split('-')[1][0]) == 2) or (int(data.split('-')[1][0]) == 4):\n\tprint(\"여성입니다.\")\n\nelse:\n\tprint(\"잘못된 주민등록번호 입니다.\")\n```\n\n\u003chr\u003e\n\n## 03. 리스트 연산하기\n\n\u003cbr\u003e  \n\n```python\na = [1, 2, 3]\nb = [4, 5, 6]\n\n# 리스트 더하기\nprint(a + b)\n출력결과 : [1, 2, 3, 4, 5, 6]\n  \n# 리스트 곱하기 (반복)\nprint(a * 3)\n출력결과 : [1, 2, 3, 1, 2, 3, 1, 2, 3]\n  \n# 리스트 길이 구하기\nprint(len(a))\n출력결과 : 3\n```\n  \n- 리스트 연산 오류\n\n```python\na = [1, 2, 3]\nprint(a[2] + \"hi\")\nprint(str(a[2]) + \"hi\")\n  \n출력결과 : TypeError: unsupported operand type(s) for +: 'int' and 'str'\n출력결과 : 3hi\n```\n  \n\u003chr\u003e\n\n## 04. 수정, 삭제, 추가\n\n\u003cbr\u003e\n\n### 리스트 수정\n  \n\u003cbr\u003e\n\n```python\nlanguage = [\"python\", \"java\", \"c++\"]\nlanguage[2] = \"c\"\nprint(language)\n  \n출력결과 : ['python', 'java', 'c']\n```\n\n\u003cbr\u003e\n  \n### 리스트 삭제\n\n- del 함수 이용\n\n- 리스트의 인덱스를 가르켜서 내용 삭제\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3, 4, 5]\ndel a[1]\ndel b[:2]\n  \nprint(a)\nprint(b)\n  \n출력결과 : [1, 3]\n출력결과 : [3, 4, 5]\n```\n  \n\u003cbr\u003e\n\n- remove 함수 이용\n\n- 리스트의 내용을 가르켜서 삭제\n\n- 첫 번째로 나오는 내용이 삭제된다.\n\n```python\nlocation = ['서울시', '경기도', '서울시', '부산시']\nlocation.remove('서울시')\nprint(location)\n  \n출력결과 : ['경기도', '서울시', '부산시']\n```\n  \n\u003cbr\u003e\n  \n- pop 함수 이용\n\n- 리스트의 맨 마지막 요소를 뽑아오고 그 요소는 리스트에서 삭제\n\n```python\nlocation = ['서울시', '경기도', '서울시', '부산시']\nprint(location.pop())\nprint(location)\n  \n출력결과 : 부산시\n출력결과 : ['서울시', '경기도', '서울시']\n```\n\n\u003cbr\u003e  \n\n### 리스트 추가\n\n- append 함수 이용\n\n- append 함수는 하나의 요소만 추가 가능\n\n- 리스트의 맨 마지막에 추가\n\n```python\na = [1, 2, 3]\n\na.append(4)\nprint(a)\n  \na.append([5, 6])\nprint(a)\n\n출력결과 : [1, 2, 3, 4]\n출력결과 : [1, 2, 3, 4, [5, 6]]\n```\n\n\u003cbr\u003e  \n\n- insert 함수 이용\n\n- 지정한 인덱스에 요소 추가\n\n```python\na = [1, 2, 3]\n\na.insert(3, 4)\nprint(a)\n\na.insert(0, 5)\nprint(a)\n\n출력결과 : [1, 2, 3, 4]\n출력결과 : [5, 1, 2, 3, 4]\n```\n\n\u003chr\u003e\n\n## 05. 리스트 다양한 함수들\n  \n- sort()\n\t- 리스트 요소 순서대로 정렬\n- reverse()\n\t- 리스트 요소 역순으로 뒤집기 (순서대로 정렬하고 뒤집기 X)\n- index()\n\t- 리스트에 해당 값이 있으면 그 위치를 반환\n- find()\n\t- 리스트에 해당 값이 있으면 그 위치를 반환\n- count()\n\t- 리스트에 포함된 요소의 개수 세기\n- extend()\n\t- 리스트 확장\n  \n\u003cbr\u003e\n\n**sort(), reverse()**\n\n```python\na = [2, 1, 4, 3]\na.sort()\nprint(a)\n  \nb = [2, 1, 4, 3]\nb.reverse()\nprint(b)\n  \n출력결과 : [1, 2, 3, 4]\n출력결과 : [3, 4, 1, 2]\n```\n\n\u003cbr\u003e\n\n```python\n# 만약, 역순으로 순서대로 배치하고 싶으면, sort -\u003e reverse\na = [1, 8, 0, 9, 14]\na.sort()\na.reverse()\nprint(a)\n  \n출력결과 : [14, 9, 8, 1, 0]\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n\n**index()**\n\n```python\na = [1, 2, 3, 4]\nprint(a.index(1))\nprint(a.index(3))\nprint(a.index(5))\n  \n출력결과 : 0\n출력결과 : 2\n출력결과 : ValueError: 5 is not in list\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n\n**index()와 find() 비교**\n\n- 이 둘은 비슷한 역할을 하는 것 같지만, 조금 다르다.\n\n```python\n# index()의 경우\nletters = input()\nvar = letters.index('n')\n\nif var \u003e= 0:\n\tprint(\"입력한 문자에 n이 있습니다.\")\nelse:\n\tprint(\"입력한 문자에 n이 없습니다.\")\n\n출력결과 : n이 있으면 -\u003e 입력한 문자에 n이 있습니다.\n출력결과 : n이 없으면 -\u003e Value Error\n\n# find()의 경우\nletters = input()\nvar = letters.find('n')\n\nif var \u003e= 0:\n\tprint(\"입력한 문자에 n이 있습니다.\")\nelse:\n\tprint(\"입력한 문자에 n이 없습니다.\")\n\n출력결과 : n이 있으면 -\u003e 입력한 문자에 n이 있습니다.\n출력결과 : n이 없으면 -\u003e 입력한 문자에 n이 없습니다.\n```\n\n\u003cbr\u003e\n\n사용자가 입력한 것에 n이 있다면 정상적으로 \"입력한 문자에 n이 있습니다.\"라고 출력 되지만, n이 없는 경우, `index()`는 Value Error가 출력되고 `find()`는 정상적으로 값이 출력된다.\n  \n\n\u003cbr\u003e\n\n이는, [[잔재미] String](brain/Lecture/pl/funny-python/funny03.md)에 기록되어있는 내용인데, `find()`는 없는 값을 찾으면 -1을 반환하지만, `index()`는 없는 값을 찾으면 오류를 반환하기 때문이다.\n\n\u003cbr\u003e\u003cbr\u003e\n\n**count()**\n\n```python\na = [1, 2, 3, 1, 1, 5]\nprint(a.count(1))\n  \n출력결과 : 3\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n  \n**extend()**\n\n- 함수 안에는 리스트만 올 수 있다.\n\n- 원래의 리스트에 `()`안의 리스트를 더하는 것이다.\n\n```python\na = [1, 2, 3]\na.extend([4, 5])\nprint(a)\n  \n출력결과 : [1, 2, 3, 4, 5]\n```\n\n\u003cbr\u003e\n\n```python\na = [1, 2, 3]\nb = [4, 5]\na.extend(b)\nprint(a)\n  \n출력결과 : [1, 2, 3, 4, 5]\n```\n  \n\u003cbr\u003e\n\n- 리스트 연산 더하기와 유사함을 알 수 있다.\n\n```python\na = [1, 2, 3]\na += [4, 5]\nprint(a)\n  \n출력결과 : [1, 2, 3, 4, 5]\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny05":{"title":"05 - Tuple","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 튜플 자료형이란?\n\n\u003cbr\u003e\n\n튜플 자료형은 리스트 자료형과 매우 유사하다. 하나의 다른 점이 있는데 그것이 리스트 자료형과 튜플 자료형을 구분한다. `튜플 자료형은 값의 변경이 불가능하다는 점이다.` 리스트는 여러 가지 함수를 이용하여 리스트의 길이를 늘렸다가 줄였다가 하면서 값을 추가, 삭제, 수정을 하였는데 튜플은 그런 것이 불가능하고, 처음 선언한 그대로 사용해야 한다.  \n\n\u003cbr\u003e\n\n그러면, 상황에 맞춰서 가변적으로 변하는 리스트를 사용하는 것이 편하고 좋지 않냐고 물을 수 있다. 물론, 리스트를 훨씬 많이 사용하지만, 튜플이 필요한 경우가 있다. 간단하게 말하면 리스트는 동적배열이고 가변 객체이기 때문에 튜플보다 무겁고 오버헤드가 크다. 상황에 따라 정적배열이며 불변객체인 튜플을 사용하는 것이 퍼포먼스를 높이는 데 도움을 줄 수 있다. 자세한 내용은 \u003ca href='https://jae-yoon.tistory.com/4' target='_blank'\u003e개발자 유니\u003c/a\u003e에 추가로 포스팅하였다.\n\n\u003cbr\u003e\n\n- 튜플\n\t- 리스트와 유사하게, 여러 가지 관계가 있는 데이터를 하나의 변수로 다루는 방법\n\t- `( )`안에 `,`를 사용해서 데이터를 넣으면 된다.\n\t- 예시) `mydata = (1, 2, 3)`\n\n\u003cbr\u003e\n\n- **데이터 구조 : 튜플**\n\t- 선언 + 입력 : `변수명 = (1, 2, 3, 4)`\n\t- 읽기 : `변수명[인덱스번호]`\n\t- 추가 : 불가\n\t- 삭제 : 불가\n\t- 수정 : 불가\n\n\u003cbr\u003e\n\n- 튜플 선언 방법\n\n- 빈 배열을 만들 때는 `()`를 사용하겠지만, 사실상 튜플은 사용할 일 없다.\n\n```python\na = tuple()\nb = ()\nc = (1,) # tuple에 값이 하나일 경우 (값,) 이렇게 콤마를 넣어야한다.\nd = (1, 2, 3)\ne = 1, 2, 3 # 괄호를 생략해도 무방, 즉, 괄호가 없는 값의 나열은 튜플로 취급한다.\nf = ('a', 'b', ('ab', 'cd'))\n```\n\n\u003chr\u003e\n\n## 02. 튜플 다루기\n\n\u003cbr\u003e\n\n튜플도 데이터 구조이기 때문에 슬라이싱, 인덱싱 모두 가능하다.\n\n```python\na = (1, 2, 3, 'a', 'b')\nprint(a[:2])\n  \n출력결과 : (1, 2)\n```\n\n\u003cbr\u003e\n\n튜플끼리 더하기, 반복하는 표현인 `*`도 가능하다.\n\n```python\na = (1, 2, 3)\nb = (4, 5, 6)\n  \nprint(a + b)\nprint(a * 3)\nprint(len(a))\n  \n출력결과 : (1, 2, 3, 4, 5, 6)\n출력결과 : (1, 2, 3, 1, 2, 3, 1, 2, 3)\n출력결과 : 3\n```\n\n\u003cbr\u003e\n\n튜플은 리스트와 굉장히 유사하다고 했는데, 서로 간단하게 type을 변경할 수 있다.\n\n```python\ndata_tuple = (1, 2, 3)\nprint(type(data_tuple))\n출력결과 : tuple\n  \ndata_list = list(data_tuple)\nprint(type(data_list))\n출력결과 : list\n\ndata_tuple = tuple(data_list)\nprint(type(data_tuple))\n출력결과 : tuple\n```\n\n\u003chr\u003e\n\n## 03. 튜플 응용\n\n- 튜플을 이용한 값 변경\n\n우리가 흔히 변수에 대입되어 있는 값을 변경할 때는 `temp`라는 임시 변수를 두고 변경하는 경우가 많았다.\n\n```python\na = 1\nb = 2\n  \ntemp = a\na = b\nb = temp\n  \nprint(\"a의 값은 %d 입니다.\" % a)\nprint(\"b의 값은 %d 입니다.\" % b)\n  \n출력결과 : a의 값은 2 입니다.\n출력결과 : b의 값은 1 입니다.\n```\n\n\u003cbr\u003e\n\n하지만, 튜플 자료형을 이용하는 python에서는 이렇게도 가능하다.\n\n```python\na = 1\nb = 2\na, b = b, a\n\nprint(\"a의 값은 %d 입니다.\" % a)\nprint(\"b의 값은 %d 입니다.\" % b)\n  \n출력결과 : a의 값은 2 입니다.\n출력결과 : b의 값은 1 입니다.\n```\n\n그 이유는 `a, b = b, a`라고 하면 괄호가 생략된 형태의 튜플로 이해할 수 있기 때문이다. 실제로는 `(a, b) = (b, a)`인데, 튜플 하나가 하나의 변수로 취급되면서 내부의 값이 일대일로 대응하여 b는 a로, a는 b로 대입되기 때문이다.\n\n\u003cbr\u003e  \n\n- 이를 응용하면 함수의 return 값도 튜플을 이용해 하나 이상의 값을 반환할 수 있다.\n\n```python\ndef mul_return(a):\n\tb = a + 1\n\treturn a, b\n\nmul_return(1)\n출력결과 : (1, 2)\n```\n  \n`return a, b`는 사실상 `return (a, b)`와 동일한 것이다. `(a, b)`라는 튜플 하나를 반환하는 것이다.\n\n\u003cbr\u003e  \n\n- 추가적으로, 튜플을 가장 흔히 볼 수 있는 형태는 리스트 내부에 있는 형태이다.\n\n```python\ndata = [(1, 2), (3, 4), (5, 6)]\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny06":{"title":"06 - Dictionary","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 딕셔너리 자료형이란?  \n\n\u003cbr\u003e\n\n`{키 : 값}`의 대응 관계를 가지는 자료형이다. 연관 배열(Associative array) 또는 해시(Hash)라고도 한다. 리스트와 튜플과는 다르게 순차적이지 않고, 오직 키(Key)를 이용해 값(Value)를 얻어낸다.  \n\n**즉, 딕셔너리의 어떤 값을 찾기 위해 순차적으로 모든 키를 탐색할 필요 없이 해당하는 값의 키만 찾으면 된다는 의미이다.**\n  \n\u003cbr\u003e\n\n- **데이터 구조 : 딕셔너리 or 사전**\n\t- 선언 + 입력 : `변수명 = {}` 또는 `dict()` , `변수명 = {키:값}`\n\t- 읽기 : `변수명[키]`\n\t- 추가 : `변수명[새로운 키] = 새로운 값`\n\t- 삭제 : `del 변수명[삭제할 키]`\n\t- 수정 : `변수명[수정할 키] = 수정할 값`\n\n\u003chr\u003e\n\n## 02. 딕셔너리 다루기\n\n\u003cbr\u003e  \n\n딕셔너리를 다루기에 앞서 리스트, 튜플, 딕셔너리 빈 배열을 만드는 방법을 정리해보자면 아래와 같다.\n\n```python\ndata_list = list() # []\ndata_tuple = tuple() # ()\ndata_dict = dict() # {}\n```\n\n\u003cbr\u003e\n\n딕셔너리는 리스트와 튜플과는 다르게 순서가 없다고 했다. 그 말은, 인덱스를 이용해서 값을 뽑아내는 것이 불가능하고 오직, **딕셔너리의 키를 이용해서 값을 뽑아내는 것 말고는 방법이 없다는 말이다.**  \n\n\u003cbr\u003e\n\n- 딕셔너리 선언과 입력\n\n```python\ndata_dict = {'한국' : 'KR', '일본' : 'JP', '중국' : 'CN'}\nprint(data_dict['한국'])\n출력결과 : 'KR'\n\na = {1 : 'hi'}\nb = {'a' : [1, 2, 3]}\n```\n\n\u003cbr\u003e\n  \n- 딕셔너리 추가\n\n```python\ndata_dict = {'한국' : 'KR', '일본' : 'JP', '중국' : 'CN'}\ndata_dict['미국'] = 'US'\n  \nprint(data_dict)\n출력결과 : {'한국' : 'KR', '일본' : 'JP', '중국' : 'CN', '미국' : 'US'}\n```\n\n\u003cbr\u003e\n\n- 딕셔너리 삭제\n\n```python\ndata_dict = {'한국' : 'KR', '일본' : 'JP', '중국' : 'CN'}\ndel data_dict['한국']\n\nprint(data_dict)\n출력결과 : {'일본': 'JP', '중국': 'CN'}\n```\n\n\u003cbr\u003e  \n\n- 딕셔너리 수정\n\n```python\ndata_dict = {'한국' : 'KR', '일본' : 'JP', '중국' : 'CN'}\ndata_dict['한국'] = 'Korea'\n\nprint(data_dict)\n출력결과 : {'한국': 'Korea', '일본': 'JP', '중국': 'CN'}\n```\n  \n\u003chr\u003e\n\n## 03. 딕셔너리 응용  \n\n\u003cbr\u003e\n\n**딕셔너리 주의사항**\n\n\u003cbr\u003e\n\n1. 키가 중복되는 경우\n\n딕셔너리 다루기에서 딕셔너리는 키(Key)를 이용해 값(Value)를 얻어낸다고 하였다. 그러면 중복된 키가 존재한다면 어떻게 될까?\n\n키가 중복되면, 1개의 값을 제외하고 나머지 값은 무시된다. 키를 통해서 값을 얻는 딕셔너리의 특징 때문에 그러하다.\n\n```python\na = {1: 'a', 1: 'b', 1: 'c'}\nprint(a[1])\n  \n출력결과 : c\n```\n\n\u003cbr\u003e\n\n2. 키로 변하는 값을 설정할 수 없다.\n\n키(Key)는 값(Value)과는 다르게 변하지 않는 요소이다. 따라서, 리스트는 사용할 수 없지만 튜플은 사용할 수 있다. 리스트는 가변 객체이고 튜플은 불변 객체이기 때문이다.\n  \n```python\na = {[1, 2] : 'hi'}\nb = {(1, 2) : 'hi'}\n  \nprint(a)\nprint(b)\n  \n출력결과 : TypeError: unhashable type: 'list'\n출력결과 : {(1, 2): 'hi'}\n```\n\n\u003chr\u003e\n  \n## 04. 딕셔너리 다양한 함수\n\n\u003cbr\u003e  \n\n- keys()\n\t- 딕셔너리의 key 만을 모아서 dict_keys 객체를 반환\n- values()\n\t- 딕셔너리의 values 만을 모아서 dict_values 객체를 반환\n- items()\n\t- 딕셔너리의 keys와 values의 쌍을 튜플로 묶어서 dict_items 객체를 반환\n- clear()\n\t- 딕셔너리 안의 모든 요소 삭제\n- get()\n\t- 해당하는 key에 대응하는 value 반환\n- in\n\t- 해당하는 key가 딕셔너리 내부에 있는지 조사\n\n\u003cbr\u003e\u003cbr\u003e  \n\n**keys()**\n\n- 파이썬 2.7 버전 까지는 keys 함수를 사용할 경우 반환 값으로 dict_keys 객체가 아닌 리스트를 반환했다. 하지만, 리스트를 반환하기 위한 과정에서 메모리 낭비가 심해 파이썬 3.0 버전 이후에는 메모리 낭비를 줄이려고 dict_keys 객체를 반환한다. \u003cbr\u003e\u003cbr\u003e 반환 값으로 리스트가 필요한 경우에는 `list(a.keys())`를 사용하면 된다.\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\nprint(a.keys())\n  \n출력결과 : dict_keys([key1, key2, key3])\n  \n# type() 함수를 이용해서 봐도 리스트가 아닌 객체 타입임을 확인 가능\nprint(type(a.keys()))\n  \n출력결과 : \u003cclass 'dict_keys'\u003e\n```\n\n\u003cbr\u003e\n\n- 반복문을 이용해서 dict_keys 객체를 핸들링 할 수 있다. 리스트를 사용하는 것과 차이는 없지만, 리스트의 append, insert 같은 함수를 사용할 수는 없다.\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\n  \nfor key in a.keys():\n\tprint(key)\n\n출력결과 :\nkey1\nkey2\nkey3\n```\n\n- keys() 함수를 가장 많이 쓰는 형태는 아래이다.\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\n  \nfor key in a.keys():\n\tprint(a[key])\n\n출력결과 :\nvalue1\nvalue2\nvalue3\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**values()**\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\n  \nfor value in a.values():\n\tprint(value)\n\n출력결과 :\nvalue1\nvalue2\nvalue3\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**items()**\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\n  \nfor data in a.items():\n\tprint(data)\n\n출력결과 :\n('key1', 'value1')\n('key2', 'value2')\n('key3', 'value3')\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**clear()**\n\n```python\na = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\na.clear()\n  \nprint(a)\n출력결과 : {}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**get()**\n\n- get() 함수는 그냥 key를 이용해셔 value를 읽는 것과 동일한 역할을 한다.\n\n- 사용하는 이유는 존재하지 않는 key를 이용하여 value를 가져 오려고 할 때, 그냥 읽으면 오류를 반환하지만 `get() 함수를 이용해서 읽으면 none을 반환해준다.`\n\n```python\na = {'key1' : 'value1', 'key2' : 'value2'}\nprint(a[key3])\nprint(a.get('key3'))\n  \n출력결과 : NameError: name 'key3' is not defined\n출력결과 : None\n```\n  \n- 찾는 값이 없을 경우, None이 아닌 원하는 디폴트 값을 반환하도록 할 수 있다.\n  \n```python\na = {'key1' : 'value1', 'key2' : 'value2'}\nprint(a.get('key3', '해당하는 키가 없어요.'))\n\n출력결과 : 해당하는 키가 없어요.\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**in()**\n\n- 해당하는 키가 딕셔너리 안에 있는 지 조사하는 것이다.\n\n```python\na = {'key1' : 'value1', 'key2' : 'value2'}\nprint('key1' in a)\nprint('key3' in a)\nprint('value1' in a)\n  \n출력결과 : True\n출력결과 : False\n출력결과 : False # key가 아닌 value를 찾으니까 false로 나온다.\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny07":{"title":"07 - Set","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 집합 자료형이란?\n\n\u003cbr\u003e\n\n집합에 관련된 것을 쉽게 처리하기 위해 만든 자료형이다. 집합 자료형은 대표적인 특징이 두 가지가 있다.\n\n- 중복을 허용하지 않는다.\n- 순서가 없다.\n\n이 특징을 이용하여 `자료형의 중복을 제거하기 위한 필터 역할`로 사용할 수 있다. 또, 순서가 없다는 특징에서 리스트와 튜플처럼 인덱싱으로 접근할 수 없다. 딕셔너리와 비슷하다는 의미이다. 굳이 인덱싱으로 접근하고 싶다면 집합을 리스트나 튜플로 변환해서 사용하면 된다.\n\n\u003cbr\u003e\n\n- **데이터 구조 : 집합**\n\t- 선언 + 입력 : `변수명 = set()`, `변수명 = {데이터1, 데이터2, ... }`, `변수명 = set(데이터1)`, `변수명 = set({데이터1, 데이터2, ... })`\n\t- 읽기 : 그냥 읽어도 되고 반복문이나 조건문 이용\n\t- 추가 : 값 1개 추가 `add()`, 값 여러 개 추가 `update()`\n\t- 삭제 : `remove()`\n\n\u003chr\u003e\n\n## 02. 집합 다루기\n\n\u003cbr\u003e\n\n집합을 다루기에 앞서 리스트, 튜플, 딕셔너리, 집합 빈 배열을 만드는 방법을 정리해보자면 아래와 같다.\n\n```python\ndata_list = list() # []\ndata_tuple = tuple() # ()\ndata_dict = dict() # {}\ndata_set = set() # {}\n```\n\n`{}`는 딕셔너리와 동일하기 때문에 보통 빈 집합을 만들때는 `set()`을 주로 사용한다.  \n\n\u003cbr\u003e\n\n집합을 선언하는 것에는 여러 방법이 있다. 그 중 `{}`를 사용하는 방법을 딕셔너리와 헷갈리지 말자. 딕셔너리는 `{ 키 : 값 }`의 대응관계를 나타내줘야 하지만, 집합은 그냥 `{데이터1, 데이터2}` 이렇게 콤마로 나열해주면 된다.\n\n```python\ndata_set = set()\ndata_set1 = set({'data1', 'data2', 'data3'})\ndata_set2 = set(['data1', 'data2', 'data3'])\ndata_set3 = {'data1', 'data2', 'data3'}\n  \nprint(data_set)\nprint(data_set1)\nprint(data_set2)\nprint(data_set3)\n  \n출력결과 : set()\n출력결과 : {'data2', 'data3', 'data1'}\n출력결과 : {'data2', 'data3', 'data1'}\n출력결과 : {'data2', 'data3', 'data1'}\n```\n  \n\u003cbr\u003e\n\n집합을 읽을 때 그냥 읽어도 되지만 반복문을 이용해서 하나씩 읽을 수도 있다.\n\n```python\n# 반복문 이용\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\n  \nfor data in smartphone:\n\tprint(data)\n\n출력결과 :\n애플\n화웨이\nLG\n삼성\n  \n# 조건문 이용\nif '삼성' in smartphone:\n\tprint(smartphone)\n\n출력결과 : {'애플', '화웨이', 'LG', '삼성'}\n```\n\n\u003cbr\u003e \u003cbr\u003e\n\n1. 교집합\n\n`\u0026` 혹은 `s1.intersection(s2)` 사용\n\n```python\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\ntelevision = {'샤오미', '삼성', 'LG', '소니'}\n\n# 스마트폰, TV 둘 다 생산하는 업체\nprint(smartphone \u0026 television)\nprint(smartphone.intersection(television))\n  \n출력결과 : {'LG', '삼성'}\n출력결과 : {'LG', '삼성'}\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n\n2. 합집합\n\n`|` 혹은 `s1.union(s2)` 사용\n\n```python\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\ntelevision = {'샤오미', '삼성', 'LG', '소니'}\n  \n# 스마트폰 또는 TV를 생산하는 업체\nprint(smartphone | television)\nprint(smartphone.union(television))\n  \n출력결과 : {'샤오미', '삼성', '화웨이', 'LG', '애플', '소니'}\n출력결과 : {'샤오미', '삼성', '화웨이', 'LG', '애플', '소니'}\n```\n  \n\u003cbr\u003e\u003cbr\u003e\n\n3. 차집합\n\n`-` 혹은 `s1.difference(s2)` 사용\n\n```python\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\ntelevision = {'샤오미', '삼성', 'LG', '소니'}\n  \n# 스마트폰만 생산하는 업체\nprint(smartphone - television)\nprint(smartphone.difference(television))\n  \n출력결과 : {'애플', '화웨이'}\n출력결과 : {'애플', '화웨이'}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n4. 대칭차집합\n\n`^` 사용, 전체에서 교집합을 뺀 것\n\n```python\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\ntelevision = {'샤오미', '삼성', 'LG', '소니'}\n\n# 스마트폰, TV 둘 다 생산하는 업체를 제외한 나머지\nprint(smartphone ^ television)\n  \n출력결과 : {'샤오미', '화웨이', '애플', '소니'}\n```\n\n\u003chr\u003e\n  \n## 03. 집합 다양한 함수들\n\n\u003cbr\u003e\n\n- add()\n\t- 값 1개 추가\n- update()\n\t- 값 여러 개 추가\n- remove()\n\t- 특정 값 제거\n- in()\n\t- 집합 내 특정 값 있는지 조사\n\n\u003cbr\u003e\n\n**add(), update(), remove()**\n\n```python\ns1 = set([1, 2, 3])\ns1.add(4)\nprint(s1)\n\n출력결과 : {1, 2, 3, 4}\n\ns2 = set([1, 2, 3])\ns2.update([4, 5, 6])\nprint(s2)\n\n출력결과 : {1, 2, 3, 4, 5, 6}\n\ns2.remove(5)\nprint(s2)\n\n출력결과 : {1, 2, 3, 4, 6}\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n**in()**\n\n```python\nsmartphone = {'삼성', '애플', 'LG', '화웨이'}\nprint('모토로라' in smartphone)\nprint('삼성' in smartphone)\n  \n출력결과 : False\n출력결과 : True\n```\n\n\u003chr\u003e\n\n## 04. 집합 응용\n  \n\u003cbr\u003e\n\n집합은 보통 \"`중복을 허용하지 않는다`\" 이 특성을 이용한다. 어떠한 리스트 자료형에 수백만 수천만의 데이터를 추가하다보면 중복이 발생할 수 있는데, 이 리스트를 집합으로 바꿨다가 다시 리스트로 바꾸면 중복된 데이터가 사라진다.\n\n```python\nsmartphone_list = ['애플', '삼성', '화웨이', '샤오미', '소니', 'LG', '애플', '삼성', '화웨이', '샤오미', '소니', 'LG', '애플', '삼성', '화웨이', '샤오미', '소니', 'LG', '애플', '삼성', '화웨이', '샤오미', '소니', 'LG', ]\n\ndata = set(smartphone_list)\nprint(data)\n\n출력결과 : {'샤오미', '삼성', '화웨이', 'LG', '애플', '소니'}\n# data를 다시 리스트로 바꿔서 사용하면 된다. list(data)\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny08":{"title":"08 - Bool","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 불 자료형이란?\n\n\u003cbr\u003e\n\n불 자료형은 참(True)과 거짓(False)를 다루는 자료형이다.\n\n- True : 참\n\n- False : 거짓\n\n\u003cbr\u003e  \n\n단순히 참과 거짓을 판별하는 것 이외에도 `자료형을 참과 거짓으로 판단할 수 있다.`\n\n- 문자열, 리스트, 튜플, 딕셔너리, 집합 등의 `값이 비어있으면 거짓, 있으면 참`\n\n- `0`은 False, `1`은 True\n\n- `None`은 False\n\n파이썬은 모든 것을 `객체`로 다룬다. 그 중 `NoneType` 클래스의 유일한 객체인 None은 값 자체가 없거나 존재하지 않거나 등의 경우를 의미한다. None에 대한 자세한 내용은 \u003ca href='https://jae-yoon.tistory.com/5' target='_blank'\u003e개발자 유니\u003c/a\u003e에 추가로 포스팅했다.\n  \n```python\nprint(type(None))\nprint(bool(None))\nprint(bool('None'))\n  \n출력결과 : \u003cclass 'NoneType'\u003e\n출력결과 : False # None은 False\n출력결과 : True # 이 None은 문자열 None이니까, True\n```\n\n\u003chr\u003e\n\n## 02. 불 자료형 다루기  \n\n\u003cbr\u003e\n\n- 리스트 내부에 값이 있으면 참이라는 것을 이용하여 반복문에 활용한 경우\n\n```python\na = [1, 2, 3, 4]\nwhile a :\n\tprint(a.pop())\n\n출력결과 :\n4\n3\n2\n1\n```\n  \n- 리스트 내부에 값이 있으면 True, 없으면 False를 이용하여 조건문에 활용한 경우\n\n```python\nif []:\n\tprint(\"참\")\nelse:\n\tprint(\"거짓\")\n\n출력결과 : 거짓\n  \nif [1, 2, 3, 4]:\n\tprint(\"참\")\nelse:\n\tprint(\"거짓\")\n\n출력결과 : 참\n```\n  \n- bool 값이 True 인지 False 인지 잘 모르겠으면 `bool()`을 사용하자\n\n```python\nprint(bool([1,2,3]))\nprint(bool([]))\nprint(bool(0))\nprint(bool(3))\n  \n출력결과 : True\n출력결과 : False\n출력결과 : False\n출력결과 : True\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny09":{"title":"09 - 변수심화","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 변수의 정확한 의미\n\n\u003cbr\u003e  \n\n`변수 = 값`의 형태로 계속 사용해왔다. `=(대입연산자, assignment)`는 우측의 값을 왼쪽 변수에 대입한다는 의미를 가진다. 조금 더 깊게 생각해보면, 파이썬은 모든 것을 객체로 다룬다고 했다.\n  \n쉽게 말해서, `우리가 지금까지 다뤄온 자료형은 객체라고 보면 된다.` 값을 생성하는 과정을 통해 자료형(객체)가 메모리에 공간을 할당받는다. 그러면 `변수가 값이 해당하는 메모리의 주소를 가리키게 된다.`  \n\n**마치, C언어의 포인터와 비슷한 느낌이다.** 실제로 변수에 값이 저장되는 것이 아니라 값이 저장되어 있는 메모리의 주소를 가리킬 뿐이다. 이를 코드로 확인해보면,\n\n```python\na = [1, 2, 3]\nprint(id(a))\n  \nb = a\nprint(id(b))\n  \n출력결과 : 140539428263424\n출력결과 : 140539428263424\n```\n  \n\u003cbr\u003e\n\na 변수에 리스트를 저장했고, a를 b에 대입한 것의 각각 메모리 주소를 확인해보면 동일한 것을 알 수 있다. 변수는 단지 메모리의 주소를 가리키는 것이기 때문이다.\n\n```python\na = [1, 2, 3]\nb = a\nprint(a is b)\n  \n출력결과 : True\n```\n  \n\u003cbr\u003e\n\n`a is b`가 뜻하는 바는 a와 b가 동일한 가 보다는 조금 더 정확하게 `a와 b가 가리키는 객체가 동일한가?`로 이해할 수 있다. 서로 가리키는 객체가 동일하기에 True가 반환된다. 이를 증명해보면,  \n\n\u003cbr\u003e\n  \n```python\na = [1, 2, 3]\nb = a\n  \na[1] = 4\n  \nprint(a)\nprint(b)\n  \n출력결과 : [1, 4, 3]\n출력결과 : [1, 4, 3]\n```\n  \n\u003cbr\u003e\n\n`a = [1, 2, 3]`인 상태를 b에 대입하고 난 이후에 a의 인덱스 값을 바꿨다. 그 이후에 b를 출력해보면 b 역시 바뀐 것을 알 수 있다. 즉, a라는 공간에 리스트를 넣어서가 아닌, `리스트 객체가 저장된 메모리의 주소를 a가 가리키기 떄문에, 또 b가 가리키기 때문에 이런 결과가 나타나는 것이다.`\n\n\u003chr\u003e\n\n## 02. 변수 다루기 응용\n\n\u003cbr\u003e\n\n값을 가져오면서 주소는 다르게 변수 복사도 가능하다. `즉, A라는 객체의 값을 가져오면서 새로 생성한 B라는 객체에 A의 값을 넣겠다는 의미이다.` A 객체의 값을 변경하더라도 B 객체는 애초에 다른 객체기 때문에 영향을 끼치지 않는다. 메모리 주소를 확인해봐도 주소가 다르다.\n\n\u003cbr\u003e\n\n- `[:]`을 사용하는 방법\n\n```python\na = [1, 2, 3]\nb = a[:]\na[1] = 4\n  \nprint(a)\nprint(b)\n  \n출력결과 : [1, 4, 3]\n출력결과 : [1, 2, 3]\n  \n# 서로 다른 메모리를 가리키는 것을 확인 가능하다.\nprint(id(a))\nprint(id(b))\n  \n출력결과 : 140011803112896\n출력결과 : 140011802234432\n```\n  \n\u003cbr\u003e\n\n- `copy 모듈`을 사용하는 방법\n  \n```python\nfrom copy import copy\n\na = [1, 2, 3]\nb = copy(a)\n\na[1] = 4\nprint(a)\nprint(b)\n  \n출력결과 : [1, 4, 3]\n출력결과 : [1, 2, 3]\n  \nprint(id(a))\nprint(id(b))\n  \n출력결과 : 139811777411136\n출력결과 : 139811777409472\n```\n\n\u003cbr\u003e\n\n- 리스트의 경우 `copy()` 함수 사용  \n\n```python\na = [1, 2, 3]\nb = a.copy()\na[1] = 4\n\nprint(a)\nprint(b)\n\n출력결과 : [1, 4, 3]\n출력결과 : [1, 2, 3]\n```\n\n\u003cbr\u003e\n\n- 다른 객체를 가리키는지 확인하려면 그냥 `is` 쓰면 되기는 한다.\n\n```python\na = [1, 2, 3]\nb = a.copy()\nc = a\n  \nprint(b is a)\nprint(c is a)\n  \n출력결과 : False\n출력결과 : True\n```\n\n\u003cbr\u003e\n\n- 변수 만들 때 `변수 = 값` 말고도 튜플, 리스트, 여러 개 대입 등도 가능하다.\n\n```python\na, b = ('hello', 'world')\n[c, d] = ['I', 'am']\ne = f = 3\n  \nprint((a, b))\nprint([c, d])\nprint(e, f)\n  \n출력결과 : ('hello', 'world')\n출력결과 : ['I', 'am']\n출력결과 : 3 3\n```\n\n\u003cbr\u003e\n\n- [[잔재미] Tuple](brain/Lecture/pl/funny-python/funny05.md)에서 설명한 내용인데 이를 이용하여 변수를 손쉽게 바꿀 수 있다. 파이썬의 강력한 특징이다.\n\n```python\na = 'hello'\nb = 'world'\n\na, b = b, a\nprint(b, a)\n\n출력결과 : hello world\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny10":{"title":"10 - Condition","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. 조건문 (if문)\n\n\u003cbr\u003e\n\n조건문은 어떠한 조건이 주어졌을 때, 그 조건에 해당한다면 명령어를 실행, 해당하지 않는다면 다른 명령어를 실행하는 구조이다. 즉, `참과 거짓을 판단하는 문장`으로 이해해도 무방하다. 다른 언어에서 많이 배웠으니 특별한 건 없다.\n\n\u003cbr\u003e\n\n```python\nif 조건문:\n\t수행할 문장1\nelif 조건문:\n\t수행할 문장2\n\t\t수행할 문장2-2\n\t\t수행할 문장2-3\nelse:\n\t수행할 문장3\n```\n\n\u003cbr\u003e  \n\n파이썬의 조건문에서 주의할 점은 조건 끝에 `:` 세미 콜론을 반드시 붙이는 것과 수행할 문장을 `들여쓰기` 하는 것이다. 내가 배웠던 C나 Java처럼 `{ }`로 묶는 것이 아니라 익숙하지 않을 것이다.\n\n\u003cbr\u003e\n\n들여쓰기에 관해서는 `탭(Tab)`으로 할 지 `공백(Space bar)`로 할 지는 의견이 갈린다. 나는 보통 탭을 사용하지만, 최근 파이썬 커뮤니티의 트렌드는 `공백(Space bar) 4번`을 쓰는 것을 권장한다고 한다. 그래서 나는 VScode 들여쓰기를 스페이스바 4번으로 설정해놨다.  \n\n\u003chr\u003e\n## 02. value와 data type 비교\n\n\u003cbr\u003e\n\n다른 언어에서도 값(value)과 자료형(data type)을 비교하는 방법이 존재한다. 자바 스크립트의 경우 `===` 연산자를 통해 간단하게 확인할 수도 있고, 자바의 경우 `equals()`를 통해 객체의 값이 같은지 확인할 수도 있다.  \n\n파이썬에서는 **값(Value)을 비교하는 경우는 `==`를 사용**하고, **객체(Object)를 비교하는 경우는 `is`를 사용**한다. 예시를 통해 자세히 살펴보겠다.  \n\n\u003cbr\u003e\n\n- 값이 다르고, 객체도 다른 경우\n\n```python\na = 1\nb = 2\n\nif a == b:\n\tprint(\"a와 b의 값이 동일\")\nelse:\n\tprint(\"a와 b의 값이 다름\")\n\nif a is b:\n\tprint(\"a와 b의 객체 같음\")\nelse:\n\tprint(\"a와 b의 객체 다름\")\n\n출력결과 : a와 b의 값이 다름\n출력결과 : a와 b의 객체 다름\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n- 값이 똑같고, 객체도 같은 경우 (1)\n\n```python\na = 1\nb = 1\n\nif a == b:\n\tprint(\"a와 b의 값이 같음\")\nelse:\n\tprint(\"a와 b의 값이 다름\")\n\nif a is b:\n\tprint(\"a와 b의 객체 같음\")\nelse:\n\tprint(\"a와 b의 객체 다름\")\n\n출력결과 : a와 b의 값이 같음\n출력결과 : a와 b의 객체 같음\n```\n\n\u003cbr\u003e\u003cbr\u003e\n\n- 값이 똑같고, 객체도 같은 경우 (2)\n\n```python\na = [1, 2, 3]\nb = a\n\nif a == b:\n\tprint(\"a와 b의 값이 같음\")\nelse:\n\tprint(\"a와 b의 값이 다름\")\n\nif a is b:\n\tprint(\"a와 b의 객체 같음\")\nelse:\n\tprint(\"a와 b의 객체 다름\")\n\n출력결과 : a와 b의 값이 같음\n출력결과 : a와 b의 객체 같음\n```\n\n\u003cbr\u003e\n\n- **값은 같은데, 객체가 다른 경우**\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\n  \nif a == b:\n\tprint(\"a와 b의 값이 같음\")\nelse:\n\tprint(\"a와 b의 값이 다름\")\n\nif a is b:\n\tprint(\"a와 b의 객체 같음\")\nelse:\n\tprint(\"a와 b의 객체 다름\")\n\n출력결과 : a와 b의 값이 같음\n출력결과 : a와 b의 객체 다름\n```\n\n\u003chr\u003e\n\n## 02. 조건부 표현식 (삼항연산자)\n\n\u003cbr\u003e\n  \n삼항연산자는 조건문이 길어지는 것을 한 문장으로 줄여서 가독성이 좋고 편의상 사용하는 것을 뜻한다. 보통 다른 언어에서는 아래와 같은 형식을 지원한다.\n\n- `[condition] ? [true_value] : [false_value]`\n\n- 조건(condition)이 참이면 `:`의 왼쪽을 실행, 거짓이면 우측을 실행한다.  \n\n\u003cbr\u003e\n\n\n```c++\n#include \u003cstdio.h\u003e\n  \nint main()\n{\n\tint num1 = 5;\n\tint num2;\n\t\n\tnum2 = num1 ? 100 : 200;\n\t// num1이 참이면 num2에 100을 할당, 거짓이면 num2에 200을 할당\n\n\tprintf(\"%d\\n\", num2);\n\t// 100: num1이 5이므로 참. num2에는 100이 할당됨\n\t\n\treturn 0;\n}\n```\n\n\u003cbr\u003e  \n\n하지만, 파이썬에서는 위와 같은 형태를 지원하지 않는다.  \n\n- `[true_value] if [condition] else [false_value]`\n\n- 영어식 표현으로 조금 더 직관적으로 이해 가능하다.\n\n\u003cbr\u003e\n\n  \n\n```python\na = 10\nprint(\"짝수\") if a % 2 == 0 else print(\"홀수\")\n\n출력결과 : 짝수\n```\n\n\u003cbr\u003e\n\n```python\narr = [1, 30, 20, -10, 10, 0, 24, 60, 3, -29]\nmin_value = arr[0]\nmax_value = arr[0]\n  \nfor val in arr:\n\tmin_value = val if val \u003c min_value else min_value\n\tmax_value = val if val \u003e= max_value else max_value\n  \n\tprint(f\"min_value : {min_value}\")\n\tprint(f\"max_value : {max_value}\")\n\n출력결과 : min_value : -29\n출력결과 : max_value : 60\n```\n\n\u003cbr\u003e\n\n참고로, 삼항 연산자도 중첩하여 elif를 표현하는 것이 가능하기는 한데, 그냥 사용 안하는 것이 더 직관적이므로 조건이 늘어나면 그냥 if문을 사용하자.\n\n\u003chr\u003e\n\n## 03. 특이한 조건문  \n\n\u003cbr\u003e\n\n파이썬은 문자, 리스트를 다루는 것에 강점을 가진 언어이다 보니 특이한 조건문을 지원한다. 해당하는 값이 안에 존재하면 True 없다면 False를 반환해준다.\n\n\u003cbr\u003e\n\n| in | not in |\n| -- | -------|\n| x in 문자열 | x not in 문자열 |\n| x in 리스트 | x not in 리스트 |\n| x in 튜플 | x not in 튜플 |\n  \n\u003cbr\u003e\n\n```python\nprint(1 in [1, 2, 3])\n출력결과 : True\n  \nprint(1 not in [1, 2, 3])\n출력결과 : False\n```\n\n\u003cbr\u003e  \n\n```python\npocket = ['paper', 'cellphone', 'money']\n\nif 'money' in pocket:\n\tprint(\"택시를 타고 가라\")\nelse:\n\tprint(\"걸어가라\")  \n\n출력결과 : 택시를 타고 가라\n```\n\n\u003cbr\u003e\n\n- 조건문의 참과 거짓에 따라 아무것도 안하게 하려면 `pass`를 사용한다.\n\n```python\npocket = ['paper', 'cellphone', 'money']\nif 'money' in pocket:\n\tpass\nelse:\n\tprint(\"돈이 없으면 카드를 내야지\")\n\n출력결과 :\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Lecture/pl/funny-python/funny11":{"title":"11 - for문","content":"\n\u003e 해당 게시글은 \u003ca href='https://www.inflearn.com/course/python-crawling-basic' target='_blank'\u003e파이썬 입문과 크롤링기초 부트캠프\u003c/a\u003e 강의를 정리한 내용입니다.\n\n\u003chr\u003e\n\n## 01. for문 기본 구조\n\n- 리스트, 튜플, 문자열 이용\n\n```python\nfor 변수 in (리스트, 튜플, 문자열):\n\t실행문1\n\t실행문2\n\n\t...\n```\n\n\u003cbr\u003e\n\n- range() 이용\n\n```python\nfor 변수 in range(정수):\n\tprint(변수)\n```\n\n가장 기본적인 두 가지 구조이다. range()이용은 아래에서 다루도록 하고 다양한 예시를 통하는 것이 이해가 빨라서 여러 가지 예시를 들겠다.\n\n\u003cbr\u003e\n  \n- 리스트  \n\n```python\ntest_list = ['one', 'two', 'three']\n  \nfor i in test_list:\n\tprint(i)\n  \n[출력]\none\ntwo\nthree\n```\n\n\u003cbr\u003e\n\n- 튜플 응용  \n\n```python\na = [(1,2), (3,4), (5,6)]\n\nfor (first, last) in a:\n\tprint(first + last)\n\n[출력]\n3\n7\n11\n```\n\n\u003cbr\u003e  \n\n```python\nscore = [90, 25, 67, 45, 80]\nstudent_number = 0\n  \nfor i in score:\n\tstudent_number = student_number + 1\n\n\tif i \u003e= 60:\n\t\tprint(\"%d번 학생은 합격입니다.\" % student_number)\n\telse:\n\t\tprint(\"%d번 학생은 불합격입니다.\" % student_number)\n\n[출력]\n1번 학생은 합격입니다.\n2번 학생은 불합격입니다.\n3번 학생은 합격입니다.\n4번 학생은 불합격입니다.\n5번 학생은 합격입니다.\n```\n\n\u003cbr\u003e\n\n- continue 이용\n\n반복문 수행 도중 continue 만나면 그 즉시 다음 반복으로 진행한다. 아래의 예시에서 점수 변수 i가 60보다 작으면 조건이 참이니까 continue를 만나서 print()를 실행하지 않고 다음으로 넘어간다. 만약 60보다 크다면 조건문 입장에서는 거짓이니까 continue를 실행하지 않고 아래의 print()문을 실행하는 것이다.  \n\n```python\nscore = [90, 25, 67, 45, 80]\nstudent_number = 0\n  \nfor i in score:\n\tstudent_number = student_number + 1\n\tif i \u003c 60:\n\t\tcontinue\n\tprint(\"%d번 학생 축하합니다. 합격입니다. \" % student_number)\n```\n\n\u003chr\u003e\n\n## 02. for문과 range 함수  \n\nfor문을 쓸 때 리스트, 튜플, 문자열 외에도 간단히 숫자를 이용한 반복을 원할 때가 있다. 그때 사용하는 것이 `range()` 함수이다.\n\n- `range(10)`의 형태는 0 이상 10 미만의 숫자를 포함하는 range 객체 생성\n\n- `range(1,10)`의 형태는 1이상 10 미만의 숫자를 포함하는 range 객체 생성  \n\n```python\nsum = 0\n\nfor i in range(1, 11):\n\tsum = sum + i\n\tprint(sum)\n\n[출력]\n55\n```\n\n\u003cbr\u003e\n\n- 배열의 길이를 range()에 적용시킨 예제\n\n```python\nscore = [90, 25, 67, 45, 80]\nfor student_number in range(len(score)):\n\tif score[student_number] \u003c 60:\n\t\tcontinue\n\tprint(\"%d번 학생 축하합니다. 합격입니다.\" % (student_number + 1))\n```\n\u003cbr\u003e\n\n- range() 이용 구구단, 이중 for문\n\n`print('')` 공백 print()문 넣음으로 인해 줄바꿈 효과 넣은 것\n\n```python\nfor i in range(2,10): # ①번 for문\n\tfor j in range(1, 10): # ②번 for문\n\t\tprint(i * j, end=\" \")\n\tprint('')\n\n[출력]\n2 4 6 8 10 12 14 16 18\n3 6 9 12 15 18 21 24 27\n4 8 12 16 20 24 28 32 36\n5 10 15 20 25 30 35 40 45\n6 12 18 24 30 36 42 48 54\n7 14 21 28 35 42 49 56 63\n8 16 24 32 40 48 56 64 72\n9 18 27 36 45 54 63 72 81\n```\n\n\u003chr\u003e\n\n## 03. 리스트 안에 for문 넣기 (리스트 내포)\n  \n리스트 내포하는 방법은 `[표현식 for 항목 in 반복가능객체 if 조건문]` 이다. 조건이 필요하지 않다면 `if 조건문` 부분은 빼도 된다.\n\n\u003cbr\u003e  \n\n- 리스트 내포 전\n\n```python\na = [1, 2, 3, 4]\nresult = []\n\nfor num in a:\n\tresult.append(num * 3)\n\tprint(result)\n\n[출력]\n[3, 6, 9, 12]\n```\n\n\u003cbr\u003e  \n\n- 리스트 내포 후\n\n```python\na = [1, 2, 3, 4]\nresult = [num * 3 for num in a]\nprint(result)\n  \n[출력]\n[3, 6, 9, 12]\n```\n\n\u003cbr\u003e\n\n- 조건문 포함 리스트 내포\n\n```python\na = [1, 2, 3, 4]\nresult = [num * 3 for num in a if num % 2 == 0]\nprint(result)\n\n[출력]\n[6, 12]\n```\n\n\u003cbr\u003e\n\n- 리스트 내포 구구단 (이중 for문)\n\n```python\nresult = [x * y for x in range(2, 10)\n\t\t\t\tfor y in range(1, 10)]\nprint(result)\n\n[출력]\n\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45, 6, 12, 18, 24, 30, 36, 42, 48, 54, 7, 14, 21, 28, 35, 42, 49, 56, 63, 8, 16, 24, 32, 40, 48, 56, 64, 72, 9, 18, 27, 36, 45, 54, 63, 72, 81]\n```","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/brain/Spring/":{"title":"Spring","content":"","lastmodified":"2024-12-05T16:13:38.262758333Z","tags":null},"/project":{"title":"Project","content":"","lastmodified":"2024-12-05T16:13:39.266750681Z","tags":null}}