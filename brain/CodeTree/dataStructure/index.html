<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="단편적 지식을 통합된 지식으로"><meta property="og:type" content="website"><meta property="og:url" content="https://shin-jae-yoon.github.io/"><meta property="og:site_name" content="개발자 유니의 두 번째 뇌"><meta property="og:title" content="개발자 유니의 두 번째 뇌"><meta property="og:description" content="단편적 지식을 통합된 지식으로"><meta property="og:image" content="https://img1.daumcdn.net/thumb/C428x428/?scode=mtistory2&fname=https%3A%2F%2Ftistory4.daumcdn.net%2Ftistory%2F5252507%2Fattach%2F9c3ad58fd9d24ab486b8a4258ba525d2"><meta property="og:article:author" content="유니"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@TISTORY"><meta property="twitter:title" content="개발자 유니의 두 번째 뇌"><meta property="twitter:description" content="단편적 지식을 통합된 지식으로"><meta property="twitter:image" content="https://img1.daumcdn.net/thumb/C428x428/?scode=mtistory2&fname=https%3A%2F%2Ftistory4.daumcdn.net%2Ftistory%2F5252507%2Fattach%2F9c3ad58fd9d24ab486b8a4258ba525d2"><meta name=naver-site-verification content="9e162597b5777707f80d8478ef502c5224430d43"><script async src="https://www.googletagmanager.com/gtag/js?id=G-GJFBQJ80N7"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GJFBQJ80N7")</script><title>개발자 유니의 두 번째 뇌</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://shin-jae-yoon.github.io//icon.png><link href=https://shin-jae-yoon.github.io/styles.0de16cd5483778b95b7a8ffc234050e2.min.css rel=stylesheet><link href=https://shin-jae-yoon.github.io/styles/_light_syntax.b3cdc1af6c90d5fc7e05ca6e6e6f3e60.min.css rel=stylesheet id=theme-link><script src=https://shin-jae-yoon.github.io/js/util.9f16e8e6e851e38941fee1829bbdba7e.min.js></script>
<script src=https://shin-jae-yoon.github.io/js/scroll.52aeab67b8d227b2efd1fac96d97bde6.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script async src=https://shin-jae-yoon.github.io/js/popover.3dd93e9b8018c80d1f4559116da09618.min.js></script>
<script defer src=https://shin-jae-yoon.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://shin-jae-yoon.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://shin-jae-yoon.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://shin-jae-yoon.github.io/",fetchData=Promise.all([fetch("https://shin-jae-yoon.github.io/indices/linkIndex.aeefdafcb37bd6688fd9106c330da876.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://shin-jae-yoon.github.io/indices/contentIndex.6605bb5cf80b3e79760f3dfef3001597.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const t=new URL(BASE_URL),n=t.pathname+"brain/",s=window.location.pathname,e=n==s;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://shin-jae-yoon.github.io",!0);const o=document.getElementById("footer");if(o){const t=document.getElementById("graph-container");if(!t)return requestAnimationFrame(render);t.textContent="";const n=e&&!0;drawGraph("https://shin-jae-yoon.github.io",n,[{"/moc":"#4388cc"}],n?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:.07,scale:.6}:{centerForce:5,depth:2,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:2.5,repelForce:1,scale:1.5})}const i=document.getElementById("footer2");if(i){const t=document.getElementById("graph-container2");if(!t)return requestAnimationFrame(render);t.textContent="";const n=e&&!0;drawGraph2("https://shin-jae-yoon.github.io",n,[{"/moc":"#4388cc"}],n?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:.07,scale:.6}:{centerForce:5,depth:2,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:2.5,repelForce:1,scale:1.5})}var a=document.getElementsByClassName("mermaid");a.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/shin-jae-yoon.github.io\/js\/router.e4f749984b89f35680b8cfadddf2b482.min.js"
    attachSPARouting(init, render)
  </script><script src=https://kit.fontawesome.com/1f943b0307.js crossorigin=anonymous></script>
<link href=https://webfontworld.github.io/BMJua/BMJua.css rel=stylesheet><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@300;400;700&display=swap" rel=stylesheet></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder=" 검색어를 입력하세요 "><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://shin-jae-yoon.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=nav-header-container><header><h1 id=page-title><a href=https://shin-jae-yoon.github.io/>Dev Uni</a></h1><li><a href=https://shin-jae-yoon.github.io/>Home</a></li><li><a href=https://shin-jae-yoon.github.io/about/>About</a></li><li><a href=https://shin-jae-yoon.github.io/brain/ id=brainHeader>Brain</a></li><li><a href=https://shin-jae-yoon.github.io/project/>Project</a></li><div id=search-icon><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg><p>Search<span style=vertical-align:middle;margin-left:1em>⌘</span> + k</p></div></ul></header></div><script>document.getElementById("brainHeader").addEventListener("click",e=>{window.Million.navigate()})</script><div class=singlePage style=padding:0;margin:0;width:100%><div class=blur-element></div><div class="section-container single-container"><div class=expand-graph-container id=footer2><i class="fa-solid fa-x" id=expand-close-btn></i><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><div id=graph-container2></div><style>:root{--g-node:var(--graphNode);--g-node-active:var(--graphNodeActive);--g-node-inactive:var(--graphNodeInactive);--g-link:var(--graphLink);--g-link-active:var(--graphLinkActive)}</style><script src=https://shin-jae-yoon.github.io/js/graph.c7d31393238aa9f7cc8094b9bcd520cf.js></script></div></div><div class=section-menu-btn><i class="fa-solid fa-bars"></i></div><div class="main-aside-box disabled"><aside class=main-aside><div class=menu-nav-header><li><a href=https://shin-jae-yoon.github.io/>Home</a></li><li><a href=https://shin-jae-yoon.github.io/about/>About</a></li><li><a href=https://shin-jae-yoon.github.io/project/>Project</a></li></div><div class=menu-content-header><a class=menu-content-header-btn href=https://shin-jae-yoon.github.io/brain/>📚 Brain</a>
<button class=collapse-btn><i class="fa-solid fa-arrow-down-up-across-line"></i></button></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Java</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Design Pattern</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Creational</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Structural</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Behavioral</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li></ul></li><li><div class=wrapper-link><a href=/brain/Java/Java/ class=page-link style=display:block;width:100%>Java 특징</a></div></li><li><div class=wrapper-link><a href=/brain/Java/JavaVersion/ class=page-link style=display:block;width:100%>Java 버전별 특징</a></div></li><li><div class=wrapper-link><a href=/brain/Java/java-settings/ class=page-link style=display:block;width:100%>Java 환경설정</a></div></li><li><div class=wrapper-link><a href=/brain/Java/JavaExecute/ class=page-link style=display:block;width:100%>Java 실행원리</a></div></li><li><div class=wrapper-link><a href=/brain/Java/JVM/ class=page-link style=display:block;width:100%>Java Virtual Machine</a></div></li><li><div class=wrapper-link><a href=/brain/Java/GC/ class=page-link style=display:block;width:100%>Garbage Collector</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Spring</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Database</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Infra</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Common</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Common/API/ class=page-link style=display:block;width:100%>API</a></div></li><li><div class=wrapper-link><a href=/brain/Common/RESTAPI/ class=page-link style=display:block;width:100%>REST API</a></div></li><li><div class=wrapper-link><a href=/brain/Common/RESTfulAPI/ class=page-link style=display:block;width:100%>RESTful API</a></div></li><li><div class=wrapper-link><a href=/brain/Common/Library/ class=page-link style=display:block;width:100%>라이브러리</a></div></li><li><div class=wrapper-link><a href=/brain/Common/Framework/ class=page-link style=display:block;width:100%>프레임워크</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Computer Science</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Algorithm</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Principle</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/Algo/principle/divideConquer/ class=page-link style=display:block;width:100%>분할 정복</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/principle/binarySearch/ class=page-link style=display:block;width:100%>이진 탐색</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Sorting</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Comparison</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/comparison/bubbleSort/ class=page-link style=display:block;width:100%>버블 정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/comparison/selectSort/ class=page-link style=display:block;width:100%>선택 정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/comparison/insertSort/ class=page-link style=display:block;width:100%>삽입 정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/comparison/mergeSort/ class=page-link style=display:block;width:100%>합병 정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/comparison/quickSort/ class=page-link style=display:block;width:100%>퀵 정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/comparison/heapSort/ class=page-link style=display:block;width:100%>힙 정렬</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Non-Comparison</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/noncomparison/radixSort/ class=page-link style=display:block;width:100%>기수 정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/noncomparison/countingSort/ class=page-link style=display:block;width:100%>계수 정렬</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>분류 방법</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/etcsort/comparisonSort/ class=page-link style=display:block;width:100%>비교정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/etcsort/noncomparisonSort/ class=page-link style=display:block;width:100%>비교하지 않는 정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/etcsort/stableSort/ class=page-link style=display:block;width:100%>안정정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/etcsort/unstableSort/ class=page-link style=display:block;width:100%>불안정정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/etcsort/internalSort/ class=page-link style=display:block;width:100%>내부 정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/etcsort/externalSort/ class=page-link style=display:block;width:100%>외부 정렬</a></div></li><li><div class=wrapper-link><a href=/brain/CS/Algo/sort/etcsort/inplaceSort/ class=page-link style=display:block;width:100%>제자리 정렬</a></div></li></ul></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Data Structure</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/DS/stack/ class=page-link style=display:block;width:100%>Stack</a></div></li><li><div class=wrapper-link><a href=/brain/CS/DS/queue/ class=page-link style=display:block;width:100%>Queue</a></div></li><li><div class=wrapper-link><a href=/brain/CS/DS/bst/ class=page-link style=display:block;width:100%>Binary Search Tree</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Network</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/Network/Socket/ class=page-link style=display:block;width:100%>소켓</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Computer Architecture</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/CA/ComputerArchitecture/ class=page-link style=display:block;width:100%>컴퓨터구조</a></div></li><li><div class=wrapper-link><a href=/brain/CS/CA/CpuArchitecture/ class=page-link style=display:block;width:100%>CPU 아키텍처</a></div></li><li><div class=wrapper-link><a href=/brain/CS/CA/ISA/ class=page-link style=display:block;width:100%>ISA</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Operating System</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/OS/Scheduling/ class=page-link style=display:block;width:100%>스케줄링</a></div></li><li><div class=wrapper-link><a href=/brain/CS/OS/SystemCall/ class=page-link style=display:block;width:100%>시스템콜</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Language Theory</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/LT/LanguageTheory/ class=page-link style=display:block;width:100%>프로그래밍 언어론</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/BNF/ class=page-link style=display:block;width:100%>BNF</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/EBNF/ class=page-link style=display:block;width:100%>EBNF</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/Lex/ class=page-link style=display:block;width:100%>Lex</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/Yacc/ class=page-link style=display:block;width:100%>Yacc</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/SyntaxTable/ class=page-link style=display:block;width:100%>구문도표</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/Interpreter/ class=page-link style=display:block;width:100%>인터프리터</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/Compile/ class=page-link style=display:block;width:100%>컴파일</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/Compiler/ class=page-link style=display:block;width:100%>컴파일러</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/ParseTree/ class=page-link style=display:block;width:100%>파스 트리</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Interview</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>개발바닥 면접스터디</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-study/ class=page-link style=display:block;width:100%>개발바닥 면접스터디</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week01/ class=page-link style=display:block;width:100%>1주차 - 불변객체, Exception</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week02/ class=page-link style=display:block;width:100%>2주차 - Exception Handling</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week03/ class=page-link style=display:block;width:100%>3주차 - Spring 기본</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week04/ class=page-link style=display:block;width:100%>4주차 - Spring 웹</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week05/ class=page-link style=display:block;width:100%>5주차 - Spring 응용</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week06/ class=page-link style=display:block;width:100%>6주차 - Spring Data</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week07/ class=page-link style=display:block;width:100%>7주차 - Spring 트랜잭션</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week08/ class=page-link style=display:block;width:100%>8주차 - Spring JPA</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week09/ class=page-link style=display:block;width:100%>9주차 - Spring 심화</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>기술면접 대비</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Interview/iv/java/ class=page-link style=display:block;width:100%>면접 - Java</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/iv/spring/ class=page-link style=display:block;width:100%>면접 - Spring</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/iv/db/ class=page-link style=display:block;width:100%>면접 - 데이터베이스</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/iv/dsAlgo/ class=page-link style=display:block;width:100%>면접 - 자료구조/알고리즘</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/iv/network/ class=page-link style=display:block;width:100%>면접 - 네트워크</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/iv/os/ class=page-link style=display:block;width:100%>면접 - 운영체제</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/iv/web/ class=page-link style=display:block;width:100%>면접 - 웹/공통</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>강의</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Algorithm</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>패캠 - 알고리즘</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Part 1 - Part 4</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch00/ class=page-link style=display:block;width:100%>Part1 - Part4 강의소개</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch01/ class=page-link style=display:block;width:100%>Ch01 - 문자열</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch02/ class=page-link style=display:block;width:100%>Ch02 - 시간복잡도</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch03/ class=page-link style=display:block;width:100%>Ch03 - 배열</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part1-4/p1-ch04/ class=page-link style=display:block;width:100%>Ch04 - 완탐/시뮬</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Part 5 - 단기완성</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part5/p5-ch00/ class=page-link style=display:block;width:100%>Part5 - 단기완성</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part5/p5-ch01/ class=page-link style=display:block;width:100%>Ch01 - 완전탐색</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part5/p5-ch02/ class=page-link style=display:block;width:100%>Ch02 - 정렬</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Part 6 - SQL</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part6/p6-ch00/ class=page-link style=display:block;width:100%>Part6 - SQL 코테</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part6/p6-ch01/ class=page-link style=display:block;width:100%>SQL코테 - 문법설명</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/algo/fastcampus-algo/part6/p6-ch02/ class=page-link style=display:block;width:100%>SQL코테 - 문제풀이</a></div></li></ul></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Backend</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>김영한 - Spring</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>스프링 입문</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/spring-intro/spring-basic/ class=page-link style=display:block;width:100%>스프링 입문 - 목차</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/spring-intro/spring-basic-01/ class=page-link style=display:block;width:100%>섹션0 - 섹션3</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/spring-intro/spring-basic-02/ class=page-link style=display:block;width:100%>섹션4 - 섹션8</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>HTTP 웹</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/http/section00/ class=page-link style=display:block;width:100%>HTTP 강좌 - 소개</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/http/section01/ class=page-link style=display:block;width:100%>인터넷 네트워크</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/http/section02/ class=page-link style=display:block;width:100%>URI & Web</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/http/section03/ class=page-link style=display:block;width:100%>HTTP 기본</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/http/section04/ class=page-link style=display:block;width:100%>HTTP 메서드</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/http/section05/ class=page-link style=display:block;width:100%>HTTP 메서드 활용</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/http/section06/ class=page-link style=display:block;width:100%>HTTP 상태코드</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/http/section07/ class=page-link style=display:block;width:100%>HTTP 헤더 - 일반</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/backend/kim-spring/http/section08/ class=page-link style=display:block;width:100%>HTTP 헤더 - 캐시</a></div></li></ul></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Database</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Hussein DB</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/db/hussein-db/lecture00/ class=page-link style=display:block;width:100%>강의소개</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/hussein-db/lecture01/ class=page-link style=display:block;width:100%>01. ACID</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>쉬운코드 DB</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture00/ class=page-link style=display:block;width:100%>강의소개</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture01/ class=page-link style=display:block;width:100%>01. DB 개론</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture02/ class=page-link style=display:block;width:100%>02. RDBMS</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture03/ class=page-link style=display:block;width:100%>03. DB/table 생성</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture04/ class=page-link style=display:block;width:100%>04. Data 추가/수정/삭제</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture05/ class=page-link style=display:block;width:100%>05. Data 조회</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture06/ class=page-link style=display:block;width:100%>06. 서브쿼리</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture07/ class=page-link style=display:block;width:100%>07. three-valued logic</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture08/ class=page-link style=display:block;width:100%>08. Join</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture09/ class=page-link style=display:block;width:100%>09. 통계함수</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture10/ class=page-link style=display:block;width:100%>10. stored function</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture11/ class=page-link style=display:block;width:100%>11. stored procedure</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture12/ class=page-link style=display:block;width:100%>12. 실무에서 프로시저</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture13/ class=page-link style=display:block;width:100%>13. trigger</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture14/ class=page-link style=display:block;width:100%>14. transaction</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/db/easy-db/lecture15/ class=page-link style=display:block;width:100%>15. 동시성 제어 1부</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Data Structure</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>쉬운코드 자료구조</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/dataStructure/easy-ds/lecture00/ class=page-link style=display:block;width:100%>강의소개</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/dataStructure/easy-ds/lecture07/ class=page-link style=display:block;width:100%>07. 트리, 이진트리</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/dataStructure/easy-ds/lecture08/ class=page-link style=display:block;width:100%>08. 이진탐색트리 BST</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/dataStructure/easy-ds/lecture09/ class=page-link style=display:block;width:100%>09. AVL 트리</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Frontend</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>코딩애플 - HTML/CSS</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/frontend/apple-html/all-in-one/ class=page-link style=display:block;width:100%>All-in-One 강의노트</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/frontend/apple-html/all-in-one-basic/ class=page-link style=display:block;width:100%>All-in-One 기초모듈</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/frontend/apple-html/all-in-one-mid/ class=page-link style=display:block;width:100%>All-in-One 중급모듈</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/frontend/apple-html/all-in-one-last/ class=page-link style=display:block;width:100%>All-in-One 고급모듈</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>코딩애플 - JavaScript</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/frontend/apple-js/apple-js/ class=page-link style=display:block;width:100%>Javascript 입문과 웹 UI 개발</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/frontend/apple-js/apple-js-01/ class=page-link style=display:block;width:100%>LEVEL 01</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/frontend/apple-js/apple-js-02/ class=page-link style=display:block;width:100%>LEVEL 02</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/frontend/apple-js/apple-js-03/ class=page-link style=display:block;width:100%>LEVEL 03</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/frontend/apple-js/js-library/ class=page-link style=display:block;width:100%>js-library</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Network</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>널널한개발자</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>네트워크 핵심 - 기초</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/network/free-dev/network-basic/intro/ class=page-link style=display:block;width:100%>네트워크 기초</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/network/free-dev/network-basic/section0/ class=page-link style=display:block;width:100%>section 0 - intro</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/network/free-dev/network-basic/section1/ class=page-link style=display:block;width:100%>section 1 - network</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/network/free-dev/network-basic/section2/ class=page-link style=display:block;width:100%>section 2 - L2</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/network/free-dev/network-basic/section3/ class=page-link style=display:block;width:100%>section 3 - L3</a></div></li></ul></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Operating System</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>쉬운코드 OS</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/os/easy-os/lecture00/ class=page-link style=display:block;width:100%>강의소개</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/os/easy-os/lecture01/ class=page-link style=display:block;width:100%>01. 프로세스/스레드</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/os/easy-os/lecture02/ class=page-link style=display:block;width:100%>02. 컨택스트 스위칭</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/os/easy-os/lecture03/ class=page-link style=display:block;width:100%>03. CPU/IO bound</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Programming Language</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>부부개발단 - Java</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java/ class=page-link style=display:block;width:100%>개요. 즐거운 자바</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java01/ class=page-link style=display:block;width:100%>01. Java 시작</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java02/ class=page-link style=display:block;width:100%>02. Java 기본 문법</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java03/ class=page-link style=display:block;width:100%>03. 객체지향 1/3</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java04/ class=page-link style=display:block;width:100%>04. 객체지향 2/3</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java05/ class=page-link style=display:block;width:100%>05. 객체지향 3/3</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java06/ class=page-link style=display:block;width:100%>06. 배열과 Arrays 클래스</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java07/ class=page-link style=display:block;width:100%>07. 제네릭과 컬렉션</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java08/ class=page-link style=display:block;width:100%>08. 예외처리, enum</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java09/ class=page-link style=display:block;width:100%>09. Java I/O</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java10/ class=page-link style=display:block;width:100%>10. Java Thread</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/fun-java/fun-java11/ class=page-link style=display:block;width:100%>11. Java Network</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>잔재미코딩 - Python</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny/ class=page-link style=display:block;width:100%>파이썬 입문</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny01/ class=page-link style=display:block;width:100%>01 - 파이썬 입문</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny02/ class=page-link style=display:block;width:100%>02 - 변수,출력</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny03/ class=page-link style=display:block;width:100%>03 - String</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny04/ class=page-link style=display:block;width:100%>04 - List</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny05/ class=page-link style=display:block;width:100%>05 - Tuple</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny06/ class=page-link style=display:block;width:100%>06 - Dictionary</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny07/ class=page-link style=display:block;width:100%>07 - Set</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny08/ class=page-link style=display:block;width:100%>08 - Bool</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny09/ class=page-link style=display:block;width:100%>09 - 변수심화</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny10/ class=page-link style=display:block;width:100%>10 - Condition</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/pl/funny-python/funny11/ class=page-link style=display:block;width:100%>11 - for문</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>ETC</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>코딩애플 - Git</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/etc/apple-git/apple-git/ class=page-link style=display:block;width:100%>코딩애플 git</a></div></li></ul></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>도서</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Do it! 자바 프로그래밍</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Book/do-it-java/do-it-java/ class=page-link style=display:block;width:100%>Do it! 자바 프로그래밍 입문</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap01/ class=page-link style=display:block;width:100%>01.자바 프로그래밍</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap02/ class=page-link style=display:block;width:100%>02.변수와 자료형</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap03/ class=page-link style=display:block;width:100%>03.자바의 연산자</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap04/ class=page-link style=display:block;width:100%>04.제어문</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap05/ class=page-link style=display:block;width:100%>05.클래스와 객체 (1)</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap06/ class=page-link style=display:block;width:100%>06.클래스와 객체 (2)</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap07/ class=page-link style=display:block;width:100%>07.배열과 ArrayList</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap08/ class=page-link style=display:block;width:100%>08.상속과 다형성</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap09/ class=page-link style=display:block;width:100%>09.추상 클래스</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap10/ class=page-link style=display:block;width:100%>10.인터페이스</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>헤드퍼스트 디자인패턴</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Book/headfirst/headfirst/ class=page-link style=display:block;width:100%>헤드퍼스트 디자인패턴</a></div></li><li><div class=wrapper-link><a href=/brain/Book/headfirst/chap01/ class=page-link style=display:block;width:100%>01. 소개와 전략패턴</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>운영체제 - 공룡책</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Book/dinosaur/dinosaur/ class=page-link style=display:block;width:100%>운영체제 -공룡책</a></div></li><li><div class=wrapper-link><a href=/brain/Book/dinosaur/chap01/ class=page-link style=display:block;width:100%>01. 서론</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>데브코스</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/DevCourse/001/ class=page-link style=display:block;width:100%>[1주차] 2023-06-02</a></div></li><li><div class=wrapper-link><a href=/brain/DevCourse/002/ class=page-link style=display:block;width:100%>[2주차] 2023-06-05</a></div></li><li><div class=wrapper-link><a href=/brain/DevCourse/003/ class=page-link style=display:block;width:100%>[2주차] 2023-06-06</a></div></li><li><div class=wrapper-link><a href=/brain/DevCourse/004/ class=page-link style=display:block;width:100%>[2주차] 2023-06-07</a></div></li><li><div class=wrapper-link><a href=/brain/DevCourse/005/ class=page-link style=display:block;width:100%>[2주차] 2023-06-08</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>코드트리</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CodeTree/basic/ class=page-link style=display:block;width:100%>개요</a></div></li><li><div class=wrapper-link><a href=/brain/CodeTree/inputoutput/ class=page-link style=display:block;width:100%>입출력</a></div></li><li><div class=wrapper-link><a href=/brain/CodeTree/math/ class=page-link style=display:block;width:100%>수학</a></div></li><li><div class=wrapper-link><a href=/brain/CodeTree/string/ class=page-link style=display:block;width:100%>문자열</a></div></li><li><div class=wrapper-link><a href=/brain/CodeTree/dataStructure/ class=page-link style=display:block;width:100%>자료구조</a></div></li><li><div class=wrapper-link><a href=/brain/CodeTree/dp/ class=page-link style=display:block;width:100%>DP</a></div></li><li><div class=wrapper-link><a href=/brain/CodeTree/graph/ class=page-link style=display:block;width:100%>그래프 탐색</a></div></li><li><div class=wrapper-link><a href=/brain/CodeTree/binarySearch/ class=page-link style=display:block;width:100%>이진탐색</a></div></li></ul></li></ul></aside><script src=https://shin-jae-yoon.github.io/js/menu.d84e1187b49e17fe6a272092d9397aba.js></script></div><div class=single-content><h1>자료구조</h1><p class=meta>Last updated -
2024년 12월 06일
<a href=https://github.com/Shin-Jae-Yoon/Shin-Jae-Yoon.github.io/tree/hugo/content/brain/CodeTree/dataStructure.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>ON THIS PAGE</summary><nav id=TableOfContents><ul><li><a href=#arraylist>ArrayList</a></li><li><a href=#linkedlist>LinkedList</a><ul><li><a href=#single-linked-list>Single Linked List</a></li><li><a href=#double-linked-list>Double Linked List</a></li><li><a href=#iterator>Iterator</a></li><li><a href=#circular-linked-list>Circular Linked List</a></li></ul></li><li><a href=#stack>Stack</a></li><li><a href=#queue>Queue</a></li><li><a href=#deque>Deque</a></li><li><a href=#vector-stack-권장하지-않는-이유>Vector, Stack 권장하지 않는 이유</a></li><li><a href=#tree>Tree</a><ul><li><a href=#binary-tree>Binary Tree</a></li><li><a href=#binary-search-tree>Binary Search Tree</a></li><li><a href=#heap>Heap</a></li></ul></li><li><a href=#hasing>Hasing</a><ul><li><a href=#hash-collision>Hash collision</a></li><li><a href=#java-hash-collision>Java Hash collision</a></li><li><a href=#hashmap>HashMap</a></li></ul></li></ul></nav></details></aside><p>코드트리(Codetree)의 <a href=https://www.codetree.ai/curriculums/6 target=_blank>Novice High - 자료구조 알고리즘</a>을 정리한 내용입니다.</p><ul><li>그림은 해당 내용을 참고하여 그렸습니다.</li></ul><hr><a href=#arraylist><h2 id=arraylist><span class=hanchor arialabel=Anchor># </span>ArrayList</h2></a><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.ArrayList</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Main</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>정적 배열과는 다르게, 가변적인 배열인 ArrayList (동적 배열)</li><li><code>add(E)</code> : 맨 뒤에 데이터 E를 추가</li><li><code>remove(index)</code> : index 위치에 있는 원소 삭제</li><li><code>size()</code> : ArrayList에 들어있는 데이터 수 반환</li><li><code>get(index)</code> : index 위치에 있는 원소 반환</li><li>삽입, 삭제, 탐색 시간 복잡도는 정적 배열과 동일<ul><li>삽입 : <mark><strong>$O(N)$</strong></mark></li><li>삭제 : <mark><strong>$O(N)$</strong></mark></li><li>탐색 : <mark><strong>$O(1)$</strong></mark><ul><li>Index 기반 <mark><strong>$O(1)$</strong></mark></li><li>Data 기반 <mark><strong>$O(N)$</strong></mark></li></ul></li></ul></li></ul><blockquote class=note-callout><p><strong>정적 배열 시간복잡도 (동적 배열과 동일)</strong></p><p></p><ul><li>삽입 : <mark><strong>$O(N)$</strong></mark></li><li>삭제 : <mark><strong>$O(N)$</strong></mark></li><li>탐색 : <mark><strong>$O(1)$</strong></mark></li><li>Index 기반으로 접근할 시 원하는 원소에 바로 접근할 수 있기 때문에 <mark><strong>$O(1)$</strong></mark></li><li>Data 기반으로 접근할 시 조건에 만족하는 Data를 찾지 못한다면 모든 원소를 한번씩 탐색해야 하기 때문에 <mark><strong>$O(N)$</strong></mark></li></ul></blockquote><br><hr><a href=#linkedlist><h2 id=linkedlist><span class=hanchor arialabel=Anchor># </span>LinkedList</h2></a><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.LinkedList</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Main</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>ll</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>addFirst(E)</code> : 맨 앞에 데이터 E 추가</li><li><code>addLast(E)</code> : 맨 뒤에 데이터 E 추가</li><li><code>pollFirst()</code> : 맨 앞에 데이터 반환하면서 리스트에서 제거</li><li><code>pollLast()</code> 맨 뒤에 데이터 반환하면서 리스트에서 제거</li><li><code>size()</code> : 데이터 수 반환</li><li><code>isEmpty()</code> : list 비어있으면 true, 아니면 false</li><li><code>peekFirst()</code> : 맨 앞에 데이터 반환</li><li><code>peekLast()</code> : 맨 뒤에 데이터 반환</li></ul><br><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-35.png width=auto alt></p><ul><li>하나의 Node는 Data와 다른 Node로 이동하는 경로를 가지고 있음</li><li>배열과는 다르게 삽입과 삭제가 자주 일어나는 상황에 용이<ul><li>삽입 : <mark><strong>$O(1)$</strong></mark></li><li>삭제 : <mark><strong>$O(1)$</strong></mark></li><li>탐색 : <mark><strong>$O(N)$</strong></mark></li></ul></li><li><a href=/brain/CodingTest/dataStructure/#single-linked-list>단일 연결리스트 (Single Linked List)</a></li><li><a href=/brain/CodingTest/dataStructure/#double-linked-list>이중 연결리스트 (Double Linked List)</a></li></ul><br><a href=#single-linked-list><h3 id=single-linked-list><span class=hanchor arialabel=Anchor># </span>Single Linked List</h3></a><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-36.png width=auto alt></p><ul><li>연결 방향이 단방향</li><li>next에 null이 있으면 연결이 끊어진 상태<ul><li>즉, 이는 노드를 삭제하는 과정에서 유용함</li></ul></li><li><mark><code>head</code> : 리스트가 시작되는 지점</mark><ul><li>ex) 리스트의 모든 값을 탐색해야 하는 상황에 시작점을 모르면 모든 값을 탐색했는지 판단할 수 없으니까 head가 필요한 것</li></ul></li><li><mark><code>tail</code> : 리스트가 종료되는 지점</mark><ul><li>ex) 종료 지점을 명시해놓으면 탐색할 때 추가적인 처리 없이 현재 방문한 노드가 종료 지점인지 판단하는 과정만 거치고 탐색을 종료할 수 있음</li></ul></li><li>단일 연결리스트는 head → tail 단방향으로, tail에 도달하면 다시 뒤로 돌아갈 수 없음</li><li>시간 복잡도<ul><li>삽입 : <mark><strong>$O(1)$</strong></mark></li><li>삭제 : <mark><strong>$O(1)$</strong></mark></li><li>탐색 : <mark><strong>$O(N)$</strong></mark><ul><li>탐색은 Head부터 Tail까지 일일이 확인해야함</li></ul></li></ul></li></ul><br><p><mark><strong>단일 연결리스트 tail 뒤에 신규 노드 삽입</strong></mark></p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-37.png width=auto alt></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function SLL.insert_end(num)
</span></span><span class=line><span class=cl>  set new_node = node(num)       # Step 1. 노드 만들기
</span></span><span class=line><span class=cl>  SLL.tail.next = new_node       # Step 2. 이어 붙이기
</span></span><span class=line><span class=cl>  SLL.tail = new_node            # Step 3. Tail 변경하기
</span></span></code></pre></td></tr></table></div></div><br><p><mark><strong>단일 연결리스트 head 앞에 신규 노드 삽입</strong></mark></p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-38.png width=auto alt></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function SLL.insert_front(num)
</span></span><span class=line><span class=cl>  set new_node = node(num)       # Step 1. 노드 만들기
</span></span><span class=line><span class=cl>  new_node.next = SLL.head       # Step 2. 이어 붙이기
</span></span><span class=line><span class=cl>  SLL.head = new_node            # Step 3. Head 변경하기
</span></span></code></pre></td></tr></table></div></div><br><p><mark><strong>단일 연결리스트 head 뒤에 신규 노드 삽입</strong></mark></p><ul><li>head 바로 뒤에 노드를 추가하는 것은 조금 복잡함</li><li>연결을 아무 생각 없이 끊어버리게 되면 예상치 못한 결과가 나올 수 있어서</li></ul><ol><li><p>새로운 노드 생성</p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-34.png width=auto alt></p></li></ol><br><ol start=2><li><p>새로운 노드의 next 값을 head의 next 값으로 설정</p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-33.png width=auto alt></p></li></ol><br><ol start=3><li><p>head의 next 값을 새로운 노드로 변경</p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-32.png width=auto alt></p></li></ol><br><ol start=4><li><p>최종</p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-31.png width=auto alt></p></li></ol><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function SLL.insert_after_head(num)
</span></span><span class=line><span class=cl>  set new_node = node(num)            # Step 1. 노드 만들기
</span></span><span class=line><span class=cl>  new_node.next = SLL.head.next       # Step 2. 새로운 노드의 next 값 변경
</span></span><span class=line><span class=cl>  SLL.head.next = new_node            # Step 3. Head의 next 값 변경
</span></span></code></pre></td></tr></table></div></div><br><p><mark><strong>단일 연결리스트 삭제</strong></mark></p><ul><li>삭제하게 되는 노드의 <mark><strong>바로 전 노드</strong></mark>에서 그 다음 노드로 연결관계를 바꿔줘야 한다는 것</li><li>ex) tail을 삭제하는 과정<ul><li>tail 바로 전 노드의 next 값을 null로 변경</li><li>tail을 그 전으로 옮기기</li></ul></li></ul><br><p><mark><strong>단일 연결리스트 tail 삭제</strong></mark></p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-30.png width=auto alt></p><ul><li>tail 바로 전 노드의 next 값 → null로 변경</li><li>tail 옮기기</li></ul><br><p><mark><strong>단일 연결리스트 head 삭제</strong></mark></p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-29.png width=auto alt></p><ul><li>head의 값을 head.next로 지정</li><li>실제로 값을 삭제하지는 않았지만, 노드가 정상적으로 삭제된 것처럼 보임</li></ul><p><br><br></p><a href=#double-linked-list><h3 id=double-linked-list><span class=hanchor arialabel=Anchor># </span>Double Linked List</h3></a><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-28.png width=auto alt></p><ul><li>연결 방향이 양방향</li><li>삽입/삭제 시 앞/뒤 연결 모두 변경해야함</li></ul><br><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-27.png width=auto alt></p><p><br><br></p><a href=#iterator><h3 id=iterator><span class=hanchor arialabel=Anchor># </span>Iterator</h3></a><ul><li>Iterator(반복자)는 연결리스트 내의 노드를 가리키는 역할</li><li>Iterator를 이용해 prev, next 값을 활용하여 특정 위치를 지정할 수 있음</li><li>최초에 k번째 위치 찾는건 <mark><strong>$O(N)$</strong></mark> 이후 바로 옆에 삽입/삭제/탐색은 <mark><strong>$O(1)$</strong></mark></li></ul><br><ol><li><mark><code>hasNext()</code> 순회</mark></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.LinkedList</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.ListIterator</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Main</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedList</span><span class=o>&lt;</span><span class=n>Character</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span> 
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=sc>&#39;a&#39;</span><span class=o>);</span>             <span class=c1>// l : [&#39;a&#39;]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>l</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=sc>&#39;b&#39;</span><span class=o>);</span>             <span class=c1>// l : [&#39;a&#39;, &#39;b&#39;]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>l</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=sc>&#39;c&#39;</span><span class=o>);</span>             <span class=c1>// l : [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=c1>// Iterator를 이용한 list 내의 원소들 순회 (맨 앞에서 시작)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ListIterator</span><span class=o>&lt;</span><span class=n>Character</span><span class=o>&gt;</span> <span class=n>it</span> <span class=o>=</span> <span class=n>l</span><span class=o>.</span><span class=na>listIterator</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>hasNext</span><span class=o>())</span>               <span class=c1>// &#39;a&#39; &#39;b&#39; &#39;c&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>next</span><span class=o>());</span>  <span class=c1>// next는 뒤로 이동하면서 값을 반환
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><ol start=2><li><mark><code>hasPrevious()</code> 순회</mark></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.LinkedList</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.ListIterator</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Main</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedList</span><span class=o>&lt;</span><span class=n>Character</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=sc>&#39;a&#39;</span><span class=o>);</span>             <span class=c1>// l : [&#39;a&#39;]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>l</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=sc>&#39;b&#39;</span><span class=o>);</span>             <span class=c1>// l : [&#39;a&#39;, &#39;b&#39;]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>l</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=sc>&#39;c&#39;</span><span class=o>);</span>             <span class=c1>// l : [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=c1>// Iterator를 이용한 list 내의 원소들 순회 (맨 뒤에서 시작)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ListIterator</span><span class=o>&lt;</span><span class=n>Character</span><span class=o>&gt;</span> <span class=n>it</span> <span class=o>=</span> <span class=n>l</span><span class=o>.</span><span class=na>listIterator</span><span class=o>(</span><span class=n>l</span><span class=o>.</span><span class=na>size</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>hasPrevious</span><span class=o>())</span>               <span class=c1>// &#39;c&#39; &#39;b&#39; &#39;a&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>previous</span><span class=o>());</span>  <span class=c1>// previous는 앞으로 이동하면서 값을 반환
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><p><mark><strong>Iterator 주요 메서드</strong></mark></p><ul><li><code>next()</code>, <code>previous()</code><ul><li><code>next()</code>는 뒤에서 <mark>앞으로</mark> 이동</li><li><code>next()</code>는 <code>hasNext()</code>가 true인 경우에만 사용</li><li><code>previous()</code>는 앞에서 <mark>뒤로</mark> 이동</li><li><code>previous()</code>는 <code>hasPrevious()</code>가 true인 경우에만 사용</li></ul></li><li><code>remove()</code><ul><li><code>next()</code>를 진행했던 원소 제거</li><li><mark><code>remove()</code>전에 <code>next()</code>가 반드시 선행되어야 함</mark></li></ul></li><li><code>add()</code><ul><li>iterator 위치에 새로운 원소 E 추가</li></ul></li></ul><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.LinkedList</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.ListIterator</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Main</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedList</span><span class=o>&lt;</span><span class=n>Character</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span> 
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=sc>&#39;a&#39;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=sc>&#39;b&#39;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=sc>&#39;c&#39;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// iterator를 list의 맨 앞에 위치시킴
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ListIterator</span><span class=o>&lt;</span><span class=n>Character</span><span class=o>&gt;</span> <span class=n>it</span> <span class=o>=</span> <span class=n>l</span><span class=o>.</span><span class=na>listIterator</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>next</span><span class=o>());</span>      <span class=c1>// 원소 값을 한 칸 뒤로 이동 (&#39;a&#39;)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>next</span><span class=o>());</span>      <span class=c1>// 원소 값을 한 칸 뒤로 이동 (&#39;b&#39;)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>previous</span><span class=o>());</span>  <span class=c1>// 원소 값을 한 칸 앞으로 이동 (&#39;b&#39;)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>previous</span><span class=o>());</span>  <span class=c1>// 원소 값을 한 칸 앞으로 이동 (&#39;a&#39;)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=n>it</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>                          <span class=c1>// remove 전에 next 필요
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>it</span><span class=o>.</span><span class=na>remove</span><span class=o>();</span>                        <span class=c1>// 원소 &#39;a&#39;를 제거
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>it</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=sc>&#39;d&#39;</span><span class=o>);</span>                        <span class=c1>// 원소 &#39;d&#39;를 추가
</span></span></span><span class=line><span class=cl><span class=c1></span>        
</span></span><span class=line><span class=cl>        <span class=c1>// list에 들어있는 원소 값을 순서대로 출력합니다.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>it</span> <span class=o>=</span> <span class=n>l</span><span class=o>.</span><span class=na>listIterator</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>hasNext</span><span class=o>())</span> <span class=o>{</span>               <span class=c1>// &#39;d&#39; &#39;b&#39; &#39;c&#39; q
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>next</span><span class=o>());</span>    <span class=c1>// 원소 값을 출력하며 한 칸 뒤로 이동합니다.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>}</span> 
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><br><br></p><a href=#circular-linked-list><h3 id=circular-linked-list><span class=hanchor arialabel=Anchor># </span>Circular Linked List</h3></a><ul><li>원형 연결리스트는 연결리스트를 원 형태로 구현한 모습</li><li>기존 연결리스트의 head와 tail만 연결하면 됨</li><li><code>head.prev = tail</code>이 되기에 굳이 tail을 들고 있을 필요가 없음</li><li>그래서 보통 head만 놔둠</li><li>head에서 next를 계속 반복하면 다시 head에 도달함</li></ul><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-26.png width=auto alt></p><br><hr><a href=#stack><h2 id=stack><span class=hanchor arialabel=Anchor># </span>Stack</h2></a><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.Stack</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Stack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>stack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Stack은 class, 구현체 그 자체 (Vector 상속)
</span></span></span></code></pre></td></tr></table></div></div><ul><li>LIFO (Last In First Out)</li><li>위에서부터 쌓아가는 자료구조</li><li><code>push(E)</code> : E를 스택 맨 위에 넣기</li><li><code>size()</code> : 스택에 쌓인 블럭 개수 반환</li><li><code>isEmpty()</code> : 스택 맨 위에 비어있으면 true, 아니면 false</li><li><code>peek()</code> : 스택 맨 위에 값 반환</li><li><code>pop()</code> : 스택 맨 위에 값 반환하면서 블럭 제거</li><li>삽입 삭제 시간복잡도 <mark><strong>$O(1)$</strong></mark></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>function</span> <span class=n>push</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>E</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>arr</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=n>maxsize</span>          <span class=o>//</span> <span class=n>배열에</span> <span class=n>이미</span> <span class=n>원소들이</span> <span class=n>가득</span> <span class=n>채워져</span> <span class=n>있으면</span>
</span></span><span class=line><span class=cl>    <span class=n>throw</span> <span class=n>exception</span><span class=p>()</span>             <span class=o>//</span> <span class=n>예외처리</span>
</span></span><span class=line><span class=cl>  <span class=n>arr</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>E</span><span class=p>)</span>                   <span class=o>//</span> <span class=n>정상적인</span> <span class=n>상황이라면</span><span class=p>,</span> <span class=n>E를</span> 
</span></span><span class=line><span class=cl>                                  <span class=o>//</span> <span class=n>마지막</span> <span class=n>위치에</span> <span class=n>추가</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>function</span> <span class=n>pop</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>arr</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span>                <span class=o>//</span> <span class=n>배열에</span> <span class=n>아무런</span> <span class=n>원소도</span> <span class=n>없다면</span>
</span></span><span class=line><span class=cl>    <span class=n>throw</span> <span class=n>exception</span><span class=p>()</span>             <span class=o>//</span> <span class=n>예외처리</span>
</span></span><span class=line><span class=cl>  <span class=nb>set</span> <span class=n>last</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>arr</span><span class=o>.</span><span class=n>size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>    <span class=o>//</span> <span class=n>정상적인</span> <span class=n>상황이라면</span><span class=p>,</span> <span class=n>마지막</span> <span class=n>값을</span> <span class=n>변수에</span> <span class=n>저장</span>
</span></span><span class=line><span class=cl>  <span class=n>delete</span> <span class=n>arr</span><span class=p>[</span><span class=n>arr</span><span class=o>.</span><span class=n>size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>        <span class=o>//</span> <span class=n>맨</span> <span class=n>끝에</span> <span class=n>있는</span> <span class=n>값을</span> <span class=n>실제로</span> <span class=n>제거</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>last</span>                     <span class=o>//</span> <span class=n>마지막에</span> <span class=n>있었던</span> <span class=n>값을</span> <span class=n>반환</span>
</span></span></code></pre></td></tr></table></div></div><br><blockquote class=note-callout><p>배열을 스택처럼 쓸 수 있음</p><p></p><ul><li>배열의 삽입 삭제 시간 복잡도는 <mark><strong>$O(N)$</strong></mark></li><li>만약, 배열의 맨 뒤에다가 값을 넣고 빼면 스택처럼 사용할 수 있겠네</li><li>다만 그 공간은 남아있어야겠네</li><li>혹은, 연결리스트를 써서 스택처럼 쓸 수도 있음 !</li><li>연결리스트는 모든 연산에 대해 시간복잡도 <mark><strong>$O(1)$</strong></mark> 이니까</li></ul></blockquote><br><hr><a href=#queue><h2 id=queue><span class=hanchor arialabel=Anchor># </span>Queue</h2></a><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.Queue</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.LinkedList</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Queue는 interface, LinkedList는 class (구현체)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Queue&lt;T&gt; queue = new Queue&lt;&gt;();
</span></span></span><span class=line><span class=cl><span class=c1>// 이렇게 작성 시 당연히 오류나겠지 ?
</span></span></span></code></pre></td></tr></table></div></div><ul><li>FIFO (First In First Out)</li><li><code>add(E)</code> : E를 맨 뒤(rear)에 추가</li><li><code>size()</code> : 큐에 들어있는 데이터 개수 반환</li><li><code>isEmpty()</code> : 큐가 비어있으면 true, 아니면 false</li><li><code>peek()</code> : 맨 앞(front)에 있는 값 반환</li><li><code>poll()</code> : 맨 앞(front)에 있는 값 반환하면서 제거</li><li>삽입 삭제 시간복잡도 <mark><strong>$O(1)$</strong></mark></li></ul><blockquote class=note-callout><p>배열을 큐처럼은?</p><p></p><ul><li>배열 맨 앞에 삽입 + 맨 뒤에 삭제하면 시간복잡도 <mark><strong>$O(N)$</strong></mark></li><li>큐처럼 쓰기에는 무리가 있음</li><li>근데 맨 앞이나 뒤에서 삽입 삭제가 일어날 때 <mark><strong>$O(1)$</strong></mark>인거 있잖아</li><li>→ 연결리스트 !</li></ul></blockquote><blockquote class=note-callout><p>큐를 스택처럼 사용하려면?</p><p></p><ul><li>큐 2개를 이용해서 사용 가능</li><li>15 35 20 순서로 데이터 삽입</li><li>스택은 15 35 20 (아래에서 위)</li><li>첫 번째 큐는 20 35 15 (왼쪽에서 오른쪽)</li><li>스택의 pop을 구현하기 위해, 첫번째 큐에서 가장 마지막에 들어온 20을 제외한 나머지를 두번째 큐로 이동하고 빼면 됨</li></ul></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function Stack.push(q, val)
</span></span><span class=line><span class=cl>  q.push(val)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>function Stack.pop(q)
</span></span><span class=line><span class=cl>  set new_q = empty queue
</span></span><span class=line><span class=cl>  while q.size() != 1
</span></span><span class=line><span class=cl>    new_q.push(q.pop())
</span></span><span class=line><span class=cl>  set top = q.pop()
</span></span><span class=line><span class=cl>  q = new_q
</span></span><span class=line><span class=cl>  return top
</span></span></code></pre></td></tr></table></div></div><br><hr><a href=#deque><h2 id=deque><span class=hanchor arialabel=Anchor># </span>Deque</h2></a><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.Deque</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.ArrayDeque</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Main</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Deque</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>dq</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayDeque</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Deque는 interface, ArrayDeque는 class (구현체)
</span></span></span></code></pre></td></tr></table></div></div><ul><li>덱은 스택과 큐의 특성을 합친 자료구조</li><li>덱은 스택처럼 큐처럼 둘다 사용 가능, 메서드가 지원됨 (<a href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/ArrayDeque.html target=_blank>오라클</a>)</li><li><mark>맨 앞, 맨 뒤에서 삽입/삭제 모두 가능</mark></li><li>삽입/삭제 시간복잡도 <mark><strong>$O(1)$</strong></mark></li><li><code>addFirst(E)</code> : 맨 앞에 데이터 E 추가</li><li><code>addLast(E)</code> : 맨 뒤에 데이터 E 추가</li><li><code>pollFirst()</code> : 맨 앞에 데이터 반환하면서 덱에서 제거</li><li><code>pollLast()</code> : 맨 뒤에 데이터 반환하면서 덱에서 제거</li><li><code>size()</code> : 덱에 있는 데이터 개수 반환</li><li><code>isEmpty()</code> : 덱이 비어있다면 true, 아니면 false 반환</li><li><code>peekFirst()</code> : 맨 앞에 데이터 반환</li><li><code>peekLast()</code> : 맨 뒤에 데이터 반환</li></ul><br><hr><a href=#vector-stack-권장하지-않는-이유><h2 id=vector-stack-권장하지-않는-이유><span class=hanchor arialabel=Anchor># </span>Vector, Stack 권장하지 않는 이유</h2></a><br><p>출처 : <a href=https://vanslog.io/posts/language/java/why-use-deque-instead-of-stack/ target=_blank>[Java] 왜 Stack 대신 Deque를 사용하는가?</a></p><br><table><thead><tr><th><strong>비교</strong></th><th><strong>Vector</strong></th><th><strong>ArrayList</strong></th></tr></thead><tbody><tr><td>동기화 처리</td><td>O</td><td>X</td></tr><tr><td>쓰레드 안전</td><td>O</td><td>X</td></tr><tr><td>성능</td><td>비교적 느림</td><td>비교적 빠름</td></tr><tr><td>용량 증가</td><td>2배</td><td>1.5배</td></tr></tbody></table><ul><li>Vector<ul><li>동기화한 메서드로 구성되어 멀티스레드 환경에서 안전</li><li>단일스레드 환경에서는 동기화 처리에 대한 오버헤드로 성능 하락</li></ul></li><li>ArrayList<ul><li>동기화처리 하지 않으니 단일스레드 환경에서 성능 좋음</li><li>멀티스레드 환경에서는 동기화 처리를 위해 <code>Collections.synchronizedList</code> 이용</li></ul></li></ul><br><table><thead><tr><th><strong>비교</strong></th><th><strong>Stack</strong></th><th><strong>ArrayDeque</strong></th></tr></thead><tbody><tr><td>동기화 처리</td><td>O</td><td>X</td></tr><tr><td>쓰레드 안전</td><td>O</td><td>X</td></tr><tr><td>성능</td><td>비교적 느림</td><td>비교적 빠름</td></tr></tbody></table><ul><li>Vector, ArrayList와 Stack, ArrayDeque는 유사한 관계</li><li>다만, ArrayDeque는 ArrayLIst 처럼 동기화처리를 위한 메서드 존재 X<ul><li><code>Collections.synchronizedDeque</code> 이런건 없음</li><li>그러나, 아래의 코드처럼 멀티스레드 환경에서 동기화처리 가능</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>SyncStack</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>stack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayDeque</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>push</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>stack</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><hr><a href=#tree><h2 id=tree><span class=hanchor arialabel=Anchor># </span>Tree</h2></a><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-14.png width=auto alt></p><ul><li><strong>노드</strong> : 각 지점, <strong>정점</strong>이라고도 부름<ul><li>루트 노드 : 트리에서 부모가 없는 최상위 노드, 트리의 시작점</li><li>부모 노드 : 루트 노드 방향으로 직접 연결된 노드</li><li>자식 노드 : 루트 노드 반대방향으로 직접 연결된 노드</li><li>형제 노드 : 같은 부모 노드를 갖는 노드들</li><li>리프 노드 : 차수가 0인 노드, 자식이 없는 노드, 단말 노드라고도 부름</li></ul></li><li><strong>간선</strong> : 두 노드를 연결하는 선, <strong>엣지</strong></li><li><strong>차수</strong> : 각 노드의 자식 개수</li><li><strong>깊이</strong> : 루트 노드와 얼마나 떨어져있는지</li><li><strong>높이</strong> : 트리에서 깊이가 가장 깊은 노드의 깊이</li><li>레벨은 논문에 따라 0부터 시작하거나 1부터 시작하거나 둘 중 하나</li></ul><br><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-15.png width=auto alt></p><ul><li><strong>Unrooted Tree</strong><ul><li>이렇게 부모-자식 관계가 정의되어있지 않아도 트리라고 부름</li><li>트리의 원래 정의는 <mark>노드끼리 전부 연결되어 있으면서 사이클이 존재하지 않는 <strong>그래프</strong></mark></li><li>위의 그림처럼 루트 노드가 설정되어 있는 트리는 <strong>Rooted Tree</strong></li></ul></li></ul><br><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-25.png width=auto alt></p><ul><li>노드끼리 전부 연결되어있지 않거나, 사이클이 존재하므로 위의 예시는 <strong>트리가 아님</strong></li></ul><p><br><hr></p><a href=#binary-tree><h3 id=binary-tree><span class=hanchor arialabel=Anchor># </span>Binary Tree</h3></a><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-19.png width=auto alt></p><ul><li><strong>이진트리</strong> : 자식의 수가 최대 2인 트리</li><li>이진트리는 배열로 구현 가능</li><li><mark>특정 노드의 위치 <code>i</code>인 경우, 그 노드의 왼쪽 자식은 <code>i * 2</code>, 오른쪽 자식은 <code>i * 2 + 1</code></mark><ul><li><mark>그럼 자식의 입장에서 부모는? <code>i / 2</code> 겠네</mark></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 1은 루트노드
</span></span><span class=line><span class=cl>// 2는 왼쪽 자식
</span></span><span class=line><span class=cl>// 3은 오른쪽 자식
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Index 0  1  2  3  4  5  6  7
</span></span><span class=line><span class=cl>Array -  5  3  3  4  7  8  9
</span></span></code></pre></td></tr></table></div></div><p><br><br></p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-20.png width=auto alt></p><ul><li>방문하는 순서에 따라 탐색을 구현할 수 있음 (전위, 중위, 후위)</li><li><strong>전위 탐색 (Preorder Traversal)</strong> : 부모 → 왼쪽 → 오른쪽<ul><li>1 - 2 - 5 - 4 - 3 - 6 - 8 - 7</li></ul></li><li><strong>중위 탐색 (Inorder Traversal)</strong> : 왼쪽 → 부모 → 오른쪽<ul><li>2 - 4 - 5 - 1 - 3 - 6 - 8 - 7</li></ul></li><li><strong>후위 탐색 (Postorder Traversal)</strong> : 왼쪽 → 오른쪽 → 부모<ul><li>4 - 5 - 2 - 8 - 6 - 7 - 3 - 1</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function Preorder(n)
</span></span><span class=line><span class=cl>	visit(n)
</span></span><span class=line><span class=cl>	Preorder(n.left)
</span></span><span class=line><span class=cl>	Preorder(n.right)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>function Inorder(n)
</span></span><span class=line><span class=cl>	Inorder(n.left)
</span></span><span class=line><span class=cl>	visit(n)
</span></span><span class=line><span class=cl>	Inorder(n.right)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>function Postorder(n)
</span></span><span class=line><span class=cl>	Postorder(n.left)
</span></span><span class=line><span class=cl>	Postorder(n.right)
</span></span><span class=line><span class=cl>	visit(n)
</span></span></code></pre></td></tr></table></div></div><p><br><hr></p><a href=#binary-search-tree><h3 id=binary-search-tree><span class=hanchor arialabel=Anchor># </span>Binary Search Tree</h3></a><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-21.png width=auto alt></p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-22.png width=auto alt></p><ul><li>이진 탐색 트리의 특성<ul><li>부모의 왼쪽 방향에 있는 노드들은 전부 부모보다 값이 작음</li><li>부모의 오른쪽 방향에 있는 노드들은 전부 부모보다 값이 큼</li><li>시간 복잡도 (삽입/삭제/탐색)<ul><li>균형 잡히지 않은 이진 탐색 트리의 경우 : <mark><strong>$O(N)$</strong></mark></li><li>균형 잡힌 이진 탐색 트리의 경우 : <mark><strong>$O(log N)$</strong></mark><ul><li>ex) Red Black Tree, AVL Tree</li><li>노드를 회전과 같은 작업을 통해 트리의 높이를 <mark><strong>$log N$</strong></mark>으로 유지할 수 있음</li></ul></li></ul></li><li><strong>이진 탐색 트리를 중위 탐색하면 정렬된 순서대로 값이 나옴</strong></li></ul></li></ul><br><ul><li><mark><strong>이진 탐색 트리 - 탐색</strong></mark></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function bst.search(x)
</span></span><span class=line><span class=cl>    set node = bst.root                     // root에서 시작
</span></span><span class=line><span class=cl>    while node != null and node.value != x  // node의 값 == x까지 계속 반복
</span></span><span class=line><span class=cl>        if node.value &gt; x                   // node의 값 &gt; x이면
</span></span><span class=line><span class=cl>            node = node.left                // 왼쪽 자식으로 내려와 탐색진행 
</span></span><span class=line><span class=cl>        else                                // node의 값 &lt; x이면
</span></span><span class=line><span class=cl>            node = node.right               // 오른쪽 자식으로 내려와 탐색진행
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    return node                             // 최종 위치를 반환
</span></span></code></pre></td></tr></table></div></div><br><ul><li><mark><strong>이진 탐색 트리 - 삽입</strong></mark><ul><li>데이터 삽입 과정은, 부모를 계속 업데이트하면서 내려가면 됨</li><li>Case 1. 부모가 비어있는(null) 인 경우 → root를 node(x)로 설정</li><li>Case 2. 부모의 값이 삽입하려는 값보다 큰 경우 → 부모의 왼쪽에 node(x) 삽입</li><li>Case 3. 부모의 값이 삽입하려는 값보다 작은 경우 → 부모의 오른쪽에 node(x) 삽입</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function bst.insert(x)
</span></span><span class=line><span class=cl>    set node = bst.root          // root에서 시작
</span></span><span class=line><span class=cl>    set parent = bst.root        // parent도 root로 설정하고 시작
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while node != null           // node가 null이 되기 전까지 반복
</span></span><span class=line><span class=cl>        parent = node            // parent는 node가 움직이기 직전 위치로 갱신 
</span></span><span class=line><span class=cl>        if node.value &gt; x        // node의 값 &gt; x이면
</span></span><span class=line><span class=cl>            node = node.left     // 왼쪽 자식으로 이동 
</span></span><span class=line><span class=cl>        else                     // node의 값 &lt; x이면
</span></span><span class=line><span class=cl>            node = node.right    // 오른쪽 자식으로 이동
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    if parent == null            // Case 1. 비어있는 tree이면
</span></span><span class=line><span class=cl>        bst.root = node(x)       // root를 node(x)로 설정.
</span></span><span class=line><span class=cl>    else if parent.value &lt; x     // Case 2. parent의 값 &lt; x이면
</span></span><span class=line><span class=cl>        parent.left = node(x)    // parent의 왼쪽에 node(x) 삽입
</span></span><span class=line><span class=cl>    else                         // Case 3. parent의 값 &gt; x
</span></span><span class=line><span class=cl>        parent.right = node(x)   // parent의 오른쪽에 node(x) 삽입
</span></span></code></pre></td></tr></table></div></div><p><br><br></p><ul><li><mark><strong>이진 탐색 트리 - 삭제</strong></mark><ul><li>Case 1. 삭제하려는 값 노드의 왼쪽 노드가 비어있음 → 오른쪽 노드 올려주기</li><li>Case 2. 삭제하려는 값 노드의 오른쪽 노드가 비어있음 → 왼쪽 노드 올려주기</li><li>Case 3. 삭제하려는 값 노드의 왼쪽 오른쪽 노드 전부 채워짐 → successor 찾기<ul><li>successor(후임자) : 현재 노드 기준으로 더 크면서 가장 작은 값을 갖는 노드</li><li>현재 노드보다 크니까, 오른쪽부터 시작해서 왼쪽으로 계속 내려가면 됨</li><li>successor의 값을 node로 옮겨주고 successor의 오른쪽 자식을 전부 올려</li><li>successor가 노드 바로 오른쪽에 있으면 node 지우고 그대로 오른쪽 노드 전체를 위로 올려</li></ul></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function bst.search(x)
</span></span><span class=line><span class=cl>    set node = bst.root                     
</span></span><span class=line><span class=cl>    while node != null and node.value != x 
</span></span><span class=line><span class=cl>        if node.value &gt; x                
</span></span><span class=line><span class=cl>            node = node.left           
</span></span><span class=line><span class=cl>        else                               
</span></span><span class=line><span class=cl>            node = node.right           
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    return node            
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>function bst.minimum(node)             // node 하위 트리에서 최솟값 구해
</span></span><span class=line><span class=cl>    while node.left != null            // node.left != null이면 내려가
</span></span><span class=line><span class=cl>        node = node.left
</span></span><span class=line><span class=cl>    return node                        // 최종 node의 위치를 반환합니다.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>function bst.delete(x)                 // x를 찾아 삭제하는 함수
</span></span><span class=line><span class=cl>    set node = bst.search(x)                // x 값 찾기
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    if node.left == null               // Case1. node의 왼쪽자식 비어있으면
</span></span><span class=line><span class=cl>        move(node.right, node)         // 오른쪽 자식을 위로 올려
</span></span><span class=line><span class=cl>    else if node.right == null         // Case2. node의 오른쪽자식 비어있으면
</span></span><span class=line><span class=cl>        move(node.left, node)          // 왼쪽 자식을 위로 올려
</span></span><span class=line><span class=cl>    else                               // Case3. 왼쪽 오른쪽 자식이 풀이면
</span></span><span class=line><span class=cl>        set succ = bst.minimum(node.right)  // successor를 구해
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        // successor는 현재 노드의 오른쪽 자식에서 시작하여 계속 왼쪽으로 내려가면 됨
</span></span><span class=line><span class=cl>        if succ == node.right          // successor가 노드의 오른쪽 자식이면 
</span></span><span class=line><span class=cl>            move(node.right, node)     // 오른쪽 자식을 위로 올려
</span></span><span class=line><span class=cl>        else                           // 그렇지 않은 일반적인 경우라면
</span></span><span class=line><span class=cl>            node.value = succ.value    // node의 값 successor 값으로 대체
</span></span><span class=line><span class=cl>            move(succ.right, succ)     // successor의 오른쪽 자식을 위로 올려
</span></span></code></pre></td></tr></table></div></div><p><br><hr></p><a href=#heap><h3 id=heap><span class=hanchor arialabel=Anchor># </span>Heap</h3></a><ul><li>힙은 이진 트리의 특별한 형태<ul><li>완전 이진트리 모양</li><li>트리의 높이 <mark><strong>$log N$</strong></mark></li></ul></li><li>최대 힙(max-heap), 최소 힙(min-heap) 둘 중 하나</li><li>특정 수가 추가되거나 삭제될 때, heap 구조를 유지하려면 <mark><strong>$O(log N)$</strong></mark> 만큼 소요됨<ul><li><mark><strong>최대 최소값을 찾는 시간복잡도 $O(1)$이 가능하게 함</strong></mark></li></ul></li></ul><br><p><strong>완전 이진 트리</strong></p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-23.png width=auto alt></p><ul><li>트리의 모든 값이 비는 것 없이 왼쪽부터 순서대로 차 있는 형태</li></ul><p><br><br></p><p><mark><strong>최대 힙(max-heap)</strong></mark></p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-24.png width=auto alt></p><ul><li>완전 이진 트리를 띄면서, 모든 노드에 대해 부모 노드가 자신의 자식 노드가 갖는 값보다 같거나 큰 경우를 만족하는 경우</li><li>루트 노드에는 전체 숫자 중 최댓값이 들어있음</li><li>시간 복잡도<ul><li>최대 힙 만드는 데에 <mark><strong>$O(N)$</strong></mark></li><li>최댓값 탐색 <mark><strong>$O(1)$</strong></mark></li><li>삽입/삭제 <mark><strong>$O(log N)$</strong></mark><ul><li>완전 이진 트리에서의 삽입/삭제니까</li></ul></li></ul></li><li>최대 힙에서의 삭제는 <strong>루트 노드</strong>에서만 가능</li><li>k번째 최댓값을 구할 수 ❌<ul><li>루트 노드를 제외하고 다른 원소가 어느 위치에 있는 지 알 수 없음</li></ul></li></ul><p><br><br></p><p><mark><strong>힙 만들기</strong></mark></p><ul><li><p>$n / 2$번째 원소부터 거꾸로 1번째 원소까지 <strong>heapify</strong> 진행</p></li><li><p>heapify : 현재 노드를 기준으로 heap 특성에 맞을 때까지 계속 밑으로 내려주는 과정</p><ol><li><code>현재 노드 위치 = i</code> , <code>왼쪽 자식 노드 = i * 2</code> , <code>오른쪽 자식 노드 = i * 2 + 1</code> 세 노드 중 가장 큰 노드를 largest 라고 한다.</li><li><code>largest 노드</code>가 <code>i</code>가 아니라 자식 노드라면, <code>현재 노드(i)</code>와 <code>자식 노드(largest)</code>의 값을 교환</li><li>만약 <code>largest 노드</code>가 <code>현재 노드(i)</code> 이면 종료</li></ol></li><li><p>힙은 트리의 높이가 $log N$ 이니까 heapify 과정은 1번 일어날 때, 최대 $log N$번까지 가능</p></li><li><p>최대 힙(max-heap) 만들 때, $n / 2$ 개의 원소에 대해 heapify 과정을 거침</p></li><li><p>각 노드별로 최대로 움직이게 되는 횟수를 합해보면 시간복잡도 <mark><strong>$O(N)$</strong></mark> 소요</p></li><li><p>예시</p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-39.png width=auto alt></p><ul><li><code>n = 7</code> 이므로, <code>n / 2 = 3</code>이니까 <code>heapify(3)</code>부터 진행</li><li><code>heapify(3)</code> 진행<ul><li>largest 노드는 7번 노드이므로, 3번 노드와 교환하고 <code>heapify(7)</code> 진행</li><li>다만, 7번 노드는 자식이 없으므로 heapify 종료</li></ul></li><li><code>heapify(2)</code> 진행<ul><li>largest 노드는 5번 노드이므로, 2번 노드와 교환하고 <code>heapify(5)</code> 진행</li><li>다만, 5번 노드는 자식이 없으므로 heapify 종료</li></ul></li><li><code>heapify(1)</code> 진행<ul><li>largest 노드는 3번 노드이므로, 1번 노드와 교체하고 <code>heapify(3)</code> 진행</li><li><code>heapify(3)</code>에서 다시 largest 노드가 6번 노드이므로, 3번 노드와 교체하고 <code>heapify(6)</code> 진행</li><li>다만, 6번 노드는 자식이 없으므로 heapfiy 종료</li></ul></li></ul></li><li><p>최종 모습</p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-40.png width=auto alt></p></li></ul><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function heapify(arr[], n, i)
</span></span><span class=line><span class=cl>  set largest = i                     // 최대 노드를 i번이라 가정
</span></span><span class=line><span class=cl>  set l = i * 2                       // 왼쪽 자식 노드 번호
</span></span><span class=line><span class=cl>  set r = i * 2 + 1                   // 오른쪽 자식 노드 번호
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if l &lt;= n &amp;&amp; arr[l] &gt; arr[largest]  // 왼쪽 자식이 크면, 최대 번호를 수정
</span></span><span class=line><span class=cl>    largest = l
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if r &lt;= n &amp;&amp; arr[r] &gt; arr[largest] // 오른쪽 자식이 크면, 최대 번호를 수정
</span></span><span class=line><span class=cl>    largest = r
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if largest != i                   // 최대 노드가 자식 노드라면
</span></span><span class=line><span class=cl>    swap(arr[i], arr[largest])      // 해당 자식과 현재 노드를 교환
</span></span><span class=line><span class=cl>    heapify(arr, n, largest)        // 내려간 위치에서 다시 heapify 진행
</span></span></code></pre></td></tr></table></div></div><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function build_heap(arr[], n)
</span></span><span class=line><span class=cl>  for i = n / 2 ... i &gt;= 1      // n / 2번째 원소부터 1번째 원소까지 돌며
</span></span><span class=line><span class=cl>    heapify(arr, n, i)         // heapify 과정을 진행하여 max-heap 만듦
</span></span></code></pre></td></tr></table></div></div><p><br><br></p><p><mark><strong>최대 힙 - 삽입</strong></mark></p><ul><li>트리 맨 끝에 삽입하고, 현재 노드 기준 부모와 값을 계속 비교하며, 부모가 더 작으면 교환</li><li>삽입의 시간 복잡도는 트리의 높이와 관련, 따라서 <mark><strong>$O(log N)$</strong></mark></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function insert(arr[], n, x)
</span></span><span class=line><span class=cl>  arr.append(x)                          // 가장 끝에 노드 x를 추가
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  set i = n + 1                          // 마지막 노드에서 시작
</span></span><span class=line><span class=cl>  while i &gt; 1 and arr[i / 2] &lt; arr[i]    // 부모가 자식보다 값이 작은 경우라면
</span></span><span class=line><span class=cl>                                         // max-heap 조건에 어긋나므로
</span></span><span class=line><span class=cl>    swap(arr[i], arr[i / 2])             // 두 값을 교환하고
</span></span><span class=line><span class=cl>    i = i / 2                            // 부모 위치로 올라감
</span></span></code></pre></td></tr></table></div></div><br><p><mark><strong>최대 힙 - 삭제</strong></mark></p><ul><li>루트 노드 값 삭제하면, 빈 자리가 남을 것</li><li>빈 자리에 트리의 끝 값을 넣고 난 이후에도 max-heap 특성 유지해야하니까 heapify 진행</li><li>n번 노드를 1번 노드로 바로 올린 것이니까 반드시 <strong><code>heapify(1)</code></strong> 진행</li><li>heapify 과정의 시간 복잡도가 <mark><strong>$O(log N)$</strong></mark> 이므로, 삭제 또한 마찬가지</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function heapify(arr[], n, i)
</span></span><span class=line><span class=cl>  set largest = i                     // 최대 노드를 i번이라 가정
</span></span><span class=line><span class=cl>  set l = i * 2                       // 왼쪽 자식 노드 번호
</span></span><span class=line><span class=cl>  set r = i * 2 + 1                   // 오른쪽 자식 노드 번호
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if l &lt;= n &amp;&amp; arr[l] &gt; arr[largest]  // 왼쪽 자식이 크면, 최대 번호를 수정
</span></span><span class=line><span class=cl>    largest = l
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if r &lt;= n &amp;&amp; arr[r] &gt; arr[largest] // 오른쪽 자식이 크면, 최대 번호를 수정
</span></span><span class=line><span class=cl>    largest = r
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if largest != i                   // 최대 노드가 자식 노드라면
</span></span><span class=line><span class=cl>    swap(arr[i], arr[largest])      // 해당 자식과 현재 노드를 교환
</span></span><span class=line><span class=cl>    heapify(arr, n, largest)        // 내려간 위치에서 다시 heapify 진행
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>function remove(arr[], n)
</span></span><span class=line><span class=cl>  arr[1] = arr[n]                   // 가장 끝 노드를 루트 노드로 이동
</span></span><span class=line><span class=cl>  delete arr[n]                     // 가장 마지막 노드를 삭제
</span></span><span class=line><span class=cl>  heapify(arr, n - 1, 1)            // 루트 노드 기준으로 heapify를 진행
</span></span><span class=line><span class=cl>                                    // max-heap 상태 계속 유지됨 
</span></span></code></pre></td></tr></table></div></div><br><hr><a href=#hasing><h2 id=hasing><span class=hanchor arialabel=Anchor># </span>Hasing</h2></a><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-41.png width=auto alt></p><ul><li>해싱, 해시 함수<ul><li><mark><strong>들어온 순서 상관 없이</strong> 삽입/삭제/탐색 자주 발생할 때 사용하기 좋음</mark></li><li>임의의 데이터를 받아, 해당 데이터를 고정된 길이의 특정 값으로 반환하는 함수</li><li>어떤 값을 넣더라도 특정 범위에 해당하는 값 반환</li><li>ex) 해시 함수의 반환값을 0부터 시작하는 양의 정수로 설정한 상황<ul><li>특정 값 → 해시함수 → 해시함수의 반환 값에 해당하는 인덱스 → 배열의 인덱스에 해당하는 위치에 값 저장</li></ul></li><li>해시 충돌 자체를 줄이기 위해, 일반적으로 들어갈 최대 데이터의 3~4배 정도의 크기로 해시 테이블을 설정함</li><li>시간 복잡도 : 해시 함수를 1번만 통과하여 나온 인덱스만 관리하면 됨<ul><li>탐색 : <mark><strong>$O(1)$</strong></mark></li><li>삽입 : <mark><strong>$O(1)$</strong></mark></li><li>삭제 : <mark><strong>$O(1)$</strong></mark></li></ul></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function append(key, value)
</span></span><span class=line><span class=cl>  set index = hash_function(key)
</span></span><span class=line><span class=cl>  hash[index] = value
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>function find(key)
</span></span><span class=line><span class=cl>  set index = hash_function(key)
</span></span><span class=line><span class=cl>  if hash[index] != null
</span></span><span class=line><span class=cl>    return hash[index]
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>function remove(key)
</span></span><span class=line><span class=cl>  set index = hash_function(key)
</span></span><span class=line><span class=cl>  if hash[index] == null
</span></span><span class=line><span class=cl>    return 
</span></span><span class=line><span class=cl>  hash[index] = null
</span></span></code></pre></td></tr></table></div></div><blockquote class=note-callout><p>해싱이 만능은 아니다</p><p></p><ul><li>문자열, 숫자 등 대응 가능한 타입이 많다</li><li>다만, 배열의 경우 배열 내 값의 개수가 불분명해서 해시 함수에서 배열을 다루지 않음</li></ul></blockquote><p><br><br></p><p><mark><strong>대표적인 해시 함수</strong></mark></p><ul><li><a href=https://dbehdrhs.tistory.com/70 target=_blank>고니님 블로그</a> 참조</li><li><a href=https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/ target=_blank>ratsgo&rsquo;s blog</a> 참조</li><li><a href=https://velog.io/@stresszero/hash-table#%EC%B6%A9%EB%8F%8C-%ED%95%B4%EA%B2%B0-%EA%B8%B0%EB%B2%95 target=_blank>개발자 강세영</a> 참조</li><li><a href=https://dev-kani.tistory.com/2 target=_blank>개발자 카니</a> 참조</li></ul><ol><li><p><strong>Division Method (제산법)</strong> : 나눗셈과 나머지 연산자 이용, 입력 값(key)을 테이블의 크기로 나눈 나머지를 반환</p><ul><li><code>hash_index = key % M</code></li><li>M은 해시 테이블의 크기인데, 소수(prime number)로 설정 시 해시 주소가 좋은 효율을 가짐<ul><li>M이 짝수라면 메모리 주소는 대부분 짝수이므로, 해시 함수값 또한 짝수가 나올 것</li><li>소수로 하게 된다면, 0 ~ M - 1을 골고루 사용하는 값을 만들어냄</li><li>특히 2의 제곱수와 거리가 먼 소수를 사용한 해시 함수가 좋은 성능을 냄</li></ul></li></ul></li><li><p><strong>Digit Folding (폴딩법)</strong> : 입력 값(key)을 몇 개의 부분으로 나누어 더하거나 비트별로 XOR 연산하여 해시 주소로 사용</p><ul><li><code>hash_index = (short)(key ^ key >> 16)</code></li><li>key가 문자열일 경우 ASCII 코드로 바꿔서 연산
</li></ul></li><li><p><strong>Multiplication Method (곱셈법)</strong> : 숫자로 된 입력 값(key)이 k이고, A는 0~1 사이의 실수일 때, 보통 2의 제곱수인 m을 활용하여 계산하고 해시 주소로 사용</p><ul><li><code>h(k) = (kA % 1) * m</code></li></ul></li><li><p><strong>Mid-Square (중간 제곱법)</strong> : 키 값을 제곱한 후에 중간의 몇 자리를 선택하여 그 중간 값을 해시 주소로 사용</p></li><li><p><strong>Radix Conversion (기수 변환법)</strong> : 입력 값(key)을 다른 진법으로 변환하여 얻은 값을 해시 주소로 사용</p></li><li><p><strong>Digit Analysis(숫자 분석법)</strong> : 입력 값(key) 각각의 위치에 있는 숫자 중 편중되지 않은 수들을 해시 테이블의 크기에 적합한 만큼 조합해 해시 주소로 사용</p></li><li><p><strong>Universal Hasing (무작위 해싱)</strong> : 다수의 해시함수를 만들고 이 해시함수의 집합 H에서 무작위로 해시함수를 선택해 해시 주소로 사용</p></li></ol><p><br><br></p><p><mark><strong>대표적인 해시 알고리즘</strong></mark></p><ul><li>MD(메시지 출력) 시리즈, SHA 시리즈, RIPEMD, WhirlPool</li><li>MD4 : MD5의 초기 버전으로, 입력 데이터(길이에 상관없는 하나의 메시지)로부터 128비트 메시지 축약을 만듦으로써 데이터 무결성을 검증하는데 사용되는 알고리즘</li><li>MD5 : 널리 사용된 해시 알고리즘이지만, 충돌 회피성에서 문제점 이 있다는 분석이 있으므로 기존의 응용과의 호환으로만 사용하고 더 이상 사용하지 않도록 하고 있음</li><li>SHA : 가장 많이 사용되고 있는 방식이다. SHA1은 DSA에서 사용하도록 되어 있으며 많은 인터넷 응용에서 default 해시 알고리즘으로 사용된다. SHA256, SHA384, SHA512 는 AES의 키 길이인 128, 192, 256 비트에 대응하도록 출력 길이를 늘인 해시 알고리즘이다.</li></ul><br><hr><a href=#hash-collision><h3 id=hash-collision><span class=hanchor arialabel=Anchor># </span>Hash collision</h3></a><ul><li><a href=https://dev-kani.tistory.com/1 target=_blank>개발자 카니</a> 참조</li></ul><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-42.png width=auto alt></p><ul><li><mark><strong>해시 충돌</strong></mark><ul><li>해시 함수를 적용해 생성된 배열의 고유한 index가 동일해서 충돌이 발생하는 상황</li><li>가장 쉬운 해결 방법으로는 인덱스에 <strong>연결 리스트</strong>를 적용<ul><li>다만, 충돌 횟수가 증가하면 연결리스트를 순회해야해서 삽입/삭제/탐색 시간복잡도가 $O(N)$이 됨</li><li>이렇게 되면 해싱을 써야할 이유가 없어짐</li><li>결국 충돌이 최대한 덜 일어나게 적절한 해시 함수 적용하는 것이 중요</li></ul></li></ul></li></ul><br><ul><li><mark><strong>해시 충돌 해결방법</strong></mark><ul><li>Separata chaining (분리 연결법, 체이닝)</li><li>Open Addressing (개방 주소법)</li></ul></li></ul><br><ul><li><mark><strong>Separata chaining (분리 연결법, 체이닝)</strong></mark>
<img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-44.png width=auto alt><ul><li>연결 리스트를 사용하여 관리</li><li>즉, 추가적인 메모리를 이용하는 방식</li><li>연결 리스트가 쌓이면 탐색에 $O(N)$ 소요</li><li>데이터가 채워짐에 따라 성능 저하 발생</li></ul></li></ul><br><ul><li>Separata chaining 상세한 내용<ul><li>연결리스트를 이용하여 관리<ul><li>key에 매핑된 index가 가리키는 LinkedList에 Node를 추가하여 Value 추가</li></ul></li><li>데이터의 주소 값(index)이 변경되지 않음</li><li>부하율이 100%에 가까울수록 삽입/삭제/탐색의 효율이 매우 낮아진다.<ul><li>부하율 (Load Factor) : 전체 버킷에서 사용 중인 버킷의 비율</li></ul></li><li>해시 함수를 선택하는 관점에서 클러스터링(Clustering)에 거의 영향을 받지 않기에 충돌의 최소화만 중점적으로 보면 됨</li><li>해시 테이블의 버킷이 채워져도 성능 저하가 선형적으로 발생</li></ul></li></ul><br><ul><li><mark><strong>Open Addressing (개방 주소법)</strong></mark>
<img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-45.png width=auto alt><ul><li>추가적인 메모리를 사용하는 Chaining 방식과 다르게 <strong>비어있는 해시 테이블의 공간을 활용하는 방법</strong></li><li><mark>선형 탐사법 (Linear Probing)</mark> : 해시충돌 시 다음 버킷 또는 비어 있지 않다면 몇 개 건너뛰어 데이터를 삽입</li><li><mark>제곱 탐사법 (Quadratic Probing)</mark> : 해시충돌 시 제곱만큼 건너뛴 버킷에 데이터를 삽입</li><li><mark>이중 해시법 (Double Hasing)</mark> : 해시충돌 시 한번 더 적용해서 나온 버킷에 데이터 삽입</li><li>n차 충돌 발생 가능, 메모리 효율 높음, 다른 자료구조가 필요 ❌, 데이터가 적을 때 유리</li><li>데이터 삭제 시, 삭제된 공간은 Dummy Space로 활용되기에 Hash Table을 재정리 해주는 작업이 필요</li></ul></li></ul><br><ul><li><p>Open Addressing 상세한 내용</p><ul><li>연결 리스트(Linked List)같은 추가적인 메모리를 사용하지 않고 해시 테이블(Hash Table)의 빈 버킷(Bucket)을 이용하는 방법</li><li>데이터의 주소 값(index) 바뀜<ul><li>충돌 발생 시, 다른 버킷에 저장하니까</li></ul></li><li>특히, 선형 검색법에서 체이닝 방식보다 뛰어난 참조 지역성(Locality of reference)을 가짐<ul><li>이러한 특성으로 LoopUp 연산에서 특히 좋은 성능</li></ul></li><li>테이블에 모두 저장될 수 있고, 캐시 라인에 적합할 수 있을 정도로 데이터의 크기가 작을수록 성능이 좋아짐</li><li>삭제의 경우 충돌에 의해 뒤에 저장된 데이터가 검색되지 않을 수 있음<ul><li>이를 방지하기 위해 삭제한 위치에 Dummy Node를 삽입</li><li>Dummy Node는 실제 값을 가지지는 않지만, 검색할 때 다음 위치(인덱스)까지 연결해주는 역할</li><li>삭제가 빈번히 일어날 경우 Dummy Node 수가 많아져서, 검색할 경우에 많은 버킷(Bucket)을 연속적으로 검색해야 하기 때문에 이 Dummy Node의 개수가 일정 수 이상이 되었을 경우에 주기적으로 새로운 배열을 만들려고 재해시(Rehash)를 해줘야 성능을 유지할 수 있음</li></ul></li></ul></li><li><p>Linear Probing 상세한 내용</p><ul><li>충돌 발생시 새로운 키(Key)를 저장할 기억공간을 찾기 위해 충돌이 일어난 그 위치에서 선형적으로 검색하여 첫 번째 빈 영역에 키를 저장하는 방법</li><li>현재의 버킷 index로부터 고정된 폭만큼 이동하여 차례대로 검색</li><li>테이블의 끝에 도달하게 되면 처음으로 되돌아 감</li><li>조사를 시작한 위치로 되돌아 오게 되면 테이블이 가득찬 것</li><li>장점 : 구조가 간단하고 캐시의 효율이 높음</li><li>단점 : 최악의 경우 해시 테이블(Hash Table) 전체를 검색해야 하는 상황이 발생할 수 있으므로 비효율적이고, 데이터의 클러스터링(Clustering)에 가장 취약</li></ul></li><li><p>Quadratic Probing 상세한 내용</p><ul><li>Linear Probing에서 발생하는 제1밀집(primary clustering) 문제를 제거하는 방법</li><li>같은 해시 값을 갖는 키(Key)에 대해서는 제2밀집(secondary clustering) 발생</li><li>해시의 저장순서 폭을 제곱으로 저장하는 방식</li><li>원래 저장할 위치로부터 1, 4, 9, 16, &mldr; 과 같이 떨어진 영역을 차례대로 검색하여 첫번째 빈 영역에 키를 저장하는 방법</li><li>캐시 효율과 클러스터링(Clustering) 방지 측면에서 Linear Probing과 Double Hashing의 중간 정도의 성능</li></ul></li><li><p>Double Hasing 상세한 내용</p><ul><li>하나의 해시 함수(Hash Function)에서 충돌이 발생하면 2차 해시 함수를 이용해 검색 이동 거리를 얻는 방법</li><li>캐시 효율은 떨어지지만 클러스터링(Clustering)에 영향을 거의 받지 않음</li><li>가장 많은 연산량을 요구</li></ul></li></ul><br><hr><a href=#java-hash-collision><h3 id=java-hash-collision><span class=hanchor arialabel=Anchor># </span>Java Hash collision</h3></a><p><a href=https://d2.naver.com/helloworld/831311 target=_blank>Naver D2의 Java HashMap은 어떻게 동작하는가?</a> 필수로 보기</p><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-43.png width=auto alt></p><ul><li>각각의 Key 값에 해시함수 적용 이후 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하는데, 이때 <mark><strong>내부적으로 저장되는 배열을 버킷</strong></mark>이라고 함</li><li>서로 다른 key 들이 같은 hash를 가지는 경우 충돌함</li></ul><br><p><strong>HashTable 에서의 충돌</strong></p><ul><li><code>hf(key1) != hf(key2)</code> 이지만, <code>hf(key1) % M == hf(key2) % M</code> 인 경우</li><li>즉, 서로 다른 key에 대하여 제산법을 적용시킨 결과가 동일한 경우</li></ul><br><p><strong>Hash Collision 발생 이유</strong></p><ul><li>완벽한 해시 함수 구현의 어려움<ul><li>Boolean같이 서로 구별되는 객체의 종류가 적거나, Integer, Long, Double 같은 Number 객체는 객체가 나타내려는 값 자체를 해시 값으로 사용할 수 있기 때문에 완전한 해시 함수 대상으로 삼을 수 있음</li><li>하지만 String이나 POJO(plain old java object)에 대하여 완전한 해시 함수를 제작하는 것은 사실상 불가능</li><li>→ 그래서, 보조 해시 함수를 사용하기도 함</li></ul></li><li>key의 크기에 비해, hash table의 크기가 작기 때문</li></ul><br><p><mark><strong>Java에서의 Hash Collision 해결</strong></mark></p><ul><li>JDK 7 이전 : LinkedList를 사용한 <strong>Separata Chaining 활용</strong></li><li>JDK 8 이후 : LinkedList와 Red-Black Tree를 혼용한 <strong>Separata Chaining 활용</strong><ul><li>충돌을 한 key-value 쌍이 적을 때 : LinkedList로 작동</li><li>충돌을 한 key-value 쌍이 임계치에 도달 : Red-Black Tree로 작동</li></ul></li><li>LinkedList의 최악은 $O(N)$ 이지만, RBT의 최악은 $O(log n)$ 이니까 성능적으로 개선됐다고 볼 수 있음</li></ul><p><img src=https://shin-jae-yoon.github.io//brain/image/dataStructure-46.png width=auto alt></p><ul><li>JDK 8에서는 슬롯(Slot)의 갯수가 8개 이하일 경우 연결 리스트(Linked List)를 사용하며 그 이상의 경우는 레드 블랙 트리(RBT) 구조를 사용하여 검색의 효율을 높임</li><li> <strong>부하율(Load Factor, 전체 버킷에서 사용중인 버킷의 비율)이 100%에 가까울수록 삽입, 삭제, 검색의 효율이 비약적으로 낮아진다</strong>는 설명을 위에서 했었는데, 보통 80%로 제한한다.<ul><li>Java의 HashMap의 경우에는 75%로 제한한다.</li></ul></li></ul><hr><a href=#hashmap><h3 id=hashmap><span class=hanchor arialabel=Anchor># </span>HashMap</h3></a><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.HashMap</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Main</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>HashMap</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span> <span class=n>V</span><span class=o>&gt;</span> <span class=n>m</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>m.put(K, V)</code> : HashMap에 쌍(Key, Value) 추가</li><li><code>m.remove(K)</code> : key가 K인 쌍을 찾아서 제거</li><li><code>m.get(K)</code> : key가 K인 쌍을 찾아서 value인 V를 반환<ul><li><code>m.containsKey(K)</code> 를 확인하여 true 인 경우에만 get을 사용</li><li>해당하는 쌍이 없으면 에러가 발생하기 때문</li><li><code>m.getOrDefault(K, D)</code> 쓰면 해당하는 쌍이 없으면 D를 기본으로 반환해줌</li></ul></li></ul><style>.github-comment{border-top:1px solid rgba(128,128,128,.344);margin-top:7em}.utterances{margin-top:2em!important}</style><div class=github-comment><blockquote><h3>Comment</h3></blockquote><script src=https://utteranc.es/client.js repo=Shin-Jae-Yoon/Shin-Jae-Yoon.github.io issue-term=pathname label=utterances theme=github-light crossorigin=anonymous async></script></div></div><div class=single-aside-box><aside class=single-aside><div class=single-graph-container id=footer><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><div class=graph-header><p>Interactive Graph</p><button class=expand-btn id=expand-btn><i class="fa-solid fa-up-right-and-down-left-from-center"></i></button></div><div id=graph-container></div><style>:root{--g-node:var(--graphNode);--g-node-active:var(--graphNodeActive);--g-node-inactive:var(--graphNodeInactive);--g-link:var(--graphLink);--g-link-active:var(--graphLinkActive)}</style><script src=https://shin-jae-yoon.github.io/js/graph.c7d31393238aa9f7cc8094b9bcd520cf.js></script></div></div><aside class=asideTOC id=asideTOC><div class=toc-header><a href=# id=asideTocTitle>ON THIS PAGE</a></div><nav id=TableOfContents><ul><li><a href=#arraylist>ArrayList</a></li><li><a href=#linkedlist>LinkedList</a><ul><li><a href=#single-linked-list>Single Linked List</a></li><li><a href=#double-linked-list>Double Linked List</a></li><li><a href=#iterator>Iterator</a></li><li><a href=#circular-linked-list>Circular Linked List</a></li></ul></li><li><a href=#stack>Stack</a></li><li><a href=#queue>Queue</a></li><li><a href=#deque>Deque</a></li><li><a href=#vector-stack-권장하지-않는-이유>Vector, Stack 권장하지 않는 이유</a></li><li><a href=#tree>Tree</a><ul><li><a href=#binary-tree>Binary Tree</a></li><li><a href=#binary-search-tree>Binary Search Tree</a></li><li><a href=#heap>Heap</a></li></ul></li><li><a href=#hasing>Hasing</a><ul><li><a href=#hash-collision>Hash collision</a></li><li><a href=#java-hash-collision>Java Hash collision</a></li><li><a href=#hashmap>HashMap</a></li></ul></li></ul></nav></aside></aside></div><script>scroll_init()</script></div><div class=btn-absolute><button class=top-btn>
<i class="top-btn-img fa-solid fa-arrow-up"></i></button>
<button class=mobile-expand-btn id=expand-btn2>
<i class="fa-solid fa-diagram-project"></i></button></div><script>btn_init(),document.querySelector(".top-btn").addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})</script><script>global_init()</script></div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><div id=contact_buttons><footer><div class=contact-left><p style=margin-bottom:0>Made by Dev Uni using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><p style=margin-top:0><a href=https://github.com/Shin-Jae-Yoon/Shin-Jae-Yoon.github.io>Dev Uni</a> has customized it by adding a features.</p><div class=contact-left-img><a href=https://pages.github.com/><img src=/images/logo-ghpages.png></a></div></div><div class=contact-right><div class=contact-right-flex><div class=contact-right-mountain><img src=/images/logo-contact.png></div><div class=contact-right-flexitem><a href=https://github.com/Shin-Jae-Yoon><img src=/images/logo-contact-github.png><p>Github</p></a></div><div class=contact-right-flexitem><a href=https://jae-yoon.tistory.com/><img src=/images/logo-contact-tistory.png><p>Tistory</p></a></div><div class=contact-right-flexitem><a href=https://open.kakao.com/o/sBqoUA7e><img src=/images/logo-message.png><p>Message</p></a></div></div></footer></div><script src=https://shin-jae-yoon.github.io/js/graph.c7d31393238aa9f7cc8094b9bcd520cf.js></script></body></html>