<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="단편적 지식을 통합된 지식으로"><meta property="og:type" content="website"><meta property="og:url" content="https://shin-jae-yoon.github.io/"><meta property="og:site_name" content="개발자 유니의 두 번째 뇌"><meta property="og:title" content="개발자 유니의 두 번째 뇌"><meta property="og:description" content="단편적 지식을 통합된 지식으로"><meta property="og:image" content="https://img1.daumcdn.net/thumb/C428x428/?scode=mtistory2&fname=https%3A%2F%2Ftistory4.daumcdn.net%2Ftistory%2F5252507%2Fattach%2F9c3ad58fd9d24ab486b8a4258ba525d2"><meta property="og:article:author" content="유니"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@TISTORY"><meta property="twitter:title" content="개발자 유니의 두 번째 뇌"><meta property="twitter:description" content="단편적 지식을 통합된 지식으로"><meta property="twitter:image" content="https://img1.daumcdn.net/thumb/C428x428/?scode=mtistory2&fname=https%3A%2F%2Ftistory4.daumcdn.net%2Ftistory%2F5252507%2Fattach%2F9c3ad58fd9d24ab486b8a4258ba525d2"><meta name=naver-site-verification content="9e162597b5777707f80d8478ef502c5224430d43"><script async src="https://www.googletagmanager.com/gtag/js?id=G-GJFBQJ80N7"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GJFBQJ80N7")</script><title>개발자 유니의 두 번째 뇌</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://shin-jae-yoon.github.io//icon.png><link href=https://shin-jae-yoon.github.io/styles.457db6eb0cd3fc8992da6c4450ca2f65.min.css rel=stylesheet><link href=https://shin-jae-yoon.github.io/styles/_light_syntax.b3cdc1af6c90d5fc7e05ca6e6e6f3e60.min.css rel=stylesheet id=theme-link><script src=https://shin-jae-yoon.github.io/js/util.9f16e8e6e851e38941fee1829bbdba7e.min.js></script>
<script src=https://shin-jae-yoon.github.io/js/scroll.52aeab67b8d227b2efd1fac96d97bde6.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script async src=https://shin-jae-yoon.github.io/js/popover.b71dd27f329bec6e58788f7b5d4fc3f7.min.js></script>
<script defer src=https://shin-jae-yoon.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://shin-jae-yoon.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://shin-jae-yoon.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://shin-jae-yoon.github.io/",fetchData=Promise.all([fetch("https://shin-jae-yoon.github.io/indices/linkIndex.d7acd49e6fed8cc73de7e03acb8508b1.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://shin-jae-yoon.github.io/indices/contentIndex.3e37f7e3b2690416f3cd36a2f4c27e2d.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const t=new URL(BASE_URL),n=t.pathname+"brain/",s=window.location.pathname,e=n==s;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://shin-jae-yoon.github.io",!0);const o=document.getElementById("footer");if(o){const t=document.getElementById("graph-container");if(!t)return requestAnimationFrame(render);t.textContent="";const n=e&&!0;drawGraph("https://shin-jae-yoon.github.io",n,[{"/moc":"#4388cc"}],n?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:.5,scale:.4}:{centerForce:5,depth:2,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:2.5,repelForce:1,scale:1.5})}const i=document.getElementById("footer2");if(i){const t=document.getElementById("graph-container2");if(!t)return requestAnimationFrame(render);t.textContent="";const n=e&&!0;drawGraph2("https://shin-jae-yoon.github.io",n,[{"/moc":"#4388cc"}],n?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:.5,scale:.4}:{centerForce:5,depth:2,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:2.5,repelForce:1,scale:1.5})}var a=document.getElementsByClassName("mermaid");a.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/shin-jae-yoon.github.io\/js\/router.e4f749984b89f35680b8cfadddf2b482.min.js"
    attachSPARouting(init, render)
  </script><script src=https://kit.fontawesome.com/1f943b0307.js crossorigin=anonymous></script>
<link href=https://webfontworld.github.io/BMJua/BMJua.css rel=stylesheet><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@300;400;700&display=swap" rel=stylesheet></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder=" 검색어를 입력하세요 "><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://shin-jae-yoon.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=nav-header-container><header><h1 id=page-title><a href=https://shin-jae-yoon.github.io/>Dev Uni</a></h1><li><a href=https://shin-jae-yoon.github.io/>Home</a></li><li><a href=https://shin-jae-yoon.github.io/about/>About</a></li><li><a href=https://shin-jae-yoon.github.io/brain/>Brain</a></li><li><a href=https://shin-jae-yoon.github.io/project/>Project</a></li><div id=search-icon><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg><p>Search<span style=vertical-align:middle;margin-left:1em>⌘</span> + k</p></div></ul></header></div><div class=singlePage style=padding:0;margin:0;width:100%><div class=blur-element></div><div class="section-container single-container"><div class=expand-graph-container id=footer2><i class="fa-solid fa-x" id=expand-close-btn></i><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><div id=graph-container2></div><style>:root{--g-node:var(--graphNode);--g-node-active:var(--graphNodeActive);--g-node-inactive:var(--graphNodeInactive);--g-link:var(--graphLink);--g-link-active:var(--graphLinkActive)}</style><script src=https://shin-jae-yoon.github.io/js/graph.6705788a3699b0ba2156c57e629980a4.js></script></div></div><div class=section-menu-btn><i class="fa-solid fa-bars"></i></div><div class="main-aside-box disabled"><aside class=main-aside><div class=menu-nav-header><li><a href=https://shin-jae-yoon.github.io/>Home</a></li><li><a href=https://shin-jae-yoon.github.io/about/>About</a></li><li><a href=https://shin-jae-yoon.github.io/project/>Project</a></li></div><div class=menu-content-header><a class=menu-content-header-btn href=https://shin-jae-yoon.github.io/brain/>📚 Brain</a>
<button class=collapse-btn><i class="fa-solid fa-arrow-down-up-across-line"></i></button></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Java</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Java/Java/ class=page-link style=display:block;width:100%>Java</a></div></li><li><div class=wrapper-link><a href=/brain/Java/java-settings/ class=page-link style=display:block;width:100%>Java 환경설정</a></div></li><li><div class=wrapper-link><a href=/brain/Java/JavaVersion/ class=page-link style=display:block;width:100%>Java 버전별 특징</a></div></li><li><div class=wrapper-link><a href=/brain/Java/JavaExecute/ class=page-link style=display:block;width:100%>Java 실행원리</a></div></li><li><div class=wrapper-link><a href=/brain/Java/JVM/ class=page-link style=display:block;width:100%>JVM</a></div></li><li><div class=wrapper-link><a href=/brain/Java/GC/ class=page-link style=display:block;width:100%>Garbage Collector</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Spring</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Database</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Infra</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Common</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Common/API/ class=page-link style=display:block;width:100%>API</a></div></li><li><div class=wrapper-link><a href=/brain/Common/RESTAPI/ class=page-link style=display:block;width:100%>REST API</a></div></li><li><div class=wrapper-link><a href=/brain/Common/RESTfulAPI/ class=page-link style=display:block;width:100%>RESTful API</a></div></li><li><div class=wrapper-link><a href=/brain/Common/Library/ class=page-link style=display:block;width:100%>라이브러리</a></div></li><li><div class=wrapper-link><a href=/brain/Common/Framework/ class=page-link style=display:block;width:100%>프레임워크</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Computer Science</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Algorithm</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Data Structure</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Network</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/Network/Socket/ class=page-link style=display:block;width:100%>소켓</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Computer Architecture</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/CA/ComputerArchitecture/ class=page-link style=display:block;width:100%>컴퓨터구조</a></div></li><li><div class=wrapper-link><a href=/brain/CS/CA/CpuArchitecture/ class=page-link style=display:block;width:100%>CPU 아키텍처</a></div></li><li><div class=wrapper-link><a href=/brain/CS/CA/ISA/ class=page-link style=display:block;width:100%>ISA</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Operating System</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/OS/Scheduling/ class=page-link style=display:block;width:100%>스케줄링</a></div></li><li><div class=wrapper-link><a href=/brain/CS/OS/SystemCall/ class=page-link style=display:block;width:100%>시스템콜</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Language Theory</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/CS/LT/LanguageTheory/ class=page-link style=display:block;width:100%>프로그래밍 언어론</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/BNF/ class=page-link style=display:block;width:100%>BNF</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/EBNF/ class=page-link style=display:block;width:100%>EBNF</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/Lex/ class=page-link style=display:block;width:100%>Lex</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/Yacc/ class=page-link style=display:block;width:100%>Yacc</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/SyntaxTable/ class=page-link style=display:block;width:100%>구문도표</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/Interpreter/ class=page-link style=display:block;width:100%>인터프리터</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/Compile/ class=page-link style=display:block;width:100%>컴파일</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/Compiler/ class=page-link style=display:block;width:100%>컴파일러</a></div></li><li><div class=wrapper-link><a href=/brain/CS/LT/ParseTree/ class=page-link style=display:block;width:100%>파스 트리</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Interview</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>개발바닥 면접스터디</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-study/ class=page-link style=display:block;width:100%>개발바닥 면접스터디</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week01/ class=page-link style=display:block;width:100%>1주차 - 불변객체, Exception</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week02/ class=page-link style=display:block;width:100%>2주차 - Exception Handling</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week03/ class=page-link style=display:block;width:100%>3주차 - Spring 기본</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week04/ class=page-link style=display:block;width:100%>4주차 - Spring 웹</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week05/ class=page-link style=display:block;width:100%>5주차 - Spring 응용</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week06/ class=page-link style=display:block;width:100%>6주차 - Spring Data</a></div></li><li><div class=wrapper-link><a href=/brain/Interview/dog-study/dog-week07/ class=page-link style=display:block;width:100%>7주차 - Spring 트랜잭션</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>기술면접 - Java</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>기술면접 - Spring</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>기술면접 - DB</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>기술면접 - 자료구조</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>기술면접 - 알고리즘</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>기술면접 - 네트워크</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>기술면접 - 운영체제</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>기술면접 - 공통</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>강의</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>김영한 - Spring</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>스프링 입문</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/kim-spring/spring-basic/spring-basic/ class=page-link style=display:block;width:100%>스프링 입문 - 목차</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/kim-spring/spring-basic/spring-basic-01/ class=page-link style=display:block;width:100%>섹션0 - 섹션3</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/kim-spring/spring-basic/spring-basic-02/ class=page-link style=display:block;width:100%>섹션4 - 섹션8</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>김영한 - JPA</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>부부개발단 - Java</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/fun-java/fun-java/ class=page-link style=display:block;width:100%>개요. 즐거운 자바</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fun-java/fun-java01/ class=page-link style=display:block;width:100%>01. Java 시작</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fun-java/fun-java02/ class=page-link style=display:block;width:100%>02. Java 기본 문법</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fun-java/fun-java03/ class=page-link style=display:block;width:100%>03. 객체지향 1/3</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fun-java/fun-java04/ class=page-link style=display:block;width:100%>04. 객체지향 2/3</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fun-java/fun-java05/ class=page-link style=display:block;width:100%>05. 객체지향 3/3</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fun-java/fun-java06/ class=page-link style=display:block;width:100%>06. 배열과 Arrays 클래스</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fun-java/fun-java07/ class=page-link style=display:block;width:100%>07. 제네릭과 컬렉션</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fun-java/fun-java08/ class=page-link style=display:block;width:100%>08. 주석문, 예외처리, enum</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>패캠 - 알고리즘</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/fastcampus-algo/ps/ class=page-link style=display:block;width:100%>문제풀이 현황</a></div></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Part 1 - Part 4</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/fastcampus-algo/part1-4/p1-ch00/ class=page-link style=display:block;width:100%>Part1 - Part4 강의소개</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fastcampus-algo/part1-4/p1-ch01/ class=page-link style=display:block;width:100%>Part1 - Ch01 문자열</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fastcampus-algo/part1-4/p1-ch02/ class=page-link style=display:block;width:100%>Part1 - Ch02 시간복잡도</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fastcampus-algo/part1-4/p1-ch03/ class=page-link style=display:block;width:100%>Part1 - Ch03 배열</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Part 5 - 단기완성</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/fastcampus-algo/part5/p5-ch00/ class=page-link style=display:block;width:100%>Part5 - Ch00 강의준비</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/fastcampus-algo/part5/p5-ch01/ class=page-link style=display:block;width:100%>Part5 - Ch01 완전탐색</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Part 6 - SQL</a><div class=a-wrapper><div class=arrow></div></div></div><ul></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>코딩애플 강의</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>코딩애플 - Git</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/apple/apple-git/apple-git/ class=page-link style=display:block;width:100%>코딩애플 git</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>코딩애플 - HTML/CSS</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/apple/apple-html/all-in-one/ class=page-link style=display:block;width:100%>All-in-One 강의노트</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/apple/apple-html/all-in-one-basic/ class=page-link style=display:block;width:100%>All-in-One 기초모듈</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/apple/apple-html/all-in-one-mid/ class=page-link style=display:block;width:100%>All-in-One 중급모듈</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/apple/apple-html/all-in-one-last/ class=page-link style=display:block;width:100%>All-in-One 고급모듈</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>코딩애플 - JavaScript</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/apple/apple-js/apple-js/ class=page-link style=display:block;width:100%>Javascript 입문과 웹 UI 개발</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/apple/apple-js/apple-js-01/ class=page-link style=display:block;width:100%>LEVEL 01</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/apple/apple-js/apple-js-02/ class=page-link style=display:block;width:100%>LEVEL 02</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/apple/apple-js/apple-js-03/ class=page-link style=display:block;width:100%>LEVEL 03</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/apple/apple-js/js-library/ class=page-link style=display:block;width:100%>js-library</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>잔재미코딩 - Python</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny/ class=page-link style=display:block;width:100%>파이썬입문과 크롤링기초 부트캠프</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny01/ class=page-link style=display:block;width:100%>01 - 파이썬 입문</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny02/ class=page-link style=display:block;width:100%>02 - 변수,출력</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny03/ class=page-link style=display:block;width:100%>03 - String</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny04/ class=page-link style=display:block;width:100%>04 - List</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny05/ class=page-link style=display:block;width:100%>05 - Tuple</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny06/ class=page-link style=display:block;width:100%>06 - Dictionary</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny07/ class=page-link style=display:block;width:100%>07 - Set</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny08/ class=page-link style=display:block;width:100%>08 - Bool</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny09/ class=page-link style=display:block;width:100%>09 - 변수심화</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny10/ class=page-link style=display:block;width:100%>10 - Condition</a></div></li><li><div class=wrapper-link><a href=/brain/Lecture/funny-python/funny11/ class=page-link style=display:block;width:100%>11 - for문</a></div></li></ul></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>도서</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Java의 정석</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Book/java-jungseok/java-jungseok/ class=page-link style=display:block;width:100%>자바의 정석</a></div></li></ul></li><li class=folder><div class=wrapper><a href=javascript:void(0) class=title>Do it! 자바 프로그래밍</a><div class=a-wrapper><div class=arrow></div></div></div><ul><li><div class=wrapper-link><a href=/brain/Book/do-it-java/do-it-java/ class=page-link style=display:block;width:100%>Do it! 자바 프로그래밍 입문</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap01/ class=page-link style=display:block;width:100%>01.자바 프로그래밍</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap02/ class=page-link style=display:block;width:100%>02.변수와 자료형</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap03/ class=page-link style=display:block;width:100%>03.자바의 연산자</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap04/ class=page-link style=display:block;width:100%>04.제어문</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap05/ class=page-link style=display:block;width:100%>05.클래스와 객체 (1)</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap06/ class=page-link style=display:block;width:100%>06.클래스와 객체 (2)</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap07/ class=page-link style=display:block;width:100%>07.배열과 ArrayList</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap08/ class=page-link style=display:block;width:100%>08.상속과 다형성</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap09/ class=page-link style=display:block;width:100%>09.추상 클래스</a></div></li><li><div class=wrapper-link><a href=/brain/Book/do-it-java/chap10/ class=page-link style=display:block;width:100%>10.인터페이스</a></div></li></ul></li></ul></li></ul></aside><script src=https://shin-jae-yoon.github.io/js/menu.00c2c8e61ed4afe7893759f1132a5ec0.js></script></div><div class=single-content><h1>5주차 - Spring 응용</h1><p class=meta>Last updated -
2023년 03월 25일
<a href=https://github.com/Shin-Jae-Yoon/Shin-Jae-Yoon.github.io/tree/hugo/content/brain/Interview/dog-study/dog-week05.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>ON THIS PAGE</summary><nav id=TableOfContents><ul><li><a href=#spring-bean>Spring Bean</a><ul><li><a href=#bean을-쓰지-않는-경우-문제점>Bean을 쓰지 않는 경우 문제점</a></li><li><a href=#bean-생명주기>Bean 생명주기</a></li><li><a href=#bean-스코프>Bean 스코프</a></li><li><a href=#bean-설정-시-주의점>Bean 설정 시 주의점</a></li></ul></li><li><a href=#싱글턴>싱글턴</a><ul><li><a href=#싱글턴-패턴의-순수한-구현>싱글턴 패턴의 순수한 구현</a></li><li><a href=#동기화synchronized>동기화(Synchronized)</a></li><li><a href=#dcl>DCL</a></li><li><a href=#bill-pugh-solution>Bill Pugh Solution</a></li><li><a href=#enum>Enum</a></li><li><a href=#권장-방법>권장 방법</a></li><li><a href=#정적-클래스>정적 클래스</a></li><li><a href=#spring-싱글턴>Spring 싱글턴</a></li></ul></li><li><a href=#annotation>Annotation</a><ul><li><a href=#java-annotation>Java Annotation</a></li><li><a href=#meta-annotation>Meta Annotation</a></li><li><a href=#spring-annotation>Spring Annotation</a></li></ul></li><li><a href=#spring-mvc>Spring MVC</a><ul><li><a href=#모델1>모델1</a></li><li><a href=#모델2--mvc패턴>모델2 = MVC패턴</a></li><li><a href=#mvc-흐름>MVC 흐름</a></li><li><a href=#mvc-장점>MVC 장점</a></li><li><a href=#mvc-주의-포인트>MVC 주의 포인트</a></li><li><a href=#서비스가-커질수록>서비스가 커질수록</a></li><li><a href=#service>Service</a></li><li><a href=#repository>Repository</a></li></ul></li><li><a href=#layered-architecture>Layered Architecture</a><ul><li><a href=#presentation-layer>Presentation Layer</a></li><li><a href=#business-layer>Business Layer</a></li><li><a href=#persistence-layer>Persistence Layer</a></li><li><a href=#spring-layered-architecture>Spring Layered Architecture</a></li><li><a href=#레이어드-아키텍처-확장>레이어드 아키텍처 확장</a></li></ul></li><li><a href=#참고>참고</a></li></ul></nav></details></aside><hr><blockquote class=note-callout><p>5주차 스터디</p><p><strong>TOPIC</strong><br></p><ul><li>Bean 정의<ul><li>생명주기</li><li>스코프</li></ul></li><li>싱글턴 vs 스프링 싱글턴</li><li>Annotation</li><li>Spring Annotation</li><li>MVC 패턴<ul><li>MVVM MVP MVI</li></ul></li><li>레이어드 아키텍쳐</li></ul></blockquote><br><a href=#spring-bean><h2 id=spring-bean><span class=hanchor arialabel=Anchor># </span>Spring Bean</h2></a><ul><li><mark><strong>Spring Bean : Spring IoC Container가 관리하는 객체</strong></mark></li><li><mark><strong>Spring IoC Continaer : Spring Bean을 관리하는 객체</strong></mark></li></ul><p>Spring Bean 이 왜 필요할까?</p><ul><li>Spring IoC Container가 특정 객체 Lifecycle을 관리한다는 것을 나타내기 위하여</li></ul><p>Spring IoC Container는 왜 Bean을 관리하는 것일까?</p><ul><li>의존성을 자동 주입하여 개발자들이 해당 의존성을 사용하는 로직에만 집중할 수 있도록 도와주는 역할</li><li>의존성을 주입할 때 사용되는 객체가 항상 동일함을 보장하기 위해</li></ul><br><a href=#bean을-쓰지-않는-경우-문제점><h3 id=bean을-쓰지-않는-경우-문제점><span class=hanchor arialabel=Anchor># </span>Bean을 쓰지 않는 경우 문제점</h3></a><p>객체를 Bean으로 등록하지 않고 직접 의존성 주입을 도입한다면 어떤 문제가 있을까?</p><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Service</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>final</span> <span class=n>Dao</span> <span class=n>dao</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=nf>Service</span><span class=o>(</span><span class=n>Dao</span> <span class=n>dao</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>.</span><span class=na>dao</span> <span class=o>=</span> <span class=n>dao</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Service</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Service</span><span class=o>(</span><span class=k>new</span> <span class=n>JdbcDao</span><span class=o>());</span>
</span></span></code></pre></td></tr></table></div></div><br><p>이렇게 Dao 구현체를 의존성 주입 한다고 하자. 그렇다면 어디에선가 new 키워드를 사용하여 객체를 생성해야 한다. 이때 Dao 구현체가 변경된다면 어떻게 될까?</p><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Service</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Service</span><span class=o>(</span><span class=k>new</span> <span class=n>TestDao</span><span class=o>());</span>
</span></span></code></pre></td></tr></table></div></div><br><p>Service를 생성할 때 의존성 주입으로 Dao를 초기화하면서 어떤 Dao의 구현체를 선택할 것인지에 대한 책임을 가지기 때문에 Service를 생성하는 곳에서도 변경이 일어난다.</p><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Service</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Service</span><span class=o>(</span><span class=k>new</span> <span class=n>Test1Dao</span><span class=o>(),</span> <span class=k>new</span> <span class=n>Test2Dao</span><span class=o>(),</span> <span class=k>new</span> <span class=n>Test3Dao</span><span class=o>());</span>
</span></span></code></pre></td></tr></table></div></div><br><p>또, 이렇게 의존성 주입을 여러 개 하는 경우 해당 의존성 주입의 순서와 관계를 모두 파악해야해서 번거로움이 생긴다.</p><p>따라서, 아래와 같이 Bean을 사용해보자.</p><ul><li>의존성 주입이 필요한 객체를 Bean으로 등록</li><li>스프링 IoC 컨테이너가 객체의 생성과 의존성 주입을 관리하도록 함</li><li>장점 : 개발자가 주입된 의존성 부분에만 집중할 수 있게 됨</li></ul><br><a href=#bean-생명주기><h3 id=bean-생명주기><span class=hanchor arialabel=Anchor># </span>Bean 생명주기</h3></a><p><mark><strong>스프링 IoC 컨테이너 생성 → 스프링 빈 객체 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료</strong></mark></p><br><p>Bean의 Lifecycle의 관리자 => Spring Container</p><ul><li>Bean의 Lifecycle 관련 <strong>callback 메서드를 호출</strong>하여, Bean 객체의 생성, 초기화, 소멸의 Lifecycle을 관리한다.</li><li>callback 메서드 : 어떤 이벤트에 의해 호출되는 함수</li></ul><p>Bean의 Lifecycle에서 callback의 필요성</p><ul><li>Database Connection, 네트워크 소켓 연결 등 시작 지점에 미리 연결한 뒤 애플리케이션 종료 시점에 연결을 종료해야하는 경우 => 객체의 초기화 및 종료 작업이 필요할 것</li><li>예를 들어, Connection Pool의 connect & disconnect</li><li>Spring Bean도 동일한 원리로 <strong>초기화 작업</strong>과 <strong>종료 작업</strong>이 나눠서 진행됨<ul><li>Spring Bean은 의존관계 주입이 끝나야만 사용이 가능하기 때문에 그때 <strong>초기화 콜백 메서드</strong>를 호출해서 사용하는 것이니까. 끝나고 나면 다시 <strong>소멸 전 콜백 메서드</strong>로 종료!</li></ul></li></ul><br><p><strong>Spring이 Bean Lifecycle Callback을 관리하는 방법</strong></p><ul><li>Spring의 인터페이스 (InitializingBean, DisposableBean)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MySpringBean</span> <span class=kd>implements</span> <span class=n>InitializingBean</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=nd>@Override</span>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kt>void</span> <span class=nf>afterPropertiesSet</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><ul><li>JSR-250 애노테이션 지원<ul><li><code>@PostConstruct</code>, <code>@PreDestroy</code> 사용</li><li><mark><strong>Spring에서 Bean 초기화, 소멸 시 권장하는 방식</strong></mark></li><li>단점 : 외부 라이브러리에는 적용 못함</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@PostConstruct</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>postConstruct</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@PreDestroy</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>preDestroy</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><ul><li><code>@Bean</code> 애노테이션에 속성을 추가<ul><li>JSR-250 애노테이션이 외부 라이브러리에는 적용 못하기 때문에 그럴 경우 <code>@Bean</code> 애노테이션에 속성을 추가하는 방식을 사용함</li><li>설정 정보에 초기화 메서드, 종료 메서드 지정</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Bean</span><span class=o>(</span><span class=n>initMethod</span> <span class=o>=</span> <span class=s>&#34;onInitialize&#34;</span><span class=o>,</span> <span class=n>destroyMethod</span> <span class=o>=</span> <span class=s>&#34;onDestroy&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>MySpringBean</span> <span class=nf>mySpringBean</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=k>new</span> <span class=n>MySpringBean</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><br><br></p><details><summary><strong>Bean의 생성 Lifecycle 상세</strong></summary><ol><li>Spring이 Bean 객체를 인스턴스화 한다.</li><li>의존 관계를 주입한다.</li><li><code>BeanNameAware.setBeanName()</code> 메서드를 호출한다.<ul><li>setBeanName의 파라미터로 넘어온 문자열 값으로 빈의 이름 설정</li></ul></li><li><code>BeanFactoryAware.setBeanFactory()</code> 메서드를 호출한다.<ul><li>BeanFactory 객체를 주입하기 위해서 사용</li></ul></li><li><code>ApplicationContextAware.setApplicationContext()</code> 메서드를 호출한다.<ul><li>ApplicationContext 객체를 주입하기 위해서 사용</li></ul></li><li><code>BeanPostProcessor.postProcessBeforeInitialization()</code> 메서드를 호출한다.</li><li><code>@PostConstruct</code>이 붙은 메서드, <code>InitializingBean.afterPropertiesSet()</code> 메서드, <code>@Bean</code>의 initMethod로 지정한 메서드 순서로 호출</li><li><code>BeanPostProcessor.postProcessAfterInitialization()</code> 메서드를 호출한다.</li></ol><p>Q. Bean의 생성과 초기화를 분리하는 이유는?</p><ul><li>생성자에서 초기화라는 무거운 작업을 하는 것보다 분리하여 유지보수에 용이하도록 하기 위하여.</li></ul><p>Q. Spring에서 BeanFactory 컨테이너보다 ApplicationContext를 권장하는 이유?</p><ul><li>BeanFactory는 스프링 컨테이너의 최상위 인터페이스이고 ApplicationContext는 BeanFactory를 상속하여 만들어져서, BeanFactory의 모든 기능을 포함하며 그보다 더 다양한 기능을 제공하기 때문이다.</li></ul></details><br><details><summary><strong>Bean의 소멸 Lifecycle 상세</strong></summary><ol><li>Spring IoC 컨테이너가 종료된다.</li><li><code>@PreDestory</code> 애노테이션이 붙은 메서드, <code>DisposableBean.destroy()</code> 메서드, <code>@Bean</code>의 destroyMethod로 지정한 메서드 순서로 실행된다.</li></ol></details><br><p>Bean의 default 설정은 싱글턴이다. Spring IoC Container에 객체로 Bean을 등록하지 않고 개발자가 객체를 싱글턴으로 만들어서 사용하면 어떤 문제가 있을까?</p><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>DatabaseConnection</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>DatabaseConnection</span> <span class=n>databaseConnection</span> <span class=o>=</span> <span class=k>new</span> <span class=n>DatabaseConnection</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=nf>DatabaseConnection</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=n>DatabaseConnection</span> <span class=nf>getConnection</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>databaseConnection</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><ol><li>다형성을 이용하지 못함. 싱글턴이라서 private을 썼기 때문에 해당 객체는 상속이 불가능하게 됨.</li><li>단위 테스트가 어렵다. 메모리 절약에는 이점이 있겠지만, 해당 객체는 공유 객체가 되므로 단위 테스트를 실행할 때마다 테스트의 순서에 따라 결과가 달라지게 된다.</li></ol><br><p>객체를 싱글턴으로 만들어서 사용했을 때 단점들은 스프링 IoC 컨테이너가 어떻게 해결했을까? 스프링 IoC 컨테이너가 Bean의 LifeCycle을 관리하는 과정을 보면 해답을 찾을 수 있다.</p><ol><li>객체 생성 + property 설정</li><li>의존 설정</li><li>초기화</li><li>사용</li><li>소멸</li></ol><br><p><strong>객체 생성 + property 설정</strong></p><ul><li>Spring IoC 컨테이너가 생성되면 빈 스코프가 싱글턴인 객체를 생성</li><li>Bean으로 등록하기 위해 애노테이션 기반, Java 설정 클래스 기반, xml 기반 등 다양한 configuration 메타 데이터를 이용하여 <strong>통일된 Bean Definition을 생성</strong>한다.</li><li>Bean으로 등록할 POJO + Bean Definition 정보를 이용하여 Bean 생성</li><li>이 과정에서 싱글턴 패턴을 사용하는 것이 아니라 평범한 Java class를 이용하여 객체를 생성</li></ul><p>그리고, Spring IoC Container에는 Singleton Registry 기능이 있다.</p><ul><li>Registry는 CS 전반적으로 사용되는 개념. Key-Value 형태로 데이터를 저장하는 방법</li><li>Spring IoC Container는 Bean Scope가 Singleton인 객체에 <strong>Bean의 이름을 Key, 객체를 Value로 저장</strong>한다.</li><li>의존성이 주입되어야하는 <strong>객체가 빈으로 등록되어 있을 때 Spring은 빈의 이름을 이용하여 항상 동일한 Single Object를 반환하게 되는 것</strong></li></ul><br><p><strong>의존 설정</strong></p><ul><li>Bean 객체가 생성되면 IoC 컨테이너가 의존 설정을 함</li><li>이 과정에서 의존성이 자동 주입되게 된다.</li></ul><br><p><strong>겍체 초기화, 사용, 소멸</strong></p><ul><li>초기화 : 모든 객체가 초기화 될 필요는 없고, Connection Pool처럼 사용전에 초기화 과정이 필요한 객체들이 초기화 됨</li><li>사용 : 초기화가 끝나면 Bean을 사용할 수 있음</li><li>소멸 : Spring Container가 종료될 때 Bean scope가 싱글턴인 객체들도 함께 소멸</li></ul><br><a href=#bean-스코프><h3 id=bean-스코프><span class=hanchor arialabel=Anchor># </span>Bean 스코프</h3></a><p><mark><strong>Bean 스코프 : 빈이 생성되고 존재하고 적용되는 범위를 지정할 수 있는 것</strong></mark></p><ul><li><p><code>@Scope</code> 애노테이션을 사용하여 설정 가능</p></li><li><p>default 타입은 싱글턴 타입</p></li><li><p>싱글턴</p><ul><li>Spring Framework의 default scope</li><li>Spring Continaer 시작과 종료까지 1개의 객체로 유지</li><li>빈 스코프를 싱글턴으로 설정할 경우 상태를 가지면 안된다.<ul><li>싱글턴 스코프의 빈이 value라는 상태를 가지고 있고 Thread 1이 value의 값을 증가시키고 Thread 2가 value라는 값을 가져와서 사용한다고 가정해보면, 해당 빈의 상태를 항상 예측할 수 없어서 의도한 결과가 항상 나온다고 보장할 수 없게 된다.</li></ul></li><li>Spring이 시작할 때 생성됨</li></ul></li><li><p>프로토타입</p><ul><li>빈의 생성, 의존관계 주입, 초기화까지만 관여하고 이후에는 컨테이너에서 관리하지 않는 스코프</li><li>이 때문에 매번 요청마다 새로 만들어진다.<ul><li>모든 스레드에서 공유하는 것이 아니므로 싱글턴과는 다르게 해당 객체는 상태를 가질 수 있다.</li></ul></li><li>요청할 때 생성됨</li></ul></li><li><p>웹 스코프</p><ul><li>request : 각 요청이 들어오고 나갈때까지 유지</li><li>session : 세션이 생성되고 종료될때까지 유지</li><li>application : 웹의 서블릿 컨텍스트와 동일한 생명주기를 갖는 스코프<ul><li>서블릿 컨텍스트는 <strong>web application내에 있는 모든 서블릿들을 관리하며 정보공유할 수 있게 도와 주는 역할</strong> 을 하는데, 톰캣 컨테이너가 실행 시 애플리케이션 하나당 한개의 서블릿컨텍스트가 생성된다.</li><li>생명 주기는 보통 톰캣의 시작과 종료와 일치한다.</li></ul></li></ul></li></ul><br><a href=#bean-설정-시-주의점><h3 id=bean-설정-시-주의점><span class=hanchor arialabel=Anchor># </span>Bean 설정 시 주의점</h3></a><ol><li>빈 스코프를 싱글턴으로 설정할 경우 상태를 가지면 안된다.</li><li>의존성을 자동 주입해야 할 인터페이스에 구현체가 두 개 이상이라면, Spring은 어떤 구현체를 자동 주입할 지 정하지 못해서 충돌이 발생함.</li></ol><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Repository</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>InMemoryStationDao</span> <span class=kd>implements</span> <span class=n>StationDao</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Repository</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>JdbcStationDao</span> <span class=kd>implements</span> <span class=n>StationDao</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Service</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>StationService</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>final</span> <span class=n>StationDao</span> <span class=n>stationDao</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=nf>StationService</span><span class=o>(</span><span class=kd>final</span> <span class=n>StationDao</span> <span class=n>stationDao</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>.</span><span class=na>stationDao</span> <span class=o>=</span> <span class=n>stationDao</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 둘 중 어떤 구현체를 넣어야 할 지 Spring은 모른다
</span></span></span></code></pre></td></tr></table></div></div><br>이 경우, 애노테이션을 이용하여 의존성 주입 시 우선순위를 정할 수 있음.<ol><li>의존성을 자동 주입해야 하는 구현체가 하나인 경우<ul><li><code>@Primary</code> 애노테이션</li></ul></li><li>상황에 따라 다른 구현체를 자동 주입 되도록<ul><li><code>@Qualifier</code> 애노테이션</li></ul></li></ol><p><a href=/brain/Interview/dog-study/dog-week03 target=_blank>3주차 - Spring 기본 # 주입하고자 하는 의존성이 여러 개 참고</a></p><br><a href=#싱글턴><h2 id=싱글턴><span class=hanchor arialabel=Anchor># </span>싱글턴</h2></a><p>프로그램 전역에서 사용되는 유일한 클래스를 만드는 방법이 <strong>싱글턴 패턴, 정적 클래스</strong>이다.</p><p>싱글턴 패턴 : 디자인 패턴 중 하나로, <mark><strong>객체 인스턴스가 오로지 한 개만 생성 되도록 설계하는 패턴이다.</strong></mark> 따라서, 애플리케이션 내에서 인스턴스가 유일해야 한다.</p><hr><a href=#싱글턴-패턴의-순수한-구현><h3 id=싱글턴-패턴의-순수한-구현><span class=hanchor arialabel=Anchor># </span>싱글턴 패턴의 순수한 구현</h3></a><ul><li>인스턴스를 private static 변수</li><li><code>getInstance()</code>에서 인스턴스 생성</li><li>외부 생성자를 private으로 막는다.</li><li>문제점 : Thread-safe하지 않다.</li></ul><br><details><summary><strong>상세 설명 보기</strong></summary><ul><li>클래스의 인스턴스를 정적 필드에 저장 (<code>private static 변수</code>)</li><li>정적 메서드로 <code>getInstance()</code>에서 인스턴스 생성<ul><li>사용자가 인스턴스를 요청할 때마다 만약에 인스턴스가 존재하지 않으면 만들어서 반환하고 존재한다면 인스턴스를 반환</li></ul></li><li>외부에서 인스턴스를 생성할 수 없도록 생성자를 private으로 막음</li></ul></details><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Settings</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=n>Settings</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=nf>Settings</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=n>Settings</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=o>(</span><span class=n>instance</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=n>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Settings</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>하지만, 이와 같은 구현은 <mark>멀티 스레드 환경에서 싱글턴이 보장되지 않는다. 즉, Thread-safe 하지 않다는 의미이다.</mark></p><p>스레드 A와 B가 동시에 요청을 보낸 상황</p><ul><li>A가 if문을 통과하여 인스턴스를 생성하기 전에 B도 통과한다고 가정해보자. 그러면 각각 다른 인스턴스가 생길 가능성이 존재한다.</li></ul><hr><a href=#동기화synchronized><h3 id=동기화synchronized><span class=hanchor arialabel=Anchor># </span>동기화(Synchronized)</h3></a><ul><li>인스턴스를 private static 변수</li><li><strong>synchronized</strong> <code>getInstance()</code></li><li>외부 생성자를 private으로 막는다.</li><li>문제점 : 리소스 낭비</li></ul><details><summary><strong>상세 설명 보기</strong></summary><ul><li>위와 같은 문제를 해결하기 위해 synchronized 키워드를 이용한 동시성 문제 해결</li><li>현재 메서드를 사용하고 있는 스레드를 제외하고 나머지 스레드가 메서드에 접근할 수 없도록 막아준다.</li></ul></details><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Settings</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=n>Settings</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=nf>Settings</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>synchronized</span> <span class=kd>static</span> <span class=n>Settings</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=o>(</span><span class=n>instance</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=n>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Settings</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>하지만, 이와 같은 구현은 <mark>리소스가 낭비된다</mark>는 단점이 있다. 멀티 스레드 환경에서 인스턴스를 하나만 만들기 위해서 synchronized 키워드를 사용했는데, 인스턴스가 존재하는 경우에는 더이상 필요 없기 때문이다.</p><ul><li>괜히, 메서드를 실행할 때마다 Lock이 걸리게 되어 리소스 낭비가 발생</li></ul><hr><a href=#dcl><h3 id=dcl><span class=hanchor arialabel=Anchor># </span>DCL</h3></a><p>DCL(Double Checked Locking)은 두 번 체크하여 리소스 낭비를 줄여본 버전이다.</p><ul><li><strong>synchronized 시점 지연</strong></li><li>private static <strong>volatile</strong> 인스턴스</li><li>외부 생성자를 private으로 막는다.</li><li>문제점 : volatile 키워드</li></ul><details><summary><strong>상세 설명 보기</strong></summary><ul><li>현재, <code>getInstance()</code> 메서드를 호출할 때마다 인스턴스가 있을 때는 synchronized 블록이 스킵되는 것이다. 즉시 인스턴스만 반환하게 되어 리소스 낭비를 없앨 수 있다.</li><li>이때, 클래스 변수에 정의해놨던 인스턴스를 <code>volatile</code> 키워드를 사용해야 한다.</li></ul></details><br><details><summary><strong>volatile 키워드?</strong></summary><p>원래, 스레드를 이용하게 되면 각각의 스레드는 성능을 위하여 CPU 레지스터의 캐시 메모리를 사용하게 된다. 첫 번째 스레드 -> 캐시 메모리 -> 메인 메모리 순서로 값을 대입한다면, 다음 스레드는 메인 메모리에 담긴 값을 메인 메모리 -> 캐시 메모리 -> 두 번째 스레드 순서로 가져온다.</p><p>문제는, 첫 번째 스레드가 메인 메모리에 값을 넣기 이전인 상황에 두 번째 스레드가 메인 메모리에서 값을 읽으려고 할 때 발생한다. 이때 volatile 키워드를 사용하면 대입과 읽는 것 모두 메인 메모리에서 하도록 만들어서 시간차를 극복할 수 있다.</p><p>Java에서 volatile 키워드는 변수의 값을 다른 스레드에서 <strong>변경할 수 있도록</strong> 하며, 클래스를 thread-safe하게 만드는 데 사용된다. 이는 여러 스레드가 동시에 메소드와 클래스 인스턴스를 사용할 수 있게 하고 문제가 발생하지 않도록 한다. volatile 키워드는 기본형 혹은 객체와 함께 사용할 수 있다.</p><p>volatile 키워드는 상호배제(mutual exclusion)를 제공하지 않고도 데이터 변경의 가시성(visibility) 측면을 보장해주므로 매우 유용하다. 다중 스레드가 코드 블록을 병렬로 실행하는 것이 문제가 되지 않지만 가시성 속성을 보장해야 하는 경우에 사용한다. 또한 happens-before ordering을 수행한다.</p><p>volatile 키워드는 두 가지 다른 용도로 사용한다. JVM이 <strong>레지스터(register)에서 값을 읽지 않도록 하고, 값을 메인 메모리에서 읽도록 하여</strong><mark> 메모리 불일치 오류(memory in-consistency errors)의 위험을 줄인다.</mark> 또한, JVM이 레지스터에서 값을 읽지 않도록 하고, 값을 메모리에서 읽도록 함으로써 <mark>메모리 일관성 오류(memory consistency errors)를 방지</mark>한다.</p><p>정리하자면, Java에서 volatile 키워드는 다중 스레드 환경에서 변수의 가시성을 보장하고, 메모리 일관성 오류를 방지하며, 다중 스레드가 동시에 클래스와 메소드 인스턴스를 사용할 수 있게 하기 위해 사용된다.</p></details><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Settings</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=kd>volatile</span> <span class=n>Settings</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=nf>Settings</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=n>Settings</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=o>(</span><span class=n>instance</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=kd>synchronized</span> <span class=o>(</span><span class=n>Settings</span><span class=o>.</span><span class=na>class</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=o>(</span><span class=n>instance</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>					<span class=n>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Settings</span><span class=o>();</span> 
</span></span><span class=line><span class=cl>				<span class=o>}</span>
</span></span><span class=line><span class=cl>			<span class=o>}</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><p>하지만, 이 코드도 완벽하지 않다. 이는 <a href=/brain/Interview/dog-study/dog-week01/ target=_blank>개발바닥 1주차 면접스터디</a>의 DLCP 지양에 관한 이야기에서도 다룬 내용이다.</p><p>문제점은 volatile 키워드 자체가 JDK 1.5 이상에서만 구현가능하다는 점이 있고, JVM에 따라서 thread-safe 하지 않는 경우가 발생할 수 있다는 것이다. 자바의 메모리 모델이 &ldquo;out-of-order-write"를 지원하기 때문에 메모리에 작성되는 순서를 보장하지 않기도 하다.</p><hr><a href=#bill-pugh-solution><h3 id=bill-pugh-solution><span class=hanchor arialabel=Anchor># </span>Bill Pugh Solution</h3></a><p><strong>Bill Pugh Solution (Initialization on demand holder idiom)</strong> : 싱글턴을 구현할 때 권장되어지는 방법 중의 하나이다. 구현 방법은 Holder 역할을 하는 <code>private static</code> 클래스를 이용하는 것이다.</p><ul><li>static inner class 인스턴스</li><li>생성자를 private</li><li>문제점 : 클라이언트가 임의로 싱글턴을 파괴할 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Settings</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=nf>Settings</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>SettingsHolder</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Settings</span> <span class=n>SETTINGS</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Settings</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=n>Settings</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>SettingsHolder</span><span class=o>.</span><span class=na>SETTINGS</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>먼저, JVM의 ClassLoader에 의해 클래스가 로드될 때 실행하는 <code>loadClass()</code> 메서드의 내부를 봐보자.</p><p><img src=https://shin-jae-yoon.github.io//brain/image/dog-week05-1.png width=auto alt></p><p>여기서 보면 내부적으로 <code>synchronized</code>가 실행되는 것을 볼 수 있다. 그래서 명시적으로 synchronized를 이용하지 않고 동일한 효과를 낼 수 있다.</p><p>왜냐하면, 해당 SettingsHolder 클래스는 static 이므로 메서드가 실행될 때 JVM의 static initializer에 의해 초기화되고 메모리로 올라간다. <strong>따라서, thread-safe와 lazy-loading을 둘 다 만족하는 싱글턴이 구현 가능하다.</strong></p><p>해당 코드의 문제점도 살펴보자. 클라이언트가 임의로 싱글턴을 파괴할 수 있다는 문제가 있다. 리플렉션과 직렬화를 통해 파괴할 수 있다고 한다.</p><br><a href=#enum><h3 id=enum><span class=hanchor arialabel=Anchor># </span>Enum</h3></a><ul><li>enum 자체가 싱글턴이다.</li><li>애초에 생성자를 private으로 갖게 만들거고 상수만 갖는 클래스이기 때문에 싱글턴의 성질을 가진다.</li><li>리플렉션과 직렬화로 싱글턴을 깰 수도 없음.</li><li>문제점 : 싱글턴을 해제할 때 번거러움, Enum 이외 클래스 상속 불가</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>enum</span> <span class=n>Settings</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>INSTANCE</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><a href=#권장-방법><h3 id=권장-방법><span class=hanchor arialabel=Anchor># </span>권장 방법</h3></a><ol><li><p>Bill Pugh 방법</p><ul><li>Lazy Loading</li><li>thread-safe</li></ul></li><li><p>enum</p><ul><li>thread-Safe</li><li>간편하다</li></ul></li></ol><br><a href=#정적-클래스><h3 id=정적-클래스><span class=hanchor arialabel=Anchor># </span>정적 클래스</h3></a><p>static class : static method만 갖고 있는 클래스를 의미한다. 자바에서는 따로 정적 클래스라는 것이 존재하지는 않는다.</p><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Setting</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=nf>Setting</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// static 메서드들
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>setMap</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><p>싱글턴과의 공통점</p><ol><li>스레드가 공유하는 메인 메모리쪽에 static이 올라가니까 전역적으로 사용 가능</li><li>인스턴스를 따로 생성하지 않아서 유일성을 보장받을 수 있다.</li></ol><p>싱글턴과의 차이점</p><ol><li>인스턴스를 생성할 수 없기 때문에 클래스 메서드를 이용한다는 점</li></ol><br><p><strong>싱글턴 패턴 vs 정적 클래스</strong></p><ul><li>싱글턴 패턴<ul><li>상속 받아서 사용할 수 있다.</li><li>메서드 파라미터로 사용할 수 있다.</li><li>권장 환경<ul><li>완벽한 객체지향을 필요로 할 때 ( = 애플리케이션 내에서 객체처럼 사용하고 싶을 때 )</li><li>lazy-loading이 필요할 때 ( = 인스턴스 생성 할 때 리소스가 많이 드는 경우 )</li></ul></li></ul></li><li>정적 클래스<ul><li>객체처럼 사용할 수는 없지만 컴파일 시 정적바인딩이 되기 때문에 보통 싱글턴보다 효율이 좋다.</li><li>권장 환경<ul><li>유틸 메서드를 보관하는 용도로 사용할 때 ( = 유틸 클래스처럼 객체 성질이 필요 없을 때 사용하는 것을 권장 )</li><li>다형성이나 상속이 필요없는 클래스</li></ul></li></ul></li></ul><br><a href=#spring-싱글턴><h3 id=spring-싱글턴><span class=hanchor arialabel=Anchor># </span>Spring 싱글턴</h3></a><p>사실, 위에서 언급한 다양한 싱글턴 패턴 구현의 단점들은 Spring 프레임워크를 사용하면서 모든 단점들이 없어지게 된다. 스프링에서 Bean 생성 시 별 다른 설정이 없으면 default로 싱글턴이 적용되는데, 이때 스프링은 컨테이너를 통해 직접 싱글턴 객체를 생성하고 관리한다.</p><p><mark><strong>객체의 생성을 스프링에 위임함으로써 스프링 컨테이너가 관리하기 때문에 그러하다.</strong></mark></p><p>스프링에서 DI(Dependency Injection)하는 방법으로 싱글턴 패턴을 적용하였다.</p><ul><li><p>싱글턴 : 농사를 하는 경우, 농부가 매번 삽을 만들면 삽을 만드는 것에 대한 리소스 낭비가 심할 것이기 때문에 공용 삽을 1개만 만들어 놓고 이를 돌려가면서 사용</p></li><li><p>DI : 농부의 손에 아무것도 쥐게 하지 않고, 손에 쥘 수 있도록 준비만 해놓은 상태에서 대감마님이 농사 도구를 손에 쥐어주는 상황</p></li></ul><p>싱글턴으로 공용 삽을 만들어놓은 상황에 알아서 사용하면 충분하지 않냐고 생각할 수 있다. 하지만, 그렇게 하면 삽을 만드는 시간, 메모리를 절약할 수 있는 장점이 있지만 <strong>의존성이 높아져서 테스트하기 어려운 단점</strong>이 있다.</p><p>예를 들어, 공용 삽과 호미 각각 1개를 농부 10명이 돌려쓰는 경우가 있다. 공용 삽과 공용 호미가 땅을 파는(Digging) 기능이 잘 되는지 테스트 해보고 싶은데, 삽이 단 1개, 호미가 단 1개이기 때문에 돌려 가면서 테스트하기 힘들다. 이때, 대감마님이 나서서 너부터 이걸로 테스트 해봐. 다음은 너가 이걸로 테스트 해봐. 교통정리 해주면 해결될 것이다.</p><p>농부가 땅파기 기능이 있는 도구를 받을 준비를 한 것이 생성자를 만들어 놓은 상태이다. 그리고 땅파 기 기능이 있는 인터페이스를 만들어놓으면 살과 호미는 땅파기 기능을 구현만 하면 된다. 이후, 대감 마님이 농사 도구를 농부에게 넘겨주는 식으로 하면 해결 !</p><p>결과적으로, 스프링에서 싱글턴 패턴을 사용하면서 얻게 되는 장점에는</p><ul><li>private 생성자가 필요 없어지게 되니까 상속이 가능해진다.</li><li>의존성이 높아져서 테스트하기 어려웠던 문제를 해결하여 테스트하기 편해진다.</li><li>프레임워크를 통해 1개의 객체 생성을 보장받을 수 있게 된다.</li><li>static 메서드를 사용하지 않아서 객체지향적으로 개발할 수 있다.</li></ul><br><a href=#annotation><h2 id=annotation><span class=hanchor arialabel=Anchor># </span>Annotation</h2></a><p><mark><strong>Annotation(주석) : 코드 사이에 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술이다.</strong></mark></p><ul><li>메타 데이터의 일종<ul><li>애플리케이션이 처리해야 할 데이터가 아니라 컴파일러를 위한 정보를 제공하기 위한 용도</li></ul></li><li>용도<ul><li>컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공</li><li>소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공</li><li>실행 시(런타임 시) 특정 기능을 실행하도록 정보 제공</li></ul></li><li>동작 순서<ul><li>애노테이션 정의</li><li>원하는 위치에 배치</li><li>코드가 실행되는 중 Reflection을 이용하여 추가 정보를 획득하여 기능 실시</li></ul></li></ul><details><summary><strong>Reflaction 상세보기</strong></summary><ul><li>Reflection이란 프로그램이 실행 중에 자신의 구조와 동작을 검사하고, 조사하고, 수정하는 것</li><li>Reflection을 사용하면 컴파일 타임에 인터페이스, 필드, 메소드의 이름을 알지 못해도 실행 중에 클래스, 인터페이스, 필드 및 메소드에 접근할 수 있다. 또한 새로운 객체의 인스턴스화 및 메소드 호출을 허용한다.</li><li><strong>Annotation 자체는 아무런 동작을 가지지 않는 단순한 표식일 뿐이지만, Reflection을 이용하면 Annotation의 적용 여부와 엘리먼트 값을 읽고 처리할 수 있다.</strong></li><li><strong>Spring 컨테이너(BeanFactory)에서 객체가 호출되면 객체의 인스턴스를 생성하게 되는데 이 때 필요하게 된다. 즉, 프레임워크에서 유연성있는 동작을 위해 쓰인다.</strong></li><li>Reflection을 이용하면 Annotation 지정만으로도 원하는 클래스를 주입할 수 있다.</li><li>Class에 적용된 Annotation 정보를 읽으려면 java.lang.Class를 이용하고<br>필드, 생성자, 메소드에 적용된 어노테이션 정보를 읽으려면 Class의 메소드를 통해 java.lang.reflect 패키지의 배열을 얻어야 한다.<ul><li>Class.forName(), getName(), getModifier(), getFields() getPackage() 등등 여러 메소드로 정보를 얻을 수 있다.</li></ul></li></ul></details><br><a href=#java-annotation><h3 id=java-annotation><span class=hanchor arialabel=Anchor># </span>Java Annotation</h3></a><p>자바 표준 애노테이션은 자바에서 기본적으로 제공하는 애노테이션이다. 가장 많이 사용하는 4가지 애노테이션은 아래와 같다.</p><p><code>@Override</code></p><ul><li>선언한 메서드가 오버라이드 되었다는 것을 나타냄</li><li>상위(부모) 클래스(혹은 인터페이스)에서 해당 메서드를 찾을 수 없으면 컴파일 에러 발생</li></ul><p><code>@Deprecated</code></p><ul><li>해당 메서드가 더 이상 사용되지 않음을 표시</li><li>컴파일러에게 이 메서드는 없어질 것이라는 걸 알려주고 사용하지 말라고 경고하는 것</li></ul><p><code>@SuppressWarnings</code></p><ul><li>선언한 곳의 컴파일 경고를 무시</li></ul><p><code>@FunctionalInterface</code></p><ul><li>Java 8부터 지원, 함수형 인터페이스를 지정</li><li>메서드가 존재하지 않거나, 1개 이상의 메서드 (default 메서드 제외)가 존재할 경우 컴파일 오류 발생</li></ul><a href=#meta-annotation><h3 id=meta-annotation><span class=hanchor arialabel=Anchor># </span>Meta Annotation</h3></a><p>사용자가 직접 정의하여 사용하는 Custom Annotation을 만들 때 사용하는 것이 Meta Annotation이며, 프레임워크나 API 등을 만들어서 사용할 때 주로 사용한다. Custom Annotation은<code>@interface</code>를 통해 애노테이션 클래스를 작성할 수 있다. 이때 애노테이션은 내부에 값을 가질 수 있고 설정할 수 있는데, 설정하려면 <code>default 값</code> 형태로 설정해야 한다.</p><p><code>@Retention</code></p><ul><li>애노테이션이 유지되는 기간을 정하기 위해 사용</li></ul><p><code>@Target</code></p><ul><li>애노테이션을 정의할 때 적용 대상을 지정할 때 사용</li></ul><p><code>@Documented</code></p><ul><li>애노테이션 정보를 javadoc로 작성된 문서에 포함</li></ul><p><code>@Inherited</code></p><ul><li>애노테이션이 하위 클래스에 상속되도록 함</li></ul><p><code>@Repeatable</code></p><ul><li>애노테이션을 반복해서 적용할 수 있게 함</li></ul><br><a href=#spring-annotation><h3 id=spring-annotation><span class=hanchor arialabel=Anchor># </span>Spring Annotation</h3></a><p>해당 Annotation에 대한 설명은 <a href=https://velog.io/@ruinak_4127/Annotation%EC%9D%B4%EB%9E%80#annotation-%EC%A2%85%EB%A5%98 target=_blank>Spring Annotation 총정리</a>에서 몇 가지 가져온 것이다.</p><ul><li><strong>@ComponentScan</strong><ul><li>@Component, @Service, @Repository, @Controller, @Configuration이 붙은 클래스 Bean들을 찾아서 Context에 bean을 등록해주는 애노테이션</li><li>전부 다 @Component를 사용하지 않고 @Repository 등으로 분리해서 사용하는 이유는, 예를 들어 @Repository는 DAO에서 발생할 수 있는 unchecked exception들을 스프링의 DataAccessException으로 처리할 수 있기 때문이다.</li><li>또한 가독성에서도 해당 애노테이션을 갖는 클래스가 무엇을 하는지 단 번에 알 수 있다.</li></ul></li><li><strong>@EnableAutoConfiguration</strong><ul><li>autoConfiguration도 Configuration중 하나에 해당한다.</li><li>spring.factories 내부에 여러 Configuration들이 있고 조건에 따라 Bean이 등록되게 되는데 메인 클래스 @SpringBootApplication을 실행하면 @EnableAutoConfiguration에 의해 spring.factories 안에 있는 수많은 자동 설정들이 조건에 따라 적용되어 수 많은 Bean들이 생성된다.</li><li>간단하게 정리하면, <strong>Application Context를 만들 때 자동으로 빈설정이 되도록 하는 기능이다.</strong></li></ul></li><li>@Component<ul><li>개발자가 직접 작성한 class를 Bean으로 등록하기 위한 애노테이션</li></ul></li><li>@Bean<ul><li>개발자가 직접 제어가 불가능한 외부 라이브러리등을 bean으로 만들려할 때 사용되는 애노테이션</li></ul></li><li>@Configuration<ul><li>@Configuration을 클래스에 적용하고 @Bean을 해당 class의 메서드에 적용하면 @autowired로 Bean을 부를 수 있다.</li></ul></li><li>@Autowired<ul><li>스프링이 Type에 따라 알아서 Bean을 주입해준다.</li><li>Type을 먼저 확인한 후 못 찾으면 Name에 따라 주입한다.</li><li>강제로 주입하고자 하는 경우 @Qulifier을 같이 명시</li></ul></li><li>@Qualifier<ul><li>같은 타입의 빈이 두 개 이상 존재하는 경우 스프링이 어떤 빈을 주입해야할 지 알 수 없어서 스프링 컨테이너를 초기화하는 과정에서 예외가 발생한다.</li><li>@Qualifier는 @Autowired와 함께 사용하여 정확히 어떤 bean을 사용할지 지정하여 특정 의존 객체를 주입할 수 있다.</li></ul></li><li><strong>@Resource</strong><ul><li><strong>@Autowired와 마찬가지로 Bean 객체를 주입해주는데 차이점은 Autowired는 타입으로, Resource는 이름으로 연결해준다.</strong></li><li><strong>애노테이션 사용으로 인해 특정 Framework에 종속적인 애플리케이션을 구성하지 않기 위해서 @Resource 사용을 권장한다.</strong></li></ul></li><li>@Controller<ul><li>API와 view를 동시에 사용하는 경우에 사용</li><li>보통 view 화면 return을 목적으로 사용한다.</li></ul></li><li>@RestController<ul><li>view가 필요 없이 API만 지원하는 서비스에서 사용</li></ul></li><li>@SpringBootApplication<ul><li>@Configuration, @EnableAutoConfiguration, @ComponentScan 3가지를 하나로 합친 애노테이션</li></ul></li></ul><br><a href=#spring-mvc><h2 id=spring-mvc><span class=hanchor arialabel=Anchor># </span>Spring MVC</h2></a><p>MVC 패턴은 디자인 패턴이다. 디자인 패턴이란, SW 개발 방법을 공식화 한 것으로 이해하자.</p><p><mark><strong>MVC 패턴 : Model & View & Controller 웹 애플리케이션을 3가지 역할로 구분한 개발 방법론이다. 모듈 간 결합도를 낮추고 응집도를 높이기 위해 사용하는 패턴이다.</strong></mark></p><ul><li>Controller : 클라이언트로부터 요청을 받아서 Model, View와 상호작용하며 적절한 응답을 제공하는 중계자의 역할</li><li>Model : 시스템에서 사용하는 도메인 모델 등을 의미</li><li>View : 클라이언트에게 제공하는 화면단을 의미</li></ul><p>도메인이란 화면, UI, 기술 인프라 등등의 영역을 제외한 <strong>시스템이 구현해야 하는 핵심 비즈니스 업무 영역</strong> 을 말한다. 컨트롤러는 도메인이 아니고, 엔티티와 리포지토리 등이 도메인으로 볼 수 있다.</p><br><a href=#모델1><h3 id=모델1><span class=hanchor arialabel=Anchor># </span>모델1</h3></a><p>MVC 패턴 이전에는 웹 애플리케이션 아키텍쳐로 모델 1을 주로 사용하였다.</p><p>구성</p><ul><li>JSP + JavaBean(Service)</li><li>뷰와 로직이 섞인다.</li><li>JSP가 흔히 아는 View, JavaBean을 Model이라고 생각하자.</li></ul><p>장점</p><ul><li>구조가 단순하다.</li></ul><p>단점</p><ul><li>출력과 로직 코드가 섞여 JSP 코드가 복잡해진다.</li><li>프론트엔드와 백엔드가 혼재되어 분업이 용이하지 않다.</li><li>유지보수가 어렵다.</li></ul><br><a href=#모델2--mvc패턴><h3 id=모델2--mvc패턴><span class=hanchor arialabel=Anchor># </span>모델2 = MVC패턴</h3></a><p>모델1의 단점때문에 나오게 된 모델2이다.</p><p>구성</p><ul><li>JavaBean(Service) + JSP + 서블릿</li><li>JavaBean이 Model, JSP가 View, 서블릿이 Controller</li></ul><p>장점</p><ul><li>뷰와 로직의 분리로 모델1에 비해 덜 복잡하다.</li><li>분업이 용이하다.</li><li>유지보수가 쉽다.</li></ul><p>단점</p><ul><li>모델1에 비해 습득이 어렵고 작업량이 많다.</li></ul><br><a href=#mvc-흐름><h3 id=mvc-흐름><span class=hanchor arialabel=Anchor># </span>MVC 흐름</h3></a><p><img src=https://shin-jae-yoon.github.io//brain/image/dog-week05-3.png width=auto alt></p><ol><li>사용자는 원하는 기능을 처리하기 위한 모든 요청을 Controller에 보냄</li><li>Controller는 Model을 사용하고, Model은 알맞은 비즈니스 로직 수행</li><li>Controller는 사용자에게 보여줄 View를 선택</li><li>선택된 View는 사용자에게 알맞는 결과 화면을 보여준다. 이때, 사용자에게 보여줄 데이터는 Controller를 통해서 전달받는다.</li></ol><br><p><strong>Model : 값과 기능을 가지고 있는 객체</strong></p><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Triangle</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>SIZE</span> <span class=o>=</span> <span class=n>3</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>NAME</span> <span class=o>=</span> <span class=s>&#34;삼각형&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;</span> <span class=n>points</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>Triangle</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;</span> <span class=n>points</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>.</span><span class=na>points</span> <span class=o>=</span> <span class=n>points</span><span class=o>;</span>	
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><p><strong>View : 모델에 포함된 데이터의 시각화</strong></p><br><p><strong>Controller : 모델 객체로의 데이터 흐름을 제어, 뷰와 모델의 역할을 분리</strong></p><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>String</span> <span class=n>inputPoints</span> <span class=o>=</span> <span class=n>InputView</span><span class=o>.</span><span class=na>inputCoordinates</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=n>Figure</span> <span class=n>figure</span> <span class=o>=</span> <span class=n>FigureFactory</span><span class=o>.</span><span class=na>create</span><span class=o>(</span><span class=n>generatePoints</span><span class=o>(</span><span class=n>inputPoints</span><span class=o>));</span>
</span></span><span class=line><span class=cl>		<span class=n>OutputView</span><span class=o>.</span><span class=na>showCoordinatePlane</span><span class=o>(</span><span class=n>figure</span><span class=o>.</span><span class=na>getXYCoordinates</span><span class=o>());</span>
</span></span><span class=line><span class=cl>		<span class=n>OutputView</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>figure</span><span class=o>.</span><span class=na>getAreaInfo</span><span class=o>());</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>err</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><a href=#mvc-장점><h3 id=mvc-장점><span class=hanchor arialabel=Anchor># </span>MVC 장점</h3></a><p>MVC는 개인용 컴퓨터에서 작동하는 애플리케이션의 개발을 목적으로 만들어진 패턴이지만, WWW(World Wide WEB) 애플리케이션을 사용하기 위한 용도로도 폭넓게 사용되고 있다.</p><ul><li>각 컴포넌트의 코드 결합도를 낮추기 위해</li><li>코드의 재사용성을 높이기 위해</li><li>구현자들 간의 커뮤니케이션 효율성을 높이기 위해</li></ul><br><a href=#mvc-주의-포인트><h3 id=mvc-주의-포인트><span class=hanchor arialabel=Anchor># </span>MVC 주의 포인트</h3></a><ol><li><p>Model에서 View에 접근하거나 View의 역할을 수행해버리는 경우</p><ul><li>예를 들어, Model에서 toString을 쓰는데 출력 로직을 여기다가 사용해버리는 경우가 있다.</li></ul></li><li><p>View에서 일어나는 &ldquo;과한&rdquo; 값 검증과 예외 처리</p><ul><li>InputView에서 받은 값을 Presentation Layer에서 체크하지 않고 InputView에 입력 외의 역할을 부여하면 <strong>단일책임원칙에 위반</strong>되어, 추후에 입력 채널이 달라질 경우 유효성 체크 로직도 옮겨가야한다는 문제가 발생할 수 있다.</li><li>사용자의 권한, 논리적인 값(존재 여부, 일치 여부) 등은 Service Layer에서 체크하면 좋다.</li><li>값 형식은 유효하지만, 도메인 모델에서 확인해야할 부분들은 생성자에서 체크하는 것이 좋다. (예를 들어, player의 이름은 몇 글자 이상이어야한다 등)</li><li>생성자에서는 유효성 체크만 하고 다른 로직은 추가하지 않는 것이 좋다.</li></ul></li><li><p>View에서 일어나는 비즈니스 로직</p><ul><li>View에서 Model을 생성한다던가 Model끼리 연산 해버린다던가 등</li></ul></li></ol><br><p><strong>모범적인 컨트롤러 사용법</strong></p><ul><li>View들을 컨트롤러가 연결만 하고 있다.</li><li>비즈니스 로직은 없음!!</li><li>어.. 그런데 여기서도 InputView에서 players와 rewards를 만들어서 사용하기 때문에 뺐으면 어땠을까? 하는 생각이 있다.</li></ul><br><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Players</span> <span class=n>players</span> <span class=o>=</span> <span class=n>InputView</span><span class=o>.</span><span class=na>createPlayers</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=n>Rewards</span> <span class=n>rewards</span> <span class=o>=</span> <span class=n>InputView</span><span class=o>.</span><span class=na>createRewards</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>Ladder</span> <span class=n>ladder</span> <span class=o>=</span> <span class=n>LadderFactory</span><span class=o>.</span><span class=na>createLadder</span><span class=o>(</span><span class=n>players</span><span class=o>.</span><span class=na>countOfPeople</span><span class=o>(),</span> <span class=n>InputView</span><span class=o>.</span><span class=na>get</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=n>OutputView</span><span class=o>.</span><span class=na>printLadder</span><span class=o>(</span><span class=n>players</span><span class=o>,</span> <span class=n>ladder</span><span class=o>,</span> <span class=n>rewards</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>MatchingResult</span> <span class=n>matchingResult</span> <span class=o>=</span> <span class=n>ladder</span><span class=o>.</span><span class=na>play</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=n>LadderResult</span> <span class=n>result</span> <span class=o>=</span> <span class=n>matchingResult</span><span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>players</span><span class=o>,</span> <span class=n>rewards</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>OutputView</span><span class=o>.</span><span class=na>printResult</span><span class=o>(</span><span class=n>result</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><br><a href=#서비스가-커질수록><h3 id=서비스가-커질수록><span class=hanchor arialabel=Anchor># </span>서비스가 커질수록</h3></a><p>서비스 규모가 커질수록, 사실 생각대로 MVC를 점점 지키기 힘들어질 것이다. 예를 들어, 쇼핑몰이라고 한다면 게시판에서도 회원 정보를 보여주고, 상품목록 보기에서도 회원 정보를 보여줘야 한다면 회원 정보를 읽어오는 코드는 어떻게 해야할까?</p><p>Controller에서 중복 발생 ! => 별도의 객체로 분리, 별도의 메서드로 분리</p><br><a href=#service><h3 id=service><span class=hanchor arialabel=Anchor># </span>Service</h3></a><p><mark><strong>Service : 비즈니스 로직(Business Logic)을 수행하는 메서드를 가지고 있는 객체</strong></mark></p><p>비즈니스 메서드를 별도의 Service 객체에서 구현하도록 하고 컨트롤러는 Service 객체를 사용하도록 한다. 예를 들어, 컨트롤러 1, 컨트롤러 2, 컨트롤러 3이 있다고 하고 회원 Service, 상품 Service, 게시판 Service가 있다고 하면 컨트롤러 1,2,3이 이 서비스들을 막 사용하는 형태로!</p><p>서비스는 하나의 트랜잭션을 가지게 된다.</p><br><p><strong>Transaction?</strong></p><ul><li>특징으로 ACID를 가진다.<ol><li>원자성 (Atomicity) : 하나의 원자 트랜잭션은 모두 성공하거나 or 모두 실패한다.</li><li>일관성 (Consistency) : 트랜잭션 작업처리 결과가 항상 일관성이 있어야 한다.</li><li>독립성 (Isolation) : 어느 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다.</li><li>지속성 (Durability) : 트랜잭션이 성공적으로 완료되었을 경우, 결과는 영구적으로 반영되야 한다.</li></ol></li></ul><br><a href=#repository><h3 id=repository><span class=hanchor arialabel=Anchor># </span>Repository</h3></a><p>Repository : DAO(Data Access Object), 데이터 액세스 메서드를 별도의 Repository 객체에서 구현하는 것이다. Service는 Repository 객체를 사용한다.</p><details><summary><strong>Repository, DAO 차이</strong></summary><p>Spring에서 Repository와 DAO의 차이점은 무엇일까?</p><ul><li><p>DAO(Data Access Object)는 데이터 영속성(persistence)의 추상화이고 Repository는 개체 컬렉션의 추상화이다. (컬렉션은 개별 객체들을 단일 단위로 표현하는 그룹을 의미함. 자바 컬렉션은 검색, 정렬, 삽입, 조작 및 삭제와 같은 모든 데이터 작업을 수행할 수 있음)</p></li><li><p>DAO는 데이터베이스(스토리지 시스템)와 더 가까운 저수준 개념이며, 주로 테이블 중심적인 구조를 가지는 반면에 Repository는 도메인(비즈니스 로직)에 더 가까운 상위수준 개념이다.</p></li><li><p>DAO는 데이터 매핑/액세스 레이어로 작동하며 못생긴 쿼리를 숨기면서 데이터 소스와의 연결 관리와 데이터 저장소에서 데이터를 가져오고 저장하는 데 필요한 액세스 메커니즘을 구현한다. Repository는 도메인과 데이터 액새스 사이의 레이어로 데이터를 수집하고 도메인 개체를 준비하는 복잡성을 숨긴다.</p></li><li><p>DAO는 Repository를 사용하여 구현할 수 없지만 Repository는 스토리지에 접근하기 위해 DAO를 사용할 수 있다.</p></li></ul><p>따라서, Repository와 DAO는 데이터 액세스를 추상화하는 패턴으로 사용되지만, 다른 추상화 계층을 가지며, Repository는 비즈니스 객체를 처리, DAO는 데이터 액세스 메커니즘을 처리하는 역할의 차이가 있다.</p></details><br><a href=#layered-architecture><h2 id=layered-architecture><span class=hanchor arialabel=Anchor># </span>Layered Architecture</h2></a><p><mark><strong>레이어드 아키텍처 패턴은 소프트웨어 아키텍처의 일반적인 패턴 중 하나이다. 일반적으로 사용자 상호 작용 레이어, 비즈니스 로직 레이어, 데이터 액세스 레이어, 데이터베이스 레이어로 구성된다.</strong></mark></p><p>레이어드 아키텍처 패턴은 백엔드 API 코드에 가장 널리 적용되는 패턴인데, <strong>코드를 논리적인 부분 혹은 역할에 따라 독립된 모듈로 나누어서 구성하는 패턴</strong>이다.</p><p><strong>레이어드 아키텍처의 핵심 요소</strong></p><ul><li>단방향 의존성 : 각각의 레이어는 오직 자기보다 하위에 있는 레이어에만 의존</li><li>각 레이어의 역할이 명확하다</li></ul><p><strong>레이어드 아키텍처의 장점</strong></p><ul><li>핵심 요소로 인하여, 각 레이어가 독립적이고 역할이 분명하다.</li><li>이로 인하여, 코드의 확장성이 높아진다.</li><li>코드의 구조를 파악하기 쉽고 재사용 가능성이 높아진다.</li><li>역할이 명확하여 각 레이어를 테스트하는 테스트 코드의 작성이 수월해짐</li></ul><p><strong>레이어드 아키텍처 주의점 - 싱크홀 안티 패턴</strong></p><ul><li>아키텍처 싱크홀 안티 패턴을 조심하자.</li><li>요청이 한 레이어에서 다른 레이어로 이동할 때 각 레이어가 아무 비즈니스 로직도 처리하지 않고 그냥 통과하는 것을 의미한다.</li><li>이런 흐름은 불필요한 객체 초기화 및 처리를 빈번하게 유발하고 쓸데없이 메모리를 소모하며 성능에도 부정적인 영향을 준다.</li><li>물론 싱크홀 안티패턴이 없을 순 없다. 전체 요청의 20%가 싱크홀인 정도면 그런대로 괜찮은 수준이다.</li></ul><p><img src=https://shin-jae-yoon.github.io//brain/image/dog-week05-2.png width=auto alt></p><br><a href=#presentation-layer><h3 id=presentation-layer><span class=hanchor arialabel=Anchor># </span>Presentation Layer</h3></a><p>Presentation Layer(User Interface) : 사용자 상호작용 레이어로, 해당 시스템을 사용하는 사용자 혹은 클라이언트 시스템과 직접적으로 연결되는 부분이다. 사용자가 애플리케이션과 상호 작용할 수 있는 스크린, 폼, 메뉴, 리포트 등을 포함한다.</p><p>웹 사이트에서는 UI 부분, 백엔드 API에서는 엔드포인트 부분에 해당한다. 그래서 백엔드 API 관점에서 보면, <strong>Presentation layer에서 API의 엔드포인트들을 정의하고 전송된 HTTP request를 읽는 로직을 구현한다. 이 이상의 역할은 담당하지 않고 실제 시스템이 구현하는 비즈니서 로직은 다음 레이어로 넘긴다.</strong></p><ul><li>EndPoint</li><li>Authentication (인증)</li><li>JSON Translation</li></ul><br><a href=#business-layer><h3 id=business-layer><span class=hanchor arialabel=Anchor># </span>Business Layer</h3></a><p>Business Layer(Business Logic) : 애플리케이션의 비즈니스 로직을 처리하는 레이어이다. Presentation layer에서 전송된 요청을 읽어들여 요청에 맞게 동작하는 로직을 구현하면 된다. 예를 들어 회원가입 요청 시 필수적인 요소들이 다 포함되어 있지 않으면 거부한다던가 하는 로직 등이 비즈니스 로직이다.</p><ul><li>Business Logic</li><li>Validation (사용자 중심의 시스템 검증)</li><li>Authorisation (권한 부여)</li></ul><details><summary><strong>영단어 Verification vs Validation</strong></summary><ul><li><strong>Verificaion</strong>은 개발자 중심의 시스템 검증 과정이며, 무언가를 만드는 <strong>&ldquo;과정"을 잘 지켰는지</strong>를 의미 ( 스펙에 대한 요구사항을 충족했니? )</li><li><strong>Validation</strong>은 사용자 중심의 시스템 검증 과정이다. 무언가를 <strong>최종적으로 만든 결과물이 잘 나왔는지</strong>를 말한다. ( 사용자에 대한 요구사랑을 충족했니? )</li></ul></details><br><a href=#persistence-layer><h3 id=persistence-layer><span class=hanchor arialabel=Anchor># </span>Persistence Layer</h3></a><p>Persistence Layer(Data Access)는 데이터베이스와 상호 작용하며 데이터를 검색하고 저장한다. 즉, 데이터베이스와 관련된 로직을 구현하는 부분이다. Business Layer에서 필요한 데이터를 생성, 수정, 읽기 등을 처리하여 실제로 데이터베이스에서 데이터를 저장, 수정, 읽어오기를 하는 역할이다.</p><ul><li>Storage Logic</li></ul><br><a href=#spring-layered-architecture><h3 id=spring-layered-architecture><span class=hanchor arialabel=Anchor># </span>Spring Layered Architecture</h3></a><p>Spring도 레이어드 아키텍터로 구성된다. 레이어는 자신의 고유 역할을 수행하고 인접한 다른 레이어에 무언가를 요청하거나 응답하기 때문에 각 레이어는 자신의 역할에만 충실하면 된다.</p><p><strong>따라서 시스템 전체를 수정하지 않고 특정한 레이어의 기능을 개선하거나 교체할 수 있기 때문에 재사용성이 좋고 유지 보수하기에도 유리하다. 또한, 레이어별로 테스트 구현이 편해지고 코드 가독성도 높아진다.</strong></p><p><img src=https://shin-jae-yoon.github.io//brain/image/dog-week05-4.png width=auto alt></p><br><p><img src=https://shin-jae-yoon.github.io//brain/image/dog-week05-5.png width=auto alt></p><ul><li>Presentation Layer<ul><li>Controller가 여기에 속한다. view를 담당하는 부분으로, 클라이언트와 직접적으로 맞닿는 부분이다.</li></ul></li><li>Business Layer<ul><li>Service가 여기에 속한다. 비즈니스 핵심 로직을 처리하는 부분이기 때문인데, 이때 Service 객체라는 것은 <strong>하나의 트랜잭션</strong>으로 구성되어 작동한다.</li></ul></li><li>Persistence Layer<ul><li>Repository가 여기에 속한다.</li></ul></li></ul><br><a href=#레이어드-아키텍처-확장><h3 id=레이어드-아키텍처-확장><span class=hanchor arialabel=Anchor># </span>레이어드 아키텍처 확장</h3></a><p>만약, 레이어드 아키텍처를 가지는 서비스가 굉장히 커져서 확장을 해야한다는 상황이 온다고 가정하자. 어떤 고민들을 해볼래?</p><ol><li>도메인 주도 설계(DDD)로 멀티모듈화하여 레이어드 아키텍처를 그대로 가져가는 방향</li><li>헥사고날 (이 부분은 추가공부 필요)</li><li>MSA는,, 웬만하면 꺼내지는 말고 추가적인 공부는 해놓자.</li></ol><br><a href=#참고><h2 id=참고><span class=hanchor arialabel=Anchor># </span>참고</h2></a><ul><li><a href="https://www.youtube.com/watch?v=3gURJvJw_T4&t=392s" rel=noopener>우테코 10분 테코톡 - 주디의 Spring Bean</a></li><li><a href="https://www.youtube.com/watch?v=5CBZPb3o0XI" rel=noopener>프로그래머스 데브코스 - Bean의 LifeCycle 정다현</a></li><li><a href="https://www.youtube.com/watch?v=5oUdqn7WeP0" rel=noopener>우테코 10분 테코톡 - 아서의 싱글턴 패턴과 정적 클래스</a></li><li><a href=https://bangu4.tistory.com/199 rel=noopener>Java Annotation</a></li><li><a href=https://ittrue.tistory.com/m/158 rel=noopener>Custom Annotation</a></li><li><a href=https://velog.io/@ruinak_4127/Annotation%EC%9D%B4%EB%9E%80#annotation-%EC%A2%85%EB%A5%98 rel=noopener>Spring Annotation 총정리</a></li><li><a href="https://www.youtube.com/watch?v=uoVNJkyXX0I" rel=noopener>우테코 10분 테코톡 - 해리&션의 MVC 패턴</a></li><li><a href=https://velog.io/@vov3616/MVVM-MVC-MVP-MVI-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%BC%EA%B9%8C rel=noopener>소프트웨어 아키텍처 패턴</a></li><li><a href=https://kimjingo.tistory.com/159 rel=noopener>레이어드 아키텍처 패턴</a></li><li><a href=https://www.javatpoint.com/spring-boot-architecture rel=noopener>스프링 부트 레이어드 아키텍처</a></li><li><a href=https://velog.io/@gmtmoney2357/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%A0%88%EC%9D%B4%EC%96%B4%EB%93%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98Layered-architecture rel=noopener>싱크홀 안티 패턴</a></li><li><a href=https://www.petrikainulainen.net/software-development/design/understanding-spring-web-application-architecture-the-classic-way rel=noopener>https://www.petrikainulainen.net/software-development/design/understanding-spring-web-application-architecture-the-classic-way</a></li></ul><style>.github-comment{border-top:1px solid rgba(128,128,128,.344);margin-top:7em}.utterances{margin-top:2em!important}</style><div class=github-comment><blockquote><h3>Comment</h3></blockquote><script src=https://utteranc.es/client.js repo=Shin-Jae-Yoon/Shin-Jae-Yoon.github.io issue-term=pathname label=utterances theme=github-light crossorigin=anonymous async></script></div></div><div class=single-aside-box><aside class=single-aside><div class=single-graph-container id=footer><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><div class=graph-header><p>Interactive Graph</p><button class=expand-btn id=expand-btn><i class="fa-solid fa-up-right-and-down-left-from-center"></i></button></div><div id=graph-container></div><style>:root{--g-node:var(--graphNode);--g-node-active:var(--graphNodeActive);--g-node-inactive:var(--graphNodeInactive);--g-link:var(--graphLink);--g-link-active:var(--graphLinkActive)}</style><script src=https://shin-jae-yoon.github.io/js/graph.6705788a3699b0ba2156c57e629980a4.js></script></div></div><aside class=asideTOC id=asideTOC><div class=toc-header><a href=# id=asideTocTitle>ON THIS PAGE</a></div><nav id=TableOfContents><ul><li><a href=#spring-bean>Spring Bean</a><ul><li><a href=#bean을-쓰지-않는-경우-문제점>Bean을 쓰지 않는 경우 문제점</a></li><li><a href=#bean-생명주기>Bean 생명주기</a></li><li><a href=#bean-스코프>Bean 스코프</a></li><li><a href=#bean-설정-시-주의점>Bean 설정 시 주의점</a></li></ul></li><li><a href=#싱글턴>싱글턴</a><ul><li><a href=#싱글턴-패턴의-순수한-구현>싱글턴 패턴의 순수한 구현</a></li><li><a href=#동기화synchronized>동기화(Synchronized)</a></li><li><a href=#dcl>DCL</a></li><li><a href=#bill-pugh-solution>Bill Pugh Solution</a></li><li><a href=#enum>Enum</a></li><li><a href=#권장-방법>권장 방법</a></li><li><a href=#정적-클래스>정적 클래스</a></li><li><a href=#spring-싱글턴>Spring 싱글턴</a></li></ul></li><li><a href=#annotation>Annotation</a><ul><li><a href=#java-annotation>Java Annotation</a></li><li><a href=#meta-annotation>Meta Annotation</a></li><li><a href=#spring-annotation>Spring Annotation</a></li></ul></li><li><a href=#spring-mvc>Spring MVC</a><ul><li><a href=#모델1>모델1</a></li><li><a href=#모델2--mvc패턴>모델2 = MVC패턴</a></li><li><a href=#mvc-흐름>MVC 흐름</a></li><li><a href=#mvc-장점>MVC 장점</a></li><li><a href=#mvc-주의-포인트>MVC 주의 포인트</a></li><li><a href=#서비스가-커질수록>서비스가 커질수록</a></li><li><a href=#service>Service</a></li><li><a href=#repository>Repository</a></li></ul></li><li><a href=#layered-architecture>Layered Architecture</a><ul><li><a href=#presentation-layer>Presentation Layer</a></li><li><a href=#business-layer>Business Layer</a></li><li><a href=#persistence-layer>Persistence Layer</a></li><li><a href=#spring-layered-architecture>Spring Layered Architecture</a></li><li><a href=#레이어드-아키텍처-확장>레이어드 아키텍처 확장</a></li></ul></li><li><a href=#참고>참고</a></li></ul></nav></aside></aside></div><script>scroll_init()</script></div><div class=btn-absolute><button class=top-btn>
<i class="top-btn-img fa-solid fa-arrow-up"></i></button>
<button class=mobile-expand-btn id=expand-btn2>
<i class="fa-solid fa-diagram-project"></i></button></div><script>btn_init(),document.querySelector(".top-btn").addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})</script><script>global_init()</script></div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><div id=contact_buttons><footer><div class=contact-left><p style=margin-bottom:0>Made by Dev Uni using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><p style=margin-top:0><a href=https://github.com/Shin-Jae-Yoon/Shin-Jae-Yoon.github.io>Dev Uni</a> has customized it by adding a features.</p><div class=contact-left-img><a href=https://pages.github.com/><img src=/images/logo-ghpages.png></a></div></div><div class=contact-right><div class=contact-right-flex><div class=contact-right-mountain><img src=/images/logo-contact.png></div><div class=contact-right-flexitem><a href=https://github.com/Shin-Jae-Yoon><img src=/images/logo-contact-github.png><p>Github</p></a></div><div class=contact-right-flexitem><a href=https://jae-yoon.tistory.com/><img src=/images/logo-contact-tistory.png><p>Tistory</p></a></div><div class=contact-right-flexitem><a href=https://open.kakao.com/o/sBqoUA7e><img src=/images/logo-message.png><p>Message</p></a></div></div></footer></div><script src=https://shin-jae-yoon.github.io/js/graph.6705788a3699b0ba2156c57e629980a4.js></script></body></html>