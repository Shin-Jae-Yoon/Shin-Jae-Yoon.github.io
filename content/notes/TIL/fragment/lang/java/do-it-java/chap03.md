---
title: "자바의 연산자"
date: "2023-02-16 03:03"
enableToc: true
tags: ["📚 Do it! 자바"]
---
<br>

> 해당 게시글은 **Do it! 자바 프로그래밍 입문** 교재를 정리한 내용입니다.

<hr>

# Chapter 03 - 자바의 여러 가지 연산자

<br>


## Java 기본 연산자

### 항과 연산자

<br>

| 연산자 | 설명 | 예시 |
| :---------: | :-----------------: | :----------------: |
| 단항 연산자 | 항이 한 개인 연산자 | ++num |
| 이항 연산자 | 항이 두 개인 연산자 | num1 + num2; |
| 삼항 연산자 | 항이 세 개인 연산자 | ( 5 > 3 ) ? 1 : 0; |

<br>


추가로, `/`는 몫, `%`는 나머지 !

```java
int num1 = 10;
int num2 = 4;
  
num1 / num2 = 2; // 몫
num1 % num2 = 2; // 나머지
```

<br>

### 논리 연산 주의점

- AND(`&&`) 연산 : 둘다 true여야 결과가 true라서 앞에꺼 하나라도 false가 나오면 뒤에 문장을 실행 안하고 false로 확정짓고 넘어감

- OR(`||`) 연산 : 둘 중 하나만 true여도 겨로가가 true라서 앞에꺼 하나라도 true가 나오면 뒤에꺼 실행 안하고 true로 확정짓고 넘어감

**논리 곱, 논리 합 연산 시 두 항을 모두 실행하지 않더라도 결과 값을 알 수 있는 경우에, 나머지 항이 실행되지 않는 것을 단락 회로 평가(Short Circuit Evaluation; SCE)라고 한다.**

```java
package chapter03;

public class pr03_OperationEx3 {
	public static void main(String[] args) {
		int num1 = 10;
		int i = 2;
		  
		boolean value = ((num1 = num1 + 10) < 10) && ((i = i + 2) < 10);
		System.out.println(value);
		System.out.println(num1);
		System.out.println(i);
		
		value = ((num1 = num1 + 10) > 10) || ((i = i + 2) < 10);
		System.out.println(value);
		System.out.println(num1);
		System.out.println(i);
	}
}

// false
// 20
// 2 논리 곱, 앞 항 거짓이라서 뒷 항 실행 안되고 i값 그대로
// true
// 30
// 2 논리 합, 앞 항 참이라서 뒷항 실행 안되고 i값 그대로
```

<br>

### 조건 연산자

<br>

| 연산자 | 기능 | 예시 |
| :--------------------: | :-------------------------------------------------------: | :--------------------------: |
| 조건식 ? 결과1 : 결과2 | 조건식이 참이면 결과 1, <br> 조건식이 거짓이면 결과2 선택 | int num = (5 > 3) ? 10 : 20; |

<br>

```java
package chapter03;

public class pr04_OperationEx4 {
	public static void main(String[] args) {
		int num = 10;
		boolean isEven;
		isEven = (num % 2 == 0) ? true : false;
		System.out.println(isEven);
	}
}

// true
```

<hr>

## Java 비트 연산자

### 비트 논리 연산자

- `&` : AND 연산자

```java
num1 : 0 0 0 0 0 1 0 1 // 5
& num2 : 0 0 0 0 1 0 1 0 // 10
------------------------
result : 0 0 0 0 0 0 0 0 // 0
  
// 5 & 10 = 0
```
  
- `|` : OR 연산자
  
```java
num1 : 0 0 0 0 0 1 0 1 // 5
| num2 : 0 0 0 0 1 0 1 0 // 10
------------------------
result : 0 0 0 0 1 1 1 1 // 15
  
// 5 | 10 = 15
```

- `^` : XOR 연산자, 같으면 0, 다르면 1
  
```java
num1 : 0 0 0 0 0 1 0 1 // 5
^ num2 : 0 0 0 0 1 0 1 0 // 10
------------------------
result : 0 0 0 0 1 1 1 1 // 15

// 5 ^ 10 = 15
```

- `~` : 반전 연산자, 부호 비트가 1이면 음수인거 까먹지 말기  

```java
num : 0 0 0 0 0 1 0 1 // 10
------------------------
~ num : 1 1 1 1 1 0 1 0 // -11
// ~10 = -11
```
  
<br>

### 비트 이동 연산자

- `<<` : 좌측 시프트 연산자, 왼쪽으로 비트 이동, 뒷부분인 오른쪽에 0 채우기  

```java
num : 0 0 0 0 0 1 0 1 // 5
num << 2 : 0 0 0 1 0 1 0 0 // 20
```

왼쪽으로 n비트 이동한다는 것은 **기존 값 \* n<sup>2</sup>** 이다.

따라서, `5 << 2`는 5 \* 2<sup>2</sup> = 20이다.

<br>

- `>>` : 우측 시프트 연산자, 오른쪽으로 비트 이동, 앞부분인 왼쪽에 0 채우기, 추가로 기존 값의 부호비트와 동일

```java
num : 0 0 0 0 1 0 1 0 // 10
num >> 2 : 0 0 0 0 0 0 1 0 // 2
```
  
왼쪽으로 n비트 이동한다는 것은 **기존 값 / n<sup>2</sup>** 이다.

따라서, `10 >> 2`는 10 / 2<sup>2</sup> = 2이다.

<br>

- `>>>` : 우측 시프트 연산자, 오른쪽으로 비트 이동, 앞부분인 왼쪽에 0 채우기, >>와 다른점은 얘는 기존 값의 부호비트와 상관 없이 무조건 0이 채워짐