---
title: "Part5 - Ch01 완전탐색"
date: "2023-04-03 01:09"
enableToc: true
tags: [""]
---

<a href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'>패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java</a> 강의를 정리한 내용

<hr>

## 완전탐색 - 기초

<br>

**완전 탐색(Brute Force)**
- 문제 해결을 위해 모든 경우를 전부 탐색하는 방법
- 그 중에서도 백 트래킹(Back-Tracking)을 통해야 하는 상황 해결
- 모든 코테 문제에서 기본적으로 접근해봐야 한다. 많은 연습이 필요하다.

> 장점 : 부분점수 얻기 좋음 <br>
> 단점 : 시간복잡도가 일반적으로 높음

<br>

### 완전탐색 종류

1. N개 중 중복을 허용해서
2. N개 중 중복 없이
3. M개를 순서있게 나열
4. M개를 고르기

(1 ,3) \/ (1, 4) \/ (2, 3) \/ (2, 4) - 4가지

완전 탐색은 함수 정의에서 50%는 먹고 들어간다.

```java
// Recurrence Function (재귀 함수)
// 만약 M개를 전부 고름 => 조건에 맞는 탐색을 한 가지 선공한 것
// 아직 M개를 고르지 않음 => k번째부터 M번째 원소를 조건에 맞게 고르는 방법을 시도
static void rec_func(int k) { }

public static void main(String[] args) {
	input();
	// 1번째 원소부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 탐색해줘
	rec_func(1);
	System.out.println(sb.totring());
}
```

<br>

### 완전탐색 복잡도

<br>

![](brain/image/p5-ch01-1.png)

<br>

### (1+3) 방법

**N개 중 중복을 허용하여 M개를 순서있게 나열**

- 15651번 문제

예를 들어, N = 4, M = 3이라고 하자. 그러면 (\_ \_ \_) 3칸이 있고 각각 1~4까지 들어갈 수 있다.

<br>

1. 시간 복잡도 계산
	- `4 * 4 * 4` 일 것이다.
	- 일반화하면 O(N<sup>M</sup>)이다. 문제에서 N과 M의 최대가 7이었으니 7<sup>7</sup> 하면 대략 82만이다. 완탐 써도 될듯?

<br>

- 강의 코드

```java
import java.util.*;  
import java.io.*;  
  
public class Main {  
    static StringBuilder sb = new StringBuilder();  
  
    static void input(){  
        FastReader scan = new FastReader();  
        N = scan.nextInt();  
        M = scan.nextInt();  
        // M번째 까지 받지만, M+1 (= 다 찬 경우) 확인을 위해  
        selected = new int[M + 1];  
    }  
  
    static int N, M;  
    static int[] selected;  
  
    // Recurrence Function (재귀 함수)  
    // 만약 M개를 전부 고름 => 조건에 맞는 탐색을 한 가지 선공한 것  
    // 아직 M개를 고르지 않음 => k번째부터 M번째 원소를 조건에 맞게 고르는 방법을 시도  
    static void rec_func(int k) {  
        if (k == M + 1) {   // 다 골랐다 !            // selected[1...M] 배열이 새롭게 탐색된 결과  
            for (int i = 1; i <= M; i++) sb.append(selected[i]).append(' ');  
            sb.append('\n');  
        } else {  
            for (int cand = 1; cand <= N; cand++) {  
                selected[k] = cand;  
                // k + 1 번째부터 ~ M 번을 모두 탐색하는 일을 해야하는 상황  
                rec_func(k + 1);  
                // 끝나면 더이상 기록할 필요 없으니까  
                selected[k] = 0;  
            }  
        }  
    }  
  
    public static void main(String[] args) {  
        input();  
  
        // 1 번째 원소부터 M 번째 원소를 조건에 맞는 모든 방법을 찾아줘  
        rec_func(1);  
        System.out.println(sb.toString());  
    }  
  
    static class FastReader {  
        BufferedReader br;  
        StringTokenizer st;  
  
        public FastReader() {  
            br = new BufferedReader(new InputStreamReader(System.in));  
        }  
  
        public FastReader(String s) throws FileNotFoundException {  
            br = new BufferedReader(new FileReader(new File(s)));  
        }  
  
        String next() {  
            while (st == null || !st.hasMoreElements()) {  
                try {  
                    st = new StringTokenizer(br.readLine());  
                } catch (IOException e) {  
                    e.printStackTrace();  
                }  
            }  
            return st.nextToken();  
        }  
  
        int nextInt() {  
            return Integer.parseInt(next());  
        }  
    }  
}
```

<br>

- 줄인 코드

```java
import java.io.*;  
import java.util.*;  
  
public class Main {  
    static int N, M;  
    static int[] selected;  
    static StringBuilder sb = new StringBuilder();  
  
    static void recv_func(int k) {  
        if (k == M + 1) {  
            for (int i = 1; i <= M; i++) sb.append(selected[i]).append(' ');  
            sb.append('\n');  
        } else {  
            for (int cand = 1; cand <= N; cand++) {  
                selected[k] = cand;  
                recv_func(k + 1);  
                selected[k] = 0;  
            }  
        }  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        N = Integer.parseInt(st.nextToken());  
        M = Integer.parseInt(st.nextToken());  
  
        selected = new int[M + 1];  
        recv_func(1);  
        System.out.println(sb.toString());  
    }  
}
```

<br>

### (2+3) 방법

**N개 중 중복을 허용없이 M개를 순서있게 나열**

- 15649번 문제

1. 이중 for문으로 시간 복잡도가 더 높은 버전

```java
import java.util.*;  
import java.io.*;  
  
public class Main {  
    static StringBuilder sb = new StringBuilder();  
    static int N, M;  
    static int[] selected;  
  
    static void recv_func(int k) {  
        if (k == M + 1) {  
            for (int i = 1; i <= M; i++) {  
                sb.append(selected[i]).append(' ');  
            }  
            sb.append('\n');  
        } else {  
            for (int cand = 1; cand <= N; cand++) {  
                boolean isUsed = false;  
                for (int j = 1; j < k; j++) {  
                    if (cand == selected[j])  
                        isUsed = true;  
                }  
                if (!isUsed) {  
                    selected[k] = cand;  
                    recv_func(k + 1);  
                    selected[k] = 0;  
                }  
            }  
        }  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        N = Integer.parseInt(st.nextToken());  
        M = Integer.parseInt(st.nextToken());  
  
        selected = new int[M + 1];  
        recv_func(1);  
        System.out.println(sb.toString());  
    }  
}
```

<br>

2. for문 1번만 쓰고 시간 복잡도 줄인 버전

```java
import java.util.*;  
import java.io.*;  
  
public class Main {  
    static StringBuilder sb = new StringBuilder();  
    static int N, M;  
    static int[] selected, used;  
  
    static void recv_func(int k) {  
        if (k == M + 1) {  
            for (int i = 1; i <= M; i++) {  
                sb.append(selected[i]).append(' ');  
            }  
            sb.append('\n');  
        } else {  
            for (int cand = 1; cand <= N; cand++) {  
                if (used[cand] == 1) continue;  
                selected[k] = cand;  
                used[cand] = 1;  
                recv_func(k + 1);  
                selected[k] = 0;  
                used[cand] = 0;  
            }  
        }  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        N = Integer.parseInt(st.nextToken());  
        M = Integer.parseInt(st.nextToken());  
  
        selected = new int[M + 1];  
        used = new int[N + 1];  
        recv_func(1);  
        System.out.println(sb.toString());  
    }  
}
```

<br>

### (1+4) 방법

**N개 중 중복을 허용하여 M개를 고르기**

- 15652번 문제

```java
import java.io.*;  
import java.util.*;  
  
public class Main {  
    static int N, M;  
    static int[] selected;  
    static StringBuilder sb = new StringBuilder();  
  
    static void recv_func(int k) {  
        if ( k == M + 1) {  
            for (int i = 1; i <= M; i++) sb.append(selected[i]).append(' ');  
            sb.append('\n');  
        } else {  
            int start = selected[k-1];  
            if (start == 0) start = 1;  
            for (int cand = start; cand <= N; cand++) {  
                selected[k] = cand;  
                recv_func(k + 1);  
                selected[k] = 0;  
            }  
        }  
  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        N = Integer.parseInt(st.nextToken());  
        M = Integer.parseInt(st.nextToken());  
  
        selected = new int[M + 1];  
        recv_func(1);  
        System.out.println(sb.toString());  
    }  
}
```

<br>

### (2+4)번 방법

**N개 중 중복없이 M개를 고르기**

- 15650번 문제

```java
import java.io.*;  
import java.util.*;  
  
public class Main {  
    static int N, M;  
    static int[] selected;  
    static StringBuilder sb = new StringBuilder();  
  
    static void recv_func(int k) {  
        if ( k == M + 1) {  
            for (int i = 1; i <= M; i++) sb.append(selected[i]).append(' ');  
            sb.append('\n');  
        } else {  
            for (int cand = selected[k-1] + 1; cand <= N; cand++) {  
                selected[k] = cand;  
                recv_func(k + 1);  
                selected[k] = 0;  
            }  
        }  
  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        N = Integer.parseInt(st.nextToken());  
        M = Integer.parseInt(st.nextToken());  
  
        selected = new int[M + 1];  
        recv_func(1);  
        System.out.println(sb.toString());  
    }  
}
```

- used 써서 한번 해봤음

```java
import java.util.*;  
import java.io.*;  
  
public class Main {  
    static int N, M;  
    static int[] selected, used;  
    static StringBuilder sb = new StringBuilder();  
  
    static void recv_func(int k) {  
        if (k == M + 1) {  
            for (int i = 1; i <= M; i++) sb.append(selected[i]).append(' ');  
            sb.append('\n');  
        } else {  
            int start = selected[k-1];  
            if (start == 0) start = 1;  
  
            for (int cand = start; cand <= N; cand++) {  
                if (used[cand] == 1) continue;  
                selected[k] = cand;  
                used[cand] = 1;  
                recv_func(k + 1);  
                selected[k] = 0;  
                used[cand] = 0;  
            }  
        }  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        N = Integer.parseInt(st.nextToken());  
        M = Integer.parseInt(st.nextToken());  
  
        selected = new int[M + 1];  
        used = new int[N + 1];  
        recv_func(1);  
        System.out.println(sb.toString());  
    }  
}
```