---
title: "Part5 - Ch01 완전탐색"
date: "2023-04-03 01:09"
enableToc: true
tags: [""]
---

<a href='https://fastcampus.co.kr/dev_online_codingtest' target='_blank'>패스트캠퍼스 핵심유형 20개로 한 번에 끝내는 알고리즘 코딩테스트 with Java</a> 강의를 정리한 내용

<hr>

## 완전탐색 - 기초

<br>

**완전 탐색(Brute Force)**
- 문제 해결을 위해 모든 경우를 전부 탐색하는 방법
- 그 중에서도 백 트래킹(Back-Tracking)을 통해야 하는 상황 해결
- 모든 코테 문제에서 기본적으로 접근해봐야 한다. 많은 연습이 필요하다.

> 장점 : 부분점수 얻기 좋음 <br>
> 단점 : 시간복잡도가 일반적으로 높음

<br>

### 완전탐색 종류

1. N개 중 중복을 허용해서
2. N개 중 중복 없이
3. M개를 순서있게 나열
4. M개를 고르기

(1 ,3) \/ (1, 4) \/ (2, 3) \/ (2, 4) - 4가지

완전 탐색은 함수 정의에서 50%는 먹고 들어간다.

```java
// Recurrence Function (재귀 함수)
// 만약 M개를 전부 고름 => 조건에 맞는 탐색을 한 가지 선공한 것
// 아직 M개를 고르지 않음 => k번째부터 M번째 원소를 조건에 맞게 고르는 방법을 시도
static void rec_func(int k) { }

public static void main(String[] args) {
	input();
	// 1번째 원소부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 탐색해줘
	rec_func(1);
	System.out.println(sb.totring());
}
```

<br>

### (1-3) 방법

**N개 중 중복을 허용하여 M개를 순서있게 나열**

- 15651번 문제

예를 들어, N = 4, M = 3이라고 하자. 그러면 (\_ \_ \_) 3칸이 있고 각각 1~4까지 들어갈 수 있다.

<br>

1. 시간 복잡도 계산
	- `4 * 4 * 4` 일 것이다.
	- 일반화하면 O(N<sup>M</sup>)이다. 문제에서 N과 M의 최대가 7이었으니 7<sup>7</sup> 하면 대략 82만이다.


