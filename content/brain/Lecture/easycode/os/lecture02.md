---
title: "02. 컨택스트 스위칭"
date: "2023-05-02 17:45"
enableToc: true
tags: [""]
weight: 3
---

유튜버 쉬운코드 님의 <a href='https://www.youtube.com/@ez./playlists' target='_blank'>운영체제</a> 강의를 정리한 내용

<hr>

## 컨택스트 스위칭

==**컨택스트 스위칭 (Context Switching)**==
- CPU/코어에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것

> 프로세스 → 프로세스로 교체된다는 것은 엄밀히 말하면, **어떤 프로세스 안에서 실행되던 스레드가 다른 프로세스 안에 실행되는 스레드로 바뀐다는 의미**이다. 서로 다른 프로세스에 속한 스레드가 바뀌는 것이기에 이때는 **프로세스가 교체된다**고 한다.

<br>

==**컨택스트 (Context)**==
- CPU에서 혹은 메모리에서 프로세스/스레드의 상태

<br>

==**컨택스트 스위칭은 왜 필요할까?**==
- 여러 프로세스/스레드를 **동시에** 실행시키기 위해서 필요

<br>

==**컨택스트 스위칭은 언제 발생하는가?**==
- 주어진 time slice(quantum)를 다 사용했을 때
- IO 작업을 해야할 때
- 다른 리소스를 기다려야할 때
- 기타 등등

<br>

**ex) 멀티태스킹 시스템에서 컨택스트 스위칭**

![](brain/image/lecture02-25.png)

<br>

==**컨택스트 스위칭은 누구에 의해 실행되는가?**==
- **OS 커널(kernel)**
	- 각종 리소스를 관리/감독하는 역할
	- 커널이 통제권을 가지고 실행한다고 이해
- **컨택스트 스위칭의 총괄하는 주체**에 관한 것인지, 이 컨택스트 스위칭을 누가 발생하는가, 누가 트리거하는가와는 다른 것이다.

<br>

==**컨택스트 스위칭은 구체적으로 어떤 과정으로 일어나는가?**==
- 다른 프로세스끼리 스위칭인지
	- ==**Process Context Switching**==
- 같은 프로세스의 스레들끼리 스위칭인지에 따라 다름
	- ==**Thread Context Switching**==

<br><hr>

### 컨택스트 스위칭 공통점

**Process Context Switching과 Thread Context Switching 공통점**
1. 커널 모드에서 실행
2. CPU의 레지스터 상태를 교체

<br>

**커널 모드에서 실행**

![](brain/image/lecture02-26.png)

- 프로세스 P1이 실행되다가, 하드웨어와 밀접한 일들, 혹은 컴퓨터에 있는 여러 리소스들을 다뤄야하는 상황이 왔을 때
- **프로세스가 직접 컴퓨터의 리소스에 접근하는 것이 아니라 운영체제의 커널을 통해 접근하게 됨**
- **커널 모드 : 프로세스에서 커널로 통제권이 넘어가서 커널에 의해서 실행되는 것**
	- 프로세스 컨택스트 스위칭이건, 스레드 컨택스트 스위칭이건, 컨택스트 스위칭은 통제권이 커널로 넘어가서 커널 모드에서 실행하게 됨

<br>

**CPU의 레지스터 상태를 교체**

![](brain/image/lecture02-27.png)

- CPU 안에 여러 **레지스터**가 존재
	- 레지스터는 각종 명령어들을 수행하기 위해 필요한 여러 데이터를 저장하는 곳
- 프로세스(P1)가 실행되는 동안 CPU의 레지스터는 여러 값들이 계속 바뀌면서 실행되고 있었을 것
- 다른 프로세스(P2)가 실행되게 되면 기존에 실행 중이던 프로세스(P1)의 레지스터 상태들을 어딘가에 저장하고 실행하는 것
	- 나중에 다시 P1을 실행하게 됐을 때 **어디까지 실행했는지에 대한 레지스터의 상태 정보를 알고 있어야 이어서 실행할 수 있으니까**
 
<br><hr>

### 컨택스트 스위칭 차이점

**Process Context Switching과 Thread Context Switching 차이점**
- **프로세스 컨택스트 스위칭**은 ==**가상(virtual) 메모리 주소 관련 처리를 추가로 수행**==
	- 서로 다른 프로세스는 메모리 주소 체계가 다르기 때문임
	- **MMU (Memory Manage Unit, 메모리 관리 장치)** 도 새로운 프로세스의 주소 체계를 바라볼 수 있도록 수정해야 함
	- **TLB (Translation Lookaside Buffer, 변환 색인 버퍼)** 도 비워야 함
- **스레드 컨택스트 스위칭**은 가상 메모리 주소 관련 처리 추가작업 필요 ❌
	- 같은 프로세스에 속하는 스레드끼리 컨택스트 스위칭은 같은 프로세스에 속하기 때문에 그 프로세스의 메모리 영역을 공유한다고 했었음
	- 그래서 컨택스트 스위칭이 발생해도 메모리 관련하고 추가 작업 필요 ❌

> TLB는 범위 밖이라 자세히 다루지는 않고 간단하게만 하겠음 <br>
> 가상 메모리 주소와 실제 메모리 주소의 매핑 정보를 가지고 있는 캐시를 의미

<br><hr>

### 컨택스트 스위칭 예제

<br>

**스레드 컨택스트 스위칭**

![](brain/image/lecture02-28.png)

<br>

**프로세스 컨택스트 스위칭**

![](brain/image/lecture02-29.png)

- MMU, TLB 작업을 반드시 수행해야함.
- 예를 들어, P2가 실행됐을 때 이 작업이 수행되지 않았다면 P1의 메모리 주소로 잘못 접근하는 일이 발생할 수 있음

<br>

==**스레드 컨택스트 스위칭이 더 빠른 이유?**==
- 프로세스 컨택스트 스위칭과는 다르게 스레드 컨택스트 스위칭은 같은 메모리 공간을 공유하기 때문에 **메모리 주소 관련 처리를 하지 않기 때문**

<br><hr>

### 캐시 오염

==**캐시 오염 (cache pollution)**==
- 컨택스트 스위칭이 미치는 **간접적인 영향을 의미**
- 컨택스트 스위칭이 발생하면 서로 다른 데이터들이기 때문에 컨**택스트 스위칭 직후에 캐시에 가봤자, 어차피 캐시에는 이전의 프로세스 혹은 스레드에서 실행됐던 정보를 가지고 있을 것**
- 그래서 내가 원하는 데이터를 찾으려면 다시 메모리까지 가야하고, 처리 속도가 떨어져서 성능에 안좋은 영향을 끼치게 됨

<br><hr>

### 유저관점 컨택스트 스위칭

==**유저 관점에서 컨택스트 스위칭은 어떤 의미?**==
- 순수한 (pure) 오버헤드 (overhead)
- 내가 실행한 프로그램의 동작과는 전혀 상관없는 순수하게 CPU를 잡아먹는 간접비용
- 따라서, **컨택스트 스위칭이 많이 일어나는 것은 좋은 것이 아니다.**
