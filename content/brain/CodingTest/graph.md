---
title: "그래프 탐색"
date: "2024-10-15 23:31"
enableToc: true
tags: [""]
---

## 그래프


![](brain/image/graph-1.png)

- 그래프(Graph) : 노드와 간선의 집합으로 구성된 자료구조
- 노드(Node) : 정점(Vertex), 각각의 지점
- 간선(Edge) : 정점과 정점을 잇는 선
- 간선의 가중치 : 간선에 값이 적혀져 있는 경우
- 차수(Degree) : 연결된 정점의 수
	- 방향그래프의 경우 들어올 수 있는 정점의 수, 나갈 수 있는 정점의 수가 다름
	- 위 그림에서 3번 노드를 기준으로 생각
	- 무방향 그래프의 3번 노드 차수 : 3
	- 진입차수(In-degree) : 0
	- 진출차수(Out-degree) : 3
- 특정 지점에서 출발하여 다시 본래의 지점을 돌아올 수 있는 경우 = 사이클이 존재한다
- 연결 그래프 : 모든 정점들에 대해서 갈 수 있는 경로가 존재하는 경우
- 비연결 그래프 : 갈 수 있는 경로가 존재하지 않는 경우
- 연결요소 : 간선으로 연결되어 있는 정점들을 묵었을 때 나오는 그룹
	- 위의 예시에서는 두 그래프 모두 연결 요소가 1
	- 만약 비연결 그래프 형태로 하나의 선을 끊었다고 치면 2가 될 것

<br>

### 그래프 구현

- 그래프는 보통 ==**인접 행렬, 인접 리스트**== 2가지 방식으로 구현
	- 일반적으로 인접 행렬이 메모리를 더 많이 차지함
	- 특정 정점과 연결된 정점의 수를 확인하는 연산은 인접 리스트가 더 빠름
		- 인접 행렬은 모든 정점의 연결관계 확인하니까 ==**$O(|V|)$**==
		- 인접 리스트는 리스트의 크기만 보면 되니까
	- 특정 두 정점이 연결되었는지 확인하는 연산은 인접 행렬이 더 빠름
		- 인접 행렬은 2차원배열의 1칸을 확인하면 되니까 ==**$O(1)$**==
		- 인접 리스트는 정점에 해당하는 연결된 정점을 찾기 위해 모든 정점을 순서대로 확인해야해서 ==**$O(|V|)$**==

<br>

**인접 행렬**

![](brain/image/graph-2.png)

- 정점의 수 $|V|$, 간선의 수 $|E|$
- 인접 행렬 : $|V| * |V|$ 크기의 2차원 배열 만들어서 연결관계 표현
- 시간 복잡도
	- 특정 정점 $I$, $J$ 연결되어 있는지 확인 : ==**$O(1)$**==
	- 특정 정점과 연결된 모든 정점 확인 : ==**$O(|V|)$**==
	- 공간 복잡도 : ==**$O(|V| * |V|)$**==

<br>

**인접 리스트**

![](brain/image/graph-3.png)

- 3번 노드의 연결 리스트 길이는 2
- 시간 복잡도
	- 특정 정점 $I$, $J$ 연결되어 있는지 확인 : ==**$O(min(degree(I), degree(J)))$**==
	- 특정 정점과 연결된 모든 정점 확인 : ==**$O(degree(X))$**==
		- X라는 정점에 해당하는 리스트의 크기, 연결된 정점의 수
	- 공간 복잡도 : ==**$O(|V| + |E|)$**==

<br><hr>

## DFS

**DFS (Depth First Search) : 깊이 우선 탐색**
- 최대한 깊게 탐색한 후, 더 이상 도달할 수 없는 상황이라면 다시 이전으로 돌아감
- DFS는 재귀를 활용해 구현하는 경우가 많음
	- 방문할 수 있는 지점이 있다면 그 지점을 방문하는 함수를 **재귀적으로 호출**하고, 더 이상 방문할 곳이 없다면 함수를 종료
- 이미 방문했던 지점을 또 방문하면 효율이 떨어지기 때문에 이전에 방문했던 지점은 다시 방문하지 않아야 함
	- 이런 처리를 위해, **visited라는 배열을 하나 만들어서** 그 번호를 갖고 있는 지점을 방문한 적이 있는지 확인하며 진행

