---
title: "01. 서론"
date: "2023-08-07 21:56"
enableToc: true
tags: ["📚 운영체제 공룡책"]
weight: 2
---

# Chapter 01 - 운영체제 서론

<br>

> 해당 게시글은 **운영체제 - 공룡책** 교재와 인프런의 <a href='https://www.inflearn.com/course/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EB%A3%A1%EC%B1%85-%EC%A0%84%EA%B3%B5%EA%B0%95%EC%9D%98' target='_blank'>주니온 님의 운영체제 공룡책 강의</a>를 함께 정리한 내용입니다.

<hr>

## 주니온 강의

### 컴퓨터, 정보 기초

운영체제(Operating System)는 컴퓨터 하드웨어를 작동시키는 소프트웨어라고 하는데, 여기서 **컴퓨터라는 것은 어떤 것을 의미하나 ?**
- ==**정보(Information)**==을 처리하는 기계

<br>

**정보라는 것은 어떤 것을 의미하나?**
- 클로드 섀넌이 정보에 대하여 수학적으로 정의하였는데, a quantitative representation that measures the uncertainty 라고 하였다.
- 즉, ==**불확실한 상황을 측정하고 이를 수치화하여 표현한 것**==이 정보이다.

<br>

$$
I(x) = -log_2 P(x)
$$

이는, **어떤 사건 $x$의 정보량 = 사건 $x$가 발생할 확률에 $-log_2$ 한 것**을 의미한다.
- 예를 들어, 동전을 던져서 앞면과 뒷면이 나올 확률이 $\frac{1}{2}$이라고 하자.
- $I(동전 던진 사건의 정보량) = -log_2 2^{-1} = 1$
- 정리하자면, ==**$\frac{1}{2}$의 사건이 되는 단위, 정보의 최소 단위 bit (binary digit)가 되는 것**==이다. 
	- 0과 1이 왜 최소 단위 1bit인지 이제 감 잡히나?
	- $2^{3} = 8$bits 는 1byte !

<br>

**컴퓨터는 정보를 어떻게 처리하나?**
- 정보의 처리는 정보의 상태 변환 (0 → 1, 1 → 0)을 의미
- 부울 대수 (Boolean Algebra)인 NOT, AND, OR과 같은 조작을 위한 스위치를 만들기 위해 물리적인 소자 트랜지스터를 이용가능
- 논리 게이트를 이용하여 여러 정보의 처리 가능
- 논리 회로 : 논리 게이트가 모인 <a href='http://www.ktword.co.kr/test/view/view.php?no=3597' target='_blank'>집적 회로</a> (IC, Intergrated Circuit)
	- 무어의 법칙 : 논리 게이트 집적도가 1년 6개월 마다 2배씩 증가
	- 황의 법칙 : 메모리가 1년에 2배씩 증가
	- 하드웨어의 발전은 양자간섭현상, 양자중첩현상에 의해 이미 거의 한계에 다다름
- 정보의 저장은 플립-플롭을 이용하여, 전송은 데이터 버스 혹은 RF(무선)를 이용하여

<br>

**본질적인 컴퓨터의 정보 처리 방법**
- 덧셈 : 반가산기, 전가산기
- 뺄셈 : 2의 보수 표현법
- 곱셈, 나눗셈 : 덧셈과 뺄셈의 반복
- 실수 연산 : 부동 소수점 표현법
- 함수 : GOTO

<br>

**그렇다면, 컴퓨터는 만능인가?**
- NOT, AND, OR 게이트만으로 모든 계산을 할 수 있는 **범용성(universality) 있는 기계**
- NAND 게이트만으로도 모든 계산을 할 수 있음
- **범용 컴퓨터(general-purpose computer)**  : 특정한 목적을 가지고 만들어진 것은 컴퓨터라고 하지 않고, 소프트웨어가 하고자 하는 것들을 하드웨어가 지원하는 범용적인 형태라면 범용성 있는 컴퓨터, universality를 가지고 있다고 한다.

<br>

### 튜링머신

**모든 컴퓨터의 할아버지는 튜링 머신**

![](brain/image/chap01-1.png)

- 튜링 머신에 대한 자세한 설명은 <a href='https://ttl-blog.tistory.com/743' target='_blank'>링크</a> 참조
- 저장장소가 없다면 유한 오토마타, 저장장소가 스택이라면 푸시다운 오토마타
- 튜링 머신은 임시 저장소가 테이프인 오토마타

<br>

### 폰 노이만

**모든 컴퓨터의 아버지는 폰 노이만**

![](brain/image/chap01-2.png)

- 오토마타인 튜링 머신과는 다르게 ==**메모리에 프로그램을 저장하는 내장형(stored-program) 컴퓨터**==이면서 RAM으로 부터 명령어를 fetch, CPU에서 execute 하는 ==**fetch-execute 사이클 컴퓨터**==를 최초 개발한 사람이 폰 노이만
- 이런 것을 ==**폰 노이만 아키텍처**==라고 함
	- 명령어 집합인 [ISA (Instruction Set Architecture)](brain/CS/CA/ISA)로 컴퓨터를 운영하는 것

<br>

### 프로그램

**프로그램(program)은 뭔데?**
- 프로그램 : ==**컴퓨터의 하드웨어에게 특정 task를 수행시키는 명령어들의 집합**==

<br>

==**그래서, 운영체제도 프로그램인가?**==
- 컴퓨터 위에서 항상 실행 중인 프로그램
- 시스템 서비스를 애플리케이션 프로그램에 제공
- 운영체제가 하는 일
	- 프로세스 관리 (가장 중요)
	- 리소스
	- 유저 인터페이스 (I/O 관련)
	- 기타 등등

<br><hr>

## 공룡책

==**운영체제(Operating System)는 컴퓨터 하드웨어를 관리하는 소프트웨어**==
- 목적 : 사용자가 프로그램을 편리하고 효율적으로 수행할 수 있는 환경을 제공하도록
- 책임 : ==**자원들을 프로그램에 할당하는 것**==

<br>

### 시스템 구성요소

![](brain/image/chap01-3.png)

<br>

**컴퓨터 시스템 구성요소**는 "H/W + O/S + Application + User" 로 구성된다.
- H/W : 기본 계산용 자원 제공
- Application : 계산 문제 해결을 위하여 자원이 어떻게 사용될지 정의
- O/S : ==**Application 간 하드웨어 사용을 제어하고 조정**==

<br>

**1. 하드웨어 기반의 컴퓨터 자원들 (computing resources)**

"CPU, memory(HDD/RAM), I/O devices" 정도가 있는데, 하드웨어 기반의 컴퓨터 자원들은 이정도가 거의 전부이다. 이중 memory의 RAM은 CPU에 들어가는 명령어들을 버퍼링 시켜준다. 이 과정이 어떻게 발생하는지 간단히 알아보자.

<br>

**1-1. HDD → CPU** : HDD에 컴파일 된 명령어가 저장되어 있는데, 이것을 CPU에 직접 올려서 실행시키는 데는 너무 오래 걸린다.

![](brain/image/chap01-4.png)

<br>

**1-2. HDD → RAM → CPU** : 따라서, RAM을 거치게 되는데, 이때 HDD에 저장된 소프트웨어 일부를 떼어내서 RAM에 올리는 작업을 한다. 일부를 떼어낼 때 페이지(page) 단위로 작업하기 때문에 이를 페이징 기법(paging) 이라고 한다.

![](brain/image/chap01-5.png)

<br>

**1-3. RAM과 컴퓨터 실행 속도의 연관성** : HDD에 저장된 소프트웨어를 더블클릭하여 실행해서 프로세스 형태로 RAM에 올린다. CPU가 (1), (2)처럼 명령어를 실행하는 동안 I/O devices가 HDD->RAM 으로 계속 올려주는 작업이 동시다발적 (concurrency)으로 일어나고 있다. **따라서, CPU가 보는 RAM은 마치 무한해 보인다**

추가로, HDD -> RAM -> CPU 순서로 갈수록 속도는 빨라지며 용량은 작아진다. 용량이 작아지기 때문에 HDD에 저장된 소프트웨어의 크기가 크다면 페이징 기법으로 쪼개서 넘겨주는 것이다. **즉, RAM의 용량이 작으면 컴퓨터 실행 속도가 느리다는 것이다. 용량이 작기 때문에 페이지를 잘게 쪼개야 하고, 그렇게 되면 I/O 과정이 너무 많아지면서 느려지는 것이다. 이 말은, RAM 용량이 크다면 페이징을 크게 크게 할 수 있다는 의미이고, RAM은 컴퓨터의 실행 속도에 큰 영향을 끼친다는 뜻이다**

![](brain/image/chap01-6.png)

<br>

**2. 운영체제 (Operating System)**

운영체제가 반드시 실행되어야 컴퓨터가 돌아가는데 그러면 운영체제도 RAM에 올려야 할까? 답은 YES이다. HDD에서 RAM으로 올릴 때 더블클릭해서 실행중인 프로세스 형태로 만들어서 올려야 하는데 우리가 더블클릭 하는 과정 없이 전원만 켜도 운영체제가 RAM에 올라가는 것은 어떤 원리일까?

![](brain/image/chap01-7.png)

제조사에서는 ROM(Read Only Memory)라는 수정이 불가능하고 읽기만 가능한 것을 만들어 놓는다. 이것을 이용한다.  

- (1) 컴퓨터 전원을 킴
- (2) ROM의 명령어들이 실행
    - (2-1) I/O 하드웨어가 잘 연결되어 있는지 확인
    - (2-2) HDD에 저장되어있는 운영체제를 RAM에 적재하기
- (3) RAM에 올라간 운영체제를 CPU에 밀어넣으면 운영체제가 구동

<br>

**3. 응용 프로그램 (Application Program)**

유저가 컴퓨터를 사용하는 과정에서 발생하는 다양한 컴퓨팅 문제들을 해결하기 위해 시스템 리소스(자원)들이 사용되는 방식을 정의하는 것이다. 응용 프로그램에는 워드 프로세서, 컴파일러, 웹 브라우저, 데이터베이스 시스템, 게임 등이 이에 속한다.

- 사용자가 사용하는 응용 프로그램 : **user level program**
- OS가 사용하는 응용 프로그램 :  **system level program**

<br>

**4. 사용자 (User)**

사용자의 입장에서 운영체제가 없다면 GUI(Graphical User Interface)가 없기 때문에 실행하기가 힘들 것이다. 사용자가 편리하게 사용할 수 있도록 입출력 등을 쉽게 하기 위하여 그래픽으로 인터페이스를 제공해주는 것이다.

또한, 사용자가 직접적으로 컴퓨터 하드웨어와 통신할 수 없다. 응용 프로그램을 반드시 거쳐야 한다.

<br>

### 운영체제가 할 일

운영체제가 하는 일은 크게 ==사용자 관점==과 ==시스템 관점==에 따라 나뉜다.

- 사용자 관점 : **사용자의 용이성**을 위해 설계됨. 성능은 약간만 신경쓰고 자원의 이용에는 전혀 신경을 쓰지 않는다. 즉, 인터페이스 관련하여 집중!
- 시스템 관점 : ==**자원 할당자(resource allocator), 자원 관리자, 제어 프로그램**==

<br>

시스템 관점에서의 운영체제가 하는 일이 매우 중요하다. 자원에 대하여 서로 상충할 수 있는 요청들에 대하여, **운영체제는 어느 요청에 자원을 할당할지를 결정한다.**

제어 프로그램으로써의 관점은 컴퓨터의 부적절한 사용을 방지하기 위하여 **입출력 장치와 사용자 프로그램을 제어한다.** 특히 **입출력 장치의 제어와 작동에 깊이 관여한다.**

<br>

> [!note] 정리하자면 ! <br>
> 예를 들어, 응용 프로그램들이 네트워크에 연결되려면 NIC에 있는 buffer에 쓰는 과정을 거쳐야 한다. 최근 하드웨어 자원들은 성능이 좋아져서 동시적으로 concurrency 하게 접근한다. 그런데, 시스템 자원은 한정적 이지만 응용 프로그램은 매우 매우 매우 많다. 이때 여러 응용 프로그램들이 동시적으로 한정적인 시스템 자원인 buffer에 write 하면 어떻게 될까?
> <br><br>
> 분명 충돌이 일어나서 옳지 않은 데이터가 buffer에 기록될 것이다. 따라서, 접근 제어하는 과정이 필요하다. **동시에 여러 개의 프로세스가 자원을 공유할 때 하나의 프로세스만 read/write 가능하도록 제어한다.** 이러한 것을 가능하게 하는 것이 바로 **운영체제**이다.

<br>

### 커널과 운영체제의 차이

운영체제는 "커널 + 시스템 프로그램"의 구성으로 이루어진다.
- 커널 : 컴퓨터에서 항상 실행되는 중요한 프로그램
- 시스템 프로그램 : OS와 관련되어 있지만, 반드시 커널의 일부일 필요는 없는 프로그램

<br>

즉, 운영체제가 더 큰 범위이고 커널은 운영체제의 범위 중 핵심적인 부분이다.

|                    | 운영체제(Operating System)                                                                 | 커널(Kernel)                                                                                   |
| ------------------ | ------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------- |
| 개념               | 컴퓨터 시스템을 관리하고 조작하는 소프트웨어의 집합체                                      | 운영체제의 핵심 부분으로, 하드웨어와 응용 프로그램 사이에서 직접적인 상호 작용을 담당하는 부분 |
| 범위               | 운영체제는 시스템 전체를 관리하고 사용자 및 응용 프로그램과 상호 작용하는 모든 기능을 포함 | 운영체제의 핵심 부분으로, 하드웨어와 직접적인 상호 작용을 담당                                 |
| 역할               | 높은 수준의 기능을 제공하며 시스템 관리, 응용 프로그램 실행 등 다양한 역할을 수행          | 운영체제의 기능을 구현하고 하드웨어와의 접점 역할                                              |
| 구조               | 여러 컴포넌트와 모듈로 구성될 수 있음                                                      | 운영체제 내에서 가장 핵심적인 부분                                                             |
| 직접적인 상호 작용 | 사용자 및 응용 프로그램과의 상호 작용을 통해 시스템을 관리                                 | 하드웨어와 직접적으로 상호 작용하여 하드웨어 자원을 제어하고 관리                                                                                               |

정리하자면, ==운영체제는 시스템 전체를 관리하고 사용자와 응용 프로그램에 다양한 서비스를 제공==하는 반면, ==커널은 운영체제의 핵심 부분으로 하드웨어와 직접적으로 상호 작용하여 시스템 기능을 제공하고 관리==

<br>

### 컴퓨터 시스템의 구성

컴퓨터 시스템의 구성(Computer-System Organization)은 크게 인터럽트(Interrupts), 저장장치 구조(Storage Structure), 입출력 구조 (I/O Structure)로 살펴보겠다.

<br>

![](brain/image/chap01-9.png)

<a href='/brain/Book/dinosaur/chap01/#컴퓨터-정보-기초'>위에서</a> 언급한 범용성 (universality) 있는 현대의 범용 컴퓨터 시스템(general-purpose computer system)은 ==**CPU + 장치 컨트롤러**==로 구성된다. 추가로,  ==**버스**==를 통해 CPU와 여러 장치 컨트롤러가 연결된다. 그림과 같이 OS에는 장치 컨트롤러마다 ==**장치 드라이버**==를 가지고 있다.

==CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁하게 되는데, 공유 메모리를 질서 있게 액세스하기 위하여 메모리 컨트롤러는 메모리에 대한 액세스를 동기화 한다.==

<br>

> [!note] 버스와 시스템 버스  <br>
> 버스는 데이터 이동을 위한 통로로, 컴퓨터 시스템에는 많은 버스가 있을 수 있지만, 시스템 버스는 주요 구성요소 사이의 주요 통신 경로이다.


<br>

> [!note] 입출력을 수행하는 프로그램 예시 <br>
> 1. 장치 드라이버가 장치 컨트롤러의 적절한 레지스터 값에 적재 <br>
> 2. 장치 컨트롤러가 레지스터의 내용 검사 <br>
> 3. 수행할 작업을 결정한 장치 컨트롤러가 장치에서 로컬 버퍼로 데이터 전송 시작 <br>
> 4. 장치 컨트롤러가 장치 드라이버에게 작업 완료 알림 <br>
> 5. 장치 드라이버가 데이터 또는 데이터에 대한 포인터를 반환하여 OS의 다른 부분에 제어 넘김

<br>

**1. 인터럽트(Interrupts)**

입출력 수행 프로그램 예시의 4번 과정에서 **장치 컨트롤러가 장치 드라이버에게 작업 완료 사실을 어떻게 알릴까?** 바로, 인터럽트를 통해 이루어진다. 인터럽트는 ==**H/W와 O/S 상호작용의 핵심적인 부분이다.**==

![](brain/image/chap01-10.png)

- CPU가 인터럽트 되면, 하던 일을 즉시 중단하고 고정된 위치로 실행 옮김
	- 고정된 위치는 인터럽트를 위한 서비스 루틴이 위치한 시작 주소 가짐
- 인터럽트 서비스 루틴이 실행
- 인터럽트 서비스 루틴 실행 완료 이후, CPU는 인터럽트 되었던 연산 재개
	- 이때 인터럽트에 의해 중단되었던 연산이 인터럽트가 발생되지 않았던 것처럼 다시 시작하기 위해 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 하고 복귀하기 전에 상태를 복원해야 함

<br>

인터럽트는 매우 빈번하게 발생하기에 빠르게 처리되어야 한다.
- 인터럽트 루틴에 대한 포인터들의 테이블 이용 가능
- 중간 루틴 둘 필요 없이, 테이블을 통하여 간접적으로 인터럽트 루틴 호출 가능
- 포인터들의 테이블은 첫 100개 정도의 위치인 하위 메모리에 저장되는데, 여기에 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 있음
	- 이 주소의 배열을 ==**인터럽트 벡터**==라고 함

<br>

**1-1. 인터럽트 작동원리**

CPU 하드웨어에 ==**인터럽트 요청 라인(interrupt request line)**==이라는 선이 있다.
- 마스크 불가능 인터럽트 라인 (nonmaskable interrupt)
- 마스킹 가능 인터럽트 라인 (maskable)
	- 장치 컨트롤러가 서비스를 요청하기 위해 사용

| 마스크 불가능 인터럽트 라인                                                                                                                                                                                                                                                              | 마스킹 가능 인터럽트 라인 |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------- |
| 발생한 인터럽트를 무시하거나 차단할 수 없는 형태의 인터럽트이다. <br><br> 복구할 수 없는 메모리 오류처럼 시스템 내의 중요한 이벤트나 상태 변화를 나타내며, CPU는 이러한 인터럽트가 발생하면 반드시 처리해야 한다. <br><br> 대표적으로 하드웨어 오류나 외부 장치의 상태 변화와 같은 상황에서 발생할 수 있다. | CPU가 특정한 조건을 충족하는 경우에만 해당 인터럽트를 처리하도록 할 수 있는 인터럽트이다. <br><br> 이 경우 CPU는 인터럽트를 무시하거나 처리할 수 있으며, 이를 위해 인터럽트 마스크(interrupt mask) 기능을 사용하여 특정 인터럽트를 활성화하거나 비활성화시킬 수 있다. <br><br> 이는 시스템의 유연한 제어를 가능하게 해주며, 우선순위에 따라 인터럽트를 처리하는 것이 가능하게 한다.                          |

<br><br>

CPU는 인터럽트 요청 라인을 통해 인터럽트를 감지한다.
- 하나의 명령어 실행 완료 → 인터럽트 라인을 통해 인터럽트 감지
- 인터럽트 번호 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용하여 ==**인터럽트 핸들러 루틴(interrupt-handler routine)**==으로 점프
- 인덱스와 관련된 주소에서 실행 시작
- 인터럽트 처리기는 작업 중에 변경될 상태 저장, 인터럽트 원인 확인, 필요한 처리 수행, 상태 복원 수행, `return_from_interrupt` 명령어 실행하여 CPU를 인터럽트 전 실행 상태로 되돌림

<br>

기본 인터럽트 기법 : 장치 컨트롤러가 서비스할 준비가 될 때와 같은 비동기 이벤트에 CPU가 대응할 수 있게 해줌

![](brain/image/chap01-11.png)

- 발생 (raise) : 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트 발생시킴
- 포착 (catch) : CPU가 인터럽트 요청 라인을 통해 인터럽트 포착
- 디스패치 (dispatch) : CPU에서 인터럽트 핸들러로 디스패치
- 지우기 (clear) : 인터럽트 핸들러가 장치를 서비스하고 인터럽트 지움

<br>

최신 OS는 더욱 정교한 인터럽트 처리 기능을 위해 ==**인터럽트 컨트롤러 하드웨어**==에 의해 아래와 같은 기능들이 제공됨
- 중요한 처리 중에 **인터럽트 처리를 연기할 수 있어야 함**
- 장치의 **적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법 필요**
- 우선순위가 높은 인터럽트, 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 **다단계 인터럽트 필요**

<br>